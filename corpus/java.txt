package ca.bcgsc.sockeye.analysis;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;
import java.util.Set;
import ca.bcgsc.sockeye.analysis.scprofile.SCProfileList;
import ca.bcgsc.sockeye.analysis.scprofile.columnscore.ColumnScoreAlgorithm;
import ca.bcgsc.sockeye.dataretrieval.chinook.AlignmentDataSource;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.datastorage.SockeyeTrackList;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.service.featureloader.common.DistributionContainer;
import ca.bcgsc.sockeye.trackmanager.AlignOperation;
import ca.bcgsc.sockeye.trackmanager.TrackRelationshipException;
import ca.bcgsc.sockeye.util.Log;
import ca.bcgsc.util.SequenceUtils;
public class Alignment {
int id = -1;
AlignOperation align_op;
SCProfileList sc_list = null;
Map seq_data = new HashMap();
static Hashtable sequence_map = new Hashtable();
protected static SockeyeTrackList storage_manager =
DataStoreUser.getInstance().getSockeyeTrackList();
public Alignment(){
}
public Alignment(AlignOperation align_operation) {
align_op = align_operation;
}
public void addSequence(TrackFeature src_region, int start, int end, boolean reversed, boolean inverted, List gaps) {
int aln_trk_id = align_op.getAlignedTrack(src_region.getTrackId());
Map seq = (Map)seq_data.get(new Integer(aln_trk_id));
if (seq == null) {
seq = new HashMap();
seq_data.put(new Integer(aln_trk_id), seq);
}
if (start > end) {
inverted = true;
int temp = start;
start = end;
end = temp;
}
int gap_length = 0;
if (gaps == null) gaps = new ArrayList();
for (int i = 0; i < gaps.size(); i++) {
DistributionContainer gap = (DistributionContainer)gaps.get(i);
gap_length += gap.getEnd() - gap.getStart() + 1;
}
if (reversed) {
int abs_end = src_region.getEnd() - src_region.getStart() + 1;
int new_start = abs_end - end + 1;
end = abs_end - start + 1;
start = new_start;
}
boolean on_negative_strand = reversed ^ inverted;
String sequence = (String)sequence_map.get(src_region);
if (sequence == null) {
int window_start = storage_manager.getTrackDataWindowStart(src_region.getTrackId());
sequence = storage_manager.getTrackSequence(src_region.getTrackId());
sequence = sequence.substring(
src_region.getStart() - window_start,
src_region.getEnd() - window_start + 1);
sequence_map.put(src_region, sequence);
}
seq.put("RelativeStart", new Integer(start));
seq.put("RelativeEnd", new Integer(end));
int region_start = src_region.getStart();
start += region_start - 1;
end += region_start - 1;
seq.put("TotalGapLength", new Integer(gap_length));
seq.put("Start", new Integer(start));
seq.put("End", new Integer(end));
seq.put("ReverseStrand", new Boolean(reversed));
seq.put("Inverted", new Boolean(inverted));
seq.put("SourceRegion", src_region);
seq.put("Gaps", gaps);
if (on_negative_strand) seq.put("Gaps", flipGaps(aln_trk_id));
}
public void setID(int id) {
this.id = id;
}
public int getID() {
return id;
}
public int[] getSequenceIDs() {
Set ids = seq_data.keySet();
try {
List track_order = align_op.getTrackRelationship().getTrackOrder(align_op.getReferenceTrack());
track_order.retainAll(ids);
int[] ordered_result = new int[track_order.size()];
for (int i = 0; i < ordered_result.length; i++) ordered_result[i] =
((Integer)track_order.get(i)).intValue();
return ordered_result;
} catch (TrackRelationshipException e) {
Log.printStackTrace(e);
return null;
}
}
public void setSCProfileList(SCProfileList scpl) {
sc_list = scpl;
}
public SCProfileList getSCProfileList() {
return sc_list;
}
public int getStart(int seq_id) {
Map seq = (Map)seq_data.get(new Integer(seq_id));
return ((Integer)seq.get("Start")).intValue();
}
public int getStartInvert(int seq_id) {
int start = getStart(seq_id);
if (isInverted(seq_id)) {
start = getEnd(seq_id);
}
return start;
}
public int getEnd(int seq_id) {
Map seq = (Map)seq_data.get(new Integer(seq_id));
return ((Integer)seq.get("End")).intValue();
}
public int getEndInvert(int seq_id) {
int end = getEnd(seq_id);
if (isInverted(seq_id)) {
end = getStart(seq_id);
}
return end;
}
public int getGappedEnd(int seq_id) {
Map seq = (Map)seq_data.get(new Integer(seq_id));
int end = ((Integer)seq.get("End")).intValue();
int gap_length = ((Integer)seq.get("TotalGapLength")).intValue();
return end + gap_length;
}
public boolean fromNegativeSourceStrand(int seq_id) {
Map seq = (Map)seq_data.get(new Integer(seq_id));
return ((Boolean)seq.get("ReverseStrand")).booleanValue();
}
public boolean isInverted(int seq_id) {
Map seq = (Map)seq_data.get(new Integer(seq_id));
return ((Boolean)seq.get("Inverted")).booleanValue();
}
public boolean onNegativeStrand(int seq_id) {
return isInverted(seq_id) ^ fromNegativeSourceStrand(seq_id);
}
public List getGaps(int seq_id) {
Map seq = (Map)seq_data.get(new Integer(seq_id));
if (seq == null) return null;
return (List)seq.get("Gaps");
}
public List getStrandGaps(int seq_id) {
List gaps;
if (onNegativeStrand(seq_id)) gaps = flipGaps(seq_id);
else gaps = getGaps(seq_id);
return gaps;
}
public AlignOperation getParentOperation() {
return align_op;
}
public float getAverageConservation(int seq1, int seq2) {
SCProfileList scpl = getSCProfileList();
float avg = -1;
if (scpl != null) {
ArrayList seqs = new ArrayList();
seqs.add(new Integer(seq1));
seqs.add(new Integer(seq2));
avg = scpl.getProfile(seqs).getMeanScore();
}
return avg;
}
public String getSequence(int seq_id, boolean gapped) {
Map seq = (Map)seq_data.get(new Integer(seq_id));
String sequence = (String)sequence_map.get(seq.get("SourceRegion"));
int start = ((Integer)seq.get("RelativeStart")).intValue();
int end = ((Integer)seq.get("RelativeEnd")).intValue();
String aln_seq_str = sequence.substring(start - 1, end);
if (gapped) {
List gaps = getGaps(seq_id);
aln_seq_str = ColumnScoreAlgorithm.insertGaps(aln_seq_str, gaps);
}
return aln_seq_str;
}
public String getStrandSequence(int seq_id, boolean gapped) {
String aln_seq_str = getSequence(seq_id, gapped);
if (onNegativeStrand(seq_id)) {
aln_seq_str = SequenceUtils.reverseComplementSequence(aln_seq_str);
}
return aln_seq_str;
}
public TrackFeature getSourceRegion(int seq_id) {
Map seq = (Map)seq_data.get(new Integer(seq_id));
return (TrackFeature)seq.get("SourceRegion");
}
public String getInputRegionSequence(int seq_id) {
Map seq = (Map)seq_data.get(new Integer(seq_id));
TrackFeature region = (TrackFeature)seq.get("SourceRegion");
return (String)sequence_map.get(region);
}
private List flipGaps(int seq_id) {
List flipped_gaps = new ArrayList();
Map seq = (Map)seq_data.get(new Integer(seq_id));
if (seq == null) return null;
List gaps = (List)seq.get("Gaps");
int seq_start = getStart(seq_id);
int seq_end = getEnd(seq_id);
int total_gap_length = ((Integer)seq.get("TotalGapLength")).intValue();
int gapped_end = seq_end - seq_start + total_gap_length + 1;
int new_start, new_end;
for (int g = 0; g < gaps.size(); g++) {
DistributionContainer gap = (DistributionContainer)gaps.get(g);
new_start = gapped_end - gap.getEnd();
new_end = gapped_end - gap.getStart();
flipped_gaps.add(new DistributionContainer(new_start, new_end, 0));
}
Collections.reverse(flipped_gaps);
return flipped_gaps;
}
public String getIdentityTag() {
String tag = "";
String sub_alignment_str = "";
String type = align_op.getAlignType();
if (type.equals(AlignmentDataSource.R_ALIGNMENT_APP_TYPE)) {
List subalignments = align_op.getSubalignments();
sub_alignment_str = " (" + id + "/" + subalignments.size() + ")";
}
tag =
align_op.getAlignApplication() + "-" + align_op.getAlignID() + sub_alignment_str;
return tag;
}
}
package ca.bcgsc.sockeye.analysis;
public class AlignmentException
extends Exception {
public AlignmentException(String msg) {
super(msg);
}
}
package ca.bcgsc.sockeye.analysis;
public class InvalidMatrixException
extends Exception {
public InvalidMatrixException(String msg) {
super(msg);
}
}
package ca.bcgsc.sockeye.analysis;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import org.biojava.bio.Annotation;
import org.biojava.bio.dist.Distribution;
import org.biojava.bio.dist.DistributionFactory;
import org.biojava.bio.dist.GapDistribution;
import org.biojava.bio.dist.PairDistribution;
import org.biojava.bio.dist.UniformDistribution;
import org.biojava.bio.dp.DP;
import org.biojava.bio.dp.DPFactory;
import org.biojava.bio.dp.DotState;
import org.biojava.bio.dp.EmissionState;
import org.biojava.bio.dp.MarkovModel;
import org.biojava.bio.dp.ScoreType;
import org.biojava.bio.dp.SimpleDotState;
import org.biojava.bio.dp.SimpleEmissionState;
import org.biojava.bio.dp.SimpleMarkovModel;
import org.biojava.bio.dp.StatePath;
import org.biojava.bio.dp.twohead.CellCalculatorFactoryMaker;
import org.biojava.bio.dp.twohead.DPInterpreter;
import org.biojava.bio.seq.DNATools;
import org.biojava.bio.seq.Sequence;
import org.biojava.bio.symbol.AlphabetManager;
import org.biojava.bio.symbol.BasisSymbol;
import org.biojava.bio.symbol.FiniteAlphabet;
import org.biojava.bio.symbol.IllegalAlphabetException;
import org.biojava.bio.symbol.IllegalSymbolException;
import org.biojava.bio.symbol.SymbolList;
import org.biojava.utils.ChangeVetoException;
public class PairwiseAlignment {
public PairwiseAlignment() {
}
public static void runPairwiseAlignment(String source_seq, String source_name,
String target_seq, String target_name) {
try {
FiniteAlphabet alpha = DNATools.getDNA();
CellCalculatorFactoryMaker cfFactM = new DPInterpreter.Maker();
DPFactory fact = new DPFactory.DefaultFactory(cfFactM);
MarkovModel model = generateAligner(
alpha,
0.5, 0.8,
0.2, 0.8
);
DP aligner = fact.createDP(model);
Sequence sourceSeq = DNATools.createDNASequence(source_seq, source_name);
Sequence targetSeq = DNATools.createDNASequence(target_seq, target_name);
Sequence[] seqs = new Sequence[] {
sourceSeq, targetSeq
};
System.out.println(
"Aligning " + sourceSeq.getName() + ":" + targetSeq.getName()
);
double forwardMin;
System.out.println("Forwards-:");
forwardMin = aligner.forward(seqs, ScoreType.PROBABILITY);
System.out.println("\t" + forwardMin);
State[] states = aligner.getStates();
forwardMin = aligner.forward(seqs, ScoreType.ODDS);
System.out.println("\t" + forwardMin);
states = aligner.getStates();
forwardMin = aligner.forward(seqs, ScoreType.NULL_MODEL);
System.out.println("\t" + forwardMin);
states = aligner.getStates();
double backward;
System.out.println("Backwards:");
backward = aligner.backward(seqs, ScoreType.PROBABILITY);
System.out.println("\t" + backward);
backward = aligner.backward(seqs, ScoreType.ODDS);
System.out.println("\t" + backward);
backward = aligner.backward(seqs, ScoreType.NULL_MODEL);
System.out.println("\t" + backward);
StatePath result;
System.out.println("Viterbi:");
result = aligner.viterbi(seqs, ScoreType.PROBABILITY);
System.out.println("\t" + result.getScore());
result = aligner.viterbi(seqs, ScoreType.ODDS);
System.out.println("\t" + result.getScore());
result = aligner.viterbi(seqs, ScoreType.NULL_MODEL);
System.out.println(StatePath.SEQUENCE);
Iterator i = result.symbolListIterator();
while (i.hasNext())
{
SymbolList sl = (SymbolList) i.next();
System.out.println(sl.seqString());
}
System.out.println("\t" + result.getScore());
}
catch (Throwable t) {
t.printStackTrace();
System.exit(1);
}
}
private static MarkovModel generateAligner(
FiniteAlphabet alpha,
double pMatch, double pExtendMatch,
double pGap, double pExtendGap
) throws IllegalAlphabetException, IllegalSymbolException, ChangeVetoException {
double pEndMatch = 1.0 - pExtendMatch;
double pEndGap = 1.0 - pExtendGap;
double pEnd = 1.0 - pMatch - 2.0 * pGap;
FiniteAlphabet dna = alpha;
FiniteAlphabet dna2 =
(FiniteAlphabet) AlphabetManager.getCrossProductAlphabet(
Collections.nCopies(2, dna)
);
MarkovModel model = new SimpleMarkovModel(2, dna2, "pair-wise aligner");
Distribution nullModel = new UniformDistribution(dna);
Distribution gap = new GapDistribution(dna);
Distribution matchDist = generateMatchDist( (FiniteAlphabet) dna2);
Distribution nullModel2 = new PairDistribution(nullModel, nullModel);
Distribution insert1Dist = new PairDistribution(nullModel, gap);
Distribution insert2Dist = new PairDistribution(gap, nullModel);
DotState hub = new SimpleDotState("hub");
EmissionState match = new SimpleEmissionState(
"match",
Annotation.EMPTY_ANNOTATION,
new int[] {1, 1}
,
matchDist
);
EmissionState insert1 = new SimpleEmissionState(
"insert1",
Annotation.EMPTY_ANNOTATION,
new int[] {1, 0}
,
insert1Dist
);
EmissionState insert2 = new SimpleEmissionState(
"insert2",
Annotation.EMPTY_ANNOTATION,
new int[] {0, 1}
,
insert2Dist
);
model.addState(hub);
model.addState(match);
model.addState(insert1);
model.addState(insert2);
Distribution dist;
model.createTransition(model.magicalState(), hub);
model.createTransition(hub, match);
model.createTransition(hub, insert1);
model.createTransition(hub, insert2);
model.createTransition(hub, model.magicalState());
model.createTransition(match, match);
model.createTransition(match, hub);
model.createTransition(insert1, insert1);
model.createTransition(insert1, hub);
model.createTransition(insert2, insert2);
model.createTransition(insert2, hub);
model.getWeights(model.magicalState()).setWeight(hub, 1.0);
dist = model.getWeights(hub);
dist.setWeight(match, pMatch);
dist.setWeight(insert1, pGap);
dist.setWeight(insert2, pGap);
dist.setWeight(model.magicalState(), pEnd);
dist = model.getWeights(match);
dist.setWeight(match, pExtendMatch);
dist.setWeight(hub, pEndMatch);
dist = model.getWeights(insert1);
dist.setWeight(insert1, pExtendGap);
dist.setWeight(hub, pEndGap);
dist = model.getWeights(insert2);
dist.setWeight(insert2, pExtendGap);
dist.setWeight(hub, pEndGap);
return model;
}
private static Distribution generateMatchDist(FiniteAlphabet dna2)
throws IllegalAlphabetException, IllegalSymbolException, ChangeVetoException {
Distribution dist = DistributionFactory.DEFAULT.createDistribution(dna2);
int size = dna2.size();
int matches = (int) Math.sqrt(size);
double pMatch = 0.15;
double matchWeight = pMatch / matches;
double missWeigth = (1.0 - pMatch) / (size - matches);
for (Iterator i = dna2.iterator(); i.hasNext(); ) {
BasisSymbol cps = (BasisSymbol) i.next();
List sl = cps.getSymbols();
if (sl.get(0) == sl.get(1)) {
dist.setWeight(cps, matchWeight);
}
else {
dist.setWeight(cps, missWeigth);
}
}
return dist;
}
}
package ca.bcgsc.sockeye.analysis;
import java.util.ArrayList;
import java.util.Hashtable;
import ca.bcgsc.sockeye.util.Log;
public class SequenceMatrix {
float[][] data; /* Row-Column data */
String[] indexNames; /* Row and Column names */
int N; /* N by N matrix */
String name;
static Hashtable speciesNames;
transient public static final int DTYPE1 = 0;
transient public static final int BTYPE1 = 1;
transient public static final int BTYPE2 = 2;
public SequenceMatrix() {
}
public SequenceMatrix(int size, String name) {
this.name = name;
if (size < 1)
size = 1;
N = size;
data = new float[N][N];
indexNames = new String[N];
}
public SequenceMatrix(float[][] values, String[] index, String name)
throws InvalidMatrixException {
this.name = name;
N = values.length;
if (N != values[0].length || N == 0) {
throw new InvalidMatrixException("Must have 0 < rowsize = colsize");
}
data = values;
setIndex(index);
}
public SequenceMatrix(String phylip_tree, String name) {
this.name = name;
N = 1;
data = new float[N][N];
indexNames = new String[N];
}
public void setName(String name) {
this.name = name;
}
public String getName() {
return name;
}
public void setIndex(String[] index) throws InvalidMatrixException {
if (index.length != N) {
throw new InvalidMatrixException(N + " index names required");
}
ArrayList temp = new ArrayList();
for (int i = 0; i < index.length; i++) {
if (temp.contains(index[i])) {
throw new InvalidMatrixException("Unique indices required.");
}
temp.add(index[i]);
}
indexNames = index;
}
public float getElement(String rowStr, String colStr)
throws IndexOutOfBoundsException {
if (rowStr.length() < 7)
rowStr = getLongSpeciesName(rowStr);
if (colStr.length() < 7)
colStr = getLongSpeciesName(colStr);
int row = -1, col = -1;
for (int i = 0; i < indexNames.length; i++) {
if (indexNames[i].equals(rowStr)) {
row = i;
}
if (indexNames[i].equals(colStr)) {
col = i;
}
}
if (row == -1) {
System.out.println(this);
throw new IndexOutOfBoundsException("row name not found:" + rowStr);
} else if (col == -1) {
System.out.println(this);
throw new IndexOutOfBoundsException("column name not found:"
+ colStr);
}
return data[row][col];
}
public float getElement(int row, int col) throws IndexOutOfBoundsException {
return data[row][col];
}
public void setElement(String rowStr, String colStr, float value)
throws IndexOutOfBoundsException {
if (rowStr.length() < 7)
rowStr = getLongSpeciesName(rowStr);
if (colStr.length() < 7)
colStr = getLongSpeciesName(colStr);
int row = -1, col = -1;
for (int i = 0; i < indexNames.length; i++) {
if (indexNames[i].equals(rowStr)) {
row = i;
}
if (indexNames[i].equals(colStr)) {
col = i;
}
}
if (row == -1 || col == -1) {
throw new IndexOutOfBoundsException("row or column name not found");
}
setElement(row, col, value);
}
public void setElement(int row, int col, float value)
throws IndexOutOfBoundsException {
data[row][col] = value;
}
public boolean isSymmetric() {
for (int i = 0; i < N; i++) {
for (int j = 0; j < N; j++) {
if (data[i][j] != data[j][i]) {
return false;
}
}
}
return true;
}
public SequenceMatrix getTranspose() throws InvalidMatrixException {
float[][] values = new float[N][N];
for (int i = 0; i < N; i++) {
for (int j = 0; j < N; j++) {
values[i][j] = data[j][i];
}
}
String[] indexCpy = new String[indexNames.length];
for (int i = 0; i < indexNames.length; i++) {
indexCpy[i] = indexNames[i];
}
return new SequenceMatrix(values, indexCpy, this.name + "_transposed");
}
public String toString() {
StringBuffer buf = new StringBuffer();
for (int i = 0; i < N; i++) {
buf.append(" " + indexNames[i] + "\t");
for (int j = 0; j < N; j++) {
buf.append(data[i][j] + "\t");
}
buf.append("\n");
}
return buf.toString();
}
public static SequenceMatrix getMatchScoreMatrix(int type) {
SequenceMatrix DMatrix = null;
if (type == DTYPE1) {
String[] index = { "A", "C", "G", "T", "-", "N", "X" };
float[][] data = { { 1, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 0, 0, 0, 0, 0 }, { 0, 0, 1, 0, 0, 0, 0 },
{ 0, 0, 0, 1, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0 },
{ 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0 }, };
try {
DMatrix = new SequenceMatrix(data, index, "Extended Boolean");
} catch (Exception e) {
e.printStackTrace();
}
}
return DMatrix;
}
public static String getLongSpeciesName(String shortName) {
if (speciesNames == null) {
speciesNames = new Hashtable();
speciesNames.put("R.nor.", "Rattus_norvegicus");
speciesNames.put("H.sap.", "Homo_sapiens");
speciesNames.put("M.mus.", "Mus_musculus");
speciesNames.put("F.rub.", "Fugu_rubripes");
speciesNames.put("D.rer.", "Danio_rerio");
speciesNames.put("C.ele.", "Caenorhabditis_elegans");
speciesNames.put("C.bri.", "Caenorhabditis_briggsae");
speciesNames.put("D.mel.", "Drosophila_melanogaster");
speciesNames.put("A.gam.", "Anopheles_gambiae");
speciesNames.put("P.tro.", "Pan_troglodytes");
speciesNames.put("G.gal.", "Gallus_Gallus");
}
String longName = (String) speciesNames.get(shortName);
if (longName == null)
longName = shortName;
return longName;
}
public static SequenceMatrix getPhyloDistanceMatrix(int type) {
SequenceMatrix BMatrix = null;
if (type == BTYPE1) {
String[] index = { "Homo_sapiens", "Pan_troglodytes",
"Macaca_mulatta", "Canis_familiaris", "Bos_taurus",
"Mus_musculus", "Rattus_norvegicus",
"Monodelphis_domestica", "Gallus_gallus", "Xenopus_tropicalis","Fugu_rubripes",
"Tetraodon_nigroviridis", "Danio_rerio",
"Caenorhabditis_elegans", "Caenorhabditis_briggsae",
"Drosophila_melanogaster", "Anopheles_gambiae",
"Apis_mellifera", "Saccharomyces_cerevisiae" };
float[][] data = {
{0, 2, 3, 5, 5, 5, 5, 6, 8, 9, 11, 11, 11, 19, 19, 18, 18, 18, 22 },
{2, 0, 3, 5, 5, 5, 5, 6, 8, 9, 11, 11, 11, 19, 19, 18, 18, 18, 22 },
{4, 4, 0, 6, 6, 6, 6, 7, 9, 10, 12, 12, 12, 20, 20, 19, 19, 19, 23 },
{5, 5, 5, 0, 5, 5, 5, 6, 8, 9, 11, 11, 11, 19, 19, 18, 18, 18, 22 },
{8, 8, 8, 8, 0, 8, 8, 9, 11, 12, 14, 14, 14, 22, 22, 21, 21, 21, 25 },
{6, 6, 6, 6, 6, 0, 2, 7, 9, 10, 12, 12, 12, 20, 20, 19, 19, 19, 23 },
{6, 6, 6, 6, 6, 2, 0, 7, 9, 10, 12, 12, 12, 20, 20, 19, 19, 19, 23 },
{6, 6, 6, 6, 6, 6, 6, 0, 8, 9, 11, 11, 11, 19, 19, 18, 18, 18, 22 },
{10, 10, 10, 10, 10, 10, 10, 10, 0, 11, 13, 13, 13, 21, 21, 20, 20, 20, 24 },
{9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 11, 11, 11, 19, 19, 18, 18, 18, 22 },
{18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 0, 2, 14, 26, 26, 25, 25, 25, 29 },
{18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 2, 0, 14, 26, 26, 25, 25, 25, 29 },
{11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 7, 7, 0, 19, 19, 18, 18, 18, 22 },
{9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 1, 9, 9, 9, 12 },
{9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 1, 0, 9, 9, 9, 12 },
{25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 0, 14, 15, 29 },
{21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 10, 0, 11, 25 },
{19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 9, 9, 0, 23 },
{8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0 },
};
try {
BMatrix = new SequenceMatrix(data, index, "SJPhyloDistance");
} catch (Exception e) {
e.printStackTrace();
}
} else if (type == BTYPE2)
try {
BMatrix = getPhyloDistanceMatrix(BTYPE1);
SequenceMatrix T = BMatrix.getTranspose();
BMatrix.setName("SJPhyloDistanceSym");
for (int i = 0; i < BMatrix.N; i++) {
for (int j = 0; j < BMatrix.N; j++) {
BMatrix.data[i][j] = (BMatrix.data[i][j] + T.data[i][j]) / 2;
}
}
} catch (Exception e) {
Log.printStackTrace(e);
}
return BMatrix;
}
public ArrayList getSpeciesDistance(Object[] sp, String ref)
throws InvalidMatrixException {
ArrayList species_distance = new ArrayList();
Object[] species = sp;
int size = species.length;
float[] distance = new float[size];
species_distance.add(species);
species_distance.add(distance);
int ref_index = getColIndex(ref);
for (int i = 0; i < N; i++) {
int index = getIndex(((Object[]) species_distance.get(0)),
indexNames[i]);
if (index != -1)
((float[]) species_distance.get(1))[index] = this.data[i][ref_index];
}
species = (Object[]) species_distance.get(0);
distance = (float[]) species_distance.get(1);
float tmp_distance;
Object tmp_species;
for (int i = 0; i < size - 1; i++) {
for (int j = i + 1; j < size; j++) {
if (distance[i] > distance[j]) {
tmp_species = species[i];
species[i] = species[j];
species[j] = tmp_species;
tmp_distance = distance[i];
distance[i] = distance[j];
distance[j] = tmp_distance;
}
}
}
return species_distance;
}
private int getIndex(Object[] array, Object obj) {
for (int i = 0; i < array.length; i++) {
if (array[i].equals(obj))
return i;
}
return -1;
}
public int getColIndex(String col_name) throws InvalidMatrixException {
col_name = getLongSpeciesName(col_name);
for (int i = 0; i < N; i++) {
if (indexNames[i].equals(col_name))
return i;
}
throw new InvalidMatrixException(
"Matrix cannot find a row or column named '" + col_name + "'");
}
public Object[] getSpeciesRelation(Object[] sp, String ref)
throws InvalidMatrixException {
if (sp == null || ref == null)
return null;
ArrayList species_distance = getSpeciesDistance(sp, ref);
return (Object[]) species_distance.get(0);
}
public ArrayList getSpeciesSubsets(Object[] sp, String ref)
throws InvalidMatrixException {
ArrayList subsets = new ArrayList();
Object[] species = getSpeciesRelation(sp, ref);
int count = 2;
ArrayList subset = new ArrayList();
for (int i = 0; i < species.length; i++) {
subset.add(species[i]);
if (subset.size() == count) {
subsets.add(subset.toArray());
subset = new ArrayList();
count++;
i = -1;
}
}
return subsets;
}
public int getSize() {
return N;
}
public String getIndexName(int index) {
if (index < indexNames.length && index >= 0) {
return indexNames[index];
} else
return null;
}
public SequenceMatrix copy() {
float[][] newValues = new float[N][N];
String[] newIndex = new String[N];
for (int i = 0; i < N; i++) {
newIndex[i] = new String(indexNames[i]);
for (int j = 0; j < N; j++) {
newValues[i][j] = data[i][j];
}
}
SequenceMatrix copy = null;
try {
copy = new SequenceMatrix(newValues, newIndex, new String(name));
} catch (InvalidMatrixException e) {
Log.printStackTrace(e);
}
return copy;
}
}/*------
package ca.bcgsc.sockeye.analysis.junit;
import ca.bcgsc.sockeye.analysis.SequenceMatrix;
import junit.framework.TestCase;
import junit.framework.TestSuite;
public class SequenceMatrixUnitTest extends TestCase
{
public SequenceMatrixUnitTest(String name)
{
super(name);
}
public static void main(String[] args)
{
junit.textui.TestRunner.run(SequenceMatrixUnitTest.suite());
}
protected void setUp()
{
}
public static TestSuite suite()
{
TestSuite testSuite = new TestSuite();
testSuite.addTest(
new SequenceMatrixUnitTest("testSequenceMatrixGetLongName"));
testSuite.addTest(new SequenceMatrixUnitTest("testSequenceMatrixOne"));
testSuite.addTest(new SequenceMatrixUnitTest("testSequenceMatrixTwo"));
return testSuite;
}
public void testSequenceMatrixGetLongName() throws Exception
{
assertEquals(
SequenceMatrix.getLongSpeciesName("R.nor."),
"Rattus_norvegicus");
assertEquals(SequenceMatrix.getLongSpeciesName("H.sap."), "Homo_sapiens");
assertEquals(SequenceMatrix.getLongSpeciesName("M.mus."), "Mus_musculus");
assertEquals(SequenceMatrix.getLongSpeciesName("F.rub."), "Fugu_rubripes");
assertEquals(SequenceMatrix.getLongSpeciesName("D.rer."), "Danio_rerio");
assertEquals(
SequenceMatrix.getLongSpeciesName("C.ele."),
"Caenorhabditis_elegans");
assertEquals(
SequenceMatrix.getLongSpeciesName("C.bri."),
"Caenorhabditis_briggsae");
assertEquals(
SequenceMatrix.getLongSpeciesName("D.mel."),
"Drosophila_melanogaster");
assertEquals(
SequenceMatrix.getLongSpeciesName("A.gam."),
"Anopheles_gambiae");
assertEquals(
SequenceMatrix.getLongSpeciesName("Anopheles_gambiae"),
"Anopheles_gambiae");
}
public void testSequenceMatrixOne() throws Exception
{
SequenceMatrix matrix = new SequenceMatrix(3, "somename");
assertTrue(matrix.isSymmetric());
assertEquals(
"Values on the diagonal should equal.",
matrix.getElement(0, 0),
matrix.getElement(1, 1),
matrix.getElement(2, 2));
matrix.setElement(2, 2, 3.0f);
matrix.setElement(1, 0, 3.0f);
assertEquals(
"Value in the matrix when it is set.",
3.0f,
matrix.getElement(2, 2),
matrix.getElement(1, 0));
String[] index = { "A", "C", "G" };
matrix.setIndex(index);
SequenceMatrix transposedMatrix = matrix.getTranspose();
assertEquals(
"Value in the matrix when it is set.",
3.0f,
transposedMatrix.getElement(2, 2),
transposedMatrix.getElement(0, 1));
assertEquals(transposedMatrix.getColIndex("A"), 0);
assertEquals(transposedMatrix.getColIndex("C"), 1);
assertEquals(transposedMatrix.getColIndex("G"), 2);
float[][] value = { { 0, 3, 0 }, {
0, 0, 0 }, {
0, 0, 3 }, };
String[] labels = { "A", "C", "G" };
SequenceMatrix matrix2 = new SequenceMatrix(value, labels, "somename");
assertTrue(matrixEquals(matrix2, transposedMatrix));
}
public void testSequenceMatrixTwo() throws Exception
{
float[][] value = { { 1, 2, 3, 4 }, {
5, 6, 7, 8 }, {
9, 10, 11, 12 }, {
13, 14, 15, 16 }
};
String[] labels = { "D", "E", "F", "G" };
SequenceMatrix matrix = new SequenceMatrix(value, labels, "somename");
assertFalse(matrix.isSymmetric());
assertEquals(matrix.getElement(1, 0), 5.0f, 5.0f);
assertEquals(matrix.getElement(0, 1), 2.0f, 2.0f);
assertEquals(matrix.getElement(2, 1), 10.0f, 10.0f);
SequenceMatrix transposed_matrix = matrix.getTranspose();
assertEquals(transposed_matrix.getElement(1, 0), 2.0f, 2.0f);
assertEquals(transposed_matrix.getElement(0, 1), 5.0f, 5.0f);
assertEquals(transposed_matrix.getElement(2, 1), 7.0f, 7.0f);
SequenceMatrix copy_matrix = transposed_matrix.copy();
assertTrue(matrixEquals(copy_matrix, transposed_matrix));
}
private boolean matrixEquals(Object matrix1, Object matrix2)
{
boolean equivalent = false;
if (matrix1 instanceof SequenceMatrix && matrix2 instanceof SequenceMatrix)
{
SequenceMatrix matr1 = (SequenceMatrix) matrix1;
SequenceMatrix matr2 = (SequenceMatrix) matrix2;
equivalent = true;
if (matr1.getSize() == matr2.getSize())
{
for (int row_index = 0; row_index < matr1.getSize(); row_index++)
{
if (!(matr1
.getIndexName(row_index)
.equals(matr2.getIndexName(row_index))))
{
return false;
}
for (int col_index = 0; col_index < matr1.getSize(); col_index++)
{
if (matr1.getElement(row_index, col_index)
!= matr2.getElement(row_index, col_index))
{
return false;
}
}
}
}
}
return equivalent;
}
}
package ca.bcgsc.sockeye.analysis.scprofile;
import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;
import ca.bcgsc.sockeye.datastorage.Track;
import ca.bcgsc.util.SequenceUtils;
public class AlignArray {
private String alignment_name;
private ArrayList aligned_tracks;
private Date date;
public AlignArray(String alignment_name_, ArrayList aligned_tracks_) {
this.alignment_name = alignment_name_;
this.aligned_tracks = aligned_tracks_;
this.date = new Date();
}
public String getAlignmentName() {
if (alignment_name == null)
return null;
return alignment_name;
}
public String getDate() {
if (date == null)
return null;
return date.toString();
}
public ArrayList getTrackIdList() {
if (aligned_tracks == null)
return null;
ArrayList ids = new ArrayList();
for (int i = 0; i < aligned_tracks.size(); i++) {
ids.add(Integer.toString( ( (Track) aligned_tracks.get(i)).getId()));
}
return ids;
}
public String getSequence(String track_name) {
return new String();
}
public int getLength() {
return 0;
}
public ArrayList getAlignedTracks() {
return aligned_tracks;
}
public void addAlignedTracks(Object[] species_sorted) throws
SCProfileException {
ArrayList ordered_gapped_track_list = new ArrayList();
for (int i = 0; i < species_sorted.length; i++) {
String species = species_sorted[i].toString();
for (int j = 0; j < aligned_tracks.size(); j++) {
Track track = (Track) aligned_tracks.get(j);
}
}
Track ref_track = null;
for (int i = 0; i < ordered_gapped_track_list.size(); i++) {
Track track = (Track) ordered_gapped_track_list.get(i);
if (i == 0)
ref_track = track;
}
addSCProfile(ref_track);
}
public ArrayList getSpeciesArray() {
ArrayList species_array = new ArrayList();
for (int i = 0; i < aligned_tracks.size(); i++) {
}
return species_array;
}
private void addSCProfile(Track ref_track) throws SCProfileException {
if (ref_track == null)
return;
SCProfileList.__DEFAULT_WINDOW_SIZE,
1,
"PhyloVISTA", "mean", null,
"SCProfileAudit.log");
ArrayList data = new ArrayList();
ArrayList names = (ArrayList) profileList.getDistributionNames();
if (data == null || data.size() == 0) {
System.out.println("No profiles!");
return;
}
PrintWriter fout = null;
try {
DateFormat df = DateFormat.getDateTimeInstance(DateFormat.SHORT,
DateFormat.SHORT);
String dateStr = df.format(date);
dateStr = dateStr.substring(0, dateStr.length() - 3).replace('/', '_').
replace(' ', '_').replace(':', '_');
String filename = "data/MPIP/AlignArray" + dateStr + ".pip";
fout = new PrintWriter(new FileOutputStream(filename));
fout.println(this.getAsMPIP());
fout.close();
filename = "data/MFASTA/AlignArray" + dateStr + ".mfa";
fout = new PrintWriter(new FileOutputStream(filename));
fout.println(this.getAsMFASTA());
}
catch (java.io.IOException e) {
Log.printStackTrace(e);
}
finally {
if (fout != null)
fout.close();
}
MultiDimTrackDistribution mdd = new MultiDimTrackDistribution(0, "Seq Cons Profile Set");
mdd.addDistributions(data);
for (int i = 0; i < data.size(); i++) {
mdd.setDistributionLabel(i, (String) names.get(i));
mdd.setDistributionThreshold(i, profileList.getProfileThreshold(i));
}
mdd.setFeature("sequence conservation profiles");
ArrayList featureList = new ArrayList();
featureList.add(mdd);
ref_track.setAttribute("SCProfiles", profileList);
mdd.setAttribute("display_string", "Sequence Conservation Profiles");
}
public String getAsMPIP() {
StringBuffer buf = new StringBuffer();
StringBuffer seqBuf = new StringBuffer();
ArrayList names = getTrackIdList();
int length = -1;
for (Iterator itr = names.iterator(); itr.hasNext(); ) {
String name = (String) itr.next();
String seq = getSequence(name);
if (length == -1 && seq != null) {
length = seq.length();
buf.append(names.size() + " " + length);
}
buf.append("\n" + name);
seqBuf.append("\n" + seq);
}
buf.append(seqBuf);
return buf.toString();
}
public String getAsMFASTA() {
StringBuffer buf = new StringBuffer();
ArrayList names = getTrackIdList();
for (Iterator itr = names.iterator(); itr.hasNext(); ) {
String name = (String) itr.next();
String seq = getSequence(name);
buf.append("\n\n>" + name);
buf.append("\n" + SequenceUtils.cutString(seq, 80, ""));
}
return buf.toString();
}
String getSpeciesNameByTrackId(int track_id) {
return null;
}
}
package ca.bcgsc.sockeye.analysis.scprofile;
import java.awt.Color;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import ca.bcgsc.sockeye.analysis.scprofile.columnscore.ColumnScoreAlgorithm;
import ca.bcgsc.sockeye.analysis.scprofile.columnscore.ColumnScoreException;
import ca.bcgsc.sockeye.analysis.scprofile.columnscore.DistanceWeightSumAlgorithm;
import ca.bcgsc.sockeye.analysis.scprofile.columnscore.IDPercentageColumnScoreAlgorithm;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.service.featureloader.common.DistributionContainer;
import ca.bcgsc.sockeye.trackmanager.PhyloDistanceRelationship;
import ca.bcgsc.sockeye.trackmanager.TrackRelationshipException;
import ca.bcgsc.sockeye.trackmanager.TrackRelationshipOrderInterface;
import ca.bcgsc.sockeye.util.Log;
public class SCProfile {
private boolean visible = true;
private float threshold = 0;
private float threshold_percent = 0;
private SCProfileList sc_list = null;
private float high_score = 0;
private transient float[] col_scores = null;
private transient float[] win_scores = null;
Map thresh_map = null;
private List total_gaps = new ArrayList();
private List sequences = null;
private PrintStream audit_stream = null;
private boolean cr_display = false;
private boolean gapped_cr_display = false;
private int red = 180, green = 180, blue = 180;
transient private static final int _TOTAL_GAP_VALUE = -1;
private boolean dirty = true;
private ColumnScoreAlgorithm m_algo = null;
public SCProfile() {
}
public SCProfile(SCProfileList sc_list, List sequences) {
this.sc_list = sc_list;
this.sequences = sequences;
this.audit_stream = sc_list.auditStream;
}
public SCProfile(SCProfileList sc_list, SCProfile source ) {
this.sc_list = sc_list;
this.sequences = new ArrayList(source.sequences);
this.audit_stream = sc_list.auditStream;
this.threshold_percent = source.threshold_percent;
this.threshold = source.threshold;
this.thresh_map = source.thresh_map;
if (source.col_scores != null) this.col_scores = (float[])source.col_scores.clone();
if (source.win_scores != null) this.win_scores = (float[])source.win_scores.clone();
this.cr_display = source.cr_display;
this.gapped_cr_display = source.gapped_cr_display;
if (source.total_gaps != null) this.total_gaps = new ArrayList(source.total_gaps);
this.high_score = source.high_score;
this.red = source.red;
this.green = source.green;
this.blue = source.blue;
this.visible = source.visible;
this.dirty = source.dirty;
}
public Map getDistributionData(int bins, int offset, int data_start, int data_end, boolean reverse) throws SCProfileException {
if (!isActive() || !isVisible()) return null;
if (!update()) return null;
float[] data_scores = win_scores;
if (reverse) {
int len = win_scores.length;
data_scores = new float[len];
for (int i = 0; i < len; i++) data_scores[i] = win_scores[len - i - 1];
}
ArrayList containers = new ArrayList();
if (bins > SCProfileList.__MAX_BIN_RESOLUTION) {
Log.println(
"WARNING from SCProfile.getDistributionData: Bin size of "
+ bins
+ " limited to "
+ SCProfileList.__MAX_BIN_RESOLUTION);
bins = SCProfileList.__MAX_BIN_RESOLUTION;
}
if (bins < 1) bins = 1;
int binSize = (int) (col_scores.length / (float)bins + 0.5f);
if (binSize < 1)
binSize = 1;
int index = 0, binIndex = 0, start = 0, end = 0;
float sum = 0;
while (index < data_scores.length) {
if (data_scores[index] == ColumnScoreAlgorithm._UNDEFINED) {
if (binIndex != 0) {
start = Math.max(index - binIndex, data_start);
end = Math.min(index, data_end);
if (start > data_end) break;
if (start <= end) containers.add(
new DistributionContainer(
start + offset,
end + offset,
sum / binIndex));
binIndex = 0;
sum = 0;
}
while (index < data_scores.length && data_scores[index] == ColumnScoreAlgorithm._UNDEFINED) index++;
continue;
} else if (binIndex == binSize) {
start = Math.max(index - binIndex, data_start);
end = Math.min(index, data_end);
if (start <= end && start <= data_end) containers.add(
new DistributionContainer(
start + offset,
end + offset,
sum / binSize));
binIndex = 0;
sum = 0;
}
sum += data_scores[index];
binIndex++;
index++;
}
if (binIndex <= binSize && binIndex != 0) {
start = Math.max(index - binIndex, data_start);
end = Math.min(index, data_end);
if (start <= end) containers.add(
new DistributionContainer(
start + offset,
end + offset,
sum / binIndex));
}
HashMap data_unit = new HashMap();
data_unit.put("Containers", containers);
data_unit.put("Label", getName());
data_unit.put("Threshold", new Float(getThreshold()));
data_unit.put("Colour", getColour());
return data_unit;
}
public List getConservedRegions(int trk_id, boolean gapped, boolean reverse) throws SCProfileException {
List regions = new ArrayList();
if (gapped && !gapped_cr_display) return regions;
else if (!gapped && !cr_display) return regions;
int seqStart = sc_list.getSequenceStart(trk_id);
if (seqStart == -1)
throw new SCProfileException("Track '" + trk_id + "' not found. Unable to calculate conserved region offset.");
List crs = calcConservedRegions(trk_id, seqStart, gapped, reverse);
if (crs == null) return regions;
for (Iterator itr = crs.iterator(); itr.hasNext();) {
DistributionContainer g_dc = (DistributionContainer)itr.next();
TrackFeature CR = new TrackFeature("Track" + trk_id, "SCProfile", "Conserved Region",
g_dc.getStart(), g_dc.getEnd(), 0, reverse ? -1 : 1, 0);
CR.setAttribute("no_gap_division", "overlap gaps");
CR.setAccessionID("CR" +CR.hashCode());
regions.add(CR);
}
return regions;
}
public float[] getColumnScores() {
if (!update()) return null;
return col_scores;
}
public float[] getSmoothedScores() {
if (!update()) return null;
return win_scores;
}
public List getSequences() {
return sequences;
}
public float getThreshold() {
return threshold;
}
public float getThresholdPercentile() {
return threshold_percent;
}
public Map getThresholdPercentileMap() {
if (!update()) return null;
return thresh_map;
}
public float getHighScore() {
return high_score;
}
public float getMedianScore() {
float[] ordered = (float[])win_scores.clone();
Arrays.sort(ordered);
int start = 0;
for (start = 0; start < ordered.length && ordered[start] == ColumnScoreAlgorithm._UNDEFINED; start++);
float[] temp = ordered;
ordered = new float[temp.length - start];
for (int i = start; i < temp.length; i++) ordered[i - start] = temp[i];
return ordered[ordered.length / 2];
}
public float getMeanScore() {
float sum = 0;
int undefined = 0;
update();
for (int i = 0; i < win_scores.length; i++) {
if (win_scores[i] == ColumnScoreAlgorithm._UNDEFINED) {
undefined++;
continue;
}
sum += win_scores[i];
}
int div = win_scores.length - undefined;
if (div < 1) return 0;
return sum / div;
}
public float getAverageIsland() {
if (!update()) return 0;
return ColumnScoreAlgorithm.getAverageIsland(col_scores, threshold);
}
public Color getColour() {
return new Color(red, green, blue);
}
public void setColour(Color c) {
red = c.getRed();
blue = c.getBlue();
green = c.getGreen();
}
public void setDirty(boolean eww_dirty) {
dirty = eww_dirty;
}
public void setCRDisplay(boolean display, boolean gapped) {
if (gapped) gapped_cr_display = display;
else cr_display = display;
}
public boolean getCRDisplay(boolean gapped) {
if (gapped) return gapped_cr_display;
else return cr_display;
}
this.threshold = threshold;
this.threshold_percent = 0;
} */
public void setThreshold(float thresh) {
if (thresh < 0) thresh = 0;
else if (thresh > 1) thresh = 1;
if (!update()) {
threshold = 0;
threshold_percent = 0;
return;
}
List percentile_values = new ArrayList(thresh_map.keySet());
List thresh_values = new ArrayList(thresh_map.values());
int index;
float lastVal = 0;
for (index = 0; index < thresh_values.size(); index++) {
float value = ((Float)thresh_values.get(index)).floatValue();
if (value >= thresh) {
if (thresh - lastVal < value - thresh) index--;
break;
}
lastVal = value;
}
if (index >= thresh_values.size()) index = thresh_values.size() - 1;
threshold = thresh;
threshold_percent = ((Float)percentile_values.get(index)).floatValue();
return;
}
public void setThresholdByPercentile(float percentile) {
if (percentile < 0) percentile = 0;
else if (percentile >= 101) percentile = 100;
if (!update()) {
threshold = 0;
return;
}
threshold_percent = percentile;
Float threshold_Float = (Float)thresh_map.get(new Float(percentile));
if (threshold_Float != null) {
threshold = threshold_Float.floatValue();
return;
}
List percentile_values = new ArrayList(thresh_map.keySet());
List thresh_values = new ArrayList(thresh_map.values());
int index;
float lastVal = 0;
for (index = 0; index < thresh_values.size(); index++) {
float perc = ((Float)percentile_values.get(index)).floatValue();
if (perc >= percentile) {
if ((percentile - lastVal < perc - percentile) && index > 0) {
index--;
}
break;
}
lastVal = perc;
}
if (index >= thresh_values.size()) index = thresh_values.size() - 1;
threshold = ((Float)thresh_values.get(index)).floatValue();
}
private List calcConservedRegions(int seq_id, int offset, boolean gapped, boolean reverse) {
if (!isActive()) return null;
if (!update()) return null;
List c_regions = new ArrayList();
float score;
boolean inRegion = false;
int index = 0, marker = 0;
int full_gapped_length = 0;
for (index = 0; index < win_scores.length; index++) {
score = win_scores[index];
if (inRegion) {
if (score < threshold) {
inRegion = false;
c_regions.add(
new DistributionContainer(marker, index - 1, threshold));
}
} else {
if (score >= threshold) {
inRegion = true;
marker = index;
}
}
}
if (inRegion) {
c_regions.add(
new DistributionContainer(marker, index - 1, threshold));
}
if (!gapped) {
int g_start = 0, g_end = 0;
List track_gaps = sc_list.getSequenceGaps(seq_id);
int g_length = 0, cr_start, cr_end;
for (Iterator gap_itr = track_gaps.iterator(); gap_itr.hasNext();) {
DistributionContainer gap = (DistributionContainer)gap_itr.next();
g_start = gap.getStart() - full_gapped_length;
g_end = gap.getEnd() - full_gapped_length;
g_length = g_end - g_start + 1;
full_gapped_length += g_length;
for (Iterator cr_itr = c_regions.iterator(); cr_itr.hasNext();) {
DistributionContainer cr = (DistributionContainer)cr_itr.next();
cr_start = cr.getStart();
cr_end = cr.getEnd();
if (cr_start >= g_start) {
cr_start -= Math.min(g_length, cr_start - g_start);
cr.setStart(cr_start);
}
if (cr_end >= g_start) {
cr_end -= Math.min(g_length, cr_end - g_start);
cr.setEnd(cr_end);
}
}
}
}
ArrayList abs_regions = new ArrayList();
int new_start = 0, new_end = 0;
int full_length = col_scores.length;
if (!gapped) full_length -= full_gapped_length;
for (Iterator itr = c_regions.iterator(); itr.hasNext();) {
DistributionContainer dc = (DistributionContainer)itr.next();
if (reverse) {
new_start = full_length - dc.getEnd() - 1;
new_end = full_length - dc.getStart() - 1;
} else {
new_start = dc.getStart();
new_end = dc.getEnd();
}
new_start += offset;
new_end += offset;
abs_regions.add(
new DistributionContainer(
new_start,
new_end,
0));
}
if (reverse) Collections.reverse(abs_regions);
return abs_regions;
}
public synchronized boolean update() {
if (dirty || win_scores == null) {
try {
col_scores = calcColumnScores();
} catch (SCProfileException e) {
Log.printStackTrace(e);
return false;
}
float[] ungapped = m_algo.calcGaps(col_scores, total_gaps);
if (SCProfileList.__FULL_AUDIT) audit("\n4. Window smoothing calculations");
win_scores =
m_algo.smoothScores(
ungapped,
sc_list.getWindowSize(),
sc_list.getStepSize(),
sc_list.getSmoothingMethod());
win_scores = ColumnScoreAlgorithm.insertGaps(win_scores, total_gaps);
thresh_map = ColumnScoreAlgorithm.getThresholdMap(win_scores);
dirty = false;
setThresholdByPercentile(this.threshold_percent);
if (audit_stream != null) try {
audit(" Threshold: " + threshold_percent + "% " + threshold);
audit(" Conserved regions: ");
List crs = getConservedRegions(0, true, false);
for (Iterator itr = crs.iterator(); itr.hasNext();) {
audit(" " + itr.next());
}
} catch (SCProfileException e) {
Log.printStackTrace(e);
}
}
return true;
}
public String getName() {
StringBuffer buf = new StringBuffer(sc_list.getProfileOrderTag(this) + ": ");
for (int i = 0; i < sequences.size(); i++) {
int trk_id = ((Integer) sequences.get(i)).intValue();
String seq_name = "" + trk_id;
try {
TrackRelationshipOrderInterface rel = sc_list.getTrackRelationship();
seq_name = rel.getRelatedName(trk_id);
if (rel.getType().equals(TrackRelationshipOrderInterface.TYPE_PHYLODISTANCE) ||
rel.getType().equals(TrackRelationshipOrderInterface.TYPE_HOMOLOGOUS)) {
seq_name = ((PhyloDistanceRelationship)rel).getSpecies(trk_id);
String[] split = seq_name.split("_");
seq_name = split[0].charAt(0) + "." + split[1].substring(0, 3);
}
} catch (TrackRelationshipException e) {
Log.printStackTrace(e);
} catch (ArrayIndexOutOfBoundsException e) {
Log.printStackTrace(e);
}
if (seq_name.length() > 25) seq_name = seq_name.substring(0, 22) + "...";
buf.append(seq_name);
if (i != sequences.size() - 1)
buf.append(", ");
}
return buf.toString();
}
private float[] calcColumnScores() throws SCProfileException {
audit("3. Column Scores");
String cs_method = sc_list.getColScoreMethod();
TrackRelationshipOrderInterface relation = sc_list.getTrackRelationship();
String[] seqs = new String[sequences.size()];
String[] seqNames = new String[sequences.size()];
Iterator itr = sequences.iterator();
int i = 0;
while (itr.hasNext()) {
int trk_id = ((Integer) itr.next()).intValue();
String seqName = sc_list.getSequenceName(trk_id);
seqs[i] = sc_list.getSequence(trk_id);
audit(seqs[i]);
seqNames[i++] = seqName;
}
int seqLength = seqs[0].length();
int seqCount = seqs.length;
float[] scores = new float[seqLength];
for (i = 1; i < seqCount; i++) {
int seqLengthN = seqs[i].length();
if (seqLengthN != seqLength) {
throw new SCProfileException("Alignment sequences must be of the same length (" + seqLength + " != " + seqLengthN + ")");
}
}
if (cs_method.equals("ID%")) {
IDPercentageColumnScoreAlgorithm algo = new IDPercentageColumnScoreAlgorithm();
algo.setAuditStream(audit_stream);
m_algo = algo;
try {
scores = algo.calcColumnScores(seqs);
} catch (ColumnScoreException e) {
e.printStackTrace();
throw new SCProfileException(e.getMessage());
}
} else if (cs_method.equals("Distance Weight Sum")) {
DistanceWeightSumAlgorithm algo = new DistanceWeightSumAlgorithm(relation);
algo.setSeqIds(sequences);
algo.setAuditStream(audit_stream);
m_algo = algo;
try {
scores = algo.calcColumnScores(seqs);
} catch (ColumnScoreException e) {
e.printStackTrace();
throw new SCProfileException(e.getMessage());
}
} else {
return null;
}
audit(" " + k + "\t" + scores[k]);
}*/
return scores;
}
private boolean inAuditRange(int k) {
return audit_stream != null;
}
private void audit(Object obj) {
if (obj == null)
obj = "NULL";
if (audit_stream != null) {
audit_stream.println(obj.toString());
}
}
public void setSequence(int trk_id, boolean include) {
Integer trk = new Integer(trk_id);
if (include && !sequences.contains(trk)) {
sequences.add(trk);
try {
List tracks = sc_list.getTrackRelationship().getTrackOrder(sc_list.getReferenceTrack());
List ordered = new ArrayList();
for (int i = 0; i < tracks.size(); i++) {
Integer r_trk = (Integer)tracks.get(i);
if (sequences.contains(r_trk)) ordered.add(r_trk);
}
sequences = ordered;
} catch (TrackRelationshipException e) {
Log.printStackTrace(e);
}
setDirty(true);
} else if (!include) {
if (sequences.remove(trk)) setDirty(true);
}
}
public boolean isActive() {
return sequences.size() > 1;
}
public boolean isVisible() {
return visible;
}
public void setVisible(boolean vis) {
visible = vis;
}
public String toString(){
return getName();
}
}
package ca.bcgsc.sockeye.analysis.scprofile;
public class SCProfileException extends Exception {
public SCProfileException(String msg) {
super(msg);
}
}
package ca.bcgsc.sockeye.analysis.scprofile;
import java.awt.Color;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import ca.bcgsc.sockeye.analysis.Alignment;
import ca.bcgsc.sockeye.analysis.SequenceMatrix;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.datastorage.SockeyeTrackList;
import ca.bcgsc.sockeye.j3d.MultiDimDistributionFeature3D;
import ca.bcgsc.sockeye.trackmanager.TrackRelationshipException;
import ca.bcgsc.sockeye.trackmanager.TrackRelationshipOrderInterface;
import ca.bcgsc.sockeye.util.Log;
import ca.bcgsc.sockeye.util.StringUtils;
import ca.bcgsc.util.SequenceUtils;
public class SCProfileList {
protected Alignment alignment;
protected int w_size = __DEFAULT_WINDOW_SIZE;
protected int w_stepsize = 1;
protected String cs_method;
protected String ws_method;
protected int ref_track;
protected List track_gaps = null;
protected PrintStream auditStream = null;
protected float group_threshold_percent;
protected TrackRelationshipOrderInterface relationship;
protected String set_def_method;
protected String audit_file = null;
protected Map profile_store = new HashMap();
protected List custom_profiles;
protected List profiles;
protected static SockeyeTrackList storage_manager =
DataStoreUser.getInstance().getSockeyeTrackList();
public transient static final int __NUM_CUSTOM_PROFILES = 2;
public transient static final String[] __COLUMN_SCORING_METHODS =
new String[] { "ID%", "Distance Weight Sum" };
public transient static final String[] __WINDOW_SMOOTHING_METHODS =
new String[] { "mean", "Gaussian" };
public transient static final float __DEFAULT_THRESHOLD_PERCENTILE = 75f;
public transient static final int __DEFAULT_WINDOW_SIZE = 20;
public transient static final int __MAX_BIN_RESOLUTION = 3000;
public transient static final String[] __COLUMN_PHYLO_SCORING_METHODS =
new String[] { "Distance Weight Sum" };
public transient static final boolean __FULL_AUDIT = true;
private transient static final String __FULL_AUDIT_HEADER =
"Sequence Conservation Profile List Creation Audit\n\n"
+ "This document illustrates the creation of a ca.bcgsc.sockeye.analysis.scprofile."
+ "SCProfileList object and all of its contained SCProfiles.\n\nCONTENTS: \n"
+ "1. Parameters including AlignArray data\n"
+ "2. List of AlignArray sequence subsets to be profiled\n"
+ "\nFor each set:\n"
+ "3. Column score calculations\n"
+ "4. Window smoothing calculations\n"
+ "5. Conserved Regions with default threshold "
+ __DEFAULT_THRESHOLD_PERCENTILE
+ "\n"
+ "6. Distribution containers in ~"
+ __MAX_BIN_RESOLUTION
+ " bins\n\n";
private transient static final String _AUDIT_HEADER =
"Sequence Conservation Profile List Creation Audit\n\n"
+ "This document illustrates the creation of a ca.bcgsc.sockeye.analysis.scprofile."
+ "SCProfileList object and all of its contained SCProfiles.\n\nCONTENTS: \n"
+ "1. Parameters\n"
+ "2. List of AlignArray sequence subsets to be profiled\n"
+ "\nFor each set:\n"
+ "5. Conserved Regions with default threshold "
+ __DEFAULT_THRESHOLD_PERCENTILE
+ "\n"
+ "6. Distribution containers in ~"
+ __MAX_BIN_RESOLUTION
+ " bins\n\n";
public SCProfileList(
Alignment alignment,
int ref_track,
TrackRelationshipOrderInterface relation,
int w_size,
String set_method,
String audit_file)
throws SCProfileException {
this.alignment = alignment;
this.relationship = relation;
this.w_size = w_size;
this.w_stepsize = 1;
this.cs_method = __COLUMN_SCORING_METHODS[0];
this.ws_method = __WINDOW_SMOOTHING_METHODS[0];
this.ref_track = ref_track;
this.set_def_method = set_method;
this.group_threshold_percent = __DEFAULT_THRESHOLD_PERCENTILE;
this.audit_file = audit_file;
profiles = new ArrayList();
if (audit_file != null) {
try {
auditStream = new PrintStream(new FileOutputStream(audit_file));
auditStream.println(__FULL_AUDIT ? __FULL_AUDIT_HEADER : _AUDIT_HEADER);
auditStream.println("1. Parameters");
auditStream.println(" window size: " + w_size + " step size: " +
w_stepsize +
" scoring method: " + cs_method +
" window method: " +
ws_method + " ref. sequence: " + ref_track);
if (__FULL_AUDIT) {
auditStream.println("\n AlignArray: ");
for (Iterator i = (relationship.getTrackOrder(ref_track)).iterator(); i.hasNext(); ) {
Integer trk_id = (Integer)i.next();
String seq = getSequence(trk_id.intValue());
auditStream.println(" " + trk_id.intValue() + ":\n Size: " + seq.length() +
"\n" + SequenceUtils.cutString(seq, 77, " "));
}
}
} catch (IOException e) {
Log.printStackTrace(e);
} catch (TrackRelationshipException e) {
Log.printStackTrace(e);
}
}
custom_profiles = new ArrayList(__NUM_CUSTOM_PROFILES);
for (int i = 0; i < __NUM_CUSTOM_PROFILES; i++) {
SCProfile c_profile = new SCProfile(this, new ArrayList());
int c_value = (60 / (__NUM_CUSTOM_PROFILES - 1)) * i + 150;
c_profile.setColour(new Color(c_value, c_value, c_value));
custom_profiles.add(c_profile);
}
redefineProfiles();
}
public SCProfileList(SCProfileList source) {
this.alignment = source.alignment;
this.audit_file = source.audit_file;
this.auditStream = source.auditStream;
this.cs_method = source.cs_method;
this.ws_method = source.ws_method;
this.custom_profiles = new ArrayList(__NUM_CUSTOM_PROFILES);
for (Iterator i = source.custom_profiles.iterator(); i.hasNext();) {
custom_profiles.add(new SCProfile(this, (SCProfile) i.next()));
}
this.profiles = new ArrayList(source.profiles.size());
for (Iterator i = source.profiles.iterator(); i.hasNext();) {
profiles.add(new SCProfile(this, (SCProfile) i.next()));
}
this.group_threshold_percent = source.group_threshold_percent;
this.ref_track = source.ref_track;
this.relationship = source.relationship;
this.set_def_method = source.set_def_method;
this.w_size = source.w_size;
this.w_stepsize = source.w_stepsize;
}
public void redefineProfiles() throws SCProfileException {
profiles.clear();
List s =
SubsetGenerator.getSubsets(relationship, ref_track, set_def_method);
if (s == null) {
throw new SCProfileException("No sequence subsets generated.");
}
SCProfile lastProfile = null;
for (int i = 0; i < s.size(); i++) {
List sequences = (List)s.get(i);
if (sequences == null || sequences.size() == 0) {
continue;
}
SCProfile newProfile =
new SCProfile(this, sequences);
int col_index = i % MultiDimDistributionFeature3D.color_set.length;
Color colour = MultiDimDistributionFeature3D.color_set[col_index].get();
newProfile.setColour(colour);
profiles.add(newProfile);
lastProfile = newProfile;
storeProfile(newProfile);
}
if (lastProfile != null) lastProfile.setThresholdByPercentile(__DEFAULT_THRESHOLD_PERCENTILE);
Iterator i = custom_profiles.iterator();
while (i.hasNext()) {
SCProfile custom = (SCProfile)i.next();
custom.setDirty(true);
}
}
public SCProfileList() {
}
public List getDistributionData(int bins, int offset, int data_start, int data_end, boolean reverse)
throws SCProfileException {
ArrayList group = new ArrayList();
for (int i = 0; i < size(); i++) {
SCProfile prof = getProfile(i);
Map data = prof.getDistributionData(bins, offset, data_start, data_end, reverse);
if (data != null) {
group.add(data);
}
}
return group;
}
public int size() {
int active_customs = 0;
for (int i = 0; i < custom_profiles.size(); i++)
if (((SCProfile)custom_profiles.get(i)).isActive()) active_customs++;
return profiles.size() + active_customs;
}
private void storeProfile(SCProfile profile) {
List seqs = new ArrayList(profile.getSequences());
Collections.sort(seqs);
profile_store.put(seqs.toString(), profile);
}
public SCProfile getProfile(int i) {
int size = size();
if (i < 0 || i >= size())
return null;
List all_profiles = new ArrayList();
all_profiles.addAll(custom_profiles);
all_profiles.addAll(profiles);
for (int idx = 0; idx < all_profiles.size(); idx++) {
SCProfile p = (SCProfile) all_profiles.get(idx);
if (!p.isActive()) i++;
if (idx == i) return p;
}
return null;
}
public synchronized SCProfile getProfile(List seq_ids) {
SCProfile profile = null;
int size = size();
for (int i = 0; i < size; i++) {
SCProfile pro = getProfile(i);
List pro_seqs = pro.getSequences();
if (pro_seqs.size() == seq_ids.size() &&
pro_seqs.containsAll(seq_ids) &&
seq_ids.containsAll(pro_seqs)) {
profile = pro;
}
}
String key = seq_ids.toString();
if (profile == null) {
Collections.sort(seq_ids);
profile = (SCProfile)profile_store.get(key);
}
if (profile == null) {
profile = new SCProfile(this, seq_ids);
profile.update();
profile_store.put(key, profile);
}
return profile;
}
public String getProfileOrderTag(int index) {
SCProfile profile = getProfile(index);
int c_index = custom_profiles.indexOf(profile);
if (c_index != -1) return "C" + (c_index + 1);
int offset = 0;
for (int i = 0; i < custom_profiles.size(); i++) {
if (((SCProfile)custom_profiles.get(i)).isActive()) offset++;
}
return "P" + (index - offset + 1);
}
public String getProfileOrderTag(SCProfile profile) {
int size = size();
String result = "";
for (int i = 0; i < size; i++) {
if (profile == getProfile(i)) {
if (custom_profiles.contains(profile)) result = "C" + (i + 1);
else {
int offset = 0;
for (int f = 0; f < custom_profiles.size(); f++) {
if (((SCProfile)custom_profiles.get(f)).isActive()) offset++;
}
result = "P" + (i - offset + 1);
}
break;
}
}
return result;
}
public SCProfile getCustomProfile(int index) {
if (index < 0 || index >= custom_profiles.size()) return null;
return (SCProfile)custom_profiles.get(index);
}
public SCProfile getPredefinedProfile(int index) {
if (index < 0 || index >= profiles.size()) return null;
return (SCProfile)profiles.get(index);
}
public List getProfileNames() {
ArrayList names = new ArrayList();
int size = size();
for (int i = 0; i < size(); i++) {
names.add(getProfile(i).getName());
}
return names;
}
public float getProfileThreshold(int i) {
SCProfile profile = getProfile(i);
if (profile == null)
return 0;
return profile.getThreshold();
}
public float getGroupThresholdByPercentile() {
return group_threshold_percent;
}
throws SCProfileException {
SCProfile profile = getProfile(i);
if (profile == null)
throw new SCProfileException("Invalid profile index: " + i);
profile.setThreshold(thresh);
}*/
public void setProfileThresholdByPercentile(int i, int per)
throws SCProfileException {
SCProfile profile = getProfile(i);
if (profile == null)
throw new SCProfileException("Invalid profile index: " + i);
profile.setThresholdByPercentile(per);
}
public void setGroupThresholdByPercentile(float per) {
group_threshold_percent = per;
for (int i = 0; i < size(); i++) {
SCProfile profile = getProfile(i);
if (profile != null) profile.setThresholdByPercentile(per);
}
}
public TrackRelationshipOrderInterface getTrackRelationship() {
return relationship;
}
public void setTrackRelationship(TrackRelationshipOrderInterface relation) {
TrackRelationshipOrderInterface temp = relationship;
relationship = relation;
if (!temp.getType().equals(relationship.getType())) setProfilesDirty();
}
public void setColumnScoreMethod(String method) {
if (!cs_method.equals(method)) setProfilesDirty();
cs_method = method;
}
public void setWindowSmoothMethod(String method) {
if (!ws_method.equals(method)) setProfilesDirty();
ws_method = method;
}
public void setWindowSize(int size) {
if (w_size != size) setProfilesDirty();
w_size = size;
}
public void setStepSize(int size) {
if (w_stepsize != size) setProfilesDirty();
w_stepsize = size;
}
public void setCustomProfile(int c_profile, int trk_id, boolean include) {
SCProfile custom = (SCProfile)custom_profiles.get(c_profile);
custom.setSequence(trk_id, include);
}
public void setSetDefinitionMethod(String method) {
String temp = set_def_method;
set_def_method = method;
if (!temp.equals(set_def_method)) setProfilesDirty();
}
public String getSetDefinitionMethod() {
return set_def_method;
}
public String getColScoreMethod() {
return this.cs_method;
}
public int getReferenceTrack() {
return ref_track;
}
public String getDMatrixName() {
return SequenceMatrix.getMatchScoreMatrix(SequenceMatrix.DTYPE1).getName();
}
public int getWindowSize() {
return w_size;
}
public int getStepSize() {
return w_stepsize;
}
public String getSmoothingMethod() {
return ws_method;
}
public String getSequence(int seq_id) {
return alignment.getStrandSequence(seq_id, true);
}
public int getSequenceStart(int seq_id) {
return alignment.getStart(seq_id);
}
public String getSequenceName(int trk_id) {
String name = StringUtils.getShortNameForTrackID(trk_id);
return name == null ? trk_id + " (nameless)" : name;
}
public void setProfilesDirty() {
Iterator itr;
for (itr = custom_profiles.iterator(); itr.hasNext();) {
SCProfile profile = (SCProfile)itr.next();
profile.setDirty(true);
}
for (itr = profiles.iterator(); itr.hasNext();) {
SCProfile profile = (SCProfile)itr.next();
profile.setDirty(true);
}
for (itr = profile_store.values().iterator(); itr.hasNext();) {
((SCProfile)itr.next()).setDirty(true);
}
}
private void audit(Object obj) {
if (obj == null)
obj = "NULL";
if (auditStream != null)
auditStream.println(obj.toString());
}
public boolean isCustomProfile(int profile) {
return custom_profiles.contains(getProfile(profile));
}
public int numInactive() {
int inactive = 0;
for (Iterator i = custom_profiles.iterator(); i.hasNext();) {
if ( !((SCProfile)i.next()).isActive()) inactive++;
}
return inactive;
}
public List getSequenceGaps(int seq_id) {
return alignment.getStrandGaps(seq_id);
}
}
package ca.bcgsc.sockeye.analysis.scprofile;
import java.util.ArrayList;
import java.util.List;
import ca.bcgsc.sockeye.trackmanager.TrackRelationshipException;
import ca.bcgsc.sockeye.trackmanager.TrackRelationshipOrderInterface;
import ca.bcgsc.sockeye.util.Log;
public class SubsetGenerator{
public static final String __SET_DISTANCE = "increasing distance from reference track";
public static final String __SET_PAIRWISE = "sequence pairs";
SubsetGenerator() {}
public static List getMethods() {
List methods = new ArrayList();
methods.add(__SET_DISTANCE);
methods.add(__SET_PAIRWISE);
return methods;
}
public static List getSubsets(TrackRelationshipOrderInterface relationship, int ref_track, String set_method) {
if (set_method.equals(__SET_DISTANCE)) {
return SubsetGenerator.getDistanceSets(relationship, ref_track);
} else if (set_method.equals(__SET_PAIRWISE)) {
return SubsetGenerator.getPairwiseSets(relationship, ref_track);
}
return null;
}
public static List getDistanceSets(TrackRelationshipOrderInterface relationship, int ref_track) {
ArrayList subsets = new ArrayList();
List tracks = null;
try {
tracks = relationship.getTrackOrder(ref_track);
} catch (TrackRelationshipException e) {
Log.printStackTrace(e);
return null;
}
for (int i = 2; i <= tracks.size(); i++) {
ArrayList subset = new ArrayList();
for (int j = 0; j < i; j++) {
subset.add(tracks.get(j));
}
subsets.add(subset);
}
return subsets;
}
public static List getPairwiseSets(TrackRelationshipOrderInterface relationship, int ref) {
ArrayList subsets = new ArrayList();
List tracks = null;
try {
tracks = relationship.getTrackOrder(ref);
} catch (TrackRelationshipException e) {
Log.printStackTrace(e);
return null;
}
for (int i = 0; i <= tracks.size(); i++) {
for (int j = i + 1; j < tracks.size(); j++) {
ArrayList subset = new ArrayList();
subset.add(tracks.get(i));
subset.add(tracks.get(j));
subsets.add(subset);
}
}
return subsets;
}
}
package ca.bcgsc.sockeye.analysis.scprofile.columnscore;
import java.io.PrintStream;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import ca.bcgsc.sockeye.analysis.scprofile.SCProfileList;
import ca.bcgsc.sockeye.service.featureloader.common.DistributionContainer;
public abstract class ColumnScoreAlgorithm {
public static final String GAUSSIAN_SMOOTH_METHOD = "Gaussian";
public static final String MEAN_SMOOTH_METHOD = "mean";
private PrintStream auditStream;
public static final float _UNDEFINED = Float.NEGATIVE_INFINITY;
abstract public float[] calcColumnScores(String[] seqs) throws ColumnScoreException;
abstract public String getName();
protected void audit(Object message) {
if (auditStream != null) {
auditStream.println(message);
} else {
if (message != null) {
}
}
}
public void setAuditStream(PrintStream stream) {
auditStream = stream;
}
public float[] smoothScores(float[] ungapped, int w_size, int w_stepsize, String ws_method) {
if (w_size > ungapped.length)
w_size = ungapped.length / 4;
if (w_size < 1)
w_size = 1;
if (w_stepsize > w_size)
w_stepsize = w_size / 2;
if (w_stepsize < 1)
w_stepsize = 1;
float[] win_scores = new float[ungapped.length];
float high_score = 0;
int w_length = 2 * (w_size / 2) + 1;
if (w_size > 1) {
if (ws_method.equals(MEAN_SMOOTH_METHOD)) {
int frame = 0;
float lastVal = 0;
float[] weights = new float[w_length];
Arrays.fill(weights, 1.0f);
for (int i = 0; i < ungapped.length; i++) {
frame = i % w_stepsize;
if (frame == 0) lastVal = windowAvg(i, w_size, ungapped, weights, w_length);
win_scores[i] = lastVal;
if (lastVal > high_score)
high_score = lastVal;
}
} else if (ws_method.equals(GAUSSIAN_SMOOTH_METHOD)) {
int frame = 0;
float lastVal = 0;
float[] weight = new float[w_length];
float SIG = (w_length - 1.0f) / 6f;
float MU = (w_length -1.0f) / 2f;
double term1 = 1f / ((Math.sqrt(2 * Math.PI) * SIG));
double term2 = -1f / (2 * Math.pow(SIG, 2));
float weight_sum = 0;
for (int x = 0; x <= w_length / 2; x++) {
double value = term1 * Math.exp(term2 * Math.pow(x - MU, 2) );
weight[x] =(float)value;
weight[w_length - x - 1] = (float)value;
}
for (int i = 0; i < weight.length; i++) weight_sum += weight[i];
for (int i = 0; i < ungapped.length; i++) {
frame = i % w_stepsize;
if (frame == 0) lastVal = windowAvg(i, w_size, ungapped, weight, weight_sum);
win_scores[i] = lastVal;
if (lastVal > high_score)
high_score = lastVal;
}
}
} else {
for (int i = 0; i < ungapped.length; i++) {
win_scores[i] = ungapped[i];
if (win_scores[i] > high_score) high_score = win_scores[i];
}
}
if (auditStream != null && SCProfileList.__FULL_AUDIT) {
StringBuffer buf = new StringBuffer();
for (int i = 0; i < win_scores.length; i++) {
buf.append(" " + i + "\t" + win_scores[i] + "\n");
}
audit(buf.toString());
}
return win_scores;
}
public static Map getThresholdMap(float[] win_scores) {
TreeMap thresh_map = new TreeMap();
thresh_map.put(new Float(0), new Float(0));
float[] ordered_scores = (float[])win_scores.clone();
Arrays.sort(ordered_scores);
int start = 0;
for (start = 0; start < ordered_scores.length && ordered_scores[start] == _UNDEFINED; start++);
float[] temp = ordered_scores;
ordered_scores = new float[temp.length - start];
for (int i = start; i < temp.length; i++) ordered_scores[i - start] = temp[i];
for (int i = 0; i < ordered_scores.length; i++) {
int num_scores_LOE = i ;
while ( (num_scores_LOE + 1) < ordered_scores.length &&
ordered_scores[num_scores_LOE] == ordered_scores[num_scores_LOE +1])
num_scores_LOE++;
float percentile = (num_scores_LOE + 1f) / ordered_scores.length * 100f;
thresh_map.put(new Float(percentile), new Float(ordered_scores[i]));
i = num_scores_LOE;
}
thresh_map.put(new Float(100 + 0.00001f), new Float(1));
return thresh_map;
}
public static float getAverageIsland(float[] scores, float threshold) {
int sum = 0;
int count = 0;
int cur_run = 0;
int max = 0;
boolean in_island = false;
for (int pos = 0; pos < scores.length; pos++) {
if (scores[pos] >= threshold) {
in_island = true;
cur_run++;
} else {
if (in_island) {
if (cur_run > 1) {
count++;
sum += cur_run;
if (cur_run > max) max = cur_run;
}
cur_run = 0;
in_island = false;
}
}
}
if (in_island) {
count++;
sum += cur_run;
}
if (count == 0) return 0;
return (float)sum / (float)count;
}
public float[] calcGaps(float[] col_scores, List gaps) {
gaps.clear();
int begin = 0, index = 0;
float[] ungapped = new float[col_scores.length];
boolean inGap = false;
for (int i = 0; i < col_scores.length; i++) {
float score = col_scores[i];
if (inGap) {
if (score != _UNDEFINED) {
inGap = false;
gaps.add(new DistributionContainer(begin, i - 1, 0));
ungapped[index++] = score;
}
} else {
if (score == _UNDEFINED) {
inGap = true;
begin = i;
} else
ungapped[index++] = score;
}
}
if (inGap) {
gaps.add(new DistributionContainer(begin, col_scores.length - 1, 0));
}
audit(" Gaps Found (" + gaps.size() + "): " + gaps + "\n");
if (gaps.size() > 0) {
float[] temp = ungapped;
ungapped = new float[index];
for (int i = 0; i < index; i++)
ungapped[i] = temp[i];
return ungapped;
} else
return ungapped;
}
public static float[] insertGaps(float[] in_arr, List gaps) {
if (gaps == null || gaps.size() == 0) return in_arr;
int total_gapped_length = 0;
for (Iterator i = gaps.iterator(); i.hasNext();) {
DistributionContainer gap = (DistributionContainer)i.next();
total_gapped_length += gap.getEnd() - gap.getStart() + 1;
}
total_gapped_length += in_arr.length;
float[] result = new float[total_gapped_length];
Iterator gapItr = gaps.iterator();
DistributionContainer nextGap = null;
if (gapItr.hasNext())
nextGap = (DistributionContainer)gapItr.next();
int nextBreak = nextGap != null ? nextGap.getStart() : total_gapped_length;
int absIndex = 0, index = 0, start = 0, end = 0;
while (index < in_arr.length && absIndex < total_gapped_length) {
if (absIndex == nextBreak) {
int x = absIndex;
absIndex += nextGap.getEnd() - nextGap.getStart() + 1;
while (x < absIndex) {
result[x] = _UNDEFINED;
x++;
}
if (gapItr.hasNext())
nextGap = (DistributionContainer)gapItr.next();
else
nextGap = null;
nextBreak = nextGap != null ? nextGap.getStart() : total_gapped_length;
continue;
} else {
result[absIndex] = in_arr[index++];
absIndex++;
}
}
while (absIndex < total_gapped_length) {
result[absIndex++] = _UNDEFINED;
}
return result;
}
public static String insertGaps(String in_string, List gaps) {
if (gaps == null) return new String(in_string);
int total_gapped_length = 0;
for (Iterator i = gaps.iterator(); i.hasNext();) {
DistributionContainer gap = (DistributionContainer)i.next();
total_gapped_length += gap.getEnd() - gap.getStart() + 1;
}
total_gapped_length += in_string.length();
StringBuffer buf = new StringBuffer(total_gapped_length);
Iterator gapItr = gaps.iterator();
DistributionContainer nextGap = null;
if (gapItr.hasNext())
nextGap = (DistributionContainer)gapItr.next();
int nextBreak = nextGap != null ? nextGap.getStart() : total_gapped_length;
int absIndex = 0, index = 0, start = 0, end = 0;
while (index < in_string.length() && absIndex < total_gapped_length) {
if (absIndex == nextBreak) {
int x = absIndex;
absIndex += nextGap.getEnd() - nextGap.getStart() + 1;
while (x < absIndex) {
buf.append("-");
x++;
}
if (gapItr.hasNext())
nextGap = (DistributionContainer)gapItr.next();
else
nextGap = null;
nextBreak = nextGap != null ? nextGap.getStart() : total_gapped_length;
continue;
} else {
buf.append(in_string.charAt(index++));
absIndex++;
}
}
while (absIndex < total_gapped_length) {
buf.append("-");
absIndex++;
}
return buf.toString();
}
int start = pos - w_size / 2;
int end = pos + w_size / 2;
int length = end - start + 1;
if (start < 0)
return 0;
if (end >= srcvalues.length)
return 0;
float[] weight = new float[(int)length];
float SIG = length / 6f;
float MU = (length -1.0f) / 2f;
double term1 = 1f / ((Math.sqrt(2 * Math.PI) * SIG));
double term2 = -1f / (2 * Math.pow(SIG, 2));
try {
for (int x = 0; x <= length / 2; x++) {
double value = term1 * Math.exp(term2 * Math.pow(x - MU, 2) );
weight[x] =(float)value;
weight[length - x - 1] = (float)value;
}
float sum_num = 0, sum_den = 0;
for (int i = start; i < end; i++) {
float score = srcvalues[i];
if (score == _UNDEFINED)
score = 0;
sum_num += score * weight[i - start];
sum_den += weight[i - start];
}
float total = sum_num / sum_den;
return total;
} catch (Exception e) {
e.printStackTrace();
return 0;
}
}*/
private static float windowAvg(int pos, int w_size, float[] srcvalues, float[] weights, float weight_sum) {
int start = pos - w_size / 2;
int end = pos + w_size / 2;
if (start < 0)
return _UNDEFINED;
if (end >= srcvalues.length)
return _UNDEFINED;
float sum_num = 0;
for (int i = start; i <= end; i++) {
float score = srcvalues[i];
assert(score != _UNDEFINED);
sum_num += score * weights[i - start];
}
float total = sum_num / weight_sum;
return total;
}
}
package ca.bcgsc.sockeye.analysis.scprofile.columnscore;
public class ColumnScoreException extends Exception {
public ColumnScoreException(String string) {
super(string);
}
}
package ca.bcgsc.sockeye.analysis.scprofile.columnscore;
import java.util.List;
import ca.bcgsc.sockeye.analysis.SequenceMatrix;
import ca.bcgsc.sockeye.trackmanager.TrackRelationshipException;
import ca.bcgsc.sockeye.trackmanager.TrackRelationshipOrderInterface;
import ca.bcgsc.sockeye.util.Log;
public class DistanceWeightSumAlgorithm extends ColumnScoreAlgorithm {
private TrackRelationshipOrderInterface relation;
private List seqIds = null;
public DistanceWeightSumAlgorithm(TrackRelationshipOrderInterface relation) {
this.relation = relation;
}
public float[] calcColumnScores(String[] seqs) throws ColumnScoreException {
if (seqIds == null) {
throw new ColumnScoreException("No seq ids specified");
}
if (seqIds.size() != seqs.length) {
throw new ColumnScoreException("Number of seqids does not match number of sequences.");
}
int seqLength = seqs[0].length();
int seqCount = seqs.length;
float[] scores = new float[seqLength];
for (int i = 0; i < seqCount; i++) {
if (seqs[i].length() != seqLength) {
throw new ColumnScoreException(
"Alignment sequences must be of the same length (" + seqLength + ")");
}
}
SequenceMatrix DMatrix =
SequenceMatrix.getMatchScoreMatrix(SequenceMatrix.DTYPE1);
audit("\n D-Matrix: \n" + DMatrix);
StringBuffer buf =
new StringBuffer(" Seq. Relationship: " + relation + "\n");
buf.append(" Rel. B_values: ");
float[][] B_values = new float[seqCount - 1][seqCount];
float Bval = 0;
for (int i = 0; i < seqCount - 1; i++) {
for (int j = i + 1; j < seqCount; j++) {
int track1 = ((Integer)seqIds.get(i)).intValue();
int track2 = ((Integer)seqIds.get(j)).intValue();
try {
Bval = relation.getRelationshipValue(track1, track2);
B_values[i][j] = Bval;
buf.append("(" + track1 + ":" + track2 + "=" + Bval + "), ");
} catch (TrackRelationshipException e) {
Log.printStackTrace(e);
throw new ColumnScoreException(
"Error finding distance value"
+ "between tracks "
+ track1
+ " and "
+ track2);
}
}
}
audit(buf.toString() + "\n");
float Dval = 0, BDSum = 0, BSum = 0;
boolean totalGap;
for (int k = 0; k < seqLength; k++) {
buf = new StringBuffer(" Column " + k + ": ");
for (int i = 0; i < seqCount; i++) {
buf.append(seqs[i].charAt(k));
}
BDSum = 0;
BSum = 0;
totalGap = true;
String bps = "";
for (int i = 0; i < seqCount; i++) {
char bp = seqs[i].charAt(k);
bps += bp;
if (bp != '-') {
totalGap = false;
}
}
if (!totalGap) {
for (int i = 0; i < seqCount - 1; i++) {
for (int j = i + 1; j < seqCount; j++) {
Bval = B_values[i][j];
Dval =
DMatrix.getElement(
"" + Character.toUpperCase(seqs[i].charAt(k)),
"" + Character.toUpperCase(seqs[j].charAt(k)));
BDSum += Bval * Dval;
BSum += Bval;
}
}
if (BSum == 0)
scores[k] = 0;
else
scores[k] = BDSum / BSum;
buf.append("\t " + BDSum + "/" + BSum + " = " + scores[k]);
} else {
scores[k] = _UNDEFINED;
buf.append("\t FULLGAP");
}
audit(buf.toString());
}
return scores;
}
public String getName() {
return "PhyloVISTA";
}
public void setSeqIds(List is) {
seqIds = is;
}
}
package ca.bcgsc.sockeye.analysis.scprofile.columnscore;
import java.util.ArrayList;
import java.util.List;
import ca.bcgsc.util.SequenceUtils;
public class IDPercentageColumnScoreAlgorithm extends ColumnScoreAlgorithm {
public float[] calcColumnScores(String[] seqs) throws ColumnScoreException {
final String[] tmp = seqs;
seqs = new String[tmp.length];
for (int i = 0; i < tmp.length; i++) {
seqs[i] = new String(tmp[i]);
char ch;
for (int j = 0; j < seqs[i].length(); j++) {
ch = seqs[i].charAt(j);
if ("ACTG-".indexOf(ch) == -1) seqs[i] = seqs[i].replace(ch, '-');
}
}
seqs[0] = "NTNTAN--N" + seqs[0].substring(9);
seqs[1] = "NNNTAA-NN" + seqs[1].substring(9);
seqs[2] = "TNNT-T-N-" + seqs[2].substring(9);
} catch (Exception e) {};*/
int seqLength = seqs[0].length();
int seqCount = seqs.length;
float[] scores = new float[seqLength];
List seq_content = new ArrayList();
for (int i = 0; i < seqCount; i++) {
String seq = seqs[i].toUpperCase();
if (seq.length() != seqLength) {
throw new ColumnScoreException("Alignment sequences must be of the same length (" + seqLength + ")");
}
double[] ch_content = SequenceUtils.characterContent(seq, true);
seq_content.add(ch_content);
}
char firstChar = '\0', ch;
float score;
int Ncount;
String output = "";
for (int k = 0; k < seqLength; k++) {
audit("\n Column " + k + ":");
for (int i = 0; i < seqCount; i++) {
audit(" " + i + "\t" + seqs[i].charAt(k));
}
score = 1;
Ncount = 0;
double[] mask_probability = {1.0, 1.0, 1.0, 1.0};
int start = 0;
while (start < seqCount) {
firstChar = seqs[start].charAt(k);
if (firstChar == 'N' || firstChar == 'X') {
Ncount++;
double[] seq_probability = (double[])seq_content.get(start);
for (int n = 0; n < 4; n++) {
mask_probability[n] = mask_probability[n] * seq_probability[n];
}
start++;
} else break;
}
for (int j = start + 1; j < seqCount; j++) {
ch = seqs[j].charAt(k);
if (ch != firstChar) {
if ((ch == 'N' || ch == 'X') && firstChar != '-') {
Ncount++;
double[] seq_probability = (double[])seq_content.get(j);
int index = nucleotide_index(firstChar);
if (index > -1) mask_probability[index] = mask_probability[index] * seq_probability[index];
} else {
score = 0;
break;
}
}
}
if (score > 0) {
if (firstChar == '-') {
if (Ncount == 0) {
score = _UNDEFINED;
output = " Score: COMPLETE GAP";
} else {
score = 0;
output = " Score: " + score;
}
} else {
if (Ncount == seqCount) {
score = 0;
for (int n = 0; n < 4; n++) {
score += mask_probability[n];
}
} else {
score = (float)mask_probability[nucleotide_index(firstChar)];
}
output = " Score: " + score;
}
} else output = " Score: 0";
audit(output);
scores[k] = score;
}
return scores;
}
private int nucleotide_index(char ch) {
switch (ch) {
case 'A' : return 0;
case 'C' : return 1;
case 'G' : return 2;
case 'T' : return 3;
}
return -1;
}
public String getName() {
return "ID%";
}
}
package ca.bcgsc.sockeye.analysis.scprofile.junit;
import java.util.List;
import java.util.Map;
import junit.framework.TestCase;
import junit.framework.TestSuite;
import ca.bcgsc.sockeye.analysis.scprofile.SCProfile;
import ca.bcgsc.sockeye.analysis.scprofile.columnscore.ColumnScoreAlgorithm;
import ca.bcgsc.sockeye.service.featureloader.common.DistributionContainer;
public class SCProfileUnitTest extends TestCase
{
TestAlignArray testArray1;
public SCProfileUnitTest(String name)
{
super(name);
}
public static void main(String[] args)
{
junit.textui.TestRunner.run(SCProfileUnitTest.suite());
}
protected void setUp()
{
testArray1 = new TestAlignArray(TestAlignArray.DATA_SET3);
}
public static TestSuite suite()
{
TestSuite testSuite = new TestSuite();
testSuite.addTestSuite(SCProfileUnitTest.class);
return testSuite;
}
public void testSCProfileOne() throws Exception
{
TestSCProfileList profileList = new TestSCProfileList(0);
List sequences = profileList.getTrackRelationship().getTrackOrder(0);
SCProfile testSCProfile = new SCProfile(profileList, sequences);
Map data = testSCProfile.getDistributionData(4, 2, 0, 10, false);
float[] exp_col_score = new float[] {1.0f,0.0f,0.14215687f,0.019607844f,0.0f,0,0,Float.NEGATIVE_INFINITY,0,0.053921569f};
float[] test_col_score = testSCProfile.getColumnScores();
assertEqualsFloatArray("ColumnScores",exp_col_score, test_col_score);
float undefined = ColumnScoreAlgorithm._UNDEFINED;
float[] exp_win_score = new float[] {undefined,undefined,0.23235294f,0.032352943f,0.032352943f,0.003921569f,0.010784314f,undefined,undefined,undefined};
float[] test_win_score = testSCProfile.getSmoothedScores();
assertEqualsFloatArray("WinScores",exp_win_score, test_win_score);
testSCProfile.setThresholdByPercentile(80);
float exp_thresh = 0.032352943f;
assertEquals(exp_thresh, testSCProfile.getThreshold(), 0f);
List aList = (List)data.get("Containers");
assertEquals("#bins", 2, aList.size());
assertBinEquals("bin1", (DistributionContainer)aList.get(0), new DistributionContainer(4, 7, 0.099019616f));
assertBinEquals("bin2", (DistributionContainer)aList.get(1), new DistributionContainer(7, 9, 0.007352941669f));
}
{
float[] scores =
{ 10.0f, 300.0f, 7.0f, 190.0f, 20.0f, 5.0f, 6.0f, 17.0f, 8.0f };
SCProfile testSCProfile =
new SCProfile(
null,
null,
scores,
15.0f,
new PrintStream(new FileOutputStream("testing.log")));
testSCProfile.smoothScores(1, 1, "mean");
List list = testSCProfile.getConservedRegions(null);
assertEquals(3, list.size());
assertTrue(
distributionContainerEquals(
list.get(0),
new DistributionContainer(1, 1, 15.0),
false));
assertTrue(
distributionContainerEquals(
list.get(1),
new DistributionContainer(3, 4, 15.0),
false));
assertTrue(
distributionContainerEquals(
list.get(2),
new DistributionContainer(7, 7, 15.0),
false));
}
{
float[] scores =
{ 10.0f, 300.0f, 7.0f, 190.0f, 20.0f, 5.0f, 6.0f, 17.0f, 8.0f };
SCProfile testSCProfile =
new SCProfile(
null,
null,
scores,
new PrintStream(new FileOutputStream("testing.log")));
testSCProfile.setThreshold(10.0f);
testSCProfile.smoothScores(1, 1, "mean");
List list = testSCProfile.getConservedRegions(null);
assertEquals(3, list.size());
assertTrue(
distributionContainerEquals(
list.get(0),
new DistributionContainer(0, 1, 10.0),
false));
assertTrue(
distributionContainerEquals(
list.get(1),
new DistributionContainer(3, 4, 10.0),
false));
assertTrue(
distributionContainerEquals(
list.get(2),
new DistributionContainer(7, 7, 10.0),
false));
}
{
float[] scores =
{
0.0f,
0.0f,
0.0f,
0.0284f,
0.0197f,
0.0126f,
0.0f,
0.0f,
0.0327f,
0.0f,
0.1f,
0.02f };
SCProfile testSCProfile =
new SCProfile(
null,
null,
scores,
0.015f,
new PrintStream(new FileOutputStream("testing.log")));
testSCProfile.smoothScores(3, 4, "mean");
ArrayList list = testSCProfile.getDistributionData(11, 0);
list = testSCProfile.getDistributionData(11, 0);
assertEquals(12, list.size());
assertTrue(
distributionContainerEquals(
list.get(0),
new DistributionContainer(0, 1, 0.0f),
true));
assertTrue(
distributionContainerEquals(
list.get(1),
new DistributionContainer(1, 2, 0.0),
true));
assertTrue(
distributionContainerEquals(
list.get(2),
new DistributionContainer(2, 3, 0.0071f),
true));
assertTrue(
distributionContainerEquals(
list.get(3),
new DistributionContainer(3, 4, 0.0071f),
true));
assertTrue(
distributionContainerEquals(
list.get(4),
new DistributionContainer(4, 5, 0.0071f),
true));
assertTrue(
distributionContainerEquals(
list.get(5),
new DistributionContainer(5, 6, 0.015175f),
true));
assertTrue(
distributionContainerEquals(
list.get(6),
new DistributionContainer(6, 7, 0.015175f),
true));
assertTrue(
distributionContainerEquals(
list.get(7),
new DistributionContainer(7, 8, 0.015175f),
true));
assertTrue(
distributionContainerEquals(
list.get(8),
new DistributionContainer(8, 9, 0.008175f),
true));
assertTrue(
distributionContainerEquals(
list.get(9),
new DistributionContainer(9, 10, 0.008175f),
true));
assertTrue(
distributionContainerEquals(
list.get(10),
new DistributionContainer(10, 11, 0.0f),
true));
assertTrue(
distributionContainerEquals(
list.get(11),
new DistributionContainer(11, 11, 0.0f),
true));
List conservedRegion = testSCProfile.getConservedRegions(null);
assertEquals(1, conservedRegion.size());
assertTrue(
distributionContainerEquals(
conservedRegion.get(0),
new DistributionContainer(5, 7, 0.015175f),
false));
}
{
float[] scores2 =
{
0.2f,
0.3f,
0.4f,
0.2f,
0.2f,
0.33f,
0.45f,
1.0f,
0.2f,
0.18f,
0.4f,
0.7f };
SCProfile testSCProfile =
new SCProfile(
null,
null,
scores2,
0.015f,
new PrintStream(new FileOutputStream("testing.log")));
testSCProfile.smoothScores(1, 1, "mean");
List list = testSCProfile.getConservedRegions(null);
assertEquals(1, list.size());
assertTrue(
distributionContainerEquals(
list.get(0),
new DistributionContainer(0, 11, 0.015f),
false));
}
{
float[] scores3 =
{
0.0f,
0.0f,
0.0f,
0.0f,
0.0f,
0.0f,
0.0f,
0.0f,
0.0f,
0.0f,
0.0f,
0.0f };
SCProfile testSCProfile =
new SCProfile(
null,
null,
scores3,
0.015f,
new PrintStream(new FileOutputStream("testing.log")));
testSCProfile.smoothScores(1, 1, "mean");
List list = testSCProfile.getConservedRegions(null);
assertEquals(0, list.size());
}
{
float[] scores2 = { 0.2f, 0.0f, 0.0f, 0.0284f, 0.0197f, 0.0126f };
SCProfile testSCProfile =
new SCProfile(
null,
null,
scores2,
0.010f,
new PrintStream(new FileOutputStream("testing.log")));
testSCProfile.smoothScores(1, 2, "mean");
List list = testSCProfile.getDistributionData(3, 0);
assertEquals(3, list.size());
assertTrue(
distributionContainerEquals(
list.get(0),
new DistributionContainer(0, 2, 0.05),
true));
assertTrue(
distributionContainerEquals(
list.get(1),
new DistributionContainer(2, 4, 0.0071),
true));
assertTrue(
distributionContainerEquals(
list.get(2),
new DistributionContainer(4, 5, 0.012f),
true));
List conservedRegion = testSCProfile.getConservedRegions(null);
assertEquals(2, conservedRegion.size());
assertTrue(
distributionContainerEquals(
conservedRegion.get(0),
new DistributionContainer(1, 1, 0.010f),
false));
assertTrue(
distributionContainerEquals(
conservedRegion.get(1),
new DistributionContainer(3, 4, 0.010f),
false));
}
{
float[] scores3 = { 0.1f, 0.2f, 0.0f, 0.0284f, 0.0197f, 0.0126f, 0.03f };
SCProfile testSCProfile =
new SCProfile(
null,
null,
scores3,
0.010f,
new PrintStream(new FileOutputStream("testing.log")));
testSCProfile.smoothScores(2, 2, "median");
List list = testSCProfile.getDistributionData(7, 0);
assertEquals(7, list.size());
assertTrue(
distributionContainerEquals(
list.get(0),
new DistributionContainer(0, 1, 0.0f),
true));
assertTrue(
distributionContainerEquals(
list.get(1),
new DistributionContainer(1, 2, 0.2f),
true));
assertTrue(
distributionContainerEquals(
list.get(2),
new DistributionContainer(2, 3, 0.2f),
true));
assertTrue(
distributionContainerEquals(
list.get(3),
new DistributionContainer(3, 4, 0.0284f),
true));
assertTrue(
distributionContainerEquals(
list.get(4),
new DistributionContainer(4, 5, 0.0284f),
true));
assertTrue(
distributionContainerEquals(
list.get(5),
new DistributionContainer(5, 6, 0.0126f),
true));
assertTrue(
distributionContainerEquals(
list.get(6),
new DistributionContainer(6, 6, 0.0f),
true));
List conservedRegion = testSCProfile.getConservedRegions(null);
assertEquals(1, conservedRegion.size());
assertTrue(
distributionContainerEquals(
conservedRegion.get(0),
new DistributionContainer(1, 5, 0.0f),
false));
}
{
float[] scores4 = { 0.0f, 0.01f, 0.01f, 0.005f, 0.00001f, 0.002f, 0.01f };
SCProfile testSCProfile =
new SCProfile(
null,
null,
scores4,
0.015f,
new PrintStream(new FileOutputStream("testing.log")));
testSCProfile.smoothScores(2, 2, "median");
List list = testSCProfile.getDistributionData(7, 0);
assertEquals(7, list.size());
assertTrue(
distributionContainerEquals(
list.get(0),
new DistributionContainer(0, 1, 0.0f),
true));
assertTrue(
distributionContainerEquals(
list.get(1),
new DistributionContainer(1, 2, 0.01f),
true));
assertTrue(
distributionContainerEquals(
list.get(2),
new DistributionContainer(2, 3, 0.01f),
true));
assertTrue(
distributionContainerEquals(
list.get(3),
new DistributionContainer(3, 4, 0.005f),
true));
assertTrue(
distributionContainerEquals(
list.get(4),
new DistributionContainer(4, 5, 0.005f),
true));
assertTrue(
distributionContainerEquals(
list.get(5),
new DistributionContainer(5, 6, 0.002f),
true));
assertTrue(
distributionContainerEquals(
list.get(6),
new DistributionContainer(6, 6, 0.0f),
true));
List conservedRegion = testSCProfile.getConservedRegions(null);
assertEquals(0, conservedRegion.size());
}*/
private void assertEqualsFloatArray(String label, float[] exp, float[] test) {
assertEquals(label +"- array length", exp.length, test.length);
for (int i = 0; i < exp.length; i++) {
assertEquals(label + "- index" + i, exp[i], test[i], 0);
}
}
private void assertBinEquals(String label, DistributionContainer exp, DistributionContainer test) {
assertEquals(label + "- start", exp.getStart(), test.getStart());
assertEquals(label + "- end", exp.getEnd(), test.getEnd());
assertEquals(label + "- score", exp.getScore(), test.getScore(), 0f);
}
}
package ca.bcgsc.sockeye.analysis.scprofile.junit;
import junit.framework.TestCase;
import junit.framework.TestSuite;
public class SubsetGeneratorUnitTest extends TestCase
{
public SubsetGeneratorUnitTest(String name)
{
super(name);
}
public static void main(String[] args)
{
junit.textui.TestRunner.run(SubsetGeneratorUnitTest.suite());
}
protected void setUp()
{
}
public static TestSuite suite()
{
TestSuite testSuite = new TestSuite();
testSuite.addTest(new SubsetGeneratorUnitTest("testSubsetGeneratorBType2"));
testSuite.addTest(new SubsetGeneratorUnitTest("testSubsetGeneratorDType1"));
testSuite.addTest(new SubsetGeneratorUnitTest("testSubsetGeneratorDType2"));
testSuite.addTest(new SubsetGeneratorUnitTest("testSubsetGeneratorTwo"));
return testSuite;
}
public void testSubsetGeneratorDType2() throws Exception
{
SubsetGenerator.getSubsetKeys(
align_array,
"H.sap. v",
SequenceMatrix.BTYPE2);
assertEquals(subsets.size(), 4);
ArrayList subset1 = (ArrayList) subsets.get(0);
assertEquals(subset1.size(), 2);
assertEquals(subset1.get(0), "H.sap. v");
assertEquals(subset1.get(1), "M.mus. v");
ArrayList subset2 = (ArrayList) subsets.get(1);
assertEquals(subset2.size(), 3);
assertEquals(subset2.get(0), "H.sap. v");
assertEquals(subset2.get(1), "M.mus. v");
assertEquals(subset2.get(2), "R.nor. v");
ArrayList subset3 = (ArrayList) subsets.get(2);
assertEquals(subset3.size(), 4);
assertEquals(subset3.get(0), "H.sap. v");
assertEquals(subset3.get(1), "M.mus. v");
assertEquals(subset3.get(2), "R.nor. v");
assertEquals(subset3.get(3), "D.rer. v");
ArrayList subset4 = (ArrayList) subsets.get(3);
assertEquals(subset4.size(), 5);
assertEquals(subset4.get(0), "H.sap. v");
assertEquals(subset4.get(1), "M.mus. v");
assertEquals(subset4.get(2), "R.nor. v");
assertEquals(subset4.get(3), "D.rer. v");
assertEquals(subset4.get(4), "F.rub. v");*/
}
public void testSubsetGeneratorDType1() throws Exception
{
SubsetGenerator.getSubsetKeys(
align_array,
"M.mus. v",
SequenceMatrix.DTYPE1);
assertEquals(subsets.size(), 4);
ArrayList subset1 = (ArrayList) subsets.get(0);
assertEquals(subset1.size(), 2);
assertEquals(subset1.get(0), "M.mus. v");
assertEquals(subset1.get(1), "R.nor. v");
ArrayList subset2 = (ArrayList) subsets.get(1);
assertEquals(subset2.size(), 3);
assertEquals(subset2.get(0), "M.mus. v");
assertEquals(subset2.get(1), "R.nor. v");
assertEquals(subset2.get(2), "H.sap. v");
ArrayList subset3 = (ArrayList) subsets.get(2);
assertEquals(subset3.size(), 4);
assertEquals(subset3.get(0), "M.mus. v");
assertEquals(subset3.get(1), "R.nor. v");
assertEquals(subset3.get(2), "H.sap. v");
assertEquals(subset3.get(3), "D.rer. v");
ArrayList subset4 = (ArrayList) subsets.get(3);
assertEquals(subset4.size(), 5);
assertEquals(subset4.get(0), "M.mus. v");
assertEquals(subset4.get(1), "R.nor. v");
assertEquals(subset4.get(2), "H.sap. v");
assertEquals(subset4.get(3), "D.rer. v");
assertEquals(subset4.get(4), "F.rub. v");
}
public void testSubsetGeneratorBType2() throws Exception
{
SubsetGenerator.getSubsetKeys(
align_array,
"D.rer. v",
SequenceMatrix.BTYPE1);
assertEquals(subsets.size(), 4);
ArrayList subset1 = (ArrayList) subsets.get(0);
assertEquals(subset1.size(), 2);
assertEquals(subset1.get(0), "D.rer. v");
assertEquals(subset1.get(1), "H.sap. v");
ArrayList subset2 = (ArrayList) subsets.get(1);
assertEquals(subset2.size(), 3);
assertEquals(subset2.get(0), "D.rer. v");
assertEquals(subset2.get(1), "H.sap. v");
assertEquals(subset2.get(2), "M.mus. v");
ArrayList subset3 = (ArrayList) subsets.get(2);
assertEquals(subset3.size(), 4);
assertEquals(subset3.get(0), "D.rer. v");
assertEquals(subset3.get(1), "H.sap. v");
assertEquals(subset3.get(2), "M.mus. v");
assertEquals(subset3.get(3), "R.nor. v");
ArrayList subset4 = (ArrayList) subsets.get(3);
assertEquals(subset4.size(), 5);
assertEquals(subset4.get(0), "D.rer. v");
assertEquals(subset4.get(1), "H.sap. v");
assertEquals(subset4.get(2), "M.mus. v");
assertEquals(subset4.get(3), "R.nor. v");
assertEquals(subset4.get(4), "F.rub. v");
}
public void testSubsetGeneratorTwo() throws Exception
{
ArrayList tracks = align_array.getAlignedTracks();
String speciesName =
SubsetGenerator.getTrackNameBySpecies(tracks, "Homo_sapiens");
assertEquals(speciesName, "H.sap. v");
assertEquals(
SubsetGenerator.getTrackNameBySpecies(tracks, "Mus_musculus"),
"M.mus. v");
assertEquals(
SubsetGenerator.getTrackNameBySpecies(tracks, "Rattus_norvegicus"),
"R.nor. v");
assertEquals(
SubsetGenerator.getTrackNameBySpecies(tracks, "Danio_rerio"),
"D.rer. v");
assertEquals(
SubsetGenerator.getTrackNameBySpecies(tracks, "Fugu_rubripes"),
"F.rub. v");
assertNull(
SubsetGenerator.getTrackNameBySpecies(tracks, "Caenorhabditis_elegans"));
assertNull(
SubsetGenerator.getTrackNameBySpecies(tracks, "Anopheles_gambiae"));
}
}
package ca.bcgsc.sockeye.analysis.scprofile.junit;
import java.util.*;
import ca.bcgsc.sockeye.trackmanager.*;
public class TestAlignArray extends ca.bcgsc.sockeye.dataretrieval.SCProfileDataSource {
ArrayList _test_data;
ArrayList _test_ids;
static ArrayList _data_sets = null;
public static final int DATA_SET1 = 0;
public static final int DATA_SET2 = 1;
public static final int DATA_SET3 = 2;
public TestAlignArray(int dataset) {
if (_data_sets == null) {
_data_sets = new ArrayList();
HashMap dataSet = new HashMap();
ArrayList test_data = new ArrayList();
test_data.add("----------TTCTTTTCTTTCCATCCACACACAGTGCCATTACCCTCATTC--TAAGCCAGCTGATTTTTAA---ATTTTCAGAAAATTTGTGAGCTAATTGTTAAACATGGCCATTATTCTAG-----ATTTTCCTATCTT-TATGAAGATTATTCTGCCTTATC--CTCAACAGTTACTGGCTATAGTCATTCTTTCAATGAA--TAGCTCATTACTGAGTATGC----ATGCTACAAGTATATGATTATTTGGGGGC-AGTTATTTTTTAAAGAATAATTTAAATATG-----GAATGTTTAGCAGTTTGTTTTTTCCCTGGGAAAAACCATACTATTATTCCCTCCCAATCCCTT");
test_data.add("----------NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN---NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNGCNAGAGGATATCCACAGGTATTGTCTTTCAGGTGCCCGGCCTGGGCCNCTCCCCGTTTTGAAAACATTGTTTAATGATAGTTCTTTTGGGTTATCTCTTAGGTTTTCATAAACATTAAGCCTAGCCCATGAGCTCTCAGT-AAGCATTCATTGTCACCAATCTCAAACCTG-----CAAACTTATCCCAGCAATTTAAGTAGGGACTCACTCTTCTTTGTGAATCTTGATCCTAAATAT");
test_data.add("TTTTTATTAGATATTTTCTTCATTTACATTTAAAATGCTATCCCCAAAGTCCCCTATACCTACTGGGGCATAT---GCTCTTCCCAAGACCAAGGGCCTCTCCTCCCAT-TGATGGCTGACCAAGCAATGATATAGTGATAAT-TATATCAGCTAACTGGTATAAGCTACTCAATGTTTACTAGATACTGCTGGTCTTCCCATGGGGCCACCCTACTCCTCAGGTTCCTCTAGCTTTTCC-GTCTGCAAGCACACCACAGC-A-TCAGTAACAGTGTTATAGCTAACACATT-----GCTGAATTGCCA---TGGGCTACTTTTAGGAAAGACTACACTGTAATAGATTTCTTGTCTGTT");
test_data.add("--AAAATGCACTACTCTAGAAATCACCTCAGCTCTTGGGTTTTCTTTATACACGCAGCTAACATAGTTTGTAGTTGATGCTAACCTTATCATAAATCCCCTTACCCCTTGGGATTTTTTTTTTAT----GAGGACGCAGTTTTGTATAATGATGACACAGGTAAGACGAATTATGAGGTATGGATCACAGTC--TTTAAAAATATATTTGTTTCACAGACAAAGACTT----ATATT-TACATATGATCGCACTTTGGTGCCATCTCACGATAACTCAATAAATTAAACGTACATCCGAAGAAGAATAGATCTGATTTGATCTAAGAAAGGACAGACAAACTCGATTGTTTTTTTTTTTT");
test_data.add("-------------------------------------------------------------GTTAAAATATAAATATCTAGACATATGTACAGGAGAGATTTTAGCCCTTTGGATTTTGATTCAG-----GAGCTTCTGGATGGAGTCGTAGCTCTTCA--CAGAGCTGCCTTCAATCACCCAGTTCCAGCACACCCCCCCCCCCACCCCCACTAATGACAAGCAAATGTT-GAGCCCCG-CCACTTTATGCTCCGACAGG---------ATGACGGTGCAGTCAGAAAAGG------CGTGCTTGA------GGGTCTTCCTCAGGACCTGCAACGTTCTGCTCACCAACACACAAACG");
ArrayList test_ids = new ArrayList();
test_ids = new ArrayList();
test_ids.add(new Integer(0));
test_ids.add(new Integer(1));
test_ids.add(new Integer(2));
test_ids.add(new Integer(3));
test_ids.add(new Integer(4));
dataSet.put("Names", test_ids);
dataSet.put("Data", test_data);
_data_sets.add(dataSet);
dataSet = new HashMap();
test_data = new ArrayList();
test_data.add("------------------------------------------------------------" +
"------------------------------------------------------------" +
"--------------------------------------AAAATGCACTACTCTAGAAATC" +
"------------ACCTCAGCTCTTGGGTTTTCTTTATACACGCAGCTAATGCTAACATTG" +
"TCCAAGACATCACTTCAGCTTTATACACACAGCTCCAGCTAACATAGTTTGTAGTTGATG" +
"CTAACCTTATCATAAATCCCCTTACCCCTTGGGATTTTTTTTAACAACAGCTAATGCTAA" +
"CATATATTGTCTAATAAATCGCTTCAGCTTCTTGGTTTTCATTTTCCACATAG-------" +
"------------------------------------------------------------" +
"---------------------------------CTAATGCTAAATTCATCCTATAAATCC" +
"CCTCAGCTTTTTGGTTTTCCTTCACCACACAGCTGATGTTAGCATTGTGTTTGCAGCTAA");
test_data.add("TTCTTTTCTTTCCATCCACACACAGTGCCATTACCCTCATTCTAAGCCTTTCAAACATCT" +
"GGCAGTAAGTGATCTGCTGCACTTAGCTCTTTCCAGCTGAGCTGATTTTTAAATTTTCAG" +
"AAAATTTGTGAGCTAATTGTTAAACATGGCCATTATTAAAAATTAAATTATTTCAACTTA" +
"T-----------------------------------------------------------" +
"-----------AATTAAATAAATTATATTAAAACAAAAGTATTAAAAACTCAAAAGTTGG" +
"CTGGGCG-----------------------------------------------------" +
"---------------------CACTGGCTCACGTCTGTAATCCCAGCACTTTGGGAGACC" +
"GAGGCAGGTGGATTGCCTGAAGTCAGGGGTTCGAGACCAACCTGACCAACATGGAGAAAC" +
"CCTGTCTCTACTAAAAATATAAAAAAATAGCCGGGCATGGTGGTGCATGCCTGTAATCCC" +
"AGCTACTCAGGAGGCTGAGGCAGGAGAATTGCTTGAACCCAG------------------");
test_data.add("------------------------------------------------------------" +
"------------------------------------------------------------" +
"---------------------------------------------------------TTT" +
"T-----------------------------------------------------------" +
"-----------TATTAGATATTTTCTTCATTTACATTTAAAATGCTATCCCCAAAGTCCC" +
"CTATACC-----------------------------------------------------" +
"---------------------CTCCCCCT-------------------------------" +
"------------------------------------------------------------" +
"-------------------------------------------GCCCTGCTCTCCAACCC" +
"ACCCACTCTTGCTTCCTGGCCCTGGAAATCCCCTGTACTGGG------------------");
test_data.add("------------------------------------------------------------" +
"------------------------------------------------------------" +
"---------------------------------------------------------NNN" +
"N-----------------------------------------------------------" +
"-----------NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN" +
"NNNNNNN-----------------------------------------------------" +
"---------------------NNNNNNNN-------------------------------" +
"------------------------------------------------------------" +
"-------------------------------------------NNNNNNNNNNNNNNNNN" +
"NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN------------------");
test_data.add("GT----------------------------------------------------------" +
"------------------------------------------------------------" +
"-------------------------------------TAAAATATAAATATCTAGACATA" +
"TGTACAGGAGAGATTTTAGCCCTTTGGATTTTGATG--------------------GCTG" +
"TTTGAGGT----TTTAACAATTGTCTTTACAAGCCCAAACATTAAATTCCCTGTTTAACA" +
"CCCCCC-----------CCCCCCCCCCCTT------------------------------" +
"----------------------TCCTCCCTGCTGGACTTAATTTTCCTTCT---------" +
"------------------------------------------------------------" +
"----------------------------------TTATTAGAGCCTCAGTTTAGAATTCC" +
"CAGAACTTTCCAGGTTCAGATCATTTATGCAAATAAGGTTG-----ATTTCTGAAACT--");
test_ids = new ArrayList();
test_ids.add(new Integer(0));
test_ids.add(new Integer(1));
test_ids.add(new Integer(2));
test_ids.add(new Integer(3));
test_ids.add(new Integer(4));
dataSet.put("Names", test_ids);
dataSet.put("Data", test_data);
_data_sets.add(dataSet);
dataSet = new HashMap();
test_data = new ArrayList();
test_data.add("CGCNNN--GC");
test_data.add("CNNAN-N--C");
test_data.add("CNNAT-----");
test_data.add("CNNNN-----");
test_data.add("CNCNN-----");
test_ids = new ArrayList();
test_ids = new ArrayList();
test_ids.add(new Integer(0));
test_ids.add(new Integer(1));
test_ids.add(new Integer(2));
test_ids.add(new Integer(3));
test_ids.add(new Integer(4));
dataSet.put("Names", test_ids);
dataSet.put("Data", test_data);
_data_sets.add(dataSet);
}
HashMap thisDataset = (HashMap)_data_sets.get(dataset);
_test_ids = (ArrayList)thisDataset.get("Names");
_test_data = (ArrayList)thisDataset.get("Data");
}
public String getSequence(int trk){
int index = _test_ids.indexOf(new Integer(trk));
return (String)_test_data.get(index);
}
public String getSequenceName(int trk_id) {
switch (trk_id) {
case 0 : return "H.sap. v";
case 1 : return "M.mus. v";
case 2: return "R.nor. v";
case 3 : return "D.rer. v";
case 4 : return "F.rub. v";
}
return "H.sap v";
}
public int getLength(){
return ((String)_test_data.get(0)).length();
}
public List getOrderedTrackIDList() {
return _test_ids;
}
public List getOrderedTrackIDList(int ref_track) {
return _test_ids;
}
public TrackRelationshipOrderInterface getTrackRelationship() {
HashMap trk_gene = new HashMap();
HashMap trk_species = new HashMap();
String species;
for (Iterator itr = _test_ids.iterator(); itr.hasNext();) {
Integer trk_id = (Integer)itr.next();
trk_gene.put(trk_id, "somegene");
species = getSequenceName(trk_id.intValue());
species = species.substring(0, species.lastIndexOf(".") + 1);
trk_species.put(trk_id, species);
}
try {
return new OrthologousRelationship(trk_gene, trk_species);
} catch (TrackRelationshipException e) {
e.printStackTrace();
}
return null;
}
}
package ca.bcgsc.sockeye.analysis.scprofile.junit;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import ca.bcgsc.sockeye.analysis.scprofile.SCProfile;
import ca.bcgsc.sockeye.analysis.scprofile.SCProfileException;
import ca.bcgsc.sockeye.analysis.scprofile.SCProfileList;
import ca.bcgsc.sockeye.analysis.scprofile.SubsetGenerator;
import ca.bcgsc.sockeye.trackmanager.OrthologousRelationship;
import ca.bcgsc.sockeye.trackmanager.TrackRelationshipOrderInterface;
public class TestSCProfileList extends SCProfileList {
List test_data;
List test_ids;
int data_set;
public TestSCProfileList(int data_set) throws SCProfileException{
this.data_set = data_set;
if (data_set == 0) {
test_data = new ArrayList();
test_data.add("CGCNNN--GC");
test_data.add("CNNAN-N--C");
test_data.add("CNNAT-----");
test_data.add("CNNNN-----");
test_data.add("CNCNN-----");
test_ids = new ArrayList();
test_ids.add(new Integer(0));
test_ids.add(new Integer(1));
test_ids.add(new Integer(2));
test_ids.add(new Integer(3));
test_ids.add(new Integer(4));
} else if (data_set == 1) {
test_data = new ArrayList();
test_data.add("AAAAAAAAAAAAAAAAAAAACCCCCCCCCCAAAAAAAAAAAAAAAAAAAACCCCCCCCCCAAAAAAAAAAAAAAAAAAAACCCCCCCCCCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
test_data.add("GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGCCCCCCCCCCGGGGGGGGGGGGGGGGGGGGCCCCCCCCCCGGGGGGGGGGGGGGGGGGGGCCCCCCCCCCGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG");
test_data.add("TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTCCCCCCCCCCTTTTTTTTTTTTTTTTTTTTCCCCCCCCCCTTTTTTTTTTTTTTTTTTTTCCCCCCCCCCTTTTTTTTTT");
test_ids = new ArrayList();
test_ids.add(new Integer(0));
test_ids.add(new Integer(1));
test_ids.add(new Integer(2));
} else return;
HashMap trk_gene = new HashMap();
HashMap dummy_species = new HashMap();
for (int i = 0; i < test_data.size(); i++) {
trk_gene.put(new Integer(i), "Gene" + i);
dummy_species.put(new Integer(i), getSequenceName(i));
}
try {
this.relationship = new OrthologousRelationship(trk_gene, dummy_species);
} catch (Exception e) {
e.printStackTrace();
}
cs_method = "Distance Weight Sum";
ws_method = "mean";
w_size = 4;
w_stepsize = 1;
this.set_def_method = SubsetGenerator.__SET_DISTANCE;
profiles = new ArrayList();
custom_profiles = new ArrayList(__NUM_CUSTOM_PROFILES);
for (int i = 0; i < __NUM_CUSTOM_PROFILES; i++) {
custom_profiles.add(
new SCProfile(
this,
new ArrayList()));
}
redefineProfiles();
set_def_method = SubsetGenerator.__SET_DISTANCE;
List s = SubsetGenerator.getSubsets(relationship, 0, set_def_method);
if (s == null) {
throw new SCProfileException("No sequence subsets generated.");
}
for (int i = 0; i < s.size(); i++) {
List sequences = (List)s.get(i);
if (sequences == null || sequences.size() == 0) {
continue;
}
cs_method = "PhyloVISTA";
ws_method = "Gaussian";
SCProfile newProfile =
new SCProfile(
this,
sequences,
50,
1,
cs_method,
ws_method,
85,
null);
this.add(newProfile);
}*/
}
public TrackRelationshipOrderInterface getTrackRelationship() {
return relationship;
}
public String getSequence(int trk) {
int index = test_ids.indexOf(new Integer(trk));
return (String)test_data.get(index);
}
public int getSequenceStart(int trk_id) {
return 1;
}
public String getSequenceName(int trk_id) {
if (data_set == 0) {
switch (trk_id) {
case 0 :
return "H.sap.";
case 1 :
return "M.mus.";
case 2 :
return "R.nor.";
case 3 :
return "D.rer.";
case 4 :
return "F.rub.";
}
return "H.sap v";
} else if (data_set == 1) {
switch (trk_id) {
case 0 :
return "C.ele.";
case 1 :
return "C.bri.";
}
return "H.sap.";
}
return null;
}
}
package ca.bcgsc.sockeye.config;
import java.util.Vector;
public class Branch {
protected String name, parent;
protected Vector branch, node;
public Branch() {
name = "";
parent = "";
}
public String getName() { return name; }
public void setName(String name) { this.name = name; }
public String getParent() { return parent; }
public void setParent(String parent) { this.parent = parent; }
public String toString() {
StringBuffer ret = new StringBuffer();
ret.append("branch: name=" + name + " parent=" + parent + "\n");
return ret.toString();
}
}
package ca.bcgsc.sockeye.config;
import java.util.Date;
import java.util.Vector;
public class ConfigContainer implements java.io.Serializable {
static protected Date date;
protected String version,
data_path,
images_path,
models_path,
matrices_path,
gff_path,
session_path,
tbfGFF_path,
appraisal_path,
user_path,
pwm_path,
HelpEmail,
tutorial,
sequence_path,
gui_blue,
browser,
features_limit,
naming_server_connection_string,
useP2P,
semZoomDefaultRange,
lookAndFeel;
protected Vector connection,
service,
source,
popup,
feature,
branch,
node,
font3d;
protected Platform platform;
public ConfigContainer() {
date = new Date();
version = "";
data_path = "";
images_path = "";
pwm_path = "";
sequence_path = "";
models_path = "";
matrices_path = "";
user_path = "";
gff_path = "";
session_path = "";
gui_blue = "";
naming_server_connection_string = "";
useP2P = "false";
browser = "mozilla";
connection = new Vector();
source = new Vector();
features_limit = "";
feature = new Vector();
popup = new Vector();
platform = new Platform();
branch = new Vector();
font3d = new Vector();
HelpEmail = "";
tutorial = "";
}
public String getSemZoomDefaultRange() {
return semZoomDefaultRange;
}
public void setSemZoomDefaultRange(String semZoomDefaultRange) {
this.semZoomDefaultRange = semZoomDefaultRange;
}
public String getLookAndFeel() {
return lookAndFeel;
}
public void setLookAndFeel(String lookAndFeel) {
this.lookAndFeel = lookAndFeel;
}
public Date getDate() {
return date;
}
public void setDate(Date date_) {
date = date_;
}
public Platform getPlatform() {
return platform;
}
public void setPlatform(Platform platform_) {
platform = platform_;
}
public String getVersion() {
return version;
}
public void setVersion(String version) {
this.version = version;
}
public String getBrowser() {
return browser;
}
public void setBrowser(String browser) {
this.browser = browser;
}
public String getFeaturesLimit() {
return features_limit;
}
public void setFeaturesLimit(String features_limit) {
this.features_limit = features_limit;
}
public String getDataPath() {
return data_path;
}
public void setDataPath(String data_path) {
this.data_path = data_path;
}
public String getImagesPath() {
return images_path;
}
public void setImagesPath(String images_path) {
this.images_path = images_path;
}
public String getPwmPath() {
return pwm_path;
}
public void setPwmPath(String pwm_path) {
this.pwm_path = pwm_path;
}
public String getSequencePath() {
return sequence_path;
}
public void setSequencePath(String sequence_path) {
this.sequence_path = sequence_path;
}
public String getMatricesPath() {
return matrices_path;
}
public void setMatricesPath(String matrices_path) {
this.matrices_path = matrices_path;
}
public String getUserPath() {
return user_path;
}
public void setUserPath(String user_path) {
this.user_path = user_path;
}
public String getModelsPath() {
return models_path;
}
public void setModelsPath(String models_path) {
this.models_path = models_path;
}
public String getGffPath() {
return gff_path;
}
public void setGffPath(String gff_path) {
this.gff_path = gff_path;
}
public String getSessionPath() {
return session_path;
}
public void setSessionPath(String session_path) {
this.session_path = session_path;
}
public String getGuiBlue() {
return gui_blue;
}
public void setGuiBlue(String gui_blue) {
this.gui_blue = gui_blue;
}
public String getNamingServerConnectionString() {
return naming_server_connection_string;
}
public String getUseP2P() {
return useP2P;
}
public void setNamingServerConnectionString(String naming_server_connection_string) {
this.naming_server_connection_string = naming_server_connection_string;
}
public void setUseP2P(String useP2P) {
this.useP2P = useP2P;
}
public Connection[] getConnection() {
Connection[] retConnection = new Connection[connection.size()];
if (connection.size() > 0) {
connection.copyInto(retConnection);
}
return retConnection;
}
public String getHelpEmail() {
return HelpEmail;
}
public void setHelpEmail(String email) {
HelpEmail = email;
}
public String getTutorial() {
return tutorial;
}
public void setTutorial(String tutorial_) {
tutorial = tutorial_;
}
public void setConnection(Connection[] newConnection) {
connection = new Vector(newConnection.length);
for (int i = 0; i < newConnection.length; i++) {
connection.addElement(newConnection[i]);
}
}
public Service[] getService() {
Service[] retService = new Service[service.size()];
if (service.size() > 0) {
service.copyInto(retService);
}
return retService;
}
public void setService(Service[] a_service) {
service = new Vector(a_service.length);
for (int i = 0; i < a_service.length; i++) {
service.addElement(a_service[i]);
}
}
public Feature[] getFeature() {
Feature[] ret_feature = new Feature[feature.size()];
if (feature.size() > 0) {
feature.copyInto(ret_feature);
}
return ret_feature;
}
public void setFeature(Feature[] new_feature) {
feature = new Vector(new_feature.length);
for (int i = 0; i < new_feature.length; i++) {
feature.addElement(new_feature[i]);
}
}
public ConfigFont[] getConfigFont() {
ConfigFont[] ret_font3d = new ConfigFont[font3d.size()];
if (font3d.size() > 0) {
font3d.copyInto(ret_font3d);
}
return ret_font3d;
}
public void setConfigFont(ConfigFont[] new_font3d) {
font3d = new Vector(new_font3d.length);
for (int i = 0; i < new_font3d.length; i++) {
font3d.addElement(new_font3d[i]);
}
}
public Popup[] getPopup() {
Popup[] retPopup = new Popup[popup.size()];
if (popup.size() > 0) {
popup.copyInto(retPopup);
}
return retPopup;
}
public void setPopup(Popup[] new_popup) {
popup = new Vector(new_popup.length);
for (int i = 0; i < new_popup.length; i++) {
popup.addElement(new_popup[i]);
}
}
public Branch[] getBranch() {
Branch[] ret_branch = new Branch[branch.size()];
if (branch.size() > 0) {
branch.copyInto(ret_branch);
}
return ret_branch;
}
public void setBranch(Branch[] new_branch) {
branch = new Vector(new_branch.length);
for (int i = 0; i < new_branch.length; i++) {
branch.addElement(new_branch[i]);
}
}
public Node[] getNode() {
Node[] ret_node = new Node[branch.size()];
if (node.size() > 0) {
node.copyInto(ret_node);
}
return ret_node;
}
public void setNode(Node[] new_node) {
node = new Vector(new_node.length);
for (int i = 0; i < new_node.length; i++) {
node.addElement(new_node[i]);
}
}
public String toString() {
StringBuffer ret = new StringBuffer();
ret.append(date.toString() + "\n");
ret.append("data_path=" + data_path + "\n");
ret.append("images_path=" + images_path + "\n");
ret.append("models_path=" + models_path + "\n");
for (int i = 0; i < connection.size(); i++) {
ret.append(" " + connection.elementAt(i).toString());
}
for (int i = 0; i < source.size(); i++) {
ret.append(" " + source.elementAt(i).toString());
}
for (int j = 0; j < feature.size(); j++) {
ret.append(" " + feature.elementAt(j).toString());
}
for (int k = 0; k < popup.size(); k++) {
ret.append(" " + popup.elementAt(k).toString());
}
for (int k = 0; k < branch.size(); k++) {
ret.append(" " + branch.elementAt(k).toString());
}
for (int k = 0; k < font3d.size(); k++) {
ret.append(" " + font3d.elementAt(k).toString());
}
return ret.toString();
}
}
package ca.bcgsc.sockeye.config;
public class ConfigFont implements java.io.Serializable {
protected String name, font, size, style;
public ConfigFont(){
name = "";
font = "";
size = "";
style = "";
}
public String getFont() {
return font;
}
public void setFont(String font) {
this.font = font;
}
public String getName() {
return name;
}
public void setName(String name) {
this.name = name;
}
public String getSize() {
return size;
}
public void setSize(String size) {
this.size = size;
}
public String getStyle() {
return style;
}
public void setStyle(String style) {
this.style = style;
}
}
package ca.bcgsc.sockeye.config;
import java.awt.Color;
import java.awt.Font;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import javax.swing.BorderFactory;
import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.border.Border;
import ca.bcgsc.sockeye.gui.util.ImageLoader;
import ca.bcgsc.sockeye.util.Log;
import com.wutka.jox.JOXBeanInputStream;
import com.wutka.jox.JOXBeanOutputStream;
public class Configuration {
public static final char SEP = System.getProperty("file.separator").charAt(0);
public static final String USER_DIR = System.getProperty("user.dir");
public static final String DEFAULT_CONFIG = "default_config.xml";
public static final String USER_CONFIG = "user_config.xml";
public static final String QUICK_LOAD = "quick_load.xml";
public static final String SCORE_FORMAT_PATTERN = "###.##";
public static final int __COMPONENT_HEIGHT = 20;
public static ImageIcon submit_icon,
help_icon,
ensembl_icon,
ncbi_icon,
wormbase_icon,
all_delete_icon;
public static ImageIcon das_icon, delete_icon,
back_icon,
back_icon_16,
forward_icon,
export_icon,
copy_icon,
save_icon,
connect_data_icon,
undo_icon,
find_icon,
find_next_icon,
transfer_icon,
clear_icon,
paste_icon,
cut_icon,
save_icon_16,
save_all_icon_16;
public static ImageIcon open_icon, info_icon, stop_icon, check, uncheck;
public static ImageIcon reverse_icon,
reverse2_icon,
reverse3_icon,
forward1_icon,
forward2_icon,
forward3_icon;
public static ImageIcon zoom_in_icon, zoom_out_icon, whatsthis_icon;
public static ImageIcon align_justify,
align_left,
align_right,
error_icon,
infor_icon;
public static ImageIcon crop_track_icon;
public static Color gui_blue;
public static Border gui_blue_border;
public static ImageIcon working_query_icon, static_query_icon;
public static ImageIcon ftShowNodeOn, ftShowNodeOff, ftShowNodeAlwaysOn_off;
public static ImageIcon distribIcon, sockeye_logo_small;
public static ImageIcon popupGetHomolog, popupNucContent, popupMarkRegion;
public static ImageIcon popupLineUp,
popupExport,
popupAlign,
popupRename,
popupDelete,
popupZoom,
popupScan,
popupDiscover,
popupPrimers,
popupPrimersOutside,
popupMcs,
popupSequenceMask,
popupPrimersInside;
public static ImageIcon movehand_icon;
public static ImageIcon mark_region_diagram,
mark_region_bar1,
mark_region_bar2,
mark_region_bar3,
mark_region_bar5;
public static ImageIcon microArray;
public static ImageIcon popupTrans_icon, popupHomolog_icon, popupAltView_icon;
public static ImageIcon popupCentre_icon,
popupFTreeSelect_icon,
popupSeqExtr_icon;
public static ImageIcon popupTrackCopy,
popupTrackDel,
popupTrackHide,
popupTrackShow,
popupTrackReverse;
public static ImageIcon mag_track_icon;
protected static ConfigContainer config_container = new ConfigContainer();
protected static QuickContainer quick_container = new QuickContainer();
protected static Hashtable ensembl_drivers = new Hashtable();
protected static Hashtable feature_display = null;
protected static List selected_features = new ArrayList();
static {
InputStream in = null;
try {
try {
in = new FileInputStream(USER_CONFIG);
} catch (FileNotFoundException e1) {
System.out.println("Loaded USER_CONFIG from classpath ...");
in =
Configuration.class.getClassLoader().getResourceAsStream(USER_CONFIG);
}
JOXBeanInputStream jox_in = new JOXBeanInputStream(in);
config_container =
(ConfigContainer) jox_in.readObject(ConfigContainer.class);
} catch (Exception exc) {
Log.printStackTrace(exc);
exc.printStackTrace();
JOptionPane.showMessageDialog(
null,
new String(exc.toString() + "\n Please check user_config.xml."),
"Error",
JOptionPane.ERROR_MESSAGE);
throw new RuntimeException();
}
}
public static int quick_read() {
InputStream in = null;
try {
try {
in = new FileInputStream(QUICK_LOAD);
} catch (FileNotFoundException e1) {
System.out.println("Loaded QUICK_LOAD from classpath ...");
in =
Configuration.class.getClassLoader().getResourceAsStream(QUICK_LOAD);
}
JOXBeanInputStream jox_in = new JOXBeanInputStream(in);
quick_container =
(QuickContainer) jox_in.readObject(QuickContainer.class);
return 0;
} catch (Exception exc) {
Log.printStackTrace(exc);
JOptionPane.showMessageDialog(
null,
new String(exc.toString() + "\n Please check quick_load.xml."),
"Error",
JOptionPane.ERROR_MESSAGE);
return -1;
}
}
public static void initUI() {
das_icon = ImageLoader.loadIcon("DAS.gif");
save_all_icon_16 = ImageLoader.loadIcon("SaveAll16.gif");
save_icon_16 = ImageLoader.loadIcon("Save16.gif");
cut_icon = ImageLoader.loadIcon("Cut16.gif");
paste_icon = ImageLoader.loadIcon("Paste16.gif");
clear_icon = ImageLoader.loadIcon("Clear.gif");
transfer_icon = ImageLoader.loadIcon("Transfer16.gif");
find_icon = ImageLoader.loadIcon("Find16.gif");
find_next_icon = ImageLoader.loadIcon("FindAgain16.gif");
submit_icon = ImageLoader.loadIcon("Forward20.gif");
help_icon = ImageLoader.loadIcon("Help20.gif");
whatsthis_icon = ImageLoader.loadIcon("ContextualHelp16.gif");
ensembl_icon = ImageLoader.loadIcon("e!16.gif");
ncbi_icon = ImageLoader.loadIcon("ncbi.gif");
wormbase_icon = ImageLoader.loadIcon("wormbase.gif");
delete_icon = ImageLoader.loadIcon("RowDelete16.gif");
all_delete_icon = ImageLoader.loadIcon("AllRowsDelete16.gif");
back_icon_16 = ImageLoader.loadIcon("Back16.gif");
back_icon = ImageLoader.loadIcon("Back24.gif");
forward_icon = ImageLoader.loadIcon("Forward24.gif");
forward1_icon = ImageLoader.loadIcon("Forward16.gif");
forward2_icon = ImageLoader.loadIcon("Forward16_2.gif");
forward3_icon = ImageLoader.loadIcon("Forward16_3.gif");
export_icon = ImageLoader.loadIcon("Export24.gif");
copy_icon = ImageLoader.loadIcon("Copy16.gif");
save_icon = ImageLoader.loadIcon("Save24.gif");
info_icon = ImageLoader.loadIcon("Information16.gif");
open_icon = ImageLoader.loadIcon("Open16.gif");
undo_icon = ImageLoader.loadIcon("Undo16.gif");
connect_data_icon = ImageLoader.loadIcon("Down20.gif");
stop_icon = ImageLoader.loadIcon("Stop16.gif");
check = ImageLoader.loadIcon("check.gif");
uncheck = ImageLoader.loadIcon("uncheck.gif");
reverse_icon = ImageLoader.loadIcon("Reverse20.gif");
reverse2_icon = ImageLoader.loadIcon("Reverse16_2.gif");
reverse3_icon = ImageLoader.loadIcon("Reverse16_3.gif");
zoom_in_icon = ImageLoader.loadIcon("ZoomInMod16.gif");
zoom_out_icon = ImageLoader.loadIcon("ZoomOutMod16.gif");
working_query_icon = ImageLoader.loadIcon("ac205.gif");
static_query_icon = ImageLoader.loadIcon("still.gif");
mag_track_icon = ImageLoader.loadIcon("magtrack23.gif");
popupMarkRegion = ImageLoader.loadIcon("markregion.gif");
crop_track_icon = ImageLoader.loadIcon("croptrack.gif");
mark_region_diagram = ImageLoader.loadIcon("markt.gif");
mark_region_bar1 = ImageLoader.loadIcon("bar1t.gif");
mark_region_bar2 = ImageLoader.loadIcon("bar2t.gif");
mark_region_bar3 = ImageLoader.loadIcon("bar3t.gif");
mark_region_bar5 = ImageLoader.loadIcon("bar4t.gif");
popupLineUp = ImageLoader.loadIcon("centWind.gif");
popupAlign = ImageLoader.loadIcon("align.gif");
popupDelete = ImageLoader.loadIcon("Delete18.gif");
popupZoom = ImageLoader.loadIcon("zoomin20.gif");
popupScan = ImageLoader.loadIcon("scan.gif");
popupDiscover = ImageLoader.loadIcon("motivdiscovery.gif");
popupRename = ImageLoader.loadIcon("dt_rename.gif");
popupPrimers = ImageLoader.loadIcon("primerprediction.gif");
popupPrimersOutside = ImageLoader.loadIcon("primerprediction1.GIF");
popupPrimersInside = ImageLoader.loadIcon("primerprediction2.GIF");
popupMcs = ImageLoader.loadIcon("mcs.gif");
infor_icon = ImageLoader.loadIcon("info.gif");
popupSequenceMask = ImageLoader.loadIcon("mask3.gif");
ftShowNodeOn = ImageLoader.loadIcon("circ_blue_16a.gif");
ftShowNodeOff = ImageLoader.loadIcon("circ_gray_16a.gif");
ftShowNodeAlwaysOn_off = ImageLoader.loadIcon("check_ball.gif");
popupGetHomolog = ImageLoader.loadIcon("homologues.gif");
popupTrans_icon = ImageLoader.loadIcon("penDiag15.gif");
popupHomolog_icon = ImageLoader.loadIcon("homologues.gif");
popupAltView_icon = ImageLoader.loadIcon("magGlass20x19.gif");
popupCentre_icon = ImageLoader.loadIcon("centWind.gif");
popupFTreeSelect_icon = ImageLoader.loadIcon("ftSelect.gif");
popupSeqExtr_icon = ImageLoader.loadIcon("sequence.gif");
popupTrackCopy = ImageLoader.loadIcon("dt_copy.gif");
popupTrackDel = ImageLoader.loadIcon("datatrackDel.gif");
popupTrackHide = ImageLoader.loadIcon("dt_hide.gif");
popupTrackShow = ImageLoader.loadIcon("dt_show.gif");
popupTrackReverse = ImageLoader.loadIcon("dt_flip.gif");
popupExport = ImageLoader.loadIcon("export20.gif");
popupNucContent = ImageLoader.loadIcon("nuccontent.gif");
microArray = ImageLoader.loadIcon("microarray.gif");
align_justify = ImageLoader.loadIcon("AlignJustify16.gif");
align_left = ImageLoader.loadIcon("AlignLeft16.gif");
align_right = ImageLoader.loadIcon("AlignRight16.gif");
error_icon = ImageLoader.loadIcon("Error.gif");
sockeye_logo_small = ImageLoader.loadIcon("logo_small.jpg");
distribIcon = ImageLoader.loadIcon("distLogo.gif");
movehand_icon = ImageLoader.loadIcon("movehand.gif");
String gb = config_container.getGuiBlue();
String[] rgb = gb.split(" ");
rgb = gb.split(" ");
int red = (int) Integer.valueOf(rgb[0]).intValue();
int green = (int) Integer.valueOf(rgb[1]).intValue();
int blue = (int) Integer.valueOf(rgb[2]).intValue();
gui_blue = new Color(red, green, blue);
int s = 80;
int h = 20;
gui_blue_border =
BorderFactory.createEtchedBorder(
new Color(red + h, green + h, blue + h),
new Color(red - s, red - s, red - s));
Feature[] features = config_container.getFeature();
for (int i = 0; i < features.length; i++) {
if (features[i].getSelected().equals("true")) {
selected_features.add(features[i].getName());
}
}
}
public static void write() {
write(USER_CONFIG);
}
public static void write(String XML_file_name) {
try {
ConfigContainer sc = new ConfigContainer();
sc.data_path = "|data|source_type|source_name|";
sc.images_path = "|images|";
sc.models_path = "|models|";
Source seq = new Source();
seq.type = "Genome";
seq.name = "Ensembl";
seq.current = true;
Server sserv1 = new Server();
sserv1.name = "BCGSC mirror";
sserv1.config = "local_mysql_server.conf" ;
sserv1.current = true;
seq.server.add(sserv1) ;
Server sserv2 = new Server();
sserv2.name = "EBI Sanger";
sserv2.config = "kaka_mysql_server.conf" ;
sserv2.current = false;
seq.server.add(sserv2) ;
Species hs = new Species();
hs.name = "Homo_sapiens";
Driver core = new Driver();
core.name = "CORE";
core.config = "homo_sapiens_core_9_30_driver.conf";
hs.driver.add(core);
Driver homology = new Driver();
homology.name = "COMPARA";
homology.config = "homology_driver.conf";
hs.driver.add(homology);
Popup gp1 = new Popup();
gp1.label = "EnsEMBL: GeneView";
gp1.url = "http:
sc.popup.add(gp1);
Popup gp2 = new Popup();
gp2.label = "EnsEMBL: TransView";
gp2.url = "http:
sc.popup.add(gp2);
Popup gp3 = new Popup();
gp3.label = "EnsEMBL: ProteinView";
gp3.url = "http:
sc.popup.add(gp3);
Popup gp4 = new Popup();
gp4.label = "NCBI: LocusLink";
gp4.url = "http:
sc.popup.add(gp4);
Feature g = new Feature();
g.name = "gene";
sc.feature.add(g);
Feature e = new Feature();
e.name = "exon";
sc.feature.add(e);
seq.species.add( hs );
Source tfbs = new Source();
tfbs.setType("TFBS");
tfbs.setName("TRANSFAC");
tfbs.current = true;
Server tserv = new Server();
tserv.name = "TRANSFAC srvr";
tserv.config = "transfac_mysql_server.conf" ;
tserv.current = true;
tfbs.server.add(tserv) ;
Source expr = new Source();
expr.type = "Expressn";
expr.name = "Expressn db";
expr.current = true;
Server eserv = new Server();
eserv.name = "Expressn srvr";
eserv.config = "unknownDB_mysql_server.conf" ;
eserv.current = true;
expr.server.add(eserv) ;
sc.source.add(seq);
sc.source.add(tfbs);
sc.source.add(expr);
FileOutputStream file_out = new FileOutputStream(XML_file_name);
JOXBeanOutputStream jox_out = new JOXBeanOutputStream(file_out);
jox_out.writeObject("Sockeye", sc);
jox_out.close();
} catch (Exception exc) {
Log.printStackTrace(exc);
}
}
public static String getVersion() {
return config_container.getVersion();
}
public static int getFeaturesLimit() {
int limit =
(Integer.valueOf(config_container.getFeaturesLimit())).intValue();
return limit;
}
public final static Hashtable getPopupConfiguration() {
Hashtable p_base = new Hashtable();
Popup[] p = config_container.getPopup();
for (int l = 0; l < p.length; l++) {
p_base.put(p[l].getLabel(), p[l].getURL());
}
return p_base;
}
public static String getModelsPath() {
String models_path = config_container.models_path;
models_path = models_path.replace('|', SEP);
models_path = new String(models_path);
return models_path;
}
public static String getImagePath() {
String images_path = config_container.images_path;
images_path = images_path.replace('|', SEP);
return images_path;
}
public static String getPwmPath() {
String pwm_path = config_container.pwm_path;
pwm_path = pwm_path.replace('|', SEP);
return pwm_path;
}
public static String getSequencePath() {
String sequence_path = config_container.sequence_path;
sequence_path = sequence_path.replace('|', SEP);
return sequence_path;
}
public static String getUserPath() {
String user_path = config_container.user_path;
user_path = user_path.replace('|', SEP);
user_path = new String(USER_DIR + user_path);
return user_path;
}
public static String getQuickImagePath() {
String images_path = quick_container.images_path;
images_path = images_path.replace('|', SEP);
return images_path;
}
public static String getSplashImage() {
String splash_image = quick_container.splash_image;
return splash_image;
}
public static String getLookAndFeel() {
return config_container.lookAndFeel;
}
public static String getNamingServerConnectionString() {
return config_container.getNamingServerConnectionString();
}
public static String getGFFPath() {
String gff_path = config_container.gff_path;
gff_path = gff_path.replace('|', SEP);
gff_path = new String(USER_DIR + gff_path);
return gff_path;
}
public static String getSessionPath() {
String session_path = config_container.session_path;
session_path = session_path.replace('|', SEP);
session_path = new String(USER_DIR + session_path);
return session_path;
}
public final static HashSet getFeatureConfiguration() {
HashSet f_base = new HashSet();
Feature[] ft = config_container.getFeature();
for (int k = 0; k < ft.length; k++) {
String feature_name = ft[k].getName();
f_base.add(feature_name);
}
return f_base;
}
public static String[] getFeatureNames() {
String[] feature_names;
Feature[] ft = config_container.getFeature();
feature_names = new String[ft.length];
for (int k = 0; k < ft.length; k++) {
feature_names[k] = ft[k].getName();
}
return feature_names;
}
public synchronized static List getSelectedFeatures() {
return selected_features;
}
public synchronized static void addSelectedFeatures(String feature_name) {
selected_features.add(feature_name);
}
public synchronized static void addSelectedFeatures(List feature_names) {
Iterator it = feature_names.iterator();
while (it.hasNext()) {
selected_features.add((String) it.next());
}
}
private static void setFeatureDisplay() {
Feature[] features = config_container.getFeature();
for (int i = 0; i < features.length; i++) {
String feature_name = features[i].getName();
feature_display.put(feature_name, new FeatureDisplay(features[i]));
}
}
public static FeatureDisplay getFeatureDisplay(
String feature_name,
boolean scored,
boolean distribution) {
if (feature_display == null) {
feature_display = new Hashtable();
setFeatureDisplay();
}
FeatureDisplay fd = null;
if (distribution) {
fd = (FeatureDisplay) feature_display.get("distribution");
fd.setColor(
((FeatureDisplay) feature_display.get(feature_name)).getColor());
} else {
fd = (FeatureDisplay) feature_display.get(feature_name);
}
if (fd == null) {
if (scored) {
fd = (FeatureDisplay) feature_display.get("generic_scored");
} else {
fd = (FeatureDisplay) feature_display.get("generic_unscored");
}
}
return fd;
}
public static Set getAllFeatureDisplay() {
if (feature_display == null) {
feature_display = new Hashtable();
setFeatureDisplay();
}
return feature_display.keySet();
}
public static float getPlatformWidth() {
return Float
.valueOf(config_container.getPlatform().getWidth())
.floatValue();
}
public static float getPlatformLength() {
return Float
.valueOf(config_container.getPlatform().getLength())
.floatValue();
}
public static float getPlatformThickness() {
return Float
.valueOf(config_container.getPlatform().getThickness())
.floatValue();
}
public static float getPlatformStickOut() {
return Float
.valueOf(config_container.getPlatform().getStickOut())
.floatValue();
}
public static float[] getPlatformColor() {
String c = config_container.getPlatform().getColor();
String[] rgb = c.split(" ");
float red = (float) Integer.valueOf(rgb[0]).intValue() / 255;
float green = (float) Integer.valueOf(rgb[1]).intValue() / 255;
float blue = (float) Integer.valueOf(rgb[2]).intValue() / 255;
float[] color = { red, green, blue };
return color;
}
public static List getFeatures() {
Feature[] f = config_container.getFeature();
List features = new ArrayList(f.length);
for (int i = 0; i < f.length; i++) {
features.add(f[i]);
}
return features;
}
public static Feature getFeature(String feature_name) {
List features = getFeatures();
for (int i = 0; i < features.size(); i++) {
if (((Feature) features.get(i)).getName().equals(feature_name)) {
return (Feature) features.get(i);
}
}
return null;
}
public static List getAllRepeatNames() {
List features = getFeatures();
List all_repeat_names = new ArrayList();
for (int i = 0; i < features.size(); i++) {
Feature feature = (Feature) features.get(i);
if (feature.getParentName() != null
&& feature.getParentName().equals("Repeats")) {
all_repeat_names.add((String) feature.getName());
}
}
return all_repeat_names;
}
public static Service[] getServices() {
return config_container.getService();
}
public static Service getService(String service_name) {
Service[] services = getServices();
for (int i = 0; i < services.length; i++) {
if (services[i].getName().equals(service_name)) {
return services[i];
}
}
return null;
}
public static boolean isParentFeatureDefined(String parent_name) {
Feature f = getFeature(parent_name);
if (f == null) {
return false;
} else {
return true;
}
}
public static Connection[] getConnections() {
return config_container.getConnection();
}
public static String getHelpEmail() {
return config_container.getHelpEmail();
}
public static String getTutorial() {
return config_container.getTutorial();
}
public static String getBrowser() {
return config_container.getBrowser();
}
public static int getSemZoomDefaultRange() {
return Integer
.valueOf(config_container.getSemZoomDefaultRange())
.intValue();
}
public static boolean getUseP2P() {
return Boolean.valueOf(config_container.getUseP2P()).booleanValue();
}
public static List getFonts() {
ConfigFont[] f = config_container.getConfigFont();
List fonts = new ArrayList(f.length);
for (int i = 0; i < f.length; i++) {
fonts.add(f[i]);
}
return fonts;
}
public static Font getFont(String font_name) {
try {
List fonts = getFonts();
for (int i = 0; i < fonts.size(); i++) {
if (((ConfigFont) fonts.get(i)).getName().equals(font_name)) {
String font = ((ConfigFont) fonts.get(i)).getFont();
int size;
try {
size =
new Integer(((ConfigFont) fonts.get(i)).getSize()).intValue();
if (size < 1)
throw new Exception("Font size can't be smaller than 1!");
} catch (Throwable t) {
System.out.println(
"Font size specification error, use default size 1 !");
size = 1;
}
String txtstyle = ((ConfigFont) fonts.get(i)).getStyle();
int style = Font.PLAIN;
if (txtstyle.equals("Plain"))
style = Font.PLAIN;
else if (txtstyle.equals("Bold"))
style = Font.BOLD;
else if (txtstyle.equals("Italic"))
style = Font.ITALIC;
else if (txtstyle.equals("Roman_Baseline"))
style = Font.ROMAN_BASELINE;
return new Font(font, style, size);
}
}
System.out.println(
"<Font3D> not specified in user_config.xml, use default font");
return new Font("Courier", Font.BOLD, 1);
} catch (Throwable t) {
System.out.println(
"Error in <Font3D> tag in user_config.xml, use default font");
return new Font("Courier", Font.BOLD, 1);
}
}
}
package ca.bcgsc.sockeye.config;
public class Connection implements java.io.Serializable {
protected String name;
protected String host;
protected String port;
protected String user;
protected String pass;
protected String type;
protected String subtype;
public Connection() {
name = "";
host = "";
port = "3306";
user = "";
pass = "";
type = "";
subtype = "";
}
public Connection(String name, String host, String port, String user, String pass, String type) {
this.name = name;
this.host = host;
this.port = port;
this.user = user;
this.pass = pass;
this.type = type;
}
public String getName() { return name; }
public void setName(String name) { this.name = name; }
public String getHost() { return host; }
public void setHost(String host) { this.host = host; }
public String getPort() { return port; }
public void setPort(String port) { this.port = port; }
public String getUser() { return user; }
public void setUser(String user) { this.user = user; }
public String getPass() { return pass; }
public void setPass(String pass) { this.pass = pass; }
public String getType() { return type; }
public void setType(String type) { this.type = type; }
public boolean equals(Object obj) {
if(!(obj instanceof Connection)) {
return false;
}
Connection connection = (Connection) obj;
if (getHost().equals(connection.getHost()) &&
getName().equals(connection.getName()) &&
getPass().equals(connection.getPass()) &&
getPort().equals(connection.getPort()) &&
getType().equals(connection.getType()) &&
getSubtype().equals(connection.getSubtype()) &&
getUser().equals(connection.getUser())) {
return true;
}
return false;
}
public int hashCode() {
return name.hashCode()
^ host.hashCode()
^ port.hashCode()
^ user.hashCode()
^ pass.hashCode()
^ type.hashCode()
^ subtype.hashCode();
}
public String toString() {
return name + "\t" +
host + "\t" +
port + "\t" +
user + "\t" +
pass + "\t" +
type + "\t" +
subtype;
}
public String getSubtype() {
return subtype;
}
public void setSubtype(String subtype) {
this.subtype = subtype;
}
}
package ca.bcgsc.sockeye.config;
public class Display implements java.io.Serializable{
protected String color, hcolor, shape, transparency, zoffset, halfheight, yoffset, strandoffset, width, orientation;
protected String thickness, scoredthickness;
protected String scaleable, length, alignment;
protected String text;
protected String collision;
public Display() {
color = "";
hcolor = "";
shape = "";
transparency = "";
zoffset = "";
halfheight = "";
yoffset = "";
strandoffset = "";
width = "";
thickness = "";
scoredthickness = "true";
orientation = "";
scaleable = "";
length = "";
alignment = "";
text = "";
collision = "";
}
public String getColor() { return color; }
public void setColor(String color) { this.color = color; }
public String getHcolor() { return hcolor; }
public void setHcolor(String hcolor) { this.hcolor = hcolor; }
public String getShape() { return shape; }
public void setShape(String shape) { this.shape = shape; }
public String getTransparency() { return transparency; }
public void setTransparency(String transparency) { this.transparency = transparency; }
public String getZoffset() { return zoffset; }
public void setZoffset(String zoffset) { this.zoffset = zoffset; }
public String getHalfHeight() { return halfheight; }
public void setHalfHeight(String halfheight) { this.halfheight = halfheight; }
public String getYoffset() { return yoffset; }
public void setYoffset(String yoffset) { this.yoffset = yoffset; }
public String getStrandoffset() { return strandoffset; }
public void setStrandoffset(String strandoffset) { this.strandoffset = strandoffset; }
public String getWidth() { return width; }
public void setWidth(String width) { this.width = width; }
public String getThickness() { return thickness; }
public void setThickness(String thickness) { this.thickness = thickness; }
public String getScoredthickness() { return scoredthickness; }
public void setScoredthickness(String scoredthickness) { this.scoredthickness = scoredthickness; }
public String getOrientation() { return orientation; }
public void setOrientation(String orientation) { this.orientation = orientation; }
public String getScaleable() { return scaleable; }
public void setScaleable(String scaleable) { this.scaleable = scaleable; }
public String getLength() { return length; }
public void setLength(String length) { this.length = length; }
public String getAlignment() { return alignment; }
public void setAlignment(String alignment) { this.alignment = alignment; }
public String getText() { return text; }
public void setText(String text) { this.text = text; }
public String getCollision() { return collision; }
public void setCollision(String collision) { this.collision = collision; }
public String toString() {
StringBuffer ret = new StringBuffer();
ret.append("display: color=" + color
+ " shape=" + shape
+ " transparency=" + transparency
+ " z_offset=" + zoffset
+ " half_height=" + halfheight
+ " y_offset=" + yoffset
+ " strand_offset=" + strandoffset
+ " width=" + width
+ " thickness=" + thickness
+ " orientation=" + orientation
+ " scaleable=" + scaleable
+ " length=" + length
+ " alignment=" + alignment
+ " text=" + text
+ "\n");
ret.append("\n");
return ret.toString();
}
}
package ca.bcgsc.sockeye.config;
public class Driver {
protected String name;
protected String config;
public Driver() {
name = "";
config = "";
}
public String getName() { return name; }
public void setName(String name) { this.name = name; }
public String getConfig() { return config ; }
public void setConfig(String config) { this.config = config; }
public String toString() {
StringBuffer ret = new StringBuffer();
ret.append("driver: name=" + name + " config=" + config +"\n");
return ret.toString();
}
}
package ca.bcgsc.sockeye.config;
public class Feature
implements java.io.Serializable {
protected String name, selected, parent_name;
protected String color, hcolor, shape, transparency, zoffset, halfheight,
yoffset, strandoffset, width, orientation;
protected String thickness, scoredthickness;
protected String scaleable, length, alignment;
protected String text, collision;
public Feature() {
name = "";
selected = "false";
parent_name = null;
color = null;
hcolor = null;
shape = null;
transparency = null;
zoffset = null;
halfheight = null;
yoffset = null;
strandoffset = null;
width = null;
thickness = null;
scoredthickness = null;
orientation = null;
scaleable = null;
length = null;
alignment = null;
text = null;
collision = null;
}
public String getName() { return name; }
public void setName(String name) { this.name = name; }
public String getSelected() { return selected; }
public void setSelected(String selected) { this.selected = selected; }
public String getParentName() { return parent_name; }
public void setParentName(String parent_name) { this.parent_name = parent_name; }
public String getColor() { return color; }
public void setColor(String color) { this.color = color; }
public String getHcolor() { return hcolor; }
public void setHcolor(String hcolor) { this.hcolor = hcolor; }
public String getShape() { return shape; }
public void setShape(String shape) { this.shape = shape; }
public String getTransparency() { return transparency; }
public void setTransparency(String transparency) { this.transparency = transparency; }
public String getZoffset() { return zoffset; }
public void setZoffset(String zoffset) { this.zoffset = zoffset; }
public String getHalfHeight() { return halfheight; }
public void setHalfHeight(String halfheight) { this.halfheight = halfheight; }
public String getYoffset() { return yoffset; }
public void setYoffset(String yoffset) { this.yoffset = yoffset; }
public String getStrandoffset() { return strandoffset; }
public void setStrandoffset(String strandoffset) { this.strandoffset = strandoffset; }
public String getWidth() { return width; }
public void setWidth(String width) { this.width = width; }
public String getThickness() { return thickness; }
public void setThickness(String thickness) { this.thickness = thickness; }
public String getScoredthickness() { return scoredthickness; }
public void setScoredthickness(String scoredthickness) { this.scoredthickness = scoredthickness; }
public String getOrientation() { return orientation; }
public void setOrientation(String orientation) { this.orientation = orientation; }
public String getScaleable() { return scaleable; }
public void setScaleable(String scaleable) { this.scaleable = scaleable; }
public String getLength() { return length; }
public void setLength(String length) { this.length = length; }
public String getAlignment() { return alignment; }
public void setAlignment(String alignment) { this.alignment = alignment; }
public String getText() { return text; }
public void setText(String text) { this.text = text; }
public String getCollision() { return collision; }
public void setCollision(String collision) { this.collision = collision; }
public String toString() {
StringBuffer ret = new StringBuffer();
ret.append("feature: name=" + name + " parent=" + parent_name + "\n");
ret.append("\n");
return ret.toString();
}
}
package ca.bcgsc.sockeye.config;
import java.awt.Color;
import java.awt.Font;
public class FeatureDisplay {
public static int __ORIENT_NORMAL = 0;
public static int __ORIENT_SWITCH_XY = 1;
public static int __ORIENT_SWITCH_YZ = 2;
public static int __ORIENT_SWITCH_YZ_DOWN = 3;
private String feature_name;
private String shape_file;
private Color color, hcolor = null;
private double transparency;
private double y_offset;
private double z_offset;
private boolean half_height_z_offset, strand_offset;
private double width;
private double thickness;
private boolean scoredthickness;
private int orientation;
private boolean scaleable;
private double length;
private int alignment;
private String text;
private Feature temp;
private boolean detects_collisions;
public FeatureDisplay(Feature feature) {
feature_name = feature.getName();
temp = feature;
while (temp.getShape() == null) {
String parent_name = temp.getParentName();
if (parent_name == null) {
parent_name = "default";
}
temp = Configuration.getFeature(parent_name);
}
shape_file = Configuration.getModelsPath().concat(temp.getShape());
temp = feature;
while (temp.getColor() == null) {
String parent_name = temp.getParentName();
if (parent_name == null) {
parent_name = "default";
}
temp = Configuration.getFeature(parent_name);
}
String c = temp.getColor();
String[] rgb = c.split(" ");
int red = (int) Integer.valueOf(rgb[0]).intValue();
int green = (int) Integer.valueOf(rgb[1]).intValue();
int blue = (int) Integer.valueOf(rgb[2]).intValue();
color = new Color(red, green, blue);
temp = feature;
while (temp.getHcolor() == null) {
String parent_name = temp.getParentName();
if (parent_name == null) {
parent_name = "default";
}
temp = Configuration.getFeature(parent_name);
}
String hc = temp.getHcolor();
if (!hc.equals("")) {
rgb = hc.split(" ");
red = (int) Integer.valueOf(rgb[0]).intValue();
green = (int) Integer.valueOf(rgb[1]).intValue();
blue = (int) Integer.valueOf(rgb[2]).intValue();
hcolor = new Color(red, green, blue);
}
temp = feature;
while (temp.getTransparency() == null) {
String parent_name = temp.getParentName();
if (parent_name == null) {
parent_name = "default";
}
temp = Configuration.getFeature(parent_name);
}
transparency = (double) Double.valueOf(temp.getTransparency()).doubleValue();
temp = feature;
while (temp.getYoffset() == null) {
String parent_name = temp.getParentName();
if (parent_name == null) {
parent_name = "default";
}
temp = Configuration.getFeature(parent_name);
}
y_offset = (double) Double.valueOf(temp.getYoffset()).doubleValue();
y_offset = y_offset * Configuration.getPlatformWidth();
temp = feature;
while (temp.getStrandoffset() == null) {
String parent_name = temp.getParentName();
if (parent_name == null) {
parent_name = "default";
}
temp = Configuration.getFeature(parent_name);
}
strand_offset = (boolean) Boolean.valueOf(temp.getStrandoffset()).
booleanValue();
temp = feature;
while (temp.getZoffset() == null) {
String parent_name = temp.getParentName();
if (parent_name == null) {
parent_name = "default";
}
temp = Configuration.getFeature(parent_name);
}
z_offset = (double) Double.valueOf(temp.getZoffset()).doubleValue();
z_offset = z_offset * Configuration.getPlatformWidth();
temp = feature;
while (temp.getHalfHeight() == null) {
String parent_name = temp.getParentName();
if (parent_name == null) {
parent_name = "default";
}
temp = Configuration.getFeature(parent_name);
}
half_height_z_offset = (boolean) Boolean.valueOf(temp.getHalfHeight()).
booleanValue();
temp = feature;
while (temp.getWidth() == null) {
String parent_name = temp.getParentName();
if (parent_name == null) {
parent_name = "default";
}
temp = Configuration.getFeature(parent_name);
}
width = (double) Double.valueOf(temp.getWidth()).doubleValue();
width = width * Configuration.getPlatformWidth();
temp = feature;
while (temp.getThickness() == null) {
String parent_name = temp.getParentName();
if (parent_name == null) {
parent_name = "default";
}
temp = Configuration.getFeature(parent_name);
}
thickness = (double) Double.valueOf(temp.getThickness()).doubleValue();
thickness = thickness * Configuration.getPlatformWidth();
temp = feature;
while (temp.getScoredthickness() == null) {
String parent_name = temp.getParentName();
if (parent_name == null) {
parent_name = "default";
}
temp = Configuration.getFeature(parent_name);
}
scoredthickness = (boolean) Boolean.valueOf(temp.getScoredthickness()).
booleanValue();
temp = feature;
while (temp.getOrientation() == null) {
String parent_name = temp.getParentName();
if (parent_name == null) {
parent_name = "default";
}
temp = Configuration.getFeature(parent_name);
}
orientation = (int) Integer.valueOf(temp.getOrientation()).intValue();
temp = feature;
while (temp.getScaleable() == null) {
String parent_name = temp.getParentName();
if (parent_name == null) {
parent_name = "default";
}
temp = Configuration.getFeature(parent_name);
}
scaleable = (boolean) Boolean.valueOf(temp.getScaleable()).booleanValue();
temp = feature;
while (temp.getLength() == null) {
String parent_name = temp.getParentName();
if (parent_name == null) {
parent_name = "default";
}
temp = Configuration.getFeature(parent_name);
}
length = (double) Double.valueOf(temp.getLength()).doubleValue();
length = length * Configuration.getPlatformWidth();
temp = feature;
while (temp.getCollision() == null) {
String parent_name = temp.getParentName();
if (parent_name == null) {
parent_name = "default";
}
temp = Configuration.getFeature(parent_name);
}
detects_collisions = (boolean) Boolean.valueOf(temp.getCollision()).booleanValue();
temp = feature;
while (temp.getAlignment() == null) {
String parent_name = temp.getParentName();
if (parent_name == null) {
parent_name = "default";
}
temp = Configuration.getFeature(parent_name);
}
String a = temp.getAlignment();
if (a.equals("center")) {
alignment = 0;
}
else if (a.equals("left")) {
alignment = -1;
}
else if (a.equals("right")) {
alignment = +1;
}
else {
alignment = 0;
}
temp = feature;
while (temp.getText() == null) {
String parent_name = temp.getParentName();
if (parent_name == null) {
parent_name = "default";
}
temp = Configuration.getFeature(parent_name);
}
text = temp.getText();
}
public String getFeatureName() {
return feature_name;
}
public String getShapeFile() {
return shape_file;
}
public Color getColor() {
return color;
}
public void setColor(Color newcolor) {
color = newcolor;
}
public Color getHcolor() {
return hcolor;
}
public double getTransparency() {
return transparency;
}
public boolean isZOffsetHalfHeight() {
return half_height_z_offset;
}
public double getZOffset() {
return z_offset;
}
public double getYOffset() {
return y_offset;
}
public boolean isYOffsetStranded() {
return strand_offset;
}
public boolean isThicknessScored() {
return scoredthickness;
}
public double getWidth() {
return width;
}
public double getThickness() {
return thickness;
}
public int getOrientation() {
return orientation;
}
public boolean getScaleable() {
return scaleable;
}
public double getLength() {
return length;
}
public boolean canDetectCollisions() {
return this.detects_collisions;
}
public int getAlignment() {
return alignment;
}
public boolean isText() {
if (text.equals("none")) {
return false;
}
else {
return true;
}
}
public Font getFont() {
String[] font;
if (!isText()) {
return null;
}
else {
font = text.split("_");
return new Font(font[0], Font.PLAIN, (Integer.valueOf(font[1])).intValue());
}
}
}
package ca.bcgsc.sockeye.config;
public class Node {
protected String name, dis, parent;
public Node() {
name = "";
dis = "";
parent = "";
}
public String getName() { return name; }
public void setName(String name) { this.name = name; }
public String getDis() { return dis; }
public void setDis(String dis) { this.dis = dis; }
public String getParent() { return parent; }
public void setParent(String parent) { this.parent = parent; }
public String toString() {
StringBuffer ret = new StringBuffer();
ret.append("node: name=" + name + " display=" + dis + "\n");
return ret.toString();
}
}
package ca.bcgsc.sockeye.config;
public class Platform implements java.io.Serializable {
String width, length, thickness, stickOut, color;
public Platform() {
width = "";
length = "";
thickness = "";
stickOut = "";
color = "";
}
public String getWidth() { return width; }
public void setWidth(String width) { this.width = width; }
public String getLength() { return length; }
public void setLength(String length) { this.length = length; }
public String getThickness() { return thickness; }
public void setThickness(String thickness) { this.thickness = thickness; }
public String getStickOut() { return stickOut; }
public void setStickOut(String stickOut) { this.stickOut = stickOut; }
public String getColor() { return color; }
public void setColor(String color) { this.color = color; }
}
package ca.bcgsc.sockeye.config;
public class Popup {
protected String label;
protected String url;
public Popup() {
label = "";
url = "";
}
public String getLabel() { return label; }
public void setLabel(String label) { this.label = label; }
public String getURL() { return url; }
public void setURL(String url) { this.url = url; }
public String toString() {
StringBuffer ret = new StringBuffer();
ret.append("popup: label=" + label + " url=" + url +"\n");
return ret.toString();
}
}
package ca.bcgsc.sockeye.config;
import java.io.Serializable;
public class QuickContainer implements Serializable {
protected String images_path, splash_image;
Constructor:
Only holds image_path right now. This was so the location of the image for the splash screen
could be found as quickly as possible. (ie. for the loading screen)
public QuickContainer() {
images_path = "";
splash_image = "";
}
public String getImagesPath() { return images_path; }
public void setImagesPath(String images_path) { this.images_path = images_path; }
public String getSplashImage() { return splash_image; }
public void setSplashImage (String splash_image) { this.splash_image = splash_image; }
public String toString() {
StringBuffer ret = new StringBuffer();
ret.append("images_path=" + images_path + "\n");
ret.append("splash_image=" + splash_image + "\n");
return ret.toString();
}
}
package ca.bcgsc.sockeye.config;
public class Service implements java.io.Serializable {
private String name;
private String mode;
private String remotehost;
private String connection;
public Service() {
name = "";
mode = "";
remotehost = "";
connection = "";
}
public String getName() { return name; }
public void setName(String name) { this.name = name; }
public String getMode() { return mode; }
public void setMode(String mode) { this.mode = mode; }
public String getRemotehost() {
return remotehost;
}
public void setRemotehost(String remotehost) {
this.remotehost = remotehost;
}
public String getConnection() {
return connection;
}
public void setConnection(String string) {
connection = string;
}
}
package ca.bcgsc.sockeye.dataretrieval;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import ca.bcgsc.sockeye.config.Connection;
import ca.bcgsc.sockeye.service.featureloader.common.ConnectionManager;
public class CisREDConnection {
private static final String _MYSQL_DB_DRIVER = "com.mysql.jdbc.Driver";
private static final String _SEP = "/";
private static final String _SHORT_URL = "jdbc:mysql:
public static final String __CISRED_FEATURE_NAME = "cisRED";
private Connection connection;
private Statement stmt = null;
private ResultSet rs = null;
private String database;
java.sql.Connection conn = null;
public CisREDConnection() {
Connection connection =
ConnectionManager.getConnectionByType(
__CISRED_FEATURE_NAME);
if (connection == null)
throw new IllegalArgumentException("Connection value is null when creating cisRED datasource!");
String url = getURL(connection.getHost(), connection.getName());
try {
Class.forName(_MYSQL_DB_DRIVER);
conn =
DriverManager.getConnection(
url,
connection.getUser(),
connection.getPass());
stmt = conn.createStatement();
} catch (ClassNotFoundException e) {
System.out.println(
"ERROR: Connection to "
+ url
+ " is failed: "
+ e.getMessage());
} catch (SQLException e) {
System.out.println(
"ERROR: Connection to "
+ url
+ " is failed: "
+ e.getMessage());
e.printStackTrace();
}
}
public ResultSet getSitesequenceByFeatureId(String feature_id) {
String query =
"SELECT * FROM `sitesequences` where feature_id=" + feature_id;
try {
return stmt.executeQuery(query);
} catch (SQLException e) {
return null;
}
}
public void closeConnection() {
try {
if (rs != null)
rs.close();
if (stmt != null)
stmt.close();
if (conn != null)
conn.close();
} catch (SQLException e) {
e.printStackTrace();
}
}
private String getURL(String host, String db) {
return _SHORT_URL + host + _SEP + db;
}
}
package ca.bcgsc.sockeye.dataretrieval;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import ca.bcgsc.sockeye.config.Connection;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
public class CisREDDRU extends DataRetrievalUnit {
private static final String _MYSQL_DB_DRIVER = "com.mysql.jdbc.Driver";
private static final String _SEP = "/";
private static final String _SHORT_URL = "jdbc:mysql:
public static final String __CISRED_FEATURE_NAME = "cisRED";
public static final String __SEARCHED_REGION_NAME = "search_region";
public static final String __FEATURE_ID = "id";
public static final boolean __QUERY_WITH_MAX_BATCH = true;
private Connection connection;
private String database;
private String chromosome;
private String species;
private int query_start;
private int query_end;
private int track_id;
private Map deliverFeatures = new HashMap();
protected List _delete_features_before_delivery;
public CisREDDRU(String chromosome_, Connection con_, String species_) {
if (con_ == null)
throw new IllegalArgumentException(
"Connection value is null when creating cisRED datasource!");
if (chromosome_ == null || chromosome_.length() == 0)
throw new IllegalArgumentException(
"Empty or null chromosome value when creating cisRED datasource!");
if (species_ == null || species_.length() == 0)
throw new IllegalArgumentException(
"Empty or null species value when creating cisRED datasource!");
connection = con_;
chromosome = chromosome_;
species = species_;
}
protected void retrieveData() {
if (_request_to_process.getFeatures().isEmpty()) {
return;
}
java.sql.Connection conn = null;
Statement stmt = null;
ResultSet rs = null;
query_start = _request_to_process.getStart();
query_end = _request_to_process.getEnd();
track_id = _request_to_process.getTrackId();
String track_name = DataStoreUser.getInstance().getSockeyeTrackList()
.getTrackAttribute(track_id, "track_name").toString();
String url = null;
try {
url = getURL(connection.getHost(), connection.getName());
Class.forName(_MYSQL_DB_DRIVER);
conn = DriverManager.getConnection(url, connection.getUser(),
connection.getPass());
stmt = conn.createStatement();
String query = getSearchedRegionQuery();
rs = stmt.executeQuery(query);
Map regions = new HashMap();
if (rs != null) {
while (rs.next()) {
TrackFeature region = new TrackFeature(
__SEARCHED_REGION_NAME);
String chrom = rs.getString("chromosome");
int start = rs.getInt("start");
int end = rs.getInt("end");
region.setSeqName(track_name.split(":")[0] + ":" + start
+ ".." + end);
region.setStart(start);
region.setEnd(end);
region.setAccessionID(__CISRED_FEATURE_NAME + "_"
+ __SEARCHED_REGION_NAME + rs.getString("id"));
regions.put(rs.getString("ensembl_gene_id"), region);
}
}
if (track_name.startsWith("H")) {
query = getFeatureQuery();
rs = stmt.executeQuery(query);
List ids = new ArrayList();
if (rs != null) {
int batch_id = 1;
while (rs.next()) {
if (__QUERY_WITH_MAX_BATCH) {
int new_batch_id = rs.getInt("batch_id");
if (new_batch_id > batch_id) {
batch_id = new_batch_id;
ids.clear();
}
if (new_batch_id == batch_id)
ids.add(rs.getString("id"));
} else
ids.add(rs.getString("id"));
}
}
query = getSitesequenceQuery();
rs = stmt.executeQuery(query);
if (rs != null) {
List tfs = new ArrayList();
List regions_list = new ArrayList();
while (rs.next()) {
String feature_id = rs.getString("feature_id");
boolean cont = false;
for (int j = 0; j < ids.size(); j++) {
if (feature_id.equals(ids.get(j).toString()))
cont = true;
}
if (!cont)
continue;
String strand_str = rs.getString("source_strand");
int strand = 0;
if (strand_str.equals("-"))
strand = -1;
else if (strand_str.equals("+"))
strand = 1;
String chrom = rs.getString("source_chromosome");
String source = rs.getString("source_type");
String gene = rs.getString("source_annotation");
int start = rs.getInt("source_start");
int end = rs.getInt("source_end");
query = getScoreQuery(feature_id);
Statement st = conn.createStatement();
double score = 0;
if (st != null) {
ResultSet rs_score = st.executeQuery(query);
if (rs_score != null) {
if (rs_score.next())
score = rs_score.getDouble("score");
rs_score.close();
st.close();
}
}
if (score == 0)
score = Math.pow(10, -5);
score = -Math.log(score) / Math.log(10);
TrackFeature tf = new TrackFeature(chrom, source,
__CISRED_FEATURE_NAME, start, end, score,
strand, 0);
tf.setAccessionID(feature_id);
tf.setAttribute(__FEATURE_ID, feature_id);
tf.setTrackId(track_id);
tfs.add(tf);
Object searched_region_obj = regions.get(gene);
if (searched_region_obj != null) {
regions_list
.add((TrackFeature) searched_region_obj);
}
}
deliverFeatures.put(__CISRED_FEATURE_NAME, tfs);
deliverFeatures.put(__SEARCHED_REGION_NAME, regions_list);
}
} else {
query = getSitesequenceQuery();
rs = stmt.executeQuery(query);
if (rs != null) {
List tfs = new ArrayList();
List regions_list = new ArrayList();
while (rs.next()) {
String feature_id = rs.getString("feature_id");
String strand_str = rs.getString("source_strand");
int strand = 0;
if (strand_str.equals("-"))
strand = -1;
else if (strand_str.equals("+"))
strand = 1;
String chrom = rs.getString("source_chromosome");
String source = rs.getString("source_type");
String gene = rs.getString("source_annotation");
int start = rs.getInt("source_start");
int end = rs.getInt("source_end");
query = getScoreQuery(feature_id);
Statement st = conn.createStatement();
double score = 0;
if (st != null) {
ResultSet rs_score = st.executeQuery(query);
if (rs_score != null) {
if (rs_score.next())
score = rs_score.getDouble("score");
rs_score.close();
st.close();
}
}
if (score == 0)
score = Math.pow(10, -5);
score = -Math.log(score) / Math.log(10);
TrackFeature tf = new TrackFeature(chrom, source,
__CISRED_FEATURE_NAME, start, end, score,
strand, 0);
tf.setAccessionID(feature_id);
tf.setAttribute(__FEATURE_ID, feature_id);
tf.setTrackId(track_id);
tfs.add(tf);
Object searched_region_obj = regions.get(gene);
if (searched_region_obj != null) {
regions_list
.add((TrackFeature) searched_region_obj);
}
}
deliverFeatures.put(__CISRED_FEATURE_NAME, tfs);
deliverFeatures.put(__SEARCHED_REGION_NAME, regions_list);
}
}
} catch (ClassNotFoundException e) {
System.out.println("ERROR: Connection to " + url + " is failed: "
+ e.getMessage());
} catch (SQLException e) {
System.out.println("ERROR: Connection to " + url + " is failed: "
+ e.getMessage());
e.printStackTrace();
} finally {
try {
if (rs != null)
rs.close();
if (stmt != null)
stmt.close();
if (conn != null)
conn.close();
} catch (SQLException e) {
e.printStackTrace();
}
}
}
protected void deliverData() {
if (_delete_features_before_delivery != null) {
_my_storage_manager.removeFeature(track_id,
_delete_features_before_delivery);
}
Set keyset = deliverFeatures.keySet();
Iterator df = keyset.iterator();
while (df.hasNext()) {
String feature_name = df.next().toString();
_my_storage_manager.addFeatures(track_id, feature_name,
(List) deliverFeatures.get(feature_name));
}
}
private String getURL(String host, String db) {
return _SHORT_URL + host + _SEP + db;
}
private String getSearchedRegionQuery() {
return "SELECT * FROM `search_region`";
}
private String getFeatureQuery() {
return "SELECT * FROM `features` where seqname='" + chromosome
+ "' and start >=" + query_start + " and end <=" + query_end;
}
private String getSitesequenceQuery() {
species = CisREDDataSource.getInfoFromDatabaseName(species,
"species");
return "SELECT * FROM `sitesequences` where source_chromosome='"
+ chromosome + "' and source_db>='" + species
+ "' and source_start >=" + query_start + " and source_end <="
+ query_end;
}
private String getScoreQuery(String faeture_id) {
return "SELECT score from features where id=" + faeture_id;
}
private String getAccessionIDQuery() {
return "SELECT accession_id, feature_id FROM `accession`";
}
}/*
package ca.bcgsc.sockeye.dataretrieval;
import ca.bcgsc.sockeye.config.Connection;
public class CisREDDataSource extends DataSource {
private String chromosome;
private String species;
private Connection connection;
private static final String _SPECIES_KEY = "species";
private static final String _VERSION_KEY = "version";
public CisREDDataSource() {
super();
}
public CisREDDataSource(int track, String chromosome_,
Connection connection_, String species_) {
super(track);
chromosome = chromosome_;
species = species_;
connection = connection_;
}
protected DataRetrievalUnit createDRU() {
CisREDDRU dru = new CisREDDRU(chromosome, connection, species);
return dru;
}
public String getDisplayString() {
if (connection == null)
return null;
return connection.getType() + "[" + connection.getName() + "]" + " "
+ species;
}
public static String getInfoFromDatabaseName(String database, String key) {
try {
String[] str = database.split("_core_");
if (key.equals(_SPECIES_KEY))
return str[0];
else if (key.equals(_VERSION_KEY)) {
str = str[1].split("_");
return str[0];
}
return "";
} catch (Exception e) {
return "";
}
}
}/*------
package ca.bcgsc.sockeye.dataretrieval;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.biojava.bio.program.gff.SimpleGFFRecord;
import ca.bcgsc.genereg.utils.Factor;
import ca.bcgsc.genereg.utils.RegEleManagerFactory;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.util.SequenceUtils;
public class CohoDRU extends DataRetrievalUnit {
List _factors;
String _group_name;
int _track_id, _method;
float _threshold;
static int _feature_id = 0;
Map deliverFeatures = new HashMap();
public CohoDRU(List factors, float threshold, int method) {
_factors = factors;
_threshold = threshold / 100;
_method = method;
}
protected void retrieveData() {
if (_request_to_process.getFeatures().isEmpty()
|| !_request_to_process.getFeatures().contains("PWM_score_fwd")
|| !_request_to_process.getFeatures().contains("PWM_score_rev")) {
return;
}
try {
List distributions_to_display = new ArrayList();
List motifs_fwd = new ArrayList();
List motifs_rev = new ArrayList();
for (int j = 0; j < _factors.size(); j++) {
Factor factor = (Factor) _factors.get(j);
System.out.println("PWM " + factor.getName());
_track_id = _request_to_process.getTrackId();
int start = _request_to_process.getStart();
int end = _request_to_process.getEnd();
String seq =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackSequence(_track_id, start, end)
.replaceAll("-", "");
String seq_RC = SequenceUtils.reverseComplementSequence(seq);
List gff_records =
RegEleManagerFactory.getInstance().scan(
seq,
factor,
_threshold);
Iterator iter = gff_records.iterator();
while (iter.hasNext()) {
TrackFeature motif = new TrackFeature((SimpleGFFRecord) iter.next());
String name = motif.getAttribute("display_name");
if (this._parent_datasource_id!=null)
motif.setSource(this._parent_datasource_id.toString());
motif.setFeature("PWM_score_fwd");
motif.setAccessionID(name + " (" + _feature_id++ +")");
motif.setTrackId(_track_id);
motifs_fwd.add(motif);
}
gff_records =
RegEleManagerFactory.getInstance().scan(
seq_RC,
factor,
_threshold);
iter = gff_records.iterator();
while (iter.hasNext()) {
TrackFeature motif = new TrackFeature((SimpleGFFRecord) iter.next());
String name = motif.getAttribute("display_name");
if (this._parent_datasource_id!=null)
motif.setSource(this._parent_datasource_id.toString());
motif.setFeature("PWM_score_rev");
motif.setAccessionID(name + " (" + _feature_id++ +")");
motif.setTrackId(_track_id);
motifs_rev.add(motif);
}
}
deliverFeatures.put("PWM_score_fwd", motifs_fwd);
deliverFeatures.put("PWM_score_rev", motifs_rev);
} catch (Exception ee) {
ee.printStackTrace();
}
}
protected void deliverData() {
Set keyset = deliverFeatures.keySet();
Iterator df = keyset.iterator();
while (df.hasNext()) {
String feature_name = df.next().toString();
_my_storage_manager.addFeatures(
_track_id,
feature_name,
(List) deliverFeatures.get(feature_name));
DataStoreUser.getInstance().getSockeyeTrackList().setFeatureVisibility(
feature_name,
true);
}
System.out.println("TFBSMotifs DRU: Delivering data DONE!");
}
}
package ca.bcgsc.sockeye.dataretrieval;
import java.util.List;
public class CohoDataSource extends DataSource {
private List _scan_group;
private float _threshold;
private String _group_name;
private int _method;
public CohoDataSource(){}
public CohoDataSource(int track, List scan_group, float threshold, int method) {
super (track);
_scan_group = scan_group;
_threshold = threshold;
_method = method;
}
public String getDisplayString(){
return "COHO: " + _group_name;
}
protected DataRetrievalUnit createDRU(){
return new CohoDRU( _scan_group, _threshold, _method);
}
}
package ca.bcgsc.sockeye.dataretrieval;
import java.util.ArrayList;
import java.util.List;
import ca.bcgsc.genereg.gui.event.ScanEvent;
import ca.bcgsc.genereg.gui.event.ScanEventListener;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.datastorage.SockeyeTrackList;
import ca.bcgsc.sockeye.datastorage.events.StorageEvent;
public class CohoUser implements ScanEventListener {
public void onEventReceived(ScanEvent e) {
CohoDataSource src = new CohoDataSource(e.getTrackId(), e.getFactors(),
e.getThreshold(), e.getMethod());
DataStoreUser.getInstance().getSockeyeTrackList().addStorageListener(src);
int ds_id = DataStoreUser.getInstance().getDataSourceManager().addDataSource(src);
DataStoreUser.getInstance().getDataSourceManager().setSingleShotSource(ds_id, true);
DataStoreUser.getInstance().getSockeyeTrackList().addDataSourceId(e.getTrackId(), ds_id);
List event_attrib = new ArrayList();
event_attrib.add(new Integer(e.getTrackId()));
event_attrib.add(new Integer(e.getStart()));
event_attrib.add(new Integer(e.getEnd()));
event_attrib.add("PWM_score_fwd");
event_attrib.add("PWM_score_rev");
( (SockeyeTrackList) DataStoreUser.getInstance().getSockeyeTrackList()).triggerEvent(
StorageEvent.
STORAGE_EVENT_TRACK_DATA_REQUEST,
event_attrib);
}
}
package ca.bcgsc.sockeye.dataretrieval;
public class DASConstants {
public static final String __HOMO_SAPIENS = "Homo_sapiens";
public static final String __HUMAN = "Human";
public static final String __ELEGANS = "Elegans";
public static final String __BRIGGSAE = "Briggsae";
public static final String __C_ELEGANS = "Caenorhabditis_elegans";
public static final String __C_BRIGGSAE = "Caenorhabditis_briggsae";
public static final String[][] __SPECIES_NAMES =
{ { __HOMO_SAPIENS, __HUMAN }, {
__C_ELEGANS, __ELEGANS }, {
__C_BRIGGSAE, __BRIGGSAE }
};
public static final String[] __HUMAN_CHROMOSOME_NAMES =
{
"1",
"2",
"3",
"4",
"5",
"6",
"7",
"8",
"9",
"10",
"11",
"12",
"13",
"14",
"15",
"16",
"17",
"18",
"19",
"20",
"21",
"22",
"X",
"Y" };
public static String[] getDefaultChromosomeNamesBySpecies(String species) {
if (species == null)
return null;
if (species.equals(__HOMO_SAPIENS) || species.equals(__HUMAN))
return __HUMAN_CHROMOSOME_NAMES;
return null;
}
public static String defineSpeciesByDescription(String descr) {
String species = null;
for (int i = 0; i < __SPECIES_NAMES.length; i++) {
String[] species_row = __SPECIES_NAMES[i];
for(int j=0; j<species_row.length; j++){
species = species_row[j];
if (descr
.toLowerCase()
.indexOf(species.toLowerCase().replaceAll("_", " "))
!= -1){
return species_row[0];
}
else
species = null;
}
}
return species;
}
public static String[] getDefaultChromosomeNamesByDescription(String descr) {
return getDefaultChromosomeNamesBySpecies(
defineSpeciesByDescription(descr));
}
}
package ca.bcgsc.sockeye.dataretrieval;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.biojava.bio.program.gff.GFFTools;
import org.xmlbio.jdas.datamodel.Feature;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
public class DASDRU extends DataRetrievalUnit {
private List features = null;
private Map deliverFeatures = new HashMap();
public DASDRU() {
super();
}
public DASDRU(List features_) {
super();
features = features_;
}
protected void retrieveData() {
String feature_name = null;
List fl;
for (int i = 0; i < features.size(); i++) {
Feature feature = (Feature) features.get(i);
feature_name = feature.getType().getName();
double score;
try {
score = Double.parseDouble(feature.getScore());
} catch (java.lang.NumberFormatException e) {
score = 0.0;
}
int strand = 0;
if (feature.getOrientation().equals("+"))
strand = 1;
else if (feature.getOrientation().equals("-"))
strand = -1;
TrackFeature tf =
new TrackFeature(
feature.getId(),
DASDataSource.__DAS_TYPE,
feature_name,
Integer.parseInt(Long.toString(feature.getStart())),
Integer.parseInt(Long.toString(feature.getEnd())),
score,
strand,
GFFTools.NO_FRAME);
tf.setAccessionID(feature.getId());
if (deliverFeatures.containsKey(feature_name)) {
fl = (List) deliverFeatures.get(feature_name);
} else {
fl = new ArrayList();
}
fl.add(tf);
deliverFeatures.put(feature_name, fl);
}
}
protected void deliverData() {
Set keyset = deliverFeatures.keySet();
Iterator df = keyset.iterator();
while (df.hasNext()) {
String feature_name = df.next().toString();
_my_storage_manager.addFeatures(
_request_to_process.getTrackId(),
feature_name,
(List) deliverFeatures.get(feature_name));
DataStoreUser.getInstance().getSockeyeTrackList().setFeatureVisibility(
feature_name,
true);
System.out.println("feature_name: " + feature_name);
}
System.out.println("DAS DRU: Delivering data DONE!");
}
}
package ca.bcgsc.sockeye.dataretrieval;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import org.xmlbio.jdas.datamodel.Feature;
import org.xmlbio.jdas.datamodel.GeneralFeatureFormat;
import org.xmlbio.jdas.datamodel.Segment;
import org.xmlbio.jdas.parameter.SegmentParameter;
import org.xmlbio.jdas.request.FeaturesRequest;
import org.xmlbio.jdas.response.DasException;
import org.xmlbio.jdas.response.DasResponse;
import org.xmlbio.jdas.response.FeaturesResponse;
public class DASDataSource extends DataSource {
public final static String __DAS_TYPE = "DAS";
private final static String _SEP = ",";
private static Map _das_ds_map = new HashMap();
private int _range_start;
private int _range_end;
private List features_list;
private List features_to_load;
private org.xmlbio.jdas.datamodel.DataSource jdas_ds;
private DASServer server;
private String chrom;
public DASDataSource() {
super();
}
public DASDataSource(int track, String server_name) {
super(track);
}
public static DASDataSource getDASDataSource(
String server_name,
String ds_name,
int track,
int start,
int end)
throws Exception {
String name =
String.valueOf(track)
+ _SEP
+ String.valueOf(start)
+ _SEP
+ String.valueOf(end);
Object obj = _das_ds_map.get(name);
DASDataSource ds = null;
if (obj == null) {
if (server_name != null && ds_name != null) {
ds = new DASDataSource(server_name, track, start, end, ds_name);
_das_ds_map.put(name, ds);
}
} else {
ds = (DASDataSource) obj;
if (server_name != null) {
ds.setServer(server_name);
if (ds_name != null)
ds.setJDASDataSource(server_name, ds_name);
}
}
return ds;
}
private DASDataSource(
String server_name,
int track,
int start,
int end,
String ds_name) {
super(track);
_range_start = start;
_range_end = end;
try {
getServer(server_name);
getJDASDataSource(server_name, ds_name);
} catch (Exception e) {
e.printStackTrace();
}
}
public void setRange(int start, int end) {
if (end <= start)
throw new IllegalArgumentException(
"Illegal coordinates for DAS range (" + start + ":" + end + ").");
_range_start = start;
_range_end = end;
}
public int getStart() {
return _range_start;
}
public int getEnd() {
return _range_end;
}
protected DataRetrievalUnit createDRU() {
return new DASDRU(features_to_load);
}
public DASServer getServer(String server_name) throws Exception {
if (server == null) {
server = DASServer.getServer(server_name);
}
return server;
}
public void setServer(String server_name) throws Exception {
server = DASServer.getServer(server_name);
}
public org.xmlbio.jdas.datamodel.DataSource getJDASDataSource(
String server_name,
String ds_name)
throws Exception {
getServer(server_name);
if (jdas_ds == null) {
jdas_ds = server.getJDASDataSourceByName(ds_name);
}
return jdas_ds;
}
public void setJDASDataSource(String server_name, String ds_name)
throws Exception {
getServer(server_name);
jdas_ds = server.getJDASDataSourceByName(ds_name);
}
public String[] getDataSourceDescriptions(
String server_name,
Object[] ds_names)
throws Exception {
return getServer(server_name).getJDASDataSourceDescriptions(ds_names);
}
public String getDataSourceDescription() throws Exception {
return jdas_ds.getDescription();
}
public String[] getChromosomeNames() throws Exception {
return server.getChromosomeNames(jdas_ds);
}
public List getFeaturesToLoad(Object[] feature_names, String chrom)
throws Exception {
if (features_list == null) {
getFeatures(chrom);
}
features_to_load = new ArrayList();
for (int i = 0; i < features_list.size(); i++) {
Feature feature = ((Feature) features_list.get(i));
for (int j = 0; j < feature_names.length; j++) {
if (feature_names[j].toString().equals(feature.getType().getName())) {
features_to_load.add(feature);
break;
}
}
}
return features_to_load;
}
private List getFeatures(String chrom_) throws Exception {
if (chrom_ == null || _range_start == 0 || _range_end == 0)
throw new IllegalStateException("DAS Datasource not correctly initialized!");
if (chrom != null && chrom.equals(chrom_) && features_list != null) {
return features_list;
}
chrom = chrom_;
if (server == null)
return null;
try {
FeaturesRequest request =
new FeaturesRequest(server.getBase(), jdas_ds.getId());
SegmentParameter segmentParam =
new SegmentParameter(chrom_, _range_start, _range_end);
request.addSegment(segmentParam);
request.setValidateXMLResponse(false);
FeaturesResponse response = new FeaturesResponse(request);
if (response.getDasStatusCode() != DasResponse.X_DAS_STATUS_OK) {
throw new Exception(
"DAS Status Code Description: "
+ response.getDasStatusCodeDescription());
}
GeneralFeatureFormat gff = response.getGeneralFeatureFormat();
ArrayList segments = gff.getSegments();
for (int i = 0; i < segments.size(); i++) {
Segment segment = (Segment) segments.get(i);
features_list = segment.getFeatures();
}
} catch (DasException e) {
throw new Exception("DasException: " + e.getMessage());
}
return features_list;
}
public Object[] getFeaturesNames(String chrom) throws Exception {
List features = getFeatures(chrom);
if (features == null)
throw new Exception(
"Features are not available for chromosome: "
+ chrom
+ " in range: "
+ _range_start
+ " - "
+ _range_end);
Map features_names = new HashMap();
for (int i = 0; i < features.size(); i++) {
String feature_name = ((Feature) features.get(i)).getType().getName();
features_names.put(feature_name, null);
}
Object[] fn = features_names.keySet().toArray();
Arrays.sort(fn);
return fn;
}
public String getServerName() throws Exception {
if (server == null)
return null;
return server.getName();
}
public String getJDASDataSourceName() throws Exception {
if (server == null)
return null;
return server.getJDASDataSourceName(jdas_ds);
}
public String getSelectedChromosome() throws Exception {
return chrom;
}
public void print() {
System.out.println();
System.out.println("DataSource:");
server.print();
System.out.println(
"\tJDASDataSource: name: "
+ jdas_ds.getName()
+ ", id: "
+ jdas_ds.getId());
System.out.println();
}
public static void printAllDataSources() {
System.out.println();
System.out.println("Data Sources:");
for (Iterator i = _das_ds_map.keySet().iterator(); i.hasNext();) {
String ds_name = (String) i.next();
DASDataSource ds = (DASDataSource) _das_ds_map.get(ds_name);
ds.print();
}
System.out.println();
}
}
package ca.bcgsc.sockeye.dataretrieval;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import org.xmlbio.jdas.datamodel.Segment;
import org.xmlbio.jdas.request.DsnRequest;
import org.xmlbio.jdas.request.EntryPointsRequest;
import org.xmlbio.jdas.response.DasException;
import org.xmlbio.jdas.response.DasResponse;
import org.xmlbio.jdas.response.DsnResponse;
import org.xmlbio.jdas.response.EntryPointsResponse;
import ca.bcgsc.sockeye.config.Connection;
import ca.bcgsc.sockeye.service.featureloader.common.ConnectionManager;
public class DASServer {
private final static String _DS_NAME_SEP = " / ";
private final static String _ATTR_CHROMOSOMES = "chromosomes";
private final static String _ATTR_SPECIES = "species";
static private Map _servers = new HashMap();
private String name;
private String base;
private Map jdas_ds_map;
public DASServer() {
}
public String getPreselectedJDASDataSourceName(String species) {
if (species == null)
return null;
if (jdas_ds_map == null) {
try {
jdas_ds_map = getJDASDataSources();
} catch (Exception e) {
return null;
}
}
if (jdas_ds_map != null) {
for (Iterator i = jdas_ds_map.keySet().iterator(); i.hasNext();) {
org.xmlbio.jdas.datamodel.DataSource jdas_ds =
(org.xmlbio.jdas.datamodel.DataSource) i.next();
String def_sp =
DASConstants.defineSpeciesByDescription(jdas_ds.getDescription());
if (def_sp != null)
if (def_sp.equals(species))
return jdas_ds.getName() + _DS_NAME_SEP + jdas_ds.getId();
}
}
return null;
}
public Object[] getJDASDataSourceNames() throws Exception {
if (jdas_ds_map == null)
getJDASDataSources();
if (jdas_ds_map != null) {
List ds_names_list = new ArrayList();
for (Iterator i = jdas_ds_map.keySet().iterator(); i.hasNext();) {
org.xmlbio.jdas.datamodel.DataSource jdas_ds =
(org.xmlbio.jdas.datamodel.DataSource) i.next();
ds_names_list.add(getJDASDataSourceName(jdas_ds));
}
Object[] ds_names = ds_names_list.toArray();
Arrays.sort(ds_names);
return ds_names;
}
return null;
}
public String getJDASDataSourceName(
org.xmlbio.jdas.datamodel.DataSource jdas_ds)
throws Exception {
return jdas_ds.getName() + _DS_NAME_SEP + jdas_ds.getId();
}
public String[] getJDASDataSourceDescriptions(Object[] ds_names)
throws Exception {
String[] ds_desc = new String[ds_names.length];
for (int i = 0; i < ds_names.length; i++) {
ds_desc[i] =
getJDASDataSourceByName(ds_names[i].toString()).getDescription();
}
return ds_desc;
}
public DASServer(String name_, String base_) {
name = name_;
base = base_;
}
public void setName(String name_) {
name = name_;
}
public String getName() {
return name;
}
public void setBase(String base_) {
base = base_;
}
public String getBase() {
return base;
}
public Map getJDASDataSources() throws Exception {
if (jdas_ds_map == null) {
jdas_ds_map = new HashMap();
try {
DsnRequest dsnRequest = new DsnRequest(base);
dsnRequest.setValidateXMLResponse(false);
DsnResponse dsnResponse = new DsnResponse(dsnRequest);
if (dsnResponse.getDasStatusCode() != DasResponse.X_DAS_STATUS_OK) {
throw new Exception(
"DAS Status Code Description: "
+ dsnResponse.getDasStatusCodeDescription());
}
List temp_ds_list = dsnResponse.getDataSources();
for (int i = 0; i < temp_ds_list.size(); i++) {
jdas_ds_map.put(
(org.xmlbio.jdas.datamodel.DataSource) temp_ds_list.get(i),
null);
}
} catch (Exception e) {
jdas_ds_map = null;
}
}
return jdas_ds_map;
}
public org.xmlbio.jdas.datamodel.DataSource getJDASDataSourceByName(
String ds_name)
throws Exception {
String[] name = ds_name.split(_DS_NAME_SEP);
if (jdas_ds_map == null) {
try {
jdas_ds_map = getJDASDataSources();
} catch (Exception e) {
return null;
}
}
if (jdas_ds_map != null) {
for (Iterator i = jdas_ds_map.keySet().iterator(); i.hasNext();) {
org.xmlbio.jdas.datamodel.DataSource jdas_ds =
(org.xmlbio.jdas.datamodel.DataSource) i.next();
if (jdas_ds.getName().equals(name[0])
&& jdas_ds.getId().equals(name[1])) {
return jdas_ds;
}
}
}
return null;
}
static public DASServer getServer(String server_name) throws Exception {
if (_servers.containsKey(server_name)) {
try {
return (DASServer) _servers.get(server_name);
} catch (Exception e) {
throw new Exception(
"Connection to server: " + server_name + " is failed");
}
} else {
List sources =
ConnectionManager.getConnectionList(DASDataSource.__DAS_TYPE);
for (int i = 0; i < sources.size(); i++) {
Connection source = (Connection) sources.get(i);
if (source.getName().equals(server_name.split(_DS_NAME_SEP)[0])) {
DASServer server = new DASServer(source.getName(), source.getHost());
_servers.put(server.getName(), server);
return server;
}
}
throw new Exception(
"Connection to server: " + server_name + " is failed");
}
}
public List getSegments(org.xmlbio.jdas.datamodel.DataSource jdas_ds)
throws Exception {
List segments = new ArrayList();
try {
String map = jdas_ds.getMapMaster();
if (map != null) {
String[] map_arr = map.split("/das/");
if (map_arr != null && map_arr.length == 2) {
EntryPointsRequest request =
new EntryPointsRequest(map_arr[0], map_arr[1].replaceAll("/", ""));
request.setValidateXMLResponse(false);
EntryPointsResponse response = new EntryPointsResponse(request);
if (response.getDasStatusCode() != DasResponse.X_DAS_STATUS_OK) {
return null;
}
return response.getEntryPoints().getSegments();
}
}
} catch (DasException e) {
System.out.println("DasException: " + e.getMessage());
}
return segments;
}
public String[] getChromosomeNames(
org.xmlbio.jdas.datamodel.DataSource jdas_ds)
throws Exception {
String[] chromosomes;
Object obj_chromosomes =
getJDASDataSourceAttribute(_ATTR_CHROMOSOMES, jdas_ds);
if (obj_chromosomes != null)
return (String[]) obj_chromosomes;
else {
List segments = getSegments(jdas_ds);
if (segments == null) {
return null;
} else {
chromosomes = new String[segments.size()];
for (int i = 0; i < segments.size(); i++) {
String chrom_name = ((Segment) segments.get(i)).getId();
chromosomes[i] = ((Segment) segments.get(i)).getId();
}
}
}
Arrays.sort(chromosomes);
if (chromosomes == null || chromosomes.length == 0) {
Object obj_species = getJDASDataSourceAttribute(_ATTR_SPECIES, jdas_ds);
if (obj_species == null) {
obj_species =
DASConstants.defineSpeciesByDescription(jdas_ds.getDescription());
addAttributeToJDASDataSource(_ATTR_SPECIES, obj_species, jdas_ds);
}
if (obj_species != null)
chromosomes =
DASConstants.getDefaultChromosomeNamesBySpecies(
obj_species.toString());
}
addAttributeToJDASDataSource(_ATTR_CHROMOSOMES, chromosomes, jdas_ds);
return chromosomes;
}
private void addAttributeToJDASDataSource(
String attr,
Object value,
org.xmlbio.jdas.datamodel.DataSource jdas_ds) {
Object obj = jdas_ds_map.get(jdas_ds);
Map m;
if (obj == null)
m = new HashMap();
else
m = (Map) obj;
m.put(attr, value);
jdas_ds_map.put(jdas_ds, m);
}
private Object getJDASDataSourceAttribute(
String attr,
org.xmlbio.jdas.datamodel.DataSource jdas_ds) {
Object obj = jdas_ds_map.get(jdas_ds);
if (obj == null)
return null;
return ((Map) obj).get(attr);
}
public void print() {
System.out.println();
System.out.println("Server: " + name + ", url: " + base);
System.out.println("\tJDASDataSources:");
for (Iterator i = jdas_ds_map.keySet().iterator(); i.hasNext();) {
org.xmlbio.jdas.datamodel.DataSource jdas_ds =
(org.xmlbio.jdas.datamodel.DataSource) i.next();
System.out.println(
"\t\tJDASDataSource: name: "
+ jdas_ds.getName()
+ ", id: "
+ jdas_ds.getId());
System.out.println(
"\t\t\tChromosomes: "
+ getJDASDataSourceAttribute(_ATTR_CHROMOSOMES, jdas_ds));
System.out.println(
"\t\t\tSpecies: " + getJDASDataSourceAttribute(_ATTR_SPECIES, jdas_ds));
System.out.println();
}
}
public static void printAllServers() {
System.out.println();
System.out.println("Servers:");
for (Iterator i = _servers.keySet().iterator(); i.hasNext();) {
String server_name = (String) i.next();
DASServer server = (DASServer) _servers.get(server_name);
server.print();
}
System.out.println();
}
}/*------
package ca.bcgsc.sockeye.dataretrieval;
import java.util.List;
public class DataRequest {
private final int _request_sequence_id;
private final int _track_id;
private final int _data_start;
private final int _data_end;
private final List _features;
private final int _data_source_id;
private boolean _is_active;
protected static int _nextSequenceNumber = 0;
public DataRequest(int t_id, int ds_id, int start, int end, List features) {
_request_sequence_id = _nextSequenceNumber++;
_track_id = t_id;
_data_source_id = ds_id;
_data_start = start;
_data_end = end;
_features = features;
_is_active = true;
}
public void setActive(boolean b){
_is_active = b;
}
public boolean isActive(){
return _is_active;
}
public int getId(){
return _request_sequence_id;
}
public int getTrackId(){
return _track_id;
}
public int getStart(){
return _data_start;
}
public int getEnd(){
return _data_end;
}
public List getFeatures(){
return _features;
}
public int getSourceId(){
return _data_source_id;
}
public String toString() {
return "DATA_REQUEST: REQID: " + _request_sequence_id + " TRACK: " + _track_id +
" START: " + _data_start + " END: " + _data_end + " DATASRC: " + _data_source_id +
" ACTIVE: " + _is_active + " FEATURES: " + _features;
}
}
package ca.bcgsc.sockeye.dataretrieval;
import ca.bcgsc.sockeye.datastorage.DataStorageManager;
abstract public class DataRetrievalUnit extends Thread {
protected DataStorageManager _my_storage_manager = null;
protected DataSourceManager _my_data_source_manager = null;
protected DataRequest _request_to_process = null;
protected Integer _parent_datasource_id = null;
public DataRetrievalUnit() {
}
public void setParentDataSourceID(int id){
_parent_datasource_id = new Integer(id);
}
public void setRequest(DataRequest dr){
_request_to_process = dr;
}
public void registerStorageManager(DataStorageManager dsm){
_my_storage_manager = dsm;
}
public void registerSourceManager(DataSourceManager dsm){
_my_data_source_manager = dsm;
}
abstract protected void retrieveData();
abstract protected void deliverData();
public void run(){
if (_my_storage_manager == null)
throw new IllegalStateException("DRU with unknown storage manager started!");
if (_my_data_source_manager == null)
throw new IllegalStateException("DRU with unknown source manager started!");
if (_request_to_process == null)
throw new IllegalStateException("DRU with unknown request started!");
try{
retrieveData();
_my_data_source_manager.waitForRequestNotBlocked(_request_to_process);
if (_request_to_process.isActive() && _my_storage_manager.hasTrack(_request_to_process.getTrackId()))
deliverData();
}
catch(Throwable t){
System.out.println ("Exception while retrieving data: ");
t.printStackTrace();
}
finally{
_my_data_source_manager.removeActiveRequest(_request_to_process);
}
}
}
package ca.bcgsc.sockeye.dataretrieval;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.List;
import ca.bcgsc.sockeye.datastorage.DataStorageManager;
import ca.bcgsc.sockeye.datastorage.SockeyeTrackList;
import ca.bcgsc.sockeye.datastorage.events.StorageEvent;
import ca.bcgsc.sockeye.datastorage.events.StorageEventListener;
import ca.bcgsc.sockeye.util.Log;
abstract public class DataSource implements StorageEventListener {
DataStorageManager _my_storage_manager = null;
DataSourceManager _my_source_manager = null;
protected int _my_track;
protected int _my_id;
protected static int _next_datasource_id = 0;
protected boolean dead = false;
protected boolean _single_shot = false;
public DataSource() {
}
public DataSource(int track) {
_my_id = _next_datasource_id++;
_my_track = track;
}
public String getDatabase() {
return null;
}
public String getSpecies(){
return null;
}
public String getChromosome(){
return null;
}
public int getId(){
return _my_id;
}
public int getTrack(){
return _my_track;
}
public void reset(){
}
public String getDisplayString(){
return "Unknown data source";
}
public static final DataSource getInstanceFromString(int id, String s){
String classname = s.split(";")[0];
DataSource ds=null;
Class newDS;
Method get_instance_method;
Class[] parameterType =
new Class[]{ Integer.TYPE, String.class };
Object[] argument =
new Object[]{ new Integer(id), s};
try{
newDS = Class.forName(classname);
get_instance_method = newDS.getMethod("instanceFromString",parameterType);
ds = (DataSource)get_instance_method.invoke(null, argument);
}
catch (ClassNotFoundException e){
Log.printStackTrace(e);
e.printStackTrace();
}
catch(NoSuchMethodException e){
Log.printStackTrace(e);
e.printStackTrace();
}
catch(InvocationTargetException e){
Log.printStackTrace(e);
e.printStackTrace();
}
catch (IllegalAccessException e){
Log.printStackTrace(e);
e.printStackTrace();
}
return ds;
}
public void registerSourceManager (DataSourceManager dsm){
_my_source_manager = dsm;
}
public void registerStorageManager (DataStorageManager dsm){
_my_storage_manager = dsm;
}
public void storageEventReceived(StorageEvent e) {
if (e.getEventType() == StorageEvent.STORAGE_EVENT_TRACK_REMOVE){
List deleted_tracks = (List)e.getAttribute();
if (deleted_tracks.contains(new Integer(_my_track))){
System.out.println("Data Source (" + _my_id +
"): My track has been deleted, my life has no meaning: bye bye");
((SockeyeTrackList)_my_storage_manager).removeStorageListener(this);
_my_source_manager.removeDataSource(_my_id);
return;
}
}
if (e.getEventType() != StorageEvent.STORAGE_EVENT_TRACK_DATA_REQUEST){
return;
}
List eventAttrib = (List)e.getAttribute();
int t_id = Integer.parseInt(eventAttrib.get(0).toString());
int start = Integer.parseInt(eventAttrib.get(1).toString());
int end = Integer.parseInt(eventAttrib.get(2).toString());
List features = eventAttrib.subList(3,eventAttrib.size());
if (t_id != _my_track){
return;
}
if (eventAttrib.isEmpty()){
return;
}
DataRequest dr = new DataRequest(t_id, _my_id, start, end, features);
processRequest (dr);
}
protected void processRequest (DataRequest drq){
if (dead){
System.out.println("Single shot DS " + _my_id + " ignored request because it's dead");
return;
}
if (_single_shot)
dead = true;
_my_source_manager.addActiveRequest(drq);
DataRetrievalUnit dru = createDRU();
dru.registerSourceManager(_my_source_manager);
dru.registerStorageManager(_my_storage_manager);
dru.setParentDataSourceID(_my_id);
dru.setRequest(drq);
dru.start();
}
static DataSource instanceFromString(int id, String s){
return null;
}
abstract protected DataRetrievalUnit createDRU();
public boolean isDead() {
return dead;
}
public void setDead(boolean dead) {
this.dead= dead;
}
public void setSingleShot(boolean ss){
_single_shot = true;
}
public boolean isSingleShot(){
return _single_shot ;
}
}
package ca.bcgsc.sockeye.dataretrieval;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import ca.bcgsc.sockeye.config.Connection;
import ca.bcgsc.sockeye.datastorage.DataStorageManager;
import ca.bcgsc.sockeye.datastorage.SockeyeTrackList;
public class DataSourceManager {
protected List _data_sources;
protected List _single_shot_data_sources;
transient protected List _active_data_requests;
protected DataStorageManager _default_storage_manager;
public DataSourceManager() {
_data_sources = new ArrayList();
_active_data_requests = new ArrayList();
_single_shot_data_sources = new ArrayList();
}
public DataSourceManager(DataStorageManager mgr) {
_data_sources = new ArrayList();
_active_data_requests = new ArrayList();
_single_shot_data_sources = new ArrayList();
_default_storage_manager = mgr;
}
public void registerDefaultStorageManager(DataStorageManager dsm) {
_default_storage_manager = dsm;
}
public DataSource getDataSource(int id) {
Iterator it = _data_sources.iterator();
while (it.hasNext()) {
DataSource ds = (DataSource) it.next();
if (ds.getId() == id)
return ds;
}
return null;
}
public synchronized int addDataSource(DataSource ds) {
System.out.println("addDataSource");
ds.registerSourceManager(this);
if (_default_storage_manager != null)
ds.registerStorageManager(_default_storage_manager);
_data_sources.add(ds);
return ds.getId();
}
public void resetAllDataSources() {
Iterator it = _data_sources.iterator();
while (it.hasNext()) {
DataSource ds = (DataSource) it.next();
ds.reset();
}
}
public void setSingleShotSource(int ds_id, boolean v) {
if (v)
_single_shot_data_sources.add(new Integer(ds_id));
else
_single_shot_data_sources.remove(new Integer(ds_id));
getDataSource(ds_id).setSingleShot(v);
}
public boolean isSingleShotSource(int ds_id) {
return _single_shot_data_sources.contains(new Integer(ds_id));
}
public synchronized void killActiveRequest(DataRequest dr) {
dr.setActive(false);
removeActiveRequest(dr);
}
public synchronized void addActiveRequest(DataRequest q) {
notifyAll();
_active_data_requests.add(q);
}
public synchronized boolean removeActiveRequest(DataRequest q) {
if (_active_data_requests.remove(q)) {
notifyAll();
if (_single_shot_data_sources.contains(new Integer(q.getSourceId())))
getDataSource(q.getSourceId()).setDead(true);
return true;
}
return false;
}
public synchronized boolean isRequestBlocked(DataRequest q) {
Iterator it = _active_data_requests.iterator();
while (it.hasNext()) {
DataRequest storedRequest = (DataRequest) it.next();
if (storedRequest.getId() == q.getId()) {
return false;
}
if (storedRequest.getTrackId() != q.getTrackId())
continue;
if (storedRequest.getStart() <= q.getStart()
&& q.getStart() <= storedRequest.getEnd()) {
return hasCommonFeature(q, storedRequest);
}
if (storedRequest.getStart() <= q.getEnd()
&& q.getEnd() <= storedRequest.getEnd()) {
return hasCommonFeature(q, storedRequest);
}
if (q.getStart() < storedRequest.getStart()
&& storedRequest.getEnd() < q.getEnd()) {
return hasCommonFeature(q, storedRequest);
}
}
return false;
}
public synchronized void waitForActiveRequestChange() {
try {
wait();
} catch (InterruptedException e) {
}
}
public synchronized int waitForActiveRequestChange(int lastvalue) {
try {
if (lastvalue != _active_data_requests.size())
return _active_data_requests.size();
wait();
} catch (InterruptedException e) {
}
return _active_data_requests.size();
}
public synchronized void waitForRequestNotBlocked(DataRequest q) {
while (isRequestBlocked(q)) {
try {
wait();
} catch (InterruptedException e) {
}
}
}
public boolean removeDataSource(int id) {
for (int i = 0; i < _data_sources.size(); i++)
if (((DataSource) _data_sources.get(i)).getId() == id) {
DataSource ds = (DataSource) _data_sources.remove(i);
((SockeyeTrackList) _default_storage_manager).removeStorageListener(ds);
return true;
}
return false;
}
public synchronized int countActiveRequests() {
return _active_data_requests.size();
}
public synchronized List getActiveRequests() {
return new ArrayList(_active_data_requests);
}
public List getTrackDatabases(int t_id) {
List ds_list = _default_storage_manager.getDataSources(t_id);
if (ds_list == null || ds_list.size() == 0)
return new ArrayList();
Iterator ds_it = ds_list.iterator();
List dbList = new ArrayList();
String db = null;
while (ds_it.hasNext()) {
DataSource ds = getDataSource(Integer.parseInt(ds_it.next().toString()));
if (ds == null)
continue;
db = ds.getDatabase();
if (db != null)
dbList.add(db);
}
return dbList;
}
public List getTrackSpecies(int t_id) {
List ds_list = _default_storage_manager.getDataSources(t_id);
Iterator ds_it = ds_list.iterator();
List speciesList = new ArrayList();
String species = null;
while (ds_it.hasNext()) {
DataSource ds = getDataSource(Integer.parseInt(ds_it.next().toString()));
if (ds == null)
continue;
species = ds.getSpecies();
if (species != null)
speciesList.add(species);
}
return speciesList;
}
public Connection getTrackEnsemblConnection(int t_id){
List ds_list = _default_storage_manager.getDataSources(t_id);
Iterator ds_it = ds_list.iterator();
while (ds_it.hasNext()) {
DataSource ds = getDataSource(Integer.parseInt(ds_it.next().toString()));
if (ds == null)
continue;
if (ds instanceof EnsemblDataSource)
return ((EnsemblDataSource)ds).getConnection();
}
return null;
}
public List getTrackChromosomes(int t_id) {
List ds_list = _default_storage_manager.getDataSources(t_id);
Iterator ds_it = ds_list.iterator();
List chList = new ArrayList();
String ch = null;
while (ds_it.hasNext()) {
DataSource ds = getDataSource(Integer.parseInt(ds_it.next().toString()));
if (ds == null)
continue;
ch = ds.getChromosome();
if (ch != null)
chList.add(ch);
}
return chList;
}
private boolean hasCommonFeature(DataRequest q1, DataRequest q2) {
Iterator feat = q1.getFeatures().iterator();
boolean has_common_feature = false;
while (feat.hasNext())
if (q2.getFeatures().contains(feat.next().toString())) {
has_common_feature = true;
break;
}
return has_common_feature;
}
public void addSerializedDataSources(
List data_sources,
boolean has_track_feature,
int t_id) {
for (int i = 0; i < data_sources.size(); i++) {
String ds = (String) data_sources.get(i);
DataSource data_source = DataSource.getInstanceFromString(t_id, ds);
if (data_source instanceof EnsemblDataSource && !has_track_feature)
continue;
((SockeyeTrackList) _default_storage_manager).addStorageListener(
data_source);
int new_ds_id = addDataSource(data_source);
((SockeyeTrackList) _default_storage_manager).addDataSourceId(
t_id,
new_ds_id);
}
}
}
package ca.bcgsc.sockeye.dataretrieval;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import ca.bcgsc.chinook.server.comobj.SerializableSimpleGFFRecord;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.config.Connection;
import ca.bcgsc.sockeye.config.Service;
import ca.bcgsc.sockeye.datastorage.TrackDistribution;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.service.featureloader.common.ConnectionManager;
import ca.bcgsc.sockeye.service.featureloader.common.DistributionContainer;
import ca.bcgsc.sockeye.service.featureloader.common.FeatureLoaderResult;
import ca.bcgsc.sockeye.service.featureloader.common.FeatureLoaderService;
import ca.bcgsc.sockeye.service.featureloader.common.FeatureLoaderServiceFactory;
import ca.bcgsc.sockeye.util.Log;
public class EnsemblDRU extends DataRetrievalUnit {
protected String _database;
protected int _query_start;
protected int _query_end;
protected int _track_id;
protected String _chromosome;
protected String _species;
protected SemanticZoomManager _szmgr;
protected Map deliverFeatures = new HashMap();
protected List _delete_features_before_delivery;
protected List _repeat_list;
private Connection connection;
public EnsemblDRU(
String database,
String chromosome,
Connection con,
SemanticZoomManager szmgr) {
_database = database;
_chromosome = chromosome;
_szmgr = szmgr;
if (database == null || database.length() == 0)
throw new IllegalArgumentException("Empty or null database value when creating ensembl DRU!");
if (chromosome == null || chromosome.length() == 0)
throw new IllegalArgumentException("Empty or null chromosome value when creating ensembl DRU!");
if (szmgr == null)
throw new IllegalArgumentException("Illegal sz-mgr value (null) when creating ensembl DRU!");
if (con == null)
connection =
ConnectionManager.getCurrentConnection("Ensembl");
else
connection = con;
_szmgr.setConnectionParameter(
connection.getHost(),
connection.getUser(),
connection.getPass());
_szmgr.setDatabase(_database);
String standard_db_name =
"([a-zA-Z]+)_([a-zA-Z]+)_([a-zA-Z])_([0-9]+)_([0-9]+)";
String standard_species_name = "([a-zA-Z]+)_([a-zA-Z]+)";
Pattern p1 = Pattern.compile(standard_db_name);
Matcher m1 = p1.matcher(database);
Pattern p2 = Pattern.compile(standard_db_name);
Matcher m2 = p2.matcher(database);
if (!m1.matches()) {
_species =
ConnectionManager.convertEnsemblDatabaseNameToSpeciesName(
database);
} else
if (!m2.matches()) {
_species = database;
} else {
_species = "unknown";
System.out.println("Wrong database/species name: " + database);
Log.println("Wrong database/species name: " + database);
}
}
protected void retrieveData() {
ArrayList warning_types = new ArrayList();
if (_request_to_process.getFeatures().isEmpty()) {
return;
}
_query_start = _request_to_process.getStart();
_query_end = _request_to_process.getEnd();
_track_id = _request_to_process.getTrackId();
_szmgr.setBasePairRange(_chromosome, _query_start, _query_end);
List featureListNonSZ = new ArrayList();
List featureListSZ = new ArrayList();
separateFeatureList(_request_to_process.getFeatures(), featureListNonSZ, featureListSZ);
FeatureLoaderServiceFactory fac = FeatureLoaderServiceFactory.getInstance();
Service service =
Configuration.getService(FeatureLoaderServiceFactory.FEATURELOADER_SERVICES);
String mode = null;
String remotehost = null;
if (service != null) {
mode = service.getMode();
remotehost = service.getRemotehost();
} else {
throw new RuntimeException("Feature loader service not set up properly.");
}
FeatureLoaderService ser = fac.getService(mode, remotehost);
if(!featureListNonSZ.isEmpty()) {
FeatureLoaderResult result = ser.getFeatures(
connection,
_database, _species, _chromosome, _query_start, _query_end,
featureListNonSZ);
warning_types.addAll(result.getWarningFeatureTypes());
addFeatures(result.getFeatures());
}
if (!warning_types.isEmpty()) {
System.out.println(
"The following features are not available: " + warning_types);
}
}
private void addFeatures(Map map) {
Iterator it = map.keySet().iterator();
while(it.hasNext()){
String featureType = (String) it.next();
List gffs = (List) map.get(featureType);
if (gffs == null) {
continue;
}
Iterator it2 = gffs.iterator();
List tfs = new ArrayList();
while(it2.hasNext()) {
SerializableSimpleGFFRecord gff = (SerializableSimpleGFFRecord)it2.next();
TrackFeature tf = new TrackFeature(gff, 0);
tf.setTrackId(_track_id);
tfs.add(tf);
}
deliverFeatures.put(featureType, tfs);
}
}
static private boolean isRepeatIncluded(List featureTypes) {
boolean query_repeats = false;
for (Iterator it = featureTypes.iterator(); it.hasNext();) {
Object obj = it.next();
if(!(obj instanceof String)){
continue;
}
if (Configuration.getAllRepeatNames().contains((String) obj)) {
query_repeats = true;
break;
}
}
return query_repeats;
}
private void separateFeatureList(List list, List featureListNonSZ, List featureListSZ) {
Iterator it = list.iterator();
while(it.hasNext()) {
featureListNonSZ.add(it.next());
}
if (list.contains("gene") && getSZDistribution("gene")
|| (list.contains("exon") && getSZDistribution("exon"))) {
featureListSZ.add("gene");
featureListNonSZ.remove("gene");
featureListNonSZ.remove("exon");
featureListNonSZ.remove("3'UTR");
featureListNonSZ.remove("5'UTR");
featureListNonSZ.remove("multitranscript");
}
if (list.contains("exon") && getSZDistribution("exon")) {
featureListSZ.add("exon");
featureListNonSZ.remove("gene");
featureListNonSZ.remove("exon");
featureListNonSZ.remove("3'UTR");
featureListNonSZ.remove("5'UTR");
featureListNonSZ.remove("multitranscript");
}
if (list.contains("SNP") && getSZDistribution("SNP")) {
featureListSZ.add("SNP");
featureListNonSZ.remove("SNP");
}
if (isRepeatIncluded(list) && getSZDistribution("repeat")) {
featureListSZ.add("repeat");
featureListNonSZ.remove("repeat");
}
}
protected void deliverData() {
if (_delete_features_before_delivery != null) {
_my_storage_manager.removeFeature(
_track_id,
_delete_features_before_delivery);
}
Set keyset = deliverFeatures.keySet();
Iterator df = keyset.iterator();
while (df.hasNext()) {
String feature_name = df.next().toString();
_my_storage_manager.addFeatures(
_track_id,
feature_name,
(List)deliverFeatures.get(feature_name));
}
}
protected boolean getSZDistribution(String feature) {
if (_szmgr.checkSZRulesGlobal(feature)) {
System.out.println("TRACK DEBUG: Doing SZ for " + feature + "...");
if (feature.equals("gene"))
_my_storage_manager.removeFeature(_track_id, "multitranscript");
if (_szmgr.getSZBehaviorForFeature(feature)
== SemanticZoomManager.SZ_BEHAVIOR_HIST) {
if (this
.translateDistributionToTrackFeature(
feature,
_szmgr.getFeatureDistribution(feature))) {
return true;
}
} else {
_my_storage_manager.setFeatureVisibility(feature, false);
return true;
}
System.out.println(
"Couldn't do Semantic Zooming for "
+ feature
+ ", loading single features instead....");
}
return false;
}
protected boolean translateDistributionToTrackFeature(
String feature,
Map distribution) {
List features_returned = new ArrayList();
deliverFeatures.put(feature, features_returned);
if (distribution == null || feature.length() == 0) {
return false;
}
List bins = new ArrayList(distribution.keySet());
Iterator it = bins.iterator();
ArrayList distContainerList = new ArrayList();
while (it.hasNext()) {
Integer bin = new Integer(it.next().toString());
int start = bin.intValue();
int end = start + _szmgr.getCurrentBinSize();
int score = Integer.parseInt(distribution.get(bin).toString());
distContainerList.add(new DistributionContainer(start, end, score));
}
String accId = feature;
TrackDistribution t =
new TrackDistribution(distContainerList, this._track_id, accId);
t.setTrackId(this._track_id);
t.setFeature(feature);
t.setAttribute(
"display_string",
"Distribution for feature: " + feature);
features_returned.add(t);
return true;
}
protected void deleteFeaturesBeforeDelivery(List features) {
if (features != null)
_delete_features_before_delivery = new ArrayList(features);
}
}
package ca.bcgsc.sockeye.dataretrieval;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.StringTokenizer;
import ca.bcgsc.sockeye.config.Connection;
import ca.bcgsc.sockeye.datastorage.DataStorageManager;
import ca.bcgsc.sockeye.datastorage.StorageException;
import ca.bcgsc.sockeye.datastorage.events.StorageEvent;
import ca.bcgsc.sockeye.service.featureloader.common.ConnectionManager;
public class EnsemblDataSource
extends DataSource {
protected String _database;
protected String _chromosome;
protected String _species;
protected int _longest_track_length;
protected int _shortest_track_length;
protected SemanticZoomManager _szmgr;
protected List _delete_before_delivery;
protected int _track_data_start;
protected int _track_data_end;
protected Connection _my_connection;
public EnsemblDataSource() {
super();
_szmgr = new SemanticZoomManager();
}
public EnsemblDataSource(int track, String db, String chromosome) {
super(track);
if (db == null || db.length() == 0)
throw new IllegalArgumentException("Empty or null database value when creating ensembl datasource!");
if (chromosome == null || chromosome.length() == 0)
throw new IllegalArgumentException("Empty or null chromosome value when creating ensembl datasource!");
_database = db;
_species = ConnectionManager.convertEnsemblDatabaseNameToSpeciesName(_database);
_chromosome = chromosome;
_szmgr = new SemanticZoomManager();
}
public String getDatabase() {
return _database;
}
public String getVersion() {
StringTokenizer st = new StringTokenizer(_database, "_");
st.nextToken();
st.nextToken();
st.nextToken();
String version = st.nextToken() + "_" + st.nextToken();
return version;
}
public String getSpecies() {
return _species;
}
public String getChromosome() {
return _chromosome;
}
public int getSZBinLength(){
return _szmgr.getCurrentBinSize();
}
public String toString(){
return this.getClass().getName() + ";" + _database + ";" + _chromosome;
}
public static DataSource instanceFromString(int id, String s){
String[] fields = s.split(";") ;
if (fields.length < 3)
throw new IllegalArgumentException("Illegal number of fields in EnsemblDataSource.getInstanceFromString()");
String database = fields[1];
String chromosome = fields[2];
return new EnsemblDataSource(id, database, chromosome);
}
public String getDisplayString(){
String host = _my_connection == null? "ENSEMBL " : "ENSEMBL["+ _my_connection.getName() + "] ";
return host + _species + "(" + getVersion() + ") Chr. " + _chromosome;
}
public void setSZBinLength(int new_size, boolean cropTrackLength){
if (cropTrackLength){
_track_data_start = _my_storage_manager.getTrackDataWindowStart(_my_track);
_track_data_end = _my_storage_manager.getTrackDataWindowEnd(_my_track);
_szmgr.setBasePairRange(this._chromosome, _track_data_start, _track_data_end);
}
_szmgr.setHistogramBinLength(new_size);
_delete_before_delivery = _szmgr.getFeaturesPresentAsDistribution();
if (_delete_before_delivery == null || _delete_before_delivery.isEmpty())
return;
List event_attrib_query = new ArrayList();
event_attrib_query.add(new Integer(_my_track));
event_attrib_query.add(new Integer(_track_data_start));
event_attrib_query.add(new Integer(_track_data_end));
event_attrib_query.addAll(_delete_before_delivery);
StorageEvent evt = new StorageEvent(this, StorageEvent.STORAGE_EVENT_TRACK_DATA_REQUEST, event_attrib_query);
super.storageEventReceived(evt);
_delete_before_delivery.clear();
}
protected DataRetrievalUnit createDRU() {
EnsemblDRU dru = new EnsemblDRU(_database, _chromosome, this._my_connection, _szmgr);
dru.deleteFeaturesBeforeDelivery(_delete_before_delivery);
return dru;
}
public void reset(){
_delete_before_delivery = _szmgr.activateNewParameterSettings();
if (_delete_before_delivery.size() == 0)
return;
Collection allFeatures = _my_storage_manager.getFeatureNames(_my_track);
_delete_before_delivery.retainAll(allFeatures);
List event_attrib_query = new ArrayList();
event_attrib_query.add(new Integer(_my_track));
event_attrib_query.add(new Integer(_track_data_start));
event_attrib_query.add(new Integer(_track_data_end));
event_attrib_query.addAll(_delete_before_delivery);
StorageEvent evt = new StorageEvent(this, StorageEvent.STORAGE_EVENT_TRACK_DATA_REQUEST, event_attrib_query);
super.storageEventReceived(evt);
_delete_before_delivery.clear();
}
public void registerStorageManager(DataStorageManager dsm) {
super.registerStorageManager(dsm);
System.out.println("registerStorageManager");
_track_data_start = dsm.getTrackDataWindowStart(_my_track);
_track_data_end = dsm.getTrackDataWindowEnd(_my_track);
updateMinMaxTrackLength();
_szmgr.setGlobalControlValue(_longest_track_length, 50);
_szmgr.setBasePairRange(_chromosome, _track_data_start, _track_data_end);
if ( (_track_data_end - _track_data_start + 1) >= _longest_track_length){
_szmgr.setBinSizeLongestTrack(_szmgr.getCurrentBinSize());
}
if ( (_track_data_end - _track_data_start + 1) <= _shortest_track_length){
_szmgr.setBinSizeShortestTrack(_szmgr.getCurrentBinSize());
}
}
public void storageEventReceived(StorageEvent e) {
switch (e.getEventType()){
case StorageEvent.STORAGE_EVENT_TRACK_ADD:
case StorageEvent.STORAGE_EVENT_TRACK_REMOVE:
case StorageEvent.STORAGE_EVENT_TRACK_DATA_WINDOW_CHANGED:
case StorageEvent.STORAGE_EVENT_TRACK_VISIBILITY_CHANGED: updateMinMaxTrackLength();
}
if (e.getEventType() == StorageEvent.STORAGE_EVENT_TRACK_DATA_REQUEST){
List eventAttrib = (List)e.getAttribute();
int t_id = Integer.parseInt(eventAttrib.get(0).toString());
if (t_id == _my_track){
int start = Integer.parseInt(eventAttrib.get(1).toString());
int end = Integer.parseInt(eventAttrib.get(2).toString());
_track_data_start = Math.min(_track_data_start, start);
_track_data_end = Math.max(_track_data_end, end);
_szmgr.setBasePairRange(_chromosome, _track_data_start, _track_data_end);
}
}
super.storageEventReceived(e);
if ( _delete_before_delivery != null && !_delete_before_delivery.isEmpty() ) {
Collection allFeatures = _my_storage_manager.getFeatureNames(_my_track);
_delete_before_delivery.retainAll(allFeatures);
List event_attrib_query = new ArrayList();
event_attrib_query.add(new Integer(_my_track));
event_attrib_query.add(new Integer(_track_data_start));
event_attrib_query.add(new Integer(_track_data_end));
event_attrib_query.addAll(_delete_before_delivery);
System.out.println ("WATCH THIS(" + _my_id + ": TRYING TO REQUERY FEATURES: " + event_attrib_query);
StorageEvent evt = new StorageEvent(this, StorageEvent.STORAGE_EVENT_TRACK_DATA_REQUEST, event_attrib_query);
super.storageEventReceived(evt);
_delete_before_delivery.clear();
}
}
private int getTrackIdFromEvent(StorageEvent e) {
if ( ((List) e.getAttribute()).get(0) instanceof Integer)
return (Integer.parseInt( ( (List) e.getAttribute()).get(0).toString()));
else
return -1;
}
private void updateMinMaxTrackLength(){
try{
if (_my_storage_manager==null || !_my_storage_manager.getTrackVisibility(_my_track))
return;
}
catch (StorageException e){return;};
Set s = _my_storage_manager.getAllTrackIds();
int temp_min = Integer.MAX_VALUE;
int temp_max = Integer.MIN_VALUE;
for (Iterator it = s.iterator(); it.hasNext(); ) {
int t_id = Integer.parseInt(it.next().toString());
try{
if (_my_storage_manager.getTrackVisibility(t_id)) {
int length = _my_storage_manager.getTrackDataWindowLength(t_id);
temp_min = Math.min(temp_min, length);
temp_max = Math.max(temp_max, length);
}
}
catch (StorageException e){/*ignore*/};
}
if (temp_min != _shortest_track_length){
_shortest_track_length = temp_min;
}
if (temp_max != _longest_track_length){
_longest_track_length = temp_max;
_delete_before_delivery = _szmgr.setGlobalControlValue(_longest_track_length, 50);
}
}
public Connection getConnection() {
return _my_connection;
}
public void setConnection(Connection my_connection) {
_my_connection= my_connection;
}
}
package ca.bcgsc.sockeye.dataretrieval;
import java.io.File;
import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.biojava.bio.program.gff.GFFTools;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.datastorage.TrackDistribution;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.parser.Parser;
import ca.bcgsc.sockeye.parser.ParserManager;
import ca.bcgsc.sockeye.service.featureloader.common.DistributionContainer;
import ca.bcgsc.sockeye.util.Log;
public class FileDRU extends DataRetrievalUnit {
private int _query_start, _query_end, _track_id, _abs_offset;
boolean _as_distrib;
private String _seq_id;
static int _feature_id = 0;
Parser _parser;
Map deliverFeatures = new HashMap();
public FileDRU(Parser parser, String seq_id, int abs_offset, boolean dist) {
_parser = parser;
_seq_id = seq_id;
_abs_offset = abs_offset;
_as_distrib = dist;
}
protected void retrieveData() {
System.out.println("File DRU: Retrieving data.......");
if (_request_to_process.getFeatures().isEmpty()) {
return;
}
_query_start = _request_to_process.getStart();
_query_end = _request_to_process.getEnd();
_track_id = _request_to_process.getTrackId();
Set all_feature_names = _parser.getFeatureNamesToImport(_seq_id);
if (all_feature_names == null)
all_feature_names = _parser.getFeatureNames(_seq_id);
Iterator it = all_feature_names.iterator();
List generic_scored = new ArrayList();
List generic_unscored = new ArrayList();
double max_score = _parser.getMaxScore(_seq_id);
while (it.hasNext()) {
String feature_name = (String) it.next();
List features = _parser.getFeatures(_seq_id, feature_name);
for (Iterator fit = features.iterator(); fit.hasNext();) {
TrackFeature tf = (TrackFeature) fit.next();
tf.setTrackId(_track_id);
if (_abs_offset != 0) {
tf.setStart(tf.getStart() + _abs_offset);
tf.setEnd(tf.getEnd() + _abs_offset);
}
tf.setAccessionID(String.valueOf(_feature_id++));
}
if (feature_name.equals("track")) {
String sequence =
((TrackFeature) features.get(0)).getAttribute("sequence");
_track_id,
"sequence",
sequence);*/
int start =
Integer.parseInt(
((TrackFeature) features.get(0)).getAttribute("data_start"));
int end =
Integer.parseInt(
((TrackFeature) features.get(0)).getAttribute("data_end"));
TrackFeature seq =
new TrackFeature(
_track_id + "",
_parent_datasource_id == null
? "GFF"
: _parent_datasource_id.toString(),
"sequence",
start,
end,
0,
0,
0);
seq.setAccessionID("sequence");
seq.setAttribute("sequence", sequence);
DataStoreUser.getInstance().getSockeyeTrackList().addFeature(
_track_id,
"sequence",
seq);
}
List features_returned = (List) deliverFeatures.get(feature_name);
if (features_returned == null) {
features_returned = new ArrayList();
} else {
features_returned.addAll(features);
}
if (_as_distrib) {
translateDistributionToTrackFeature(feature_name, features);
} else if (
!Configuration.getAllFeatureDisplay().contains(feature_name)) {
if (areScored(features)) {
generic_scored.addAll(features);
} else {
generic_unscored.addAll(features);
}
} else {
deliverFeatures.put(feature_name, features);
}
}
if (!generic_scored.isEmpty())
deliverFeatures.put("generic_scored", generic_scored);
if (!generic_unscored.isEmpty())
deliverFeatures.put("generic_unscored", generic_unscored);
if (!deliverFeatures.containsKey("sequence")) {
}
}
protected void deliverData() {
System.out.println("File DRU: Delivering data.......");
Set keyset = deliverFeatures.keySet();
Iterator df = keyset.iterator();
while (df.hasNext()) {
String feature_name = df.next().toString();
System.out.println("feature_name = " + feature_name + " (" + ((List)deliverFeatures.get(feature_name)).size() + ")");
_my_storage_manager.addFeatures(
_track_id,
feature_name,
(List) deliverFeatures.get(feature_name));
}
_my_storage_manager.setFeatureVisibility(new ArrayList(keyset), true);
DataStoreUser
.getInstance()
.getDataSourceManager()
.addSerializedDataSources(
(List) _parser.getDataSources(),
_parser.hasTrackFeature(),
_track_id);
System.out.println("File DRU: Delivering data DONE!");
}
protected boolean translateDistributionToTrackFeature(
String feature_name,
List features) {
List features_returned = new ArrayList();
deliverFeatures.put(feature_name, features_returned);
Iterator it = features.iterator();
ArrayList dist_container_list = new ArrayList();
while (it.hasNext()) {
TrackFeature tf = (TrackFeature) it.next();
if( tf.getFeature().equals("track") || tf.getScore() == GFFTools.NO_SCORE ) continue;
dist_container_list.add(
new DistributionContainer(tf.getStart(), tf.getEnd(), tf.getScore()));
}
TrackDistribution t =
new TrackDistribution(
dist_container_list,
this._track_id,
String.valueOf(_feature_id));
t.setAccessionID(String.valueOf(_feature_id++));
t.setTrackId(this._track_id);
t.setAttribute(
"display_string",
"Distribution for feature: " + feature_name);
features_returned.add(t);
return true;
}
public static Parser getParser(File file) {
String file_name = file.getName();
int sep_index = file_name.lastIndexOf(".");
String file_extension = file_name.substring(sep_index + 1);
String parser_class =
ParserManager.getClassNameForAnnotationExtension(file_extension);
Parser parser;
try {
if (parser_class == null) {
throw new Exception("No parser found for file");
}
Class[] parameters = new Class[1];
parameters[0] = File.class;
Constructor con = Class.forName(parser_class).getConstructor(parameters);
Object[] obj = new Object[1];
obj[0] = (Object) file;
parser = (Parser) con.newInstance(obj);
return parser;
} catch (Exception e) {
Log.printStackTrace(e);
return null;
}
}
private static ArrayList buildTrackFeatureArray(
ArrayList features,
int abs_offset,
double max_score,
int track_id) {
ArrayList ret = new ArrayList();
for (int i = 0; i < features.size(); i++) {
TrackFeature tf = (TrackFeature) features.get(i);
tf.setTrackId(track_id);
if (abs_offset != 0) {
tf.setStart(tf.getStart() + abs_offset);
tf.setEnd(tf.getEnd() + abs_offset);
}
double norm_score = tf.getScore() / max_score * 100;
tf.setScore(norm_score);
ret.add(i, tf);
}
return ret;
}
private boolean areScored(List features) {
for (int i = 0; i < features.size(); i++) {
if (((TrackFeature) features.get(i)).getScore() != GFFTools.NO_SCORE)
return true;
}
return false;
}
}
package ca.bcgsc.sockeye.dataretrieval;
import java.util.List;
import ca.bcgsc.sockeye.parser.Parser;
public class FileDataSource extends DataSource {
protected String file_path;
protected int _abs_offset;
protected boolean _as_distrib = false;
private Parser _parser;
private String _seq_id;
transient final public static String __NEW_TRACK = "New track";
public FileDataSource() {
super();
}
public FileDataSource(int track, Parser parser, String seq_id, int abs_offset) {
super(track);
_parser = parser;
_seq_id = seq_id;
_abs_offset = abs_offset;
}
public String getDisplayString() {
return "File: " + _parser.getDisplaySequenceName(_seq_id);
}
public void setLoadAsDistribution(boolean b) {
_as_distrib = b;
}
public boolean getLoadAsDistribution() {
return _as_distrib;
}
protected DataRetrievalUnit createDRU() {
return new FileDRU(_parser, _seq_id, _abs_offset, _as_distrib);
}
public String toString() {
return this.getClass().getName() + ";" + _parser.getDisplaySequenceName(_seq_id);
}
}
package ca.bcgsc.sockeye.dataretrieval;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.swing.JOptionPane;
import org.biojava.bio.program.gff.GFFTools;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.config.Service;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.service.ncc.common.NCCService;
import ca.bcgsc.sockeye.service.ncc.common.NCCServiceException;
import ca.bcgsc.sockeye.service.ncc.common.NCCServiceFactory;
import ca.bcgsc.sockeye.util.Log;
import ca.bcgsc.util.ArrayUtils;
public class NCCDRU extends DataRetrievalUnit {
private NCCDataSource ncc_data_source = null;
private Map deliverFeatures = new HashMap();
private int track_id;
static int _feature_id = 0;
public NCCDRU(NCCDataSource ncc_data_source) {
this.ncc_data_source = ncc_data_source;
}
protected void retrieveData() {
System.out.println( "Retreive data");
List features = _request_to_process.getFeatures();
if (features.isEmpty()) {
return;
}
if (!features.contains(NCCDataSource.NCC_SCORE_FWD)
&& !features.contains(NCCDataSource.NCC_SCORE_REV)) {
return;
}
Service service =
Configuration.getService(
NCCServiceFactory.NCC_SERVICE);
String mode = null;
String remotehost = null;
if (service != null) {
mode = service.getMode();
remotehost = service.getRemotehost();
} else {
System.out.println("ChinookPlusPlus service not set up properly. " +
"No data retreived");
return;
}
NCCService ncc_service =
NCCServiceFactory.getInstance().getService(
mode,
remotehost);
track_id = _request_to_process.getTrackId();
int start = _request_to_process.getStart();
int end = _request_to_process.getEnd();
String seq =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackSequence(track_id, start, end)
.replaceAll("-", "");
int motif_size = ncc_data_source.motif_size;
int window_size = ncc_data_source.window_size;
double threshold = ncc_data_source.threshold;
List databases =
DataStoreUser.getInstance().getDataSourceManager().getTrackDatabases(
track_id);
String database = "";
if (databases.size() > 0)
database = (String) databases.get(0);
String[] part_db = database.split("_");
database = part_db[0] + "_" + part_db[1] + "_ncc";
double[] raw_ncc_scores = null;
try {
raw_ncc_scores = ncc_service.scanNCC(database, seq, motif_size, true);
} catch (NCCServiceException e) {
e.printStackTrace();
Log.printStackTrace(e);
JOptionPane.showMessageDialog(
null,
"No NCC scan is currently available for this species.\n",
"Warning",
JOptionPane.WARNING_MESSAGE);
System.out.println( "NCCDRU: No data retrieved, no NCC service available");
return;
}
double max_score = ArrayUtils.getMax(raw_ncc_scores);
double min_score = ArrayUtils.getMin(raw_ncc_scores);
List motifs_fwd = new ArrayList();
double[] ncc_scores = ArrayUtils.windowScore(raw_ncc_scores, window_size);
for (int i = 0; i < ncc_scores.length; i++) {
double score = ncc_scores[i];
if (!(score < threshold)) {
TrackFeature ncc_score =
new TrackFeature(
"sequence",
_parent_datasource_id == null? "Motif_finder":_parent_datasource_id.toString(),
NCCDataSource.NCC_SCORE_FWD,
start + i,
start + i + motif_size,
(score - threshold) / (max_score - threshold) * 300.,
1,
GFFTools.NO_FRAME);
ncc_score.setAccessionID(
NCCDataSource.NCC_SCORE_FWD + " (" + _feature_id++ +")");
ncc_score.setTrackId(track_id);
ncc_score.setAttribute("threshold", String.valueOf(threshold));
DecimalFormat formatter = new DecimalFormat("##.##");
ncc_score.setAttribute("score", String.valueOf(formatter.format(score)));
motifs_fwd.add(ncc_score);
}
}
deliverFeatures.put(NCCDataSource.NCC_SCORE_FWD, motifs_fwd);
}
protected void deliverData() {
Set keyset = deliverFeatures.keySet();
Iterator df = keyset.iterator();
while (df.hasNext()) {
String feature_name = df.next().toString();
_my_storage_manager.addFeatures(
track_id,
feature_name,
(List) deliverFeatures.get(feature_name));
DataStoreUser.getInstance().getSockeyeTrackList().setFeatureVisibility(
feature_name,
true);
}
System.out.println("NCC DRU: Delivering data DONE!");
}
}
package ca.bcgsc.sockeye.dataretrieval;
import ca.bcgsc.sockeye.dataretrieval.DataRetrievalUnit;
import ca.bcgsc.sockeye.dataretrieval.DataSource;
public class NCCDataSource extends DataSource {
public static final String NCC_SCORE_FWD = "ncc_score_fwd";
public static final String NCC_SCORE_REV = "ncc_score_rev";
public double threshold;
public int window_size, motif_size;
public NCCDataSource(int track, double threshold, int motif_size, int window_size) {
super(track);
this.threshold = threshold;
this.motif_size = motif_size;
this.window_size = window_size;
}
protected DataRetrievalUnit createDRU() {
return new NCCDRU(this);
}
public String getDisplayString() {
return "NCC Scan: ";
}
}
package ca.bcgsc.sockeye.dataretrieval;
import ca.bcgsc.chinook.client.comobj.SequenceCoordinate;
import ca.bcgsc.chinook.client.local.JobQueue;
import ca.bcgsc.chinook.client.local.JobThreader;
import ca.bcgsc.chinook.server.comobj.ApplicationParameter;
import ca.bcgsc.chinook.server.comobj.Report;
import ca.bcgsc.sockeye.dataretrieval.chinook.ChinookDataSourceException;
import ca.bcgsc.sockeye.dataretrieval.chinook.ChinookUser;
import ca.bcgsc.sockeye.dataretrieval.DataRequest;
public class PrimerPredictionRunner {
private static final String PRIMER_PREDICTION = "Primer Prediction";
private ChinookUser cu;
private ApplicationParameter[] params;
private SequenceCoordinate[] scs;
public PrimerPredictionRunner(SequenceCoordinate[] sc, ApplicationParameter[] param) throws Exception {
this.scs = sc;
this.params = param;
try {
this.cu = new ChinookUser();
} catch (ChinookDataSourceException e) {
e.printStackTrace();
throw new Exception();
}
}
public Report run(DataRequest drq) throws RunnerException {
int job_id =
cu.getApplicationClient().runApplication(
PRIMER_PREDICTION,
scs,
params,
Boolean.TRUE);
if (job_id != 0) {
Thread jt =
new JobThreader(
PRIMER_PREDICTION,
job_id,
cu.getApplicationClient(),
Boolean.TRUE,
null);
jt.start();
try {
while (!JobQueue.isReportReady(job_id) && drq.isActive()) {
System.out.println(
"PrimerPrediction_DRU waiting on job " + job_id);
Thread.sleep(1500);
}
if (!drq.isActive()){
System.out.println("This Primer Prediction run has been interrupted by the user!");
throw new RunnerException();
}
} catch (InterruptedException e) {
e.printStackTrace();
job_id = -1;
throw new RunnerException();
}
} else {
throw new RunnerException();
}
Report job_report = JobQueue.getReport(job_id);
return job_report;
}
}
package ca.bcgsc.sockeye.dataretrieval;
public class RunnerException extends Exception {
}
package ca.bcgsc.sockeye.dataretrieval;
import java.awt.Color;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import javax.vecmath.Color3f;
import ca.bcgsc.sockeye.analysis.Alignment;
import ca.bcgsc.sockeye.analysis.scprofile.SCProfile;
import ca.bcgsc.sockeye.analysis.scprofile.SCProfileException;
import ca.bcgsc.sockeye.analysis.scprofile.SCProfileList;
import ca.bcgsc.sockeye.analysis.scprofile.SubsetGenerator;
import ca.bcgsc.sockeye.datastorage.MultiDimTrackDistribution;
import ca.bcgsc.sockeye.datastorage.StorageException;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.trackmanager.AlignOperation;
import ca.bcgsc.sockeye.trackmanager.TrackRelationshipException;
import ca.bcgsc.sockeye.util.Log;
public class SCProfileDRU extends DataRetrievalUnit {
SCProfileList profiles = null;
int ref_trk_id;
SCProfileDataSource a_ds;
AlignOperation a_op;
Alignment align_3d;
static final String _FEATURE_NAME =
"sequence conservation profile set";
public SCProfileDRU(SCProfileDataSource source) {
a_ds = source;
}
protected void retrieveData() {
if (_request_to_process.getFeatures().isEmpty()) {
return;
}
if (!_request_to_process.getFeatures().contains(_FEATURE_NAME)) {
return;
}
ref_trk_id = _request_to_process.getTrackId();
a_op = a_ds.getAlignOperation();
align_3d = a_op.get3DSubalignment();
try {
profiles = align_3d.getSCProfileList();
if (profiles == null) {
profiles =
new SCProfileList(align_3d, a_op.getReferenceTrack(), a_op.getTrackRelationship(), SCProfileList.__DEFAULT_WINDOW_SIZE, SubsetGenerator.__SET_DISTANCE, null);
align_3d.setSCProfileList((SCProfileList)profiles);
}
} catch (SCProfileException e) {
Log.printStackTrace(e);
}
}
protected void deliverData() {
if (profiles == null) {
return;
}
String aln_key = a_op.getAlignApplication() + " " + a_op.getAlignID();
try {
boolean ref_reversed = align_3d.onNegativeStrand(ref_trk_id);
int ref_src_trk = a_op.getSourceTrack(ref_trk_id);
MultiDimTrackDistribution mdd =
(MultiDimTrackDistribution) _my_storage_manager.getFeature(
ref_trk_id,
_FEATURE_NAME,
"Seq Cons Profile Set");
if (mdd != null) _my_storage_manager.removeFeature(ref_trk_id, _FEATURE_NAME, "Seq Cons Profile Set");
List aln_trks = a_op.getTrackRelationship().getTrackOrder(ref_trk_id);
for (int t = 0; t < aln_trks.size(); t++) {
int trk_id = ((Integer)aln_trks.get(t)).intValue();
int src_trk = a_op.getSourceTrack(trk_id);
_my_storage_manager.removeFeature(trk_id, "Conserved Region");
_my_storage_manager.removeFeature(src_trk, "Conserved Region");
try {
List all_c_regions = new ArrayList(_my_storage_manager.getFeatures(src_trk, "Conserved Region"));
for (int j = 0; j < all_c_regions.size(); j++) {
TrackFeature c_region = (TrackFeature)all_c_regions.get(j);
if (c_region.getAccessionID().indexOf(aln_key) > -1) {
_my_storage_manager.removeFeature(src_trk, "Conserved Region", c_region.getAccessionID());
}
}
} catch (StorageException e) {
} catch (NullPointerException e) {
} **/
}
TrackFeature src_region = null;
src_region = align_3d.getSourceRegion(ref_trk_id);
if (src_region == null) throw new SCProfileException("Unable to determine source region of aligned track: " + ref_trk_id);
int track_start = _my_storage_manager.getTrackDataWindowStart(ref_trk_id);
int track_end = _my_storage_manager.getTrackDataWindowEnd(ref_trk_id);
List data =
profiles.getDistributionData(
SCProfileList.__MAX_BIN_RESOLUTION,
track_start, 0, track_end - track_start + 1, ref_reversed);
if (data == null || data.size() == 0) {
Log.println("SCProfileDRU - No profiles to deliver!");
Log.println("");
return;
}
List containers = new ArrayList();
List labels = new ArrayList();
List thresholds = new ArrayList();
List colours = new ArrayList();
for (Iterator i = data.iterator(); i.hasNext(); ) {
HashMap p_data = (HashMap)i.next();
containers.add(p_data.get("Containers"));
labels.add(p_data.get("Label"));
thresholds.add(p_data.get("Threshold"));
colours.add(p_data.get("Colour"));
}
mdd =
new MultiDimTrackDistribution(ref_trk_id, "Seq Cons Profile Set");
mdd.addDistributions(containers);
for (int i = 0; i < data.size(); i++) {
mdd.setDistributionLabel(i, (String)labels.get(i));
mdd.setDistributionThreshold(i, ((Float)thresholds.get(i)).floatValue());
mdd.setDistributionColour(i, new Color3f((Color)colours.get(i)));
}
mdd.setStart(track_start);
mdd.setEnd(track_end);
mdd.setFeature(_FEATURE_NAME);
mdd.setAttribute("no_gap_division", "overlap gaps");
_my_storage_manager.addFeature(ref_trk_id, _FEATURE_NAME, mdd);
for (int t = 0; t < aln_trks.size(); t++) {
int trk_id = ((Integer)aln_trks.get(t)).intValue();
int src_trk = a_op.getSourceTrack(trk_id);
boolean reversed_track = align_3d.onNegativeStrand(trk_id);
List c_regions = new ArrayList();
List c_regions_ungapped = new ArrayList();
for (int i = 0; i < profiles.size(); i++) {
SCProfile profile = profiles.getProfile(i);
c_regions.addAll(
profile.getConservedRegions(trk_id, true, reversed_track));
c_regions_ungapped.addAll(
profile.getConservedRegions(trk_id, false, reversed_track));
}
for (int i = 0; i < c_regions.size(); i++) {
TrackFeature c_region = (TrackFeature)c_regions.get(i);
c_region.setAccessionID(aln_key + "_" + c_region.getAccessionID());
c_region.setAttribute("display_string", aln_key + " conserved region");
}
for (int i = 0; i < c_regions_ungapped.size(); i++) {
TrackFeature c_region = (TrackFeature)c_regions_ungapped.get(i);
c_region.setAccessionID(aln_key + "_" + c_region.getAccessionID());
c_region.setAttribute("display_string", aln_key + " conserved region");
}
if (c_regions.size() + c_regions_ungapped.size() > 0) {
if (c_regions.size() > 0) _my_storage_manager.addFeatures(trk_id, "Conserved Region", c_regions);
if (c_regions_ungapped.size() > 0) try {
_my_storage_manager.addFeatures(
src_trk,
"Conserved Region",
c_regions_ungapped);
} catch (StorageException e) {
}
}
}
ArrayList visible_list = new ArrayList();
visible_list.add("gap");
visible_list.add(AlignOperation.ALN_HIGHLIGHT_FEATURE);
visible_list.add("Conserved Region");
visible_list.add(_FEATURE_NAME);
_my_storage_manager.setFeatureVisibility(visible_list , true);
for (int i = 0; i < aln_trks.size(); i++) {
int trk = ((Integer)aln_trks.get(i)).intValue();
_my_storage_manager.setTrackVisibility(trk, true);
}
} catch (SCProfileException e) {
Log.printStackTrace(e);
} catch (TrackRelationshipException e) {
Log.printStackTrace(e);
}
}
}
package ca.bcgsc.sockeye.dataretrieval;
import java.util.ArrayList;
import java.util.List;
import ca.bcgsc.sockeye.datastorage.DataStorageManager;
import ca.bcgsc.sockeye.trackmanager.AlignOperation;
public class SCProfileDataSource extends DataSource {
private AlignOperation align_op;
public SCProfileDataSource() {
super(-1);
}
public SCProfileDataSource(int track, AlignOperation op) {
super(track);
this.align_op = op;
}
public AlignOperation getAlignOperation() {
return align_op;
}
public DataStorageManager getStorageManager() {
return this._my_storage_manager;
}
protected DataRetrievalUnit createDRU() {
return new SCProfileDRU(this);
}
public String toString() {
return null;
}
public static DataSource instanceFromString(int id, String s) {
return null;
}
public String getDisplayString(){
return "SC Profile";
}
public void reset() {
List features = new ArrayList();
features.add(SCProfileDRU._FEATURE_NAME);
DataRequest dr = new DataRequest(this._my_track, _my_id, 0, 0, features);
processRequest (dr);
}
}
package ca.bcgsc.sockeye.dataretrieval;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.Vector;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.config.Connection;
import ca.bcgsc.sockeye.config.Service;
import ca.bcgsc.sockeye.service.featureloader.common.ConnectionManager;
import ca.bcgsc.sockeye.service.featureloader.common.FeatureDistributionLoaderResult;
import ca.bcgsc.sockeye.service.featureloader.common.FeatureLoaderService;
import ca.bcgsc.sockeye.service.featureloader.common.FeatureLoaderServiceFactory;
import ca.bcgsc.sockeye.service.featureloader.common.RemoteFeatureCountAdapter;
public class SemanticZoomManager implements java.io.Serializable{
public SemanticZoomManager() {
_histogramAdapter = new RemoteFeatureCountAdapter();
init();
}
public SemanticZoomManager (String host, String user, String pass, String database){
_histogramAdapter = new RemoteFeatureCountAdapter (host, user, pass, database);
init();
}
public SemanticZoomManager (String host, String user, String pass){
_histogramAdapter = new RemoteFeatureCountAdapter (host, user, pass);
init();
}
public void setConnectionParameter(String host, String user, String pass){
_histogramAdapter.setConnectionParameters(host, user, pass);
}
public void setDatabase (String database){
_histogramAdapter.setCoreDatabase(database);
}
public Map getFeatureDistribution (String feature){
Map retDist = (Map)_featureDistributions.get(feature);
if (retDist != null && rangeUnchanged()){
return retDist;
}
if (retDist != null && rangeShrunk()){
return retDist;
}
_featureDistributions.remove(feature);
if (_markerStart < _bpStart)
_bpStart = _markerStart;
if (_markerEnd > _bpEnd)
_bpEnd = _markerEnd;
_markerStart = _bpStart;
_markerEnd = _bpEnd;
retDist = queryAndAddFeatureDistribution (feature, _bpStart, _bpEnd);
return retDist;
}
protected boolean rangeUnchanged(){
return ( (_markerStart == _bpStart) && (_markerEnd == _bpEnd) );
}
protected boolean rangeShrunk(){
return ( (_markerStart <= _bpStart) && (_markerEnd >= _bpEnd));
}
protected Map queryAndAddFeatureDistribution (String feature, int start, int end){
if (! isBPRangeInitialised() || _binSize <= 0){
System.out.println ("ERROR: BP range or bin size not initialised ("+_binSize+")!");
return null;
}
System.out.println ("SZ manager: QUERYING using the following parameters: "
+ feature + " " + _chromosome + " " + start + " " + end + " " + _binSize);
FeatureLoaderServiceFactory fac = FeatureLoaderServiceFactory.getInstance();
Service service =
Configuration.getService(FeatureLoaderServiceFactory.FEATURELOADER_SERVICES);
String mode = null;
String remotehost = null;
if (service != null) {
mode = service.getMode();
remotehost = service.getRemotehost();
} else {
throw new RuntimeException("Feature loader service not set up properly.");
}
FeatureLoaderService ser = fac.getService(mode, remotehost);
Connection conn = ConnectionManager.getCurrentConnection("Ensembl");
List featureList = new ArrayList();
featureList.add(feature);
FeatureDistributionLoaderResult result = ser.getFeatureDistributions(conn,
_histogramAdapter.getDatabase(),
null,
_chromosome,
_bpStart,
_bpEnd,
featureList,
_binSize
);
Map distrib = result.get(feature);
if (distrib != null)
{
_featureDistributions.put (feature, distrib);
}
else{
System.out.println("SZ debug: NO distribution for " + feature + " found!");
}
return distrib;
}
public void setBasePairRange (String chromosome, int bpStart, int bpEnd){
if (bpEnd <= bpStart){
System.out.println("SZ manager debug: ERROR! Illegal base range: " +
bpStart + ", " + bpEnd);
return;
}
_chromosome = chromosome;
_bpStart = bpStart;
_bpEnd = bpEnd;
if (_binSize <= 0)
_binSize = determineBinSize();
if (_markerEnd == -1 || _markerStart == -1){
_markerStart = bpStart;
_markerEnd = bpEnd;
}
}
public void setHistogramBinLength (int binLength){
if (binLength < 2){
System.out.println("SZ manager debug: ERROR! Illegal bin size (length): " +
binLength);
return;
}
if (_featureDistributions.size() == 0)
{
_binSize = binLength;
return;
}
if (binLength > _binSize && (binLength % _binSize) == 0){
System.out.println("No need to requery, just join all existing features...");
setBinLengthAndResize(binLength);
}
else{
_binSize = binLength;
requeryAllFeatures();
}
}
public void setHistogramBinCount (int binCount){
setHistogramBinLength ((int) ((_bpEnd - _bpStart) / binCount));
}
public boolean checkSZRulesGlobal(String feature){
return testSZRulesForValue (feature, _globalControlValue);
}
public boolean checkSZRulesGlobalAndRange (String feature){
return (checkSZRulesGlobal(feature) || testSZRulesLocalRange(feature));
}
public boolean testSZRulesForValue (String feature, int value){
int index = _supportedFeatures.indexOf(feature);
if (index < 0 )
return false;
if (_suppFeatureOptionSettings[index][0] == SZ_BEHAVIOR_OFF)
return false;
if ( value > _suppFeatureOptionSettings[index][1])
return true;
return false;
}
public boolean testSZRulesLocalRange (String feature){
return testSZRulesForValue(feature, _bpEnd-_bpStart+1);
}
public int getCurrentBinSize(){
return _binSize;
}
public int getSZBehaviorForFeature(String feature){
int index = _supportedFeatures.indexOf(feature);
if (index <0)
return -1;
return _suppFeatureOptionSettings[index][0];
}
public List getListOfChangedFeatures(){
List changedFeatures = new ArrayList();
String fName;
for (int sf = 0; sf < _supportedFeatures.size(); sf++){
fName = (String) _supportedFeatures.get(sf);
if (checkSZRulesGlobal(fName) != _featureDistributions.containsKey(fName))
changedFeatures.add(fName);
}
return changedFeatures;
}
public List setGlobalControlValue (int value, int binSize){
List changedFeatures = new ArrayList();
for (int sf = 0; sf < _supportedFeatures.size(); sf++)
{
if (checkSZRulesGlobal( (String) _supportedFeatures.get(sf)) !=
testSZRulesForValue( (String) _supportedFeatures.get(sf),
value))
changedFeatures.add(_supportedFeatures.get(sf));
}
_globalControlValue = value;
return changedFeatures;
}
public int getGlobalControlValue(){
return _globalControlValue;
}
protected boolean isBPRangeInitialised()
{
return (_chromosome.length() > 0
&& _bpStart != -1
&& _bpEnd != -1 );
}
protected void requeryAllFeatures(){
List keys = new ArrayList(_featureDistributions.keySet());
Iterator it = keys.iterator();
while (it.hasNext())
this.queryAndAddFeatureDistribution (it.next().toString(), _bpStart, _bpEnd);
}
protected void setBinLengthAndResize(int newLength){
List featureKeys = new ArrayList(_featureDistributions.keySet());
List binKeys;
Iterator fIt = featureKeys.iterator();
Iterator kIt;
while (fIt.hasNext()){
int numNewBins = (int)((_bpEnd-_bpStart)/newLength);
int tempBinContainer[] = new int[numNewBins] ;
Map newDistribution = new TreeMap();
Object feature = fIt.next();
binKeys = new ArrayList (((Map)(_featureDistributions.get(feature.toString()))).keySet());
kIt=binKeys.iterator();
while (kIt.hasNext())
{
Object oldBin = kIt.next();
int newBin = (int)(Integer.parseInt(oldBin.toString()) / newLength);
tempBinContainer[newBin] += Integer.parseInt(((Map)(_featureDistributions.get(feature.toString()))).get(oldBin).toString());
}
for (int i=0; i< tempBinContainer.length; i++)
if (tempBinContainer[i] > 0)
{
newDistribution.put(new Integer(_bpStart + i * newLength),
new Integer(tempBinContainer[i]));
}
_featureDistributions.put(feature, newDistribution);
}
_binSize = newLength;
}
protected void init(){
_chromosome = new String();
_bpStart = -1;
_bpEnd = -1;
_binSize = -1;
_markerStart = -1;
_markerEnd = -1;
_uniqueID = 0;
_featureDistributions = new HashMap();
_suppFeatureOptionSettings = new int[_supportedFeatures.size()][2];
activateNewParameterSettings();
}
private int determineBinSize(){
int returnValue = -1;
System.out.println("SZ Manager DEBUG: Determining bin size...");
if (_firstInstance){
System.out.println("\tBin Size: First track...");
if (_binSizeCustomMetric[0] == 0){
System.out.println("\t\tMetric BASES PER BIN, value " + _binSizeCustomValue[0][0]+ " (= return value)");
returnValue = _binSizeCustomValue[0][0];
}
else{
System.out.println("\t\tMetric BINS PER TRACK, value " + _binSizeCustomValue[0][1]);
System.out.println("\t\t Return value = " + Math.ceil( (_bpEnd - _bpStart)/_binSizeCustomValue[0][1] ) );
returnValue = (int) Math.ceil( (_bpEnd - _bpStart)/_binSizeCustomValue[0][1] );
}
_bin_size_last_track = returnValue;
_firstInstance = false;
return returnValue;
}
switch (_trackBinSizeRuleInUse){
case 0:
System.out.println("\t Rule 0: last added track");
returnValue = _bin_size_last_track;
break;
case 1:
System.out.println("\t Rule 1: longest visible data window");
returnValue = _bin_size_longest_track;
break;
case 2:
System.out.println("\t Rule 2: shortest visible data window ");
returnValue = _bin_size_shortest_track;
break;
case 3:
System.out.println("\t Rule 3: custom");
if (_binSizeCustomMetric[1] == 0){
System.out.println("\t\tMetric BASES PER BIN, value " + _binSizeCustomValue[1][0]+ " (= return value)");
returnValue = _binSizeCustomValue[1][0];
}
else{
System.out.println("\t\tMetric BINS PER TRACK, value " + _binSizeCustomValue[1][1]);
System.out.println("\t\t Return value = " + Math.ceil( (_bpEnd - _bpStart)/_binSizeCustomValue[1][1] ) );
returnValue = (int) Math.ceil( (_bpEnd - _bpStart)/_binSizeCustomValue[1][1] );
}
break;
}
_bin_size_last_track = returnValue;
_firstInstance = false;
return returnValue;
}
public static void setBinSizeSelectedRule(int track, int rule){
if (track>0)
if (rule >= 0 && rule < _trackBinSizeRules.length)
_trackBinSizeRuleInUse=rule;
else
System.out.println ("SZ setting bin size rule: Illegal rule id!");
}
public static void setBinSizeCustomValue(int track, int[] values, int selectedMetric){
track = (track==0)?0:1;
if (selectedMetric < 0 || selectedMetric >= _availableMetricNames.length)
{
return;
}
_binSizeCustomMetric[track]=selectedMetric;
_binSizeCustomValue[track]=values;
}
public List activateNewParameterSettings(){
List featuresChanged = new ArrayList();
for (int row=0; row < _temp_parameter_matrix_buffer.size(); row++){
Vector rowContent = (Vector)_temp_parameter_matrix_buffer.get(row);
if (rowContent.size() < 3){
continue;
}
int featureId = _supportedFeatures.indexOf(rowContent.get(0));
if (featureId < 0) {
continue;
}
int beh;
for (beh = 0; beh < _szBehaviorString.length; beh++)
if (_szBehaviorString[beh].equals(rowContent.get(1)))
break;
if (beh == _szBehaviorString.length){
continue;
}
int thresh = Integer.parseInt(rowContent.get(2).toString());
boolean criticalChange = false;
if (_suppFeatureOptionSettings[featureId][1] != beh &&
_suppFeatureOptionSettings[featureId][1] >= _globalControlValue &&
thresh < _globalControlValue )
criticalChange = true;
else
if (_suppFeatureOptionSettings[featureId][1] < _globalControlValue &&
thresh >= _globalControlValue )
criticalChange = true;
if (_suppFeatureOptionSettings[featureId][0] == SZ_BEHAVIOR_OFF &&
beh == SZ_BEHAVIOR_OFF) {
System.out.println(
"DEBUG set parameter (" + featureId + "): SZ was off and stays off - no rescan necessary");
}
else
if ((beh == SZ_BEHAVIOR_OFF || beh == SZ_BEHAVIOR_HIDE) &&
_suppFeatureOptionSettings[featureId][1] < _globalControlValue) {
System.out.println(
"DEBUG set parameter: SZ switched off/hidden and feature was binned, need to rescan!");
featuresChanged.add(rowContent.get(0));
}
else
if (criticalChange)
featuresChanged.add(rowContent.get(0));
else
if (_suppFeatureOptionSettings[featureId][0] == SZ_BEHAVIOR_OFF &&
_suppFeatureOptionSettings[featureId][1] < _globalControlValue)
featuresChanged.add(rowContent.get(0));
_suppFeatureOptionSettings[featureId][0] = beh;
_suppFeatureOptionSettings[featureId][1] = thresh;
}
return featuresChanged;
}
public static void setSupportedFeatureParameterMatrix(Vector opt){
_temp_parameter_matrix_buffer = opt;
}
public void setBinSizeLongestTrack(int bs){
_bin_size_longest_track = bs;
}
public void setBinSizeShortestTrack(int bs){
_bin_size_shortest_track = bs;
}
public static int[] getBinSizeCustomValues(int track){
return _binSizeCustomValue[ (track==0)? 0 : 1 ];
}
public static int getBinSizeSelectedCustomMetric(int track){
return _binSizeCustomMetric[ (track==0)? 0 : 1 ];
}
public static String[] getBinSizeMetricNames(){
return _availableMetricNames;
}
public static String[] getBinSizeOptionList(int track){
if (track==0)
return new String[]{"custom"};
else
return _trackBinSizeRules;
}
public static int getBinSizeSelectedOption(int track){
return ( (track==0)?0:_trackBinSizeRuleInUse );
}
public static String[] getAvailableSZStateStrings(){
return _szBehaviorString;
}
public List getFeaturesPresentAsDistribution(){
return new ArrayList(_featureDistributions.keySet());
}
public static Vector getSupportedFeatureParameterMatrix(){
return _temp_parameter_matrix_buffer;
}
public static String getUniqueId(){
return ("SZ " + Integer.toString(_uniqueID++));
}
public List filterFeaturesByState(List features, int state){
List hiddenFeatures = new ArrayList();
for (int i=0; i< features.size(); i++)
{
String feature = features.get(i).toString();
int index = _supportedFeatures.indexOf(feature);
if (index >= 0)
if (_suppFeatureOptionSettings[index][0] == state && checkSZRulesGlobalAndRange(feature))
hiddenFeatures.add(feature);
}
return hiddenFeatures;
}
private RemoteFeatureCountAdapter _histogramAdapter;
private String _chromosome;
private int _bpStart;
private int _bpEnd;
private int _binSize;
private int _markerStart;
private int _markerEnd;
private static int _bin_size_longest_track = 0;
private static int _bin_size_shortest_track = 0;
private static int _bin_size_last_track = 0;
private static int _uniqueID;
private static int[] _globalBinSizeList = {0,0,0};
private static boolean _firstInstance = true;
private Map _featureDistributions;
private static String[] _availableMetricNames = {"Bases per bin", "Bins per track"};
private static int[][] _binSizeCustomValue = {{10000, 150}, {10000, 150}};
private static int[] _binSizeCustomMetric = { 1, 1 };
private static String[] _trackBinSizeRules = {"last added track",
"longest visible data window", "shortest visible data window", "custom"};
private static int _trackBinSizeRuleInUse = 3;
private static Vector _supportedFeatures = new Vector();
private static String[] _szBehaviorString={"Histogram", "Hide", "Off"};
transient public static final int SZ_BEHAVIOR_HIST = 0;
transient public static final int SZ_BEHAVIOR_HIDE = 1;
transient public static final int SZ_BEHAVIOR_OFF = 2;
private int[][] _suppFeatureOptionSettings;
private int _globalControlValue = -1;
private static Vector _temp_parameter_matrix_buffer;
static{
_supportedFeatures.add(new String("gene"));
_supportedFeatures.add(new String("exon"));
_supportedFeatures.add(new String("SNP"));
_supportedFeatures.add(new String("repeat"));
_temp_parameter_matrix_buffer = new Vector();
for (int row=0; row< _supportedFeatures.size(); row++){
Vector line = new Vector();
line.add(_supportedFeatures.get(row));
line.add(_szBehaviorString[0]);
line.add(new Integer(Configuration.getSemZoomDefaultRange()));
_temp_parameter_matrix_buffer.add(line);
}
}
}
package ca.bcgsc.sockeye.dataretrieval.chinook;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import javax.swing.JOptionPane;
import org.biojava.bio.program.gff.GFFTools;
import ca.bcgsc.chinook.client.comobj.SequenceCoordinate;
import ca.bcgsc.chinook.client.local.JobQueue;
import ca.bcgsc.chinook.client.local.JobThreader;
import ca.bcgsc.chinook.server.comobj.ApplicationParameter;
import ca.bcgsc.chinook.server.comobj.GapMarker;
import ca.bcgsc.sockeye.analysis.Alignment;
import ca.bcgsc.sockeye.analysis.AlignmentException;
import ca.bcgsc.sockeye.analysis.scprofile.SCProfile;
import ca.bcgsc.sockeye.analysis.scprofile.SCProfileException;
import ca.bcgsc.sockeye.analysis.scprofile.SCProfileList;
import ca.bcgsc.sockeye.analysis.scprofile.SubsetGenerator;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.datastorage.StorageException;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.gui.Sockeye;
import ca.bcgsc.sockeye.service.featureloader.common.DistributionContainer;
import ca.bcgsc.sockeye.trackmanager.AlignOperation;
import ca.bcgsc.sockeye.trackmanager.Operation;
import ca.bcgsc.sockeye.trackmanager.SequenceConservationRelationship;
import ca.bcgsc.sockeye.trackmanager.TrackManager;
import ca.bcgsc.sockeye.trackmanager.TrackManagerFactory;
import ca.bcgsc.sockeye.trackmanager.TrackRelationshipException;
import ca.bcgsc.sockeye.util.Log;
public class AlignmentDRU extends ChinookDRU {
AlignOperation a_op = null;
public AlignmentDRU(AlignmentDataSource align_ds) {
super(align_ds);
}
protected void retrieveData() {
List features = _request_to_process.getFeatures();
if (features.isEmpty()) {
job_id = -1;
return;
}
if (!features.contains(AlignmentDataSource.ALIGNMENT_APP_TYPE)) {
job_id = -1;
return;
}
TrackManager t_manager = TrackManagerFactory.getInstance();
trk_id = _request_to_process.getTrackId();
Operation op = t_manager.getUpOperations(trk_id);
if (op.getType() != Operation.__ALIGN_OPERATION_TYPE) {
Log.println(
"AlignmentDRU: Ignoring request"
+ _request_to_process.getId()
+ ", no AlignmentOperation found");
job_id = -1;
return;
}
a_op = (AlignOperation) op;
HashMap parameters = chinook_ds.getParameters();
scs = (SequenceCoordinate[]) parameters.get("SequenceCoordinates");
ApplicationParameter[] app_params =
(ApplicationParameter[]) parameters.get("ApplicationParameters");
debug(
"AlignmentDRU job start: "
+ chinook_ds.getApplication()
+ " / "
+ app_params);
job_id =
chinook_ds.getApplicationClient().runApplication(
chinook_ds.getApplication(),
scs,
app_params,
chinook_ds.getCondenseReport());
if (job_id != 0) {
Thread jt =
new JobThreader(
chinook_ds.getApplication(),
job_id,
chinook_ds.getApplicationClient(),
chinook_ds.getCondenseReport(),
null);
jt.start();
for (Iterator itr = a_op.getSourceTracks().iterator(); itr.hasNext();) {
int src_trk = ((Integer) itr.next()).intValue();
DataStoreUser.getInstance().getSockeyeTrackList().getTrackSequence(
src_trk);
}
try {
while (!JobQueue.isReportReady(job_id) && _request_to_process.isActive()) {
sleep(1000);
}
} catch (InterruptedException e) {
Log.println("Job " + job_id + " report retrieval interrupted.");
Log.printStackTrace(e);
job_id = -1;
return;
}
if (!_request_to_process.isActive()) {
a_op.cancel();
return;
}
job_report = JobQueue.getReport(job_id);
debug("AlignmentDRU got report for job " + job_id);
} else {
Log.println("Unable to get a job id for alignment.");
job_id = -1;
}
}
protected void deliverData() {
if (job_id == -1) {
if (a_op != null)
a_op.cancel();
return;
}
String error = null;
String err_msg = null;
a_op.setAlignApplication(chinook_ds.getApplication());
a_op.setAlignType(AlignmentDataSource.ALIGNMENT_APP_TYPE);
Alignment alignment = new Alignment(a_op);
List add_list = new ArrayList();
add_list.add(alignment);
a_op.addSubalignments(add_list);
Map src_targ_trks = a_op.getSourceTargetMapping();
try {
List t_id_list = a_op.getSourceTracks();
List src_regions = this.a_op.getSourceRegions();
if (job_report != null) {
debug(
"AlignmentDRU delivering report for data source: "
+ chinook_ds.getId());
ArrayList results = job_report.getSimpleArray().getArray();
if (results != null && results.size() > 0 && results.get(0) instanceof String) {
err_msg = (String)results.get(0);
throw new ChinookDataSourceException(err_msg);
}
Hashtable gaps = new Hashtable();
List align_region_marker = new ArrayList();
Iterator l = results.iterator();
while (l.hasNext()) {
GapMarker gm = (GapMarker) l.next();
String track_name = gm.name;
if (gm.end < 0){
System.out.println("Found local alignment region boundary marker for track: " + track_name + " beeing: " + gm.start );
align_region_marker.add(gm);
continue;
}
ArrayList gap_list = (ArrayList) gaps.get(track_name);
if (gap_list == null) {
gap_list = new ArrayList();
}
gap_list.add(new DistributionContainer(gm.start, gm.end, 0));
gaps.put(track_name, gap_list);
}
SequenceCoordinate cur_scs = null;
int targ_trk = -1;
for (int t = 0; t < t_id_list.size(); t++) {
List gap_array = null;
int t_id = ((Integer) t_id_list.get(t)).intValue();
String track_id_str = t_id + "";
gap_array = (ArrayList) gaps.get(track_id_str);
if (gap_array == null) gap_array = new ArrayList();
int total_gap_length = 0;
for (int i = 0; i < gap_array.size(); i++) {
DistributionContainer gap = (DistributionContainer)gap_array.get(i);
total_gap_length += gap.getEnd() - gap.getStart() + 1;
}
for (int s = 0; s < scs.length; s++) {
if (scs[s].getName().equals(track_id_str)) {
cur_scs = scs[s];
break;
}
}
if (cur_scs == null) {
Log.println(
"Aligned Sequence for track "
+ track_id_str
+ " not found... skipping.");
continue;
}
boolean negative_strand = false;
if (cur_scs.getStrand().equals("-1")) {
negative_strand = true;
}
targ_trk =
((Integer) src_targ_trks.get(new Integer(t_id))).intValue();
TrackFeature src_region = (TrackFeature) src_regions.get(t);
if (src_region == null) {
Log.println(
"Alignment delivery error: Can't find source region for track "
+ t_id
+ "... skipping");
continue;
}
int start = 1, end = src_region.getEnd() - src_region.getStart() + 1;
boolean got_start = false;
for (int i = 0; i < align_region_marker.size(); i++) {
GapMarker marker = (GapMarker)align_region_marker.get(i);
if (Integer.parseInt(marker.name) == t_id) {
if (!got_start) {
start = marker.start;
got_start = true;
} else {
end = marker.start - total_gap_length - 1;
}
}
}
if (got_start) {
for (int i = 0; i < gap_array.size(); i++) {
DistributionContainer gap = (DistributionContainer)gap_array.get(i);
gap.setStart(gap.getStart() - start + (negative_strand ? 1 : 0));
gap.setEnd(gap.getEnd() - start + (negative_strand ? 1 : 0));
}
}
alignment.addSequence(src_region, start, end, negative_strand, false, gap_array);
}
a_op.complete();
try {
SCProfileList profiles =
new SCProfileList(alignment,
trk_id,
a_op.getTrackRelationship(),
1,
SubsetGenerator.__SET_PAIRWISE,
null);
profiles.getDistributionData(0,0,0,0,false);
SequenceConservationRelationship new_relation =
new SequenceConservationRelationship();
for (int i = 0; i < profiles.size(); i++) {
SCProfile profile = profiles.getProfile(i);
List tracks = profile.getSequences();
Integer track1 = (Integer) tracks.get(0);
Integer track2 = (Integer) tracks.get(1);
new_relation.addTracks(
track1.intValue(),
track2.intValue(),
profile.getMeanScore());
}
a_op.addRelationship(new_relation);
} catch (TrackRelationshipException e) {
Log.printStackTrace(e);
} catch (SCProfileException e) {
Log.printStackTrace(e);
} catch (NullPointerException e) {
Log.printStackTrace(e);
}
} else {
throw new ChinookDataSourceException("No report");
}
} catch (AlignmentException e) {
Log.printStackTrace(e);
error = "Cannot complete alignment";
err_msg = "Alignment error.";
} catch (ChinookDataSourceException e) {
Log.printStackTrace(e);
error = "Cannot complete alignment";
err_msg = e.getMessage();
} catch (StorageException e) {
Log.printStackTrace(e);
error = "Cannot complete alignment";
err_msg =
"Source sequences were deleted before the\noperation could complete.";
} catch (Exception e) {
Log.printStackTrace(e);
error = "Cannot complete alignment";
err_msg = e.getMessage();
}
if (error != null)
try {
a_op.cancel();
JOptionPane.showMessageDialog(
Sockeye.__frame,
err_msg,
error,
JOptionPane.ERROR_MESSAGE);
} catch (Exception e) {
Log.printStackTrace(e);
}
}
private TrackFeature createGapFeature(
int trk_id,
String accession_id,
GapMarker gm) {
TrackFeature gap =
new TrackFeature(
accession_id,
_parent_datasource_id == null? "ENSEMBL" :_parent_datasource_id.toString(),
"gap",
gm.start,
gm.end,
GFFTools.NO_SCORE,
0,
GFFTools.NO_FRAME);
gap.setTrackId(trk_id);
gap.setAccessionID(accession_id);
ArrayList attrib = new ArrayList();
return gap;
}
}
package ca.bcgsc.sockeye.dataretrieval.chinook;
import java.util.*;
import ca.bcgsc.sockeye.dataretrieval.*;
public class AlignmentDataSource extends ChinookDataSource {
transient public static final String ALIGNMENT_APP_TYPE = "ALIGNMENT";
transient public static final String R_ALIGNMENT_APP_TYPE = "R-ALIGNMENT";
String application_type;
public AlignmentDataSource() throws ChinookDataSourceException {
super();
}
public AlignmentDataSource(
int track,
String app_type,
String app_name,
HashMap parameters,
Boolean condense_report,
ChinookUser cc)
throws ChinookDataSourceException {
super(track, app_name, parameters, condense_report, cc);
application_type = app_type;
}
protected DataRetrievalUnit createDRU() {
if (application_type.equals(ALIGNMENT_APP_TYPE))
return new AlignmentDRU(this);
else if (application_type.equals(R_ALIGNMENT_APP_TYPE))
return new RAlignmentDRU(this);
else
return null;
}
public String getDisplayString() {
return "Alignment";
}
}
package ca.bcgsc.sockeye.dataretrieval.chinook;
import ca.bcgsc.chinook.client.comobj.SequenceCoordinate;
import ca.bcgsc.chinook.server.comobj.Report;
import ca.bcgsc.sockeye.dataretrieval.*;
abstract public class ChinookDRU extends DataRetrievalUnit {
protected ChinookDataSource chinook_ds;
protected int job_id = -1;
protected int trk_id = -1;
protected SequenceCoordinate[] scs;
protected Report job_report;
public ChinookDRU(ChinookDataSource chinook_ds) {
this.chinook_ds = chinook_ds;
}
public void debug(String out) {
chinook_ds.debug(out);
}
}
package ca.bcgsc.sockeye.dataretrieval.chinook;
import java.util.HashMap;
import ca.bcgsc.chinook.client.local.ApplicationClient;
import ca.bcgsc.sockeye.dataretrieval.*;
public abstract class ChinookDataSource extends DataSource {
private HashMap parameters;
private String app_name;
private ChinookUser cc;
private Boolean condense_report;
transient static final boolean _DEBUG = true;
public ChinookDataSource() throws ChinookDataSourceException {
super();
}
public ChinookDataSource(
int track,
String app_name,
HashMap parameters,
Boolean condense_report,
ChinookUser cc)
throws ChinookDataSourceException {
super(track);
this.app_name = app_name;
this.parameters = parameters;
this.cc = cc;
this.condense_report = condense_report;
debug("ChinookDataSource created:" + app_name + "/" + parameters);
}
protected abstract DataRetrievalUnit createDRU();
public String getApplication() {
return app_name;
}
public void setApplication(String app_name) {
this.app_name = app_name;
}
public HashMap getParameters() {
return parameters;
}
public void setParameters(HashMap map) {
parameters = map;
}
public ApplicationClient getApplicationClient() {
return cc.getApplicationClient();
}
public Boolean getCondenseReport() {
return this.condense_report;
}
public void debug(String out) {
if (_DEBUG) {
System.out.println(out);
}
}
}
package ca.bcgsc.sockeye.dataretrieval.chinook;
public class ChinookDataSourceException
extends Exception {
public ChinookDataSourceException(String msg) {
super(msg);
}
}
package ca.bcgsc.sockeye.dataretrieval.chinook;
import java.util.List;
import ca.bcgsc.chinook.client.comobj.SequenceCoordinate;
import ca.bcgsc.chinook.client.local.ApplicationClient;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.config.Service;
import ca.bcgsc.sockeye.util.Log;
public class ChinookUser {
transient private static final String _CHINOOK_SERVICE = "Chinook";
private ApplicationClient _ac;
public ChinookUser() throws ChinookDataSourceException {
initClient();
}
protected void initClient() throws ChinookDataSourceException {
if (_ac != null) return;
try {
Service service = Configuration.getService(_CHINOOK_SERVICE);
String mode = null;
if (service != null) {
mode = service.getMode();
}
String connection_string = null;
if ("rmi".equals(mode)) {
connection_string = Configuration.getNamingServerConnectionString();
}
else {
connection_string = service.getRemotehost();
}
_ac = new ApplicationClient(mode, connection_string);
}
catch (Exception e) {
Log.printStackTrace(e);
throw new ChinookDataSourceException("Unable to connect with Chinook application client.");
}
}
public List getApplicationNamesForType(String application_type)
throws ChinookDataSourceException{
return _ac.getApplicationNamesForType(application_type);
}
public List getApplicationParameters(String application)
throws ChinookDataSourceException {
return _ac.getRequiredParametersForApplicationName(application);
}
public int getMinimumNumberOfSequencesForApplicationName(String application)
throws ChinookDataSourceException {
return _ac.getMinimumNumberOfSequencesForApplicationName(application);
}
public int getMaximumNumberOfSequencesForApplicationName(String application)
throws ChinookDataSourceException {
return _ac.getMaximumNumberOfSequencesForApplicationName(application);
}
public boolean validateSequence(SequenceCoordinate sc)
throws ChinookDataSourceException {
return _ac.validateSequence(sc);
}
public ApplicationClient getApplicationClient() {
return _ac;
}
}
package ca.bcgsc.sockeye.dataretrieval.chinook;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import javax.swing.JOptionPane;
import ca.bcgsc.chinook.client.comobj.SequenceCoordinate;
import ca.bcgsc.chinook.client.local.JobQueue;
import ca.bcgsc.chinook.client.local.JobThreader;
import ca.bcgsc.chinook.server.comobj.ApplicationParameter;
import ca.bcgsc.chinook.server.comobj.SerializableSimpleGFFRecord;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.util.Log;
public class McsDRU extends ChinookDRU {
static int _feature_count = 0;
public McsDRU(McsDataSource source) {
super(source);
}
protected void retrieveData() {
List features = _request_to_process.getFeatures();
if (features.isEmpty() || (!features.contains(McsDataSource.MCS_CALC))) {
job_id = -1;
return;
}
HashMap parameters = chinook_ds.getParameters();
scs = (SequenceCoordinate[]) parameters.get("SequenceCoordinates");
ApplicationParameter[] app_params =
(ApplicationParameter[]) parameters.get("ApplicationParameters");
job_id =
chinook_ds.getApplicationClient().runApplication(
chinook_ds.getApplication(),
scs,
app_params,
chinook_ds.getCondenseReport());
if (job_id != 0) {
Thread jt =
new JobThreader(
chinook_ds.getApplication(),
job_id,
chinook_ds.getApplicationClient(),
chinook_ds.getCondenseReport(),
null);
jt.start();
try {
while (!JobQueue.isReportReady(job_id)) {
debug("Mcs_DRU waiting on job " + job_id);
sleep(1500);
}
} catch (InterruptedException e) {
Log.println("Job " + job_id + " report retrieval interrupted.");
Log.printStackTrace(e);
job_id = -1;
return;
}
job_report = JobQueue.getReport(job_id);
debug("Mcs_DRU got report for job " + job_id);
} else {
Log.println("Unable to get a job id for MCS.");
job_id = -1;
}
}
protected void deliverData() {
if (job_id == -1) {
return;
}
if (job_report != null) {
System.out.println("McsDRU: Delivering data...");
debug("McsDRU delivering report for data source: " + chinook_ds.getId());
HashMap param = this.chinook_ds.getParameters();
SequenceCoordinate[] seqCoords =
(SequenceCoordinate[]) param.get("SequenceCoordinates");
int reference_track_id = chinook_ds.getTrack();
SequenceCoordinate reference_coords = null;
for (int i = 0; i < seqCoords.length; i++) {
if (seqCoords[i]
.getName()
.equals(String.valueOf(reference_track_id))) {
reference_coords = seqCoords[i];
break;
}
}
ArrayList results = job_report.getSimpleArray().getArray();
if (results.size() <= 1) {
JOptionPane.showMessageDialog(
null,
"No result returned by MCS",
"Warning Dialog",
javax.swing.JOptionPane.WARNING_MESSAGE);
}
SerializableSimpleGFFRecord gff_title =
(SerializableSimpleGFFRecord) results.get(0);
String track_title = gff_title.getSeqName();
results.remove(0);
Iterator l = results.iterator();
l = results.iterator();
while (l.hasNext()) {
SerializableSimpleGFFRecord gffr =
(SerializableSimpleGFFRecord) l.next();
int featureStart = reference_coords.getStart() + gffr.getStart();
int featureEnd = reference_coords.getStart() + gffr.getEnd() - 1;
TrackFeature feature =
new TrackFeature(
gffr.getSeqName(),
gffr.getSource(),
McsDataSource.MCS_CALC,
featureStart,
featureEnd,
gffr.getScore(),
gffr.getStrand(),
gffr.getFrame());
feature.setTrackId(reference_track_id);
feature.setAccessionID("(" +_feature_count++ + ") " + gffr.getSeqName());
DecimalFormat formatter = new DecimalFormat("##.##");
feature.setAttribute(
"coordinates",
featureStart + ".." + featureEnd);
feature.setAttribute(
"score",
String.valueOf(formatter.format(gffr.getScore())));
ArrayList al = new ArrayList();
al.add(feature);
_my_storage_manager.addFeatures(
reference_track_id,
McsDataSource.MCS_CALC,
al);
}
_my_storage_manager.setFeatureVisibility(McsDataSource.MCS_CALC, true);
System.out.println("McsDRU: Delivering data DONE!");
} else {
throw new IllegalStateException("No report available");
}
}
}
package ca.bcgsc.sockeye.dataretrieval.chinook;
import java.util.HashMap;
import ca.bcgsc.sockeye.dataretrieval.DataRetrievalUnit;
public class McsDataSource extends ChinookDataSource {
public static final String MCS_CALC = "mcs_calculation";
private int _track = 0;
private String _app = null;
private HashMap _param = null;
public McsDataSource(
int track,
String app_name,
HashMap parameters,
Boolean condense_report,
ChinookUser cc)
throws ChinookDataSourceException {
super(track, app_name, parameters, condense_report, cc);
_track = track;
_app = app_name;
_param = parameters;
}
protected DataRetrievalUnit createDRU() {
return new McsDRU(this);
}
public String getDisplayString() {
return new String(
"MCS Calculation\tMethod "
+ _app
+ "\tTrack: "
+ _track
+ "\tParameters "
+ _param);
}
}
package ca.bcgsc.sockeye.dataretrieval.chinook;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import ca.bcgsc.chinook.client.comobj.SequenceCoordinate;
import ca.bcgsc.chinook.client.local.JobQueue;
import ca.bcgsc.chinook.client.local.JobThreader;
import ca.bcgsc.chinook.server.comobj.ApplicationParameter;
import ca.bcgsc.chinook.server.comobj.MotifDiscoveryHit;
import ca.bcgsc.chinook.server.comobj.SerializableSimpleGFFRecord;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.gui.MotifDiscoveryDialog;
import ca.bcgsc.sockeye.util.Log;
public class MotifDiscoveryDRU extends ChinookDRU {
static int _feature_id = 0;
static MotifDiscoveryDialog mdialog;
public MotifDiscoveryDRU(MotifDiscoveryDataSource source) {
super(source);
}
protected void retrieveData() {
List features = _request_to_process.getFeatures();
if (features.isEmpty()
|| (!features.contains(MotifDiscoveryDataSource.MOTIF_DISCOVERY))) {
job_id = -1;
return;
}
HashMap parameters = chinook_ds.getParameters();
scs = (SequenceCoordinate[]) parameters.get("SequenceCoordinates");
ApplicationParameter[] app_params =
(ApplicationParameter[]) parameters.get("ApplicationParameters");
job_id =
chinook_ds.getApplicationClient().runApplication(
chinook_ds.getApplication(),
scs,
app_params,
chinook_ds.getCondenseReport());
if (job_id != 0) {
Thread jt =
new JobThreader(
chinook_ds.getApplication(),
job_id,
chinook_ds.getApplicationClient(),
chinook_ds.getCondenseReport(),
null);
jt.start();
try {
while (!JobQueue.isReportReady(job_id)) {
debug("MotifDiscover_DRU waiting on job " + job_id);
sleep(1500);
}
} catch (InterruptedException e) {
Log.println("Job " + job_id + " report retrieval interrupted.");
Log.printStackTrace(e);
job_id = -1;
return;
}
job_report = JobQueue.getReport(job_id);
debug("MotifDiscovery_DRU got report for job " + job_id);
} else {
Log.println("Unable to get a job id for Motif Discovery.");
job_id = -1;
}
}
protected void deliverData() {
if (job_id == -1) {
return;
}
if (job_report != null) {
System.out.println("MotifDiscoveryDRU: Delivering data...");
debug(
"MotifDiscoveryDRU delivering report for data source: "
+ chinook_ds.getId());
HashMap param = this.chinook_ds.getParameters();
SequenceCoordinate[] seqCoords =
(SequenceCoordinate[]) param.get("SequenceCoordinates");
List results = job_report.getSimpleArray().getArray();
Iterator l = results.iterator();
l = results.iterator();
while (l.hasNext()) {
MotifDiscoveryHit motifHit = (MotifDiscoveryHit) l.next();
List records = motifHit.getGffRecord();
if (records != null) {
for (Iterator itr = records.iterator(); itr.hasNext();) {
SerializableSimpleGFFRecord gffr =
(SerializableSimpleGFFRecord) itr.next();
int trk_chinook_pos = new Integer(gffr.getSeqName()).intValue();
int trk_id =
(new Integer(seqCoords[trk_chinook_pos - 1].getName()))
.intValue();
TrackFeature tf =
createFeature(trk_id, gffr, seqCoords[trk_chinook_pos - 1]);
tf.setScore(100.);
ArrayList al = new ArrayList();
al.add(tf);
_my_storage_manager.addFeatures(
trk_id,
MotifDiscoveryDataSource.MOTIF_DISCOVERY,
al);
}
}
}
_my_storage_manager.setFeatureVisibility(
MotifDiscoveryDataSource.MOTIF_DISCOVERY,
true);
System.out.println("MotifDiscoveryDRU: Delivering data DONE!");
} else {
throw new IllegalStateException("No report available");
}
}
private TrackFeature createFeature(
int trk_id,
SerializableSimpleGFFRecord gffr,
SequenceCoordinate coord) {
try {
int startPos = 0;
int endPos = 0;
int featureStrand = 0;
int strand = new Integer(coord.getStrand()).intValue();
if (strand == 1) {
startPos = gffr.getStart() + coord.getStart();
endPos = gffr.getEnd() + coord.getStart() - 1;
featureStrand = gffr.getStrand() * strand;
} else {
startPos = coord.getEnd() - gffr.getEnd() + 1;
endPos = coord.getEnd() - gffr.getStart();
featureStrand = gffr.getStrand() * strand;
}
if (!((featureStrand == 1) || (featureStrand == -1))) {
throw new Exception("Strand has to be either 1 or -1; strand = " +featureStrand);
}
TrackFeature feature =
new TrackFeature(
gffr.getSeqName(),
gffr.getSource(),
MotifDiscoveryDataSource.MOTIF_DISCOVERY,
startPos,
endPos,
gffr.getScore(),
featureStrand,
gffr.getFrame());
feature.setTrackId(trk_id);
feature.setAccessionID(_feature_id++ + " " + gffr.getComment());
DecimalFormat formatter = new DecimalFormat("##.##");
feature.setAttribute("coordinates", startPos + ".." + endPos);
feature.setAttribute("score", String.valueOf(formatter.format(gffr.getScore())));
return feature;
}
catch(Throwable t){
t.printStackTrace();
return null;
}
}
}
package ca.bcgsc.sockeye.dataretrieval.chinook;
import java.util.HashMap;
import ca.bcgsc.sockeye.dataretrieval.*;
public class MotifDiscoveryDataSource extends ChinookDataSource {
public static final String MOTIF_DISCOVERY = "motif_discovery";
private int _track = 0;
private String _app = null;
private HashMap _param = null;
static public String[] background_model =
{
"Bmi1_HMR_CpG_20040327.o2.bckd",
"Bmi1_HMR_CpG_20040327.o3.bckd",
"Cbri.cb25agp8.clean_promotors.o2.bckd",
"Cbri.cb25agp8.clean_promotors.o3.bckd",
"Cele110_Cbri.clean_promotors.o2.bckd",
"Cele110_Cbri.clean_promotors.o3.bckd",
"Cele110.clean_promotors.o2.bckd",
"Cele110.clean_promotors.o3.bckd",
"Cele_clean_promotors_v110.unix.mfa.o3.bckd",
"CG_collection_MmusHsapRnor.o2.bckd",
"CG_collection_MmusHsapRnor.o3.bckd",
"dro3_EnsMArt_1K_upstreams.o3.ms_bckd",
"dro3_EnsMArt_2K_upstreams.o3.ms_bckd",
"dro3_EnsMArt_5K_upstreams.o3.ms_bckd",
"HMR_Dro3_upstream2000_f0.025.o3.ms_bckd",
"Hsap_Mmus_upstream1000.o2.bckd",
"Hsap_Mmus_upstream1000.o3.bckd",
"human34_upstream1000.motifsampler.o3.bckd",
"human_mouse_rat_upstreams5000_f0.1.o3.bckd",
"magnaporthe_grisea_2.3_gene_upstream_1000.o2.bckd",
"magnaporthe_grisea_2.3_gene_upstream_1000.o3.bckd",
"Mmus_mm4_upstream1000.o2.bckd",
"Mmus_mm4_upstream1000.o3.bckd",
"Mmus_mm4_upstream5000.o2.bckd",
"Mmus_mm4_upstream5000.o3.bckd",
"Scere_100_1Kb_randomseqs_RSAT.o2.bckd",
"Scere_100_1Kb_randomseqs_RSAT.o3.bckd",
"Scere_800b_upstreams_RSAT.o3.bckd",
"user_input_sequences" };
public MotifDiscoveryDataSource(
int track,
String app_name,
HashMap parameters,
Boolean condense_report,
ChinookUser cc)
throws ChinookDataSourceException {
super(track, app_name, parameters, condense_report, cc);
_track = track;
_app = app_name;
_param = parameters;
}
protected DataRetrievalUnit createDRU() {
return new MotifDiscoveryDRU(this);
}
public String getDisplayString() {
return new String(
"Motif Discovery\tMethod "
+ _app
+ "\tTrack: "
+ _track
+ "\tParameters "
+ _param);
}
}
package ca.bcgsc.sockeye.dataretrieval.chinook;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import ca.bcgsc.chinook.client.comobj.SequenceCoordinate;
import ca.bcgsc.chinook.server.comobj.ApplicationParameter;
import ca.bcgsc.chinook.server.comobj.SerializableSimpleGFFRecord;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import javax.swing.JOptionPane;
import ca.bcgsc.sockeye.dataretrieval.*;
public class PrimerPredictionDRU extends ChinookDRU {
private double maxScore = 0, minScore = Double.MAX_VALUE;
static private int PRIMER_MAX_SIZE = 28;
static private String featureTreeName = "Primers result";
public PrimerPredictionDRU(PrimerPredictionDataSource source) {
super(source);
}
protected void retrieveData() {
List features = _request_to_process.getFeatures();
if (features.isEmpty()) {
job_id = -1;
return;
}
if (!features.contains(PrimerPredictionDataSource.PRIMER_PREDICTION)) {
job_id = -1;
return;
}
trk_id = _request_to_process.getTrackId();
HashMap parameters = chinook_ds.getParameters();
scs = (SequenceCoordinate[]) parameters.get("SequenceCoordinates");
ApplicationParameter[] app_params =
(ApplicationParameter[]) parameters.get("ApplicationParameters");
ApplicationParameter[] all_params =
new ApplicationParameter[app_params.length + 4];
System.arraycopy(app_params, 0, all_params, 0, app_params.length);
for (int i = app_params.length; i < all_params.length; i++) {
all_params[i] = new ApplicationParameter();
}
int seqStart = scs[0].getStart();
int seqEnd = scs[0].getEnd();
int featStart = scs[0].getStart();
int featEnd = scs[0].getEnd();
int featLength = featEnd - featStart + 1;
int sizeRangeLower = PRIMER_MAX_SIZE;
int sizeRangeUpper = featLength;
int nb = -1;
for (int i = 0; i < app_params.length; i++) {
if (app_params[i].name.equals("neighbourhood")) {
if (features.contains("Primers Inside Target")) {
break;
}
nb = Integer.valueOf(all_params[i].value).intValue();
seqStart = scs[0].getStart() - nb;
seqEnd = scs[0].getEnd() + nb;
sizeRangeLower = featLength;
sizeRangeUpper = seqEnd - seqStart + 1;
}
}
all_params[app_params.length].name = "fstart";
all_params[app_params.length].value = "" + scs[0].getStart();
all_params[app_params.length + 1].name = "fend";
all_params[app_params.length + 1].value = "" + scs[0].getEnd();
all_params[app_params.length + 2].name = "sizerange";
all_params[app_params.length + 2].value =
sizeRangeLower + "-" + sizeRangeUpper;
all_params[app_params.length + 3].name = "insideTarget";
if (features.contains("Primers Inside Target")) {
all_params[app_params.length + 3].value = "1";
}
else {
all_params[app_params.length + 3].value = "0";
}
parameters.put("ApplicationParameters", all_params);
String temp =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackAttribute(trk_id, "track_max_length")
.toString();
int max_track_length = Integer.valueOf(temp).intValue();
if ((seqStart < 1) || (seqEnd > max_track_length)) {
JOptionPane.showMessageDialog(
null,
"Cannot generate primers on this region. This region is too "
+ "close to the end(s) of the entire sequence for this species.",
"Primer Prediction warning\n",
JOptionPane.WARNING_MESSAGE);
return;
}
if (seqStart < DataStoreUser.getInstance().getSockeyeTrackList().getTrackDataStart(trk_id)) {
DataStoreUser.getInstance().getSockeyeTrackList().setTrackDataWindow(
trk_id,
seqStart,
DataStoreUser.getInstance().getSockeyeTrackList().getTrackDataEnd(trk_id));
}
if (seqEnd > DataStoreUser.getInstance().getSockeyeTrackList().getTrackDataEnd(trk_id)) {
DataStoreUser.getInstance().getSockeyeTrackList().setTrackDataWindow(
trk_id,
DataStoreUser.getInstance().getSockeyeTrackList().getTrackDataStart(trk_id),
seqEnd);
}
scs[0].setStart(seqStart);
scs[0].setEnd(seqEnd);
scs[0].setSequence(
DataStoreUser.getInstance().getSockeyeTrackList().getTrackSequence(
trk_id,
seqStart,
seqEnd));
try {
PrimerPredictionRunner prRunner =
new PrimerPredictionRunner(scs, all_params);
job_report = prRunner.run(this._request_to_process);
job_id = 1;
} catch (Exception e) {
e.printStackTrace();
job_id = -1;
return;
}
}
protected void deliverData() {
if (job_id == -1) {
return;
}
if (job_report != null) {
System.out.println("PrimerPredictionDRU: Delivering data...");
debug(
"PrimerPrediction delivering report for data source: "
+ chinook_ds.getId());
HashMap param = this.chinook_ds.getParameters();
SequenceCoordinate[] seqCoords =
(SequenceCoordinate[]) param.get("SequenceCoordinates");
List results = job_report.getSimpleArray().getArray();
if (results.size() == 0) {
JOptionPane.showMessageDialog(
null,
"No acceptable primers were found. Try relaxing input parameters..",
"Primer Prediction warning\n",
JOptionPane.WARNING_MESSAGE);
return;
}
int trk_id = _request_to_process.getTrackId();
int numLoops = 1;
Iterator l = results.iterator();
while (l.hasNext()) {
SerializableSimpleGFFRecord gffr =
(SerializableSimpleGFFRecord) l.next();
TrackFeature tf = createFeature(trk_id, gffr);
tf.setAttachment("Primer Prediction Report", results);
tf.setAttachment("Chinook Parameters", param);
tf.setAttachment(
"Date Time",
Calendar.getInstance().getTime().toString());
ArrayList al = new ArrayList();
al.add(tf);
ArrayList alSingle = new ArrayList();
alSingle.add(tf);
_my_storage_manager.addFeatures(trk_id, "forward_primer", alSingle);
tf = createFeature(trk_id, (SerializableSimpleGFFRecord) l.next());
tf.setAttachment("Primer Prediction Report", results);
tf.setAttachment("Chinook Parameters", param);
tf.setAttachment(
"Date Time",
Calendar.getInstance().getTime().toString());
al.add(tf);
alSingle = new ArrayList();
alSingle.add(tf);
_my_storage_manager.addFeatures(trk_id, "reverse_primer", alSingle);
tf = createFeature(trk_id, (SerializableSimpleGFFRecord) l.next());
tf.setAttachment("Primer Prediction Report", results);
tf.setAttachment("Chinook Parameters", param);
tf.setAttachment(
"Date Time",
Calendar.getInstance().getTime().toString());
al.add(tf);
alSingle = new ArrayList();
alSingle.add(tf);
_my_storage_manager.addFeatures(trk_id, "amplicon", alSingle);
featureTreeName =
"Primers result " + numLoops + ";" + tf.getAccessionID();
_my_storage_manager.addFeatures(trk_id, featureTreeName, al);
if (numLoops == 1) {
_my_storage_manager.setFeatureVisibility(featureTreeName, true);
}
numLoops++;
}
System.out.println("PrimerPrediction: Delivering data DONE!");
} else {
throw new IllegalStateException("No report available");
}
}
private TrackFeature createFeature(
int trk_id,
SerializableSimpleGFFRecord gffr) {
TrackFeature feature =
new TrackFeature(
gffr.getSeqName(),
_parent_datasource_id == null? gffr.getSource() :_parent_datasource_id.toString(),
gffr.getFeature(),
gffr.getStart(),
gffr.getEnd(),
gffr.getScore(),
gffr.getStrand(),
gffr.getFrame());
feature.setTrackId(trk_id);
feature.setAccessionID(" " + gffr.getStart() + "..." + gffr.getEnd());
return feature;
}
}
package ca.bcgsc.sockeye.dataretrieval.chinook;
import java.util.HashMap;
import ca.bcgsc.sockeye.dataretrieval.*;
public class PrimerPredictionDataSource extends ChinookDataSource {
public static final String PRIMER_PREDICTION = "Primer Prediction";
public PrimerPredictionDataSource()
throws ChinookDataSourceException {
super();
}
public PrimerPredictionDataSource(
int track,
String app_name,
HashMap parameters,
Boolean condense_report,
ChinookUser cc)
throws ChinookDataSourceException {
super(track, app_name, parameters, condense_report, cc);
}
protected DataRetrievalUnit createDRU() {
return new PrimerPredictionDRU(this);
}
public String getDisplayString(){
return PRIMER_PREDICTION + ": ";
}
}
package ca.bcgsc.sockeye.dataretrieval.chinook;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import javax.swing.JOptionPane;
import ca.bcgsc.chinook.client.comobj.SequenceCoordinate;
import ca.bcgsc.chinook.client.local.JobQueue;
import ca.bcgsc.chinook.client.local.JobThreader;
import ca.bcgsc.chinook.server.comobj.ApplicationParameter;
import ca.bcgsc.sockeye.analysis.Alignment;
import ca.bcgsc.sockeye.analysis.AlignmentException;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.datastorage.StorageException;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.service.featureloader.common.DistributionContainer;
import ca.bcgsc.sockeye.trackmanager.AlignOperation;
import ca.bcgsc.sockeye.trackmanager.Operation;
import ca.bcgsc.sockeye.trackmanager.TrackManager;
import ca.bcgsc.sockeye.trackmanager.TrackManagerFactory;
import ca.bcgsc.sockeye.util.Log;
import ca.bcgsc.sockeye.gui.Sockeye;
import ca.bcgsc.sockeye.gui.alignment.MultiAlignmentDialog;
public class RAlignmentDRU extends ChinookDRU {
AlignOperation a_op = null;
public RAlignmentDRU(AlignmentDataSource align_ds) {
super(align_ds);
}
protected void retrieveData() {
List features = _request_to_process.getFeatures();
if (features.isEmpty()) {
job_id = -1;
return;
}
if (!features.contains(AlignmentDataSource.R_ALIGNMENT_APP_TYPE)) {
job_id = -1;
return;
}
TrackManager t_manager = TrackManagerFactory.getInstance();
trk_id = _request_to_process.getTrackId();
Operation op = t_manager.getUpOperations(trk_id);
if (op.getType() != Operation.__ALIGN_OPERATION_TYPE) {
Log.println(
"AlignmentDRU: Ignoring request"
+ _request_to_process.getId()
+ ", no AlignmentOperation found");
job_id = -1;
return;
}
a_op = (AlignOperation) op;
HashMap parameters = chinook_ds.getParameters();
scs = (SequenceCoordinate[]) parameters.get("SequenceCoordinates");
ApplicationParameter[] app_params =
(ApplicationParameter[]) parameters.get("ApplicationParameters");
debug(
"AlignmentDRU job start: "
+ chinook_ds.getApplication()
+ " / "
+ app_params);
job_id =
chinook_ds.getApplicationClient().runApplication(
chinook_ds.getApplication(),
scs,
app_params,
chinook_ds.getCondenseReport());
if (job_id != 0) {
Thread jt =
new JobThreader(
chinook_ds.getApplication(),
job_id,
chinook_ds.getApplicationClient(),
chinook_ds.getCondenseReport(),
null);
jt.start();
for (Iterator itr = a_op.getSourceTracks().iterator(); itr.hasNext();) {
int trk_id = ((Integer) itr.next()).intValue();
DataStoreUser.getInstance().getSockeyeTrackList().getTrackSequence(
trk_id);
}
try {
while (!JobQueue.isReportReady(job_id) && _request_to_process.isActive()) {
sleep(1000);
}
} catch (InterruptedException e) {
Log.println("Job " + job_id + " report retrieval interrupted.");
Log.printStackTrace(e);
job_id = -1;
return;
}
if (!_request_to_process.isActive()) {
a_op.cancel();
return;
}
job_report = JobQueue.getReport(job_id);
debug("RAlignmentDRU got report for job " + job_id);
} else {
Log.println("Unable to get a job id for alignment.");
job_id = -1;
}
}
protected void deliverData() {
if (job_id == -1) {
if (a_op != null)
a_op.cancel();
return;
}
String error = null;
String err_msg = null;
a_op.setAlignApplication(chinook_ds.getApplication());
a_op.setAlignType(AlignmentDataSource.R_ALIGNMENT_APP_TYPE);
try {
if (job_report != null) {
debug(
"RAlignmentDRU delivering report for data source: "
+ chinook_ds.getId());
ArrayList results = job_report.getSimpleArray().getArray();
Object head_obj = results.get(0);
if (head_obj instanceof String) throw new AlignmentException((String)head_obj);
List alignments = new ArrayList();
List anchors = new ArrayList();
Map header = (Map)head_obj;
String command_line = (String)header.get("CommandLine");
String output_file_id = (String)header.get("OutputFileID");
List src_regions = a_op.getSourceRegions();
Map align, aln_seq_map;
TrackFeature region;
int aln_start, aln_end;
List tmp_gaps, gaps;
List old_anchors = (List)((Map)head_obj).get("Anchors");
for (int i = 1; i < results.size(); i++) {
align = (Map)results.get(i);
Alignment new_align = new Alignment(a_op);
new_align.setID(i);
alignments.add(new_align);
for (int j = 0; j < src_regions.size(); j++) {
boolean inversion = false;
aln_seq_map = (HashMap)align.get(new Integer(j));
aln_start = ((Integer)aln_seq_map.get("Start")).intValue();
aln_end = ((Integer)aln_seq_map.get("End")).intValue();
inversion = ((Boolean)aln_seq_map.get("Inverted")).booleanValue();
tmp_gaps = (List)aln_seq_map.get("Gaps");
if (tmp_gaps == null) tmp_gaps = new ArrayList();
gaps = new ArrayList();
int g_end, g_start;
for (int g = 0; g < tmp_gaps.size(); g += 2) {
g_start = ((Integer) tmp_gaps.get(g)).intValue();
g_end = ((Integer) tmp_gaps.get(g + 1)).intValue();
gaps.add(new DistributionContainer(g_start, g_end, 0));
}
region = (TrackFeature)src_regions.get(j);
boolean reversed = false;
for (int s = 0; s < scs.length; s++) {
if (scs[s].getName().equals(region.getTrackId() + "")) {
reversed = scs[s].getStrand().equals("-1");
break;
}
}
new_align.addSequence(region, aln_start, aln_end, reversed, inversion, gaps);
}
}
Map cur_anchor;
int anc_start, anc_end;
for (int i = 1; i < old_anchors.size(); i++) {
cur_anchor = (Map)old_anchors.get(i);
Alignment new_anchor = new Alignment(a_op);
new_anchor.setID(i);
anchors.add(new_anchor);
for (int j = 0; j < src_regions.size(); j++) {
List coords = (List)cur_anchor.get(new Integer(j));
anc_start = ((Integer)coords.get(0)).intValue();
anc_end = ((Integer)coords.get(1)).intValue();
region = (TrackFeature)src_regions.get(j);
boolean reversed = false;
for (int s = 0; s < scs.length; s++) {
if (scs[s].getName().equals(region.getTrackId() + "")) {
reversed = scs[s].getStrand().equals("-1");
break;
}
}
new_anchor.addSequence(region, anc_start, anc_end, reversed, false, null);
}
}
a_op.addSubalignments(alignments);
a_op.addAnchors(anchors);
a_op.setCommandline(command_line);
a_op.setOutputFileID(output_file_id);
a_op.complete();
try {
MultiAlignmentDialog dialog = new MultiAlignmentDialog(a_op);
} catch (Exception e) {
Log.printStackTrace(e);
}
} else {
throw new ChinookDataSourceException("No report");
}
} catch (AlignmentException e) {
Log.printStackTrace(e);
error = "Cannot complete alignment";
err_msg = "Unable to retrieve alignment data:\n" + e.getMessage();
} catch (ChinookDataSourceException e) {
Log.printStackTrace(e);
error = "Cannot complete alignment";
err_msg = "Unable to retrieve alignment data.";
} catch (StorageException e) {
Log.printStackTrace(e);
error = "Cannot complete alignment";
err_msg =
"Source sequences were deleted before the\noperation could complete.";
} catch (Exception e) {
Log.printStackTrace(e);
error = "Cannot complete alignment";
err_msg = e.getClass().getName() + ": " + e.getMessage();
}
if (error != null)
try {
a_op.cancel();
JOptionPane.showMessageDialog(
Sockeye.__frame,
err_msg,
error,
JOptionPane.ERROR_MESSAGE);
} catch (Exception e) {
Log.printStackTrace(e);
}
}
}
package ca.bcgsc.sockeye.dataretrieval.chinook.client.gui.container;
import java.awt.*;
import javax.swing.*;
import javax.swing.table.JTableHeader;
import java.util.ArrayList;
import ca.bcgsc.sockeye.dataretrieval.chinook.client.gui.tables.*;
import ca.bcgsc.chinook.client.utils.ClientUtils;
import ca.bcgsc.chinook.server.comobj.ApplicationParameter;
public class ParameterEntryContainer
extends JPanel {
ParameterEntryTable pet;
BooleanEntryTable bet;
public ParameterEntryContainer(ArrayList parameters) {
this.setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
this.pet = new ParameterEntryTable(ClientUtils.getStringParameters(
parameters));
this.bet = new BooleanEntryTable(ClientUtils.getBooleanParameters(
parameters));
this.bet.setBorder(BorderFactory.createLineBorder(Color.gray));
this.pet.setBorder(BorderFactory.createLineBorder(Color.gray));
JTableHeader pth = pet.getTableHeader();
JTableHeader bth = bet.getTableHeader();
this.add(pth);
this.add(pet);
this.add(bth);
this.add(bet);
}
public ApplicationParameter[] getApplicationParameters() {
if (bet == null || pet == null) { return null; }
ApplicationParameter[] ap = pet.getParameters();
ApplicationParameter[] ap2 = bet.getParameters();
ApplicationParameter[] ret_param = new ApplicationParameter[ap.length +
ap2.length];
int j = 0;
for (int i = 0; i < ap.length; i++) {
ret_param[j++] = ap[i];
}
for (int i = 0; i < ap2.length; i++) {
ret_param[j++] = ap2[i];
}
return ret_param;
}
}
package ca.bcgsc.sockeye.dataretrieval.chinook.client.gui.container;
import java.awt.*;
import javax.swing.*;
import javax.swing.table.JTableHeader;
import ca.bcgsc.chinook.client.comobj.SequenceCoordinate;
import ca.bcgsc.sockeye.dataretrieval.chinook.client.gui.tables.SequenceEntryTable;
public class SequenceEntryContainer
extends JPanel {
SequenceEntryTable set;
public SequenceEntryContainer(int number_of_sequences) {
this.setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
this.set = new SequenceEntryTable(number_of_sequences);
this.set.setBorder(BorderFactory.createLineBorder(Color.gray));
JTableHeader sth = set.getTableHeader();
this.add(sth);
this.add(set);
}
public SequenceEntryContainer(SequenceCoordinate [] scs) {
this.setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
this.set = new SequenceEntryTable(scs);
this.set.setBorder(BorderFactory.createLineBorder(Color.gray));
JTableHeader sth = set.getTableHeader();
this.add(sth);
this.add(set);
}
public SequenceCoordinate[] getSequenceParameters() {
if (set == null) {
return null;
}
return set.getSequences();
}
public void setSequenceParameters(SequenceCoordinate[] scs) {
if (set != null) {
set.setSequences(scs);
}
}
}
package ca.bcgsc.sockeye.dataretrieval.chinook.client.gui.ds;
public class ChromosomeContainer {
public String chromosome;
public ChromosomeContainer() {
this.chromosome = new String("");
}
public String getChromosome() {
return this.chromosome;
}
public void setChromosome(String chromosome) {
this.chromosome = chromosome;
}
}
package ca.bcgsc.sockeye.dataretrieval.chinook.client.gui.ds;
public class ParameterValue {
private String _regex_format;
private String _value;
public ParameterValue() {
this._regex_format = "";
this._value = "";
}
public boolean check_regex() {
if (_value instanceof String) {
return ((String) _value).matches(this._regex_format);
}
return false;
}
public String getValue() {
return this._value;
}
public void setValue(String value) {
this._value = value;
}
public String getRegexFormat() {
return this._regex_format;
}
public void setRegexFormat(String regex_format) {
this._regex_format = regex_format;
}
}
package ca.bcgsc.sockeye.dataretrieval.chinook.client.gui.ds;
public class SpeciesContainer {
public String species;
public SpeciesContainer() {
this.species = "Homo_sapiens";
}
public String getSpecies() {
return this.species;
}
public void setSpecies(String species) {
this.species = species;
}
}
package ca.bcgsc.sockeye.dataretrieval.chinook.client.gui.ds;
public class StrandContainer {
String strand;
public StrandContainer() {
strand = "1";
}
public String getStrand() {
return this.strand;
}
public void setStrand(String strand) {
this.strand = strand;
}
}
package ca.bcgsc.sockeye.dataretrieval.chinook.client.gui.frames;
import java.awt.BorderLayout;
import java.awt.HeadlessException;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JSplitPane;
import ca.bcgsc.chinook.client.comobj.SequenceCoordinate;
import ca.bcgsc.sockeye.dataretrieval.chinook.client.gui.tables.BooleanEntryTable;
import ca.bcgsc.sockeye.dataretrieval.chinook.client.gui.tables.ParameterEntryTable;
import ca.bcgsc.sockeye.dataretrieval.chinook.client.gui.tables.SequenceEntryTable;
import ca.bcgsc.chinook.client.local.ApplicationClient;
import ca.bcgsc.chinook.client.local.JobThreader;
import ca.bcgsc.chinook.client.utils.ClientUtils;
import ca.bcgsc.chinook.server.comobj.ApplicationParameter;
public class ParameterEntry
extends JFrame {
SequenceEntryTable set;
ParameterEntryTable pet;
BooleanEntryTable bet;
JButton b_commit; ;
JButton b_cancel;
String _app_name;
SequenceCoordinate[] sc;
public ParameterEntry(ArrayList parameters, int number_of_input_sequences,
String application_name) throws HeadlessException {
super(application_name + " Parameter Entry Table");
setSize(500, 200);
setDefaultCloseOperation(EXIT_ON_CLOSE);
b_commit = new JButton("Run " + application_name);
b_cancel = new JButton("Cancel");
this._app_name = application_name;
set = new SequenceEntryTable(number_of_input_sequences);
pet = new ParameterEntryTable(ClientUtils.getStringParameters(parameters));
bet = new BooleanEntryTable(ClientUtils.getBooleanParameters(parameters));
JSplitPane sp1 = new JSplitPane(JSplitPane.VERTICAL_SPLIT,
new JScrollPane(bet), commandPane());
JSplitPane sp2 = new JSplitPane(JSplitPane.VERTICAL_SPLIT,
new JScrollPane(pet), sp1);
JSplitPane sp3 = new JSplitPane(JSplitPane.VERTICAL_SPLIT,
new JScrollPane(set), sp2);
getContentPane().add(sp3, BorderLayout.CENTER);
}
public ParameterEntry(ArrayList parameters, SequenceCoordinate[] sc,
String application_name) throws HeadlessException {
super(application_name + " Parameter Entry Table");
setSize(500, 200);
setDefaultCloseOperation(EXIT_ON_CLOSE);
this.sc = sc;
b_commit = new JButton("Run " + application_name);
b_cancel = new JButton("Cancel");
this._app_name = application_name;
pet = new ParameterEntryTable(ClientUtils.getStringParameters(parameters));
bet = new BooleanEntryTable(ClientUtils.getBooleanParameters(parameters));
JSplitPane sp1 = new JSplitPane(JSplitPane.VERTICAL_SPLIT,
new JScrollPane(bet), commandPane());
JSplitPane sp2 = new JSplitPane(JSplitPane.VERTICAL_SPLIT,
new JScrollPane(pet), sp1);
getContentPane().add(sp2, BorderLayout.CENTER);
}
private JPanel commandPane() {
JPanel jp = new JPanel(new BorderLayout());
b_commit.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
commitPressed();
}
});
b_cancel.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
cancelPressed();
}
});
jp.add(b_commit, BorderLayout.WEST);
jp.add(b_cancel, BorderLayout.EAST);
return jp;
}
private void commitPressed() {
ApplicationParameter[] ap = getParameters();
if (set != null) {
SequenceCoordinate[] seqs = set.getSequences();
ApplicationClient app_client = new ApplicationClient("rmi", "localhost:1099");
int job_id = app_client.runApplication(_app_name, seqs, ap, Boolean.TRUE);
Thread jt = new JobThreader(_app_name, job_id, app_client, Boolean.TRUE, null);
jt.start();
}
else {
ApplicationClient app_client = new ApplicationClient("rmi", "localhost:1099");
int job_id = app_client.runApplication(_app_name, sc, ap, Boolean.TRUE);
Thread jt = new JobThreader(_app_name, job_id, app_client, Boolean.TRUE, null);
jt.start();
}
}
private ApplicationParameter[] getParameters() {
ApplicationParameter[] ap = pet.getParameters();
ApplicationParameter[] ap2 = bet.getParameters();
ApplicationParameter[] ret_param = new ApplicationParameter[ap.length +
ap2.length];
int j = 0;
for (int i = 0; i < ap.length; i++) {
ret_param[j++] = ap[i];
}
for (int i = 0; i < ap2.length; i++) {
ret_param[j++] = ap2[i];
}
return ret_param;
}
private void cancelPressed() {
System.exit(0);
}
}
package ca.bcgsc.sockeye.dataretrieval.chinook.client.gui.models;
import java.util.ArrayList;
import java.util.Iterator;
import javax.swing.table.AbstractTableModel;
import ca.bcgsc.chinook.server.comobj.ApplicationParameter;
public class BooleanEntryModel
extends AbstractTableModel {
String headers[] = new String[] {
"Name", "Value", "Type", "Description"};
Class columnClasses[] = {
String.class, Boolean.class, String.class, String.class};
Object data[][];
public BooleanEntryModel(ArrayList parameters) {
data = new Object[parameters.size()][4];
int j = 0;
Iterator i = parameters.iterator();
while (i.hasNext()) {
data[j++] = getParameterEntryObject( (ApplicationParameter) i.
next());
}
}
public int getRowCount() {
return data.length;
}
public int getColumnCount() {
return headers.length;
}
public Class getColumnClass(int c) {
return columnClasses[c];
}
public String getColumnName(int c) {
return headers[c];
}
public boolean isCellEditable(int r, int c) {
if (c == 1) {
return true;
}
else {
return false;
}
}
public Object getValueAt(int r, int c) {
return data[r][c];
}
public void setValueAt(Object value, int r, int c) {
data[r][c] = value;
}
public static Object[] getParameterEntryObject(ApplicationParameter param) {
Object[] parameter_entry_object = new Object[4];
parameter_entry_object[0] = new String(param.name);
parameter_entry_object[1] = new Boolean(false);
parameter_entry_object[2] = new String(param.type);
parameter_entry_object[3] = new String(param.description);
return parameter_entry_object;
}
public void dump() {
for (int i = 0; i < data.length; i++) {
System.out.print("|");
for (int j = 0; j < data[0].length; j++) {
System.out.print(data[i][j] + "|");
}
System.out.println();
}
}
}
package ca.bcgsc.sockeye.dataretrieval.chinook.client.gui.models;
import java.util.ArrayList;
import java.util.Iterator;
import javax.swing.table.AbstractTableModel;
import ca.bcgsc.sockeye.dataretrieval.chinook.client.gui.ds.ParameterValue;
import ca.bcgsc.chinook.server.comobj.ApplicationParameter;
public class ParameterEntryModel
extends AbstractTableModel {
String headers[] = new String[] {
"Name", "Value", "Type", "Description"};
Class columnClasses[] = {
String.class, ParameterValue.class, String.class, String.class};
Object data[][];
public ParameterEntryModel(ArrayList parameters) {
data = new Object[parameters.size()][4];
int j = 0;
Iterator i = parameters.iterator();
while (i.hasNext()) {
data[j++] = getParameterEntryObject( (ApplicationParameter) i.
next());
}
}
public int getRowCount() {
return data.length;
}
public int getColumnCount() {
return headers.length;
}
public Class getColumnClass(int c) {
return columnClasses[c];
}
public String getColumnName(int c) {
return headers[c];
}
public boolean isCellEditable(int r, int c) {
if (c == 1) {
return true;
}
else {
return false;
}
}
public Object getValueAt(int r, int c) {
return data[r][c];
}
public void setValueAt(Object value, int r, int c) {
if (c == 1) {
if (value != null) {
( (ParameterValue) data[r][c]).setValue( (String) value);
}
else {
( (ParameterValue) data[r][c]).setValue("");
}
}
else {
data[r][c] = value;
}
}
public static Object[] getParameterEntryObject(ApplicationParameter param) {
Object[] parameter_entry_object = new Object[4];
parameter_entry_object[0] = new String(param.name);
ParameterValue pv = new ParameterValue();
pv.setRegexFormat(param.regex_format);
pv.setValue(param.value);
parameter_entry_object[1] = pv;
parameter_entry_object[2] = new String(param.type);
parameter_entry_object[3] = new String(param.description);
return parameter_entry_object;
}
public void dump() {
for (int i = 0; i < data.length; i++) {
System.out.print("|");
for (int j = 0; j < data[0].length; j++) {
System.out.print(data[i][j] + "|");
}
System.out.println();
}
}
}
package ca.bcgsc.sockeye.dataretrieval.chinook.client.gui.models;
import javax.swing.table.*;
import ca.bcgsc.sockeye.dataretrieval.chinook.client.gui.ds.*;
public class SequenceEntryModel
extends AbstractTableModel {
String headers[] = new String[] {
"Name", "Species", "Chromosome", "Start", "End", "Strand"};
Class columnClasses[] = {
String.class, SpeciesContainer.class, String.class, Integer.class, Integer.class,
StrandContainer.class};
Object data[][];
public SequenceEntryModel(int number_of_required_sequences) {
data = getParameterEntryObject(number_of_required_sequences);
}
public int getRowCount() {
return data.length;
}
public int getColumnCount() {
return headers.length;
}
public Class getColumnClass(int c) {
return columnClasses[c];
}
public String getColumnName(int c) {
return headers[c];
}
public boolean isCellEditable(int r, int c) {
return true;
}
public Object getValueAt(int r, int c) {
return data[r][c];
}
public void setValueAt(Object value, int r, int c) {
if (c == 1) {
( (SpeciesContainer) data[r][c]).setSpecies( (String) value);
}
else if (c == 5) {
( (StrandContainer) data[r][c]).setStrand( (String) value);
}
else {
data[r][c] = value;
}
}
public static Object[][] getParameterEntryObject(int
number_of_required_sequences) {
Object[][] parameter_entry_object = new Object[number_of_required_sequences][
6];
for (int i = 0; i < number_of_required_sequences; i++) {
parameter_entry_object[i][0] = new String();
parameter_entry_object[i][1] = new SpeciesContainer();
parameter_entry_object[i][2] = new String();
parameter_entry_object[i][3] = new Integer(0);
parameter_entry_object[i][4] = new Integer(0);
parameter_entry_object[i][5] = new StrandContainer();
}
return parameter_entry_object;
}
public void dump() {
for (int i = 0; i < data.length; i++) {
System.out.print("|");
for (int j = 0; j < data[0].length; j++) {
System.out.print(data[i][j] + "|");
}
System.out.println();
}
}
}
package ca.bcgsc.sockeye.dataretrieval.chinook.client.gui.tables;
import java.util.ArrayList;
import java.util.Iterator;
import javax.swing.JTable;
import ca.bcgsc.sockeye.dataretrieval.chinook.client.gui.models.BooleanEntryModel;
import ca.bcgsc.chinook.server.comobj.ApplicationParameter;
public class BooleanEntryTable extends JTable {
ArrayList _parameters;
public BooleanEntryTable(ArrayList parameters) {
super();
this._parameters = parameters;
BooleanEntryModel bem = new BooleanEntryModel(parameters);
this.setModel(bem);
}
public ApplicationParameter[] getParameters() {
int count = 0;
int j = 0;
Iterator i = _parameters.iterator();
while (i.hasNext()) {
ApplicationParameter ap = (ApplicationParameter) i.next();
this.getValueAt(j, 0);
if (((Boolean)this.getValueAt(j, 1)).booleanValue() ) {
count++;
}
j++;
}
ApplicationParameter[] ret_params = new ApplicationParameter[count];
j = 0;
int l = 0;
Iterator k = _parameters.iterator();
while (k.hasNext()) {
ApplicationParameter ap = (ApplicationParameter) k.next();
if (((Boolean)this.getValueAt(j, 1)).booleanValue() ) {
ret_params[l] = ap;
ret_params[l].value = ((Boolean)this.getValueAt(j, 1)).toString();
l++;
}
j++;
}
return ret_params;
}
}
package ca.bcgsc.sockeye.dataretrieval.chinook.client.gui.tables;
import java.awt.Component;
import java.util.EventObject;
import java.util.Vector;
import javax.swing.JCheckBox;
import javax.swing.JTable;
import javax.swing.event.CellEditorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.table.TableCellEditor;
public class BooleanValueEditor extends JCheckBox implements TableCellEditor {
protected transient Vector listeners;
protected transient Boolean original_value;
protected transient boolean editing;
public BooleanValueEditor() {
super();
listeners = new Vector();
}
public Component getTableCellEditorComponent(JTable table, Object value,
boolean isSelected, int row,
int column) {
if (value == null) {
return this;
}
if (value instanceof Boolean) {
Boolean b = (Boolean) value;
this.setSelected(b.booleanValue());
} else {
this.setSelected(false);
}
original_value = new Boolean(this.isSelected());
return this;
}
public void cancelCellEditing() {
this.fireEditingCanceled();
}
public boolean stopCellEditing() {
this.fireEditingStopped();
return true;
}
public boolean isCellEditable(EventObject eo) {
return true;
}
public boolean shouldSelectCell(EventObject e) {
return true;
}
public Object getCellEditorValue() { return new String(this.getText()); }
public void addCellEditorListener(CellEditorListener cel) {
listeners.addElement(cel);
}
public void removeCellEditorListener(CellEditorListener cel) {
listeners.removeElement(cel);
}
protected void fireEditingCanceled() {
setSelected(original_value.booleanValue());
ChangeEvent ce = new ChangeEvent(this);
for (int i = listeners.size() - 1; i >= 0; i--) {
((CellEditorListener)listeners.elementAt(i)).editingCanceled(ce);
}
}
protected void fireEditingStopped() {
ChangeEvent ce = new ChangeEvent(this);
for (int i = listeners.size() - 1; i >= 0; i--) {
((CellEditorListener)listeners.elementAt(i)).editingStopped(ce);
}
}
}
package ca.bcgsc.sockeye.dataretrieval.chinook.client.gui.tables;
import java.awt.Color;
import java.awt.Component;
import javax.swing.JCheckBox;
import javax.swing.JTable;
import javax.swing.table.TableCellRenderer;
public class BooleanValueRenderer extends JCheckBox implements TableCellRenderer {
public BooleanValueRenderer() {
super();
this.setBackground(Color.green);
}
public Component getTableCellRendererComponent(JTable table, Object value,
boolean isSelected,
boolean hasFocus, int row,
int column) {
if (value == null) {
return this;
}
if (value instanceof Boolean) {
Boolean b = (Boolean) value;
this.setSelected(b.booleanValue());
} else {
this.setSelected(false);
}
return this;
}
}
package ca.bcgsc.sockeye.dataretrieval.chinook.client.gui.tables;
import java.util.ArrayList;
import java.util.Iterator;
import javax.swing.JTable;
import ca.bcgsc.sockeye.dataretrieval.chinook.client.gui.ds.ParameterValue;
import ca.bcgsc.sockeye.dataretrieval.chinook.client.gui.models.ParameterEntryModel;
import ca.bcgsc.chinook.server.comobj.ApplicationParameter;
public class ParameterEntryTable
extends JTable {
ArrayList _parameters;
public ParameterEntryTable(ArrayList parameters) {
super();
this._parameters = parameters;
ParameterEntryModel pem = new ParameterEntryModel(parameters);
this.setModel(pem);
this.setDefaultRenderer(ParameterValue.class, new ParameterValueRenderer());
this.setDefaultEditor(ParameterValue.class, new ParameterValueEditor());
}
public ApplicationParameter[] getParameters() {
int count = 0;
int j = 0;
Iterator i = _parameters.iterator();
while (i.hasNext()) {
ApplicationParameter ap = (ApplicationParameter) i.next();
if (! ( ( (ParameterValue)this.getValueAt(j, 1)).getValue().equals(""))) {
count++;
}
j++;
}
ApplicationParameter[] ret_params = new ApplicationParameter[count];
j = 0;
int l = 0;
Iterator k = _parameters.iterator();
while (k.hasNext()) {
ApplicationParameter ap = (ApplicationParameter) k.next();
if (! ( ( (ParameterValue)this.getValueAt(j, 1)).getValue().equals("")) ) {
ret_params[l] = ap;
ret_params[l].value = ( (ParameterValue)this.getValueAt(j, 1)).getValue();
l++;
}
j++;
}
return ret_params;
}
}
package ca.bcgsc.sockeye.dataretrieval.chinook.client.gui.tables;
import java.awt.Component;
import java.util.EventObject;
import java.util.Vector;
import javax.swing.JTable;
import javax.swing.JTextArea;
import javax.swing.event.CellEditorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.table.TableCellEditor;
import ca.bcgsc.sockeye.dataretrieval.chinook.client.gui.ds.ParameterValue;
public class ParameterValueEditor
extends JTextArea
implements TableCellEditor {
protected transient Vector listeners;
protected transient String original_value;
protected transient boolean editing;
public ParameterValueEditor() {
super();
listeners = new Vector();
}
public Component getTableCellEditorComponent(JTable table, Object value,
boolean isSelected, int row,
int column) {
if (value == null) {
return this;
}
if (value instanceof ParameterValue) {
this.setText((String) ((ParameterValue) value).getValue());
} else {
this.setText("");
}
original_value = this.getText();
return this;
}
public void cancelCellEditing() {
this.fireEditingCanceled();
}
public boolean stopCellEditing() {
this.fireEditingStopped();
return true;
}
public boolean isCellEditable(EventObject eo) {
return true;
}
public boolean shouldSelectCell(EventObject e) {
return true;
}
public Object getCellEditorValue() { return new String(this.getText()); }
public void addCellEditorListener(CellEditorListener cel) {
listeners.addElement(cel);
}
public void removeCellEditorListener(CellEditorListener cel) {
listeners.removeElement(cel);
}
protected void fireEditingCanceled() {
setText(original_value);
ChangeEvent ce = new ChangeEvent(this);
for (int i = listeners.size() - 1; i >= 0; i--) {
((CellEditorListener)listeners.elementAt(i)).editingCanceled(ce);
}
}
protected void fireEditingStopped() {
ChangeEvent ce = new ChangeEvent(this);
for (int i = listeners.size() - 1; i >= 0; i--) {
((CellEditorListener)listeners.elementAt(i)).editingStopped(ce);
}
}
}
package ca.bcgsc.sockeye.dataretrieval.chinook.client.gui.tables;
import java.awt.Color;
import java.awt.Component;
import javax.swing.JTable;
import javax.swing.JTextField;
import javax.swing.table.TableCellRenderer;
import ca.bcgsc.sockeye.dataretrieval.chinook.client.gui.ds.ParameterValue;
public class ParameterValueRenderer
extends JTextField
implements TableCellRenderer {
public ParameterValueRenderer() {
super();
}
private void regex_match_background(boolean regex_match_status) {
if (regex_match_status) {
this.setBackground(Color.green);
}
else {
this.setBackground(Color.red);
}
}
public Component getTableCellRendererComponent(JTable table, Object value,
boolean isSelected,
boolean hasFocus, int row,
int column) {
if (value == null) {
return this;
}
if (value instanceof ParameterValue) {
this.setText((String) ((ParameterValue) value).getValue());
if (((ParameterValue) value).check_regex() || ((ParameterValue) value).getValue().equals("")) {
this.regex_match_background(true);
} else {
this.regex_match_background(false);
}
} else {
this.setText("");
this.regex_match_background(true);
}
return this;
}
}
package ca.bcgsc.sockeye.dataretrieval.chinook.client.gui.tables;
import java.awt.Component;
import javax.swing.JTable;
import javax.swing.JTextField;
import javax.swing.table.TableCellRenderer;
import ca.bcgsc.sockeye.dataretrieval.chinook.client.gui.ds.ChromosomeContainer;
import ca.bcgsc.sockeye.dataretrieval.chinook.client.gui.ds.SpeciesContainer;
import ca.bcgsc.sockeye.dataretrieval.chinook.client.gui.ds.StrandContainer;
public class SequenceEntryRenderer extends JTextField implements TableCellRenderer {
public SequenceEntryRenderer() {
super();
}
public Component getTableCellRendererComponent(JTable table, Object value,
boolean isSelected,
boolean hasFocus, int row,
int column) {
if (value == null) {
return this;
}
if (value instanceof ChromosomeContainer) {
this.setText(((ChromosomeContainer) value).getChromosome());
} else if (value instanceof SpeciesContainer) {
this.setText(((SpeciesContainer) value).getSpecies());
} else if (value instanceof StrandContainer) {
this.setText(((StrandContainer) value).getStrand());
} else if (value instanceof Integer) {
this.setText(((Integer) value).toString());
} else {
this.setText("");
}
return this;
}
}
package ca.bcgsc.sockeye.dataretrieval.chinook.client.gui.tables;
import javax.swing.DefaultCellEditor;
import javax.swing.JComboBox;
import javax.swing.JTable;
import javax.swing.JTextField;
import javax.swing.table.DefaultTableCellRenderer;
import ca.bcgsc.chinook.client.comobj.SequenceCoordinate;
import ca.bcgsc.sockeye.dataretrieval.chinook.client.gui.ds.SpeciesContainer;
import ca.bcgsc.sockeye.dataretrieval.chinook.client.gui.ds.StrandContainer;
import ca.bcgsc.sockeye.dataretrieval.chinook.client.gui.models.SequenceEntryModel;
public class SequenceEntryTable
extends JTable {
private SequenceCoordinate[] scs;
public SequenceEntryTable(int required_number_of_sequences) {
super();
SequenceEntryModel sem = new SequenceEntryModel(
required_number_of_sequences);
this.setModel(sem);
setRendererEditors();
}
public SequenceEntryTable(SequenceCoordinate[] scs) {
super();
this.scs = scs;
setSequences(scs);
setRendererEditors();
}
private void setRendererEditors() {
this.setDefaultRenderer(SpeciesContainer.class,
new SequenceEntryRenderer());
this.setDefaultRenderer(String.class,
new DefaultTableCellRenderer());
this.setDefaultRenderer(StrandContainer.class, new SequenceEntryRenderer());
this.setDefaultEditor(SpeciesContainer.class,
new DefaultCellEditor(new
JComboBox(new Object[] {
"Homo_sapiens", "Mus_musculus", "Rattus_norvegicus",
"Caenorhabditis_elegans", "Caenorhabditis_briggsae",
"Anopheles_gambiae", "Drosophila_melanogaster", "Fugu_rubripes",
"Danio_rerio"})));
this.setDefaultEditor(String.class,
new DefaultCellEditor(new JTextField()));
this.setDefaultEditor(StrandContainer.class,
new DefaultCellEditor(new
JComboBox(new Object[] {"1",
"-1"})));
}
public SequenceCoordinate[] getSequences() {
int size = this.getRowCount();
SequenceCoordinate[] ret_seq = new SequenceCoordinate[size];
for (int i = 0; i < size; i++) {
ret_seq[i] = new SequenceCoordinate( (String)this.getValueAt(i, 0),
( (SpeciesContainer)this.getValueAt(
i, 1)).getSpecies(),
(String)this.getValueAt(i, 2),
( (Integer)this.getValueAt(i, 3)).
intValue(),
( (Integer)this.getValueAt(i, 4)).
intValue(),
( (StrandContainer)this.getValueAt(i,
5)).getStrand(),
scs[i].getEnsemblVersion(),
scs[i].getSequence());
}
return ret_seq;
}
public void setSequences(SequenceCoordinate[] scs) {
SequenceEntryModel sem = new SequenceEntryModel(
scs.length);
this.setModel(sem);
for (int i = 0; i < scs.length; i++) {
this.setValueAt(scs[i].getName(), i, 0);
this.setValueAt(scs[i].getSpecies(), i, 1);
this.setValueAt(scs[i].getChromosome(), i, 2);
this.setValueAt(new Integer(scs[i].getStart()), i, 3);
this.setValueAt(new Integer(scs[i].getEnd()), i, 4);
this.setValueAt(scs[i].getStrand(), i, 5);
}
}
}
package ca.bcgsc.sockeye.dataretrieval.chinookP2P;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import javax.swing.JOptionPane;
import ca.bcgsc.chinook.client.comobj.SequenceCoordinate;
import ca.bcgsc.chinook.p2p.gui.ds.Job;
import ca.bcgsc.chinook.server.comobj.GapMarker;
import ca.bcgsc.chinook.server.comobj.Report;
import ca.bcgsc.sockeye.analysis.Alignment;
import ca.bcgsc.sockeye.analysis.scprofile.SCProfile;
import ca.bcgsc.sockeye.analysis.scprofile.SCProfileException;
import ca.bcgsc.sockeye.analysis.scprofile.SCProfileList;
import ca.bcgsc.sockeye.analysis.scprofile.SubsetGenerator;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.datastorage.StorageException;
import ca.bcgsc.sockeye.datastorage.Track;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.gui.Sockeye;
import ca.bcgsc.sockeye.service.featureloader.common.DistributionContainer;
import ca.bcgsc.sockeye.trackmanager.AlignOperation;
import ca.bcgsc.sockeye.trackmanager.SequenceConservationRelationship;
import ca.bcgsc.sockeye.trackmanager.TrackManagerFactory;
import ca.bcgsc.sockeye.trackmanager.TrackRelationshipException;
import ca.bcgsc.sockeye.util.Log;
import ca.bcgsc.sockeye.trackmanager.TrackRelationshipOrderInterface;
public class AlignmentP2PDRU
extends ChinookP2PDRU {
private AlignOperation _align_op;
private SequenceCoordinate[] _scs;
List src_regions;
TrackRelationshipOrderInterface _relation;
int _ref_track;
public AlignmentP2PDRU(Job job, AlignOperation align_op,
SequenceCoordinate[] scs) {
super(job);
this._align_op = align_op;
this._scs = scs;
}
public AlignmentP2PDRU(Job job, SequenceCoordinate[] scs,
List regions,
TrackRelationshipOrderInterface relation,
int ref_track) {
super(job);
this._scs = scs;
this.src_regions = regions;
this._relation = relation;
this._ref_track = ref_track;
}
protected void retrieveData() {
super.retrieveData();
if (!_request_to_process.isActive()) {
_align_op.cancel();
}
}
protected void deliverData() {
String error = null, err_msg = null;
List new_tracks = new ArrayList();
if (this.getJob().getStatus().equals(Job.SUCCESS)) {
try {
_align_op = new AlignOperation(src_regions);
_align_op.setCurrentRelationship(_relation);
_align_op.setReferenceTrack(_ref_track);
_align_op.setAlignApplication(this.getJob().getService().getService());
_align_op.setAlignType(AlignmentP2PDataSource.ALIGNMENT_APP_TYPE);
int[] up_tracks = new int[src_regions.size()];
for (int t = 0; t < up_tracks.length; t++) up_tracks[t]
= ((TrackFeature)src_regions.get(t)).getTrackId();
TrackManagerFactory.getInstance().addOperation(this._align_op, up_tracks);
Alignment alignment = new Alignment(_align_op);
List add_list = new ArrayList();
add_list.add(alignment);
_align_op.addSubalignments(add_list);
Report rep = this.getJob().getReport();
ArrayList results = rep.getSimpleArray().getArray();
List t_id_list = this._align_op.getSourceTracks();
List align_region_marker = new ArrayList();
Map src_targ_trks = new HashMap();
Hashtable gaps = new Hashtable();
Iterator l = results.iterator();
while (l.hasNext()) {
GapMarker gm = (GapMarker) l.next();
String track_name = gm.name;
if (gm.end < 0){
System.out.println("Found local alignment region boundary marker for track: " + track_name + " beeing: " + gm.start );
align_region_marker.add(gm);
continue;
}
ArrayList gap_list = (ArrayList) gaps.get(track_name);
if (gap_list == null) {
gap_list = new ArrayList();
}
gap_list.add(new DistributionContainer(gm.start, gm.end, 0));
gaps.put(track_name, gap_list);
}
int new_t_id = -1;
for (int t = 0; t < t_id_list.size(); t++) {
List gap_array = null;
Track aligned_track = null;
int t_id = ((Integer) t_id_list.get(t)).intValue();
String track_id_str = t_id + "";
gap_array = (ArrayList) gaps.get(track_id_str);
if (gap_array == null) gap_array = new ArrayList();
int total_gap_length = 0;
for (int i = 0; i < gap_array.size(); i++) {
DistributionContainer gap = (DistributionContainer)gap_array.get(i);
total_gap_length += gap.getEnd() - gap.getStart() + 1;
}
SequenceCoordinate cur_scs = null;
for (int s = 0; s < _scs.length; s++) {
if (_scs[s].getName().equals(track_id_str)) {
cur_scs = _scs[s];
break;
}
}
if (cur_scs == null) {
Log.println("Aligned Sequence for track " + track_id_str +
" not found... skipping.");
continue;
}
boolean negative_strand = false;
if (cur_scs.getStrand().equals("-1")) {
negative_strand = true;
}
TrackFeature src_region = (TrackFeature) src_regions.get(t);
Track new_track = new Track(src_region.getStart(), src_region.getEnd());
new_track.setAttribute("ungapped_end", src_region.getEnd() + "");
new_t_id = DataStoreUser.getInstance().getSockeyeTrackList().
addTrack(new_track);
TrackManagerFactory.getInstance().addTrack(this._align_op, new_t_id);
new_tracks.add(new Integer(new_t_id));
src_targ_trks.put(new Integer(t_id), new Integer(new_t_id));
int start = 1, end = src_region.getEnd() - src_region.getStart() + 1;
boolean got_start = false;
for (int i = 0; i < align_region_marker.size(); i++) {
GapMarker marker = (GapMarker)align_region_marker.get(i);
if (Integer.parseInt(marker.name) == t_id) {
if (!got_start) {
start = marker.start;
got_start = true;
} else {
end = marker.start - total_gap_length - 1;
}
}
}
if (got_start) {
for (int i = 0; i < gap_array.size(); i++) {
DistributionContainer gap = (DistributionContainer)gap_array.get(i);
gap.setStart(gap.getStart() - start + (negative_strand ? 1 : 0));
gap.setEnd(gap.getEnd() - start + (negative_strand ? 1 : 0));
}
}
int length = src_region.getEnd() - src_region.getStart() + 1;
alignment.addSequence(src_region, 1, length, negative_strand, false, gap_array);
}
this._align_op.complete();
try {
SCProfileList profiles =
new SCProfileList(alignment,
_align_op.getReferenceTrack(),
_align_op.getTrackRelationship(),
1,
SubsetGenerator.__SET_PAIRWISE,
null);
profiles.getDistributionData(0,0,0,0,false);
SequenceConservationRelationship new_relation =
new SequenceConservationRelationship();
for (int i = 0; i < profiles.size(); i++) {
SCProfile profile = profiles.getProfile(i);
List tracks = profile.getSequences();
Integer track1 = (Integer) tracks.get(0);
Integer track2 = (Integer) tracks.get(1);
new_relation.addTracks(
track1.intValue(),
track2.intValue(),
profile.getMeanScore());
}
_align_op.addRelationship(new_relation);
}
catch (TrackRelationshipException e) {
Log.printStackTrace(e);
}
catch (SCProfileException e) {
Log.printStackTrace(e);
}
}
catch (StorageException e) {
Log.printStackTrace(e);
error = "Cannot complete alignment";
err_msg =
"Source sequences were deleted before the\noperation could complete.";
}
catch (Exception e) {
Log.printStackTrace(e);
error = "Cannot complete alignment";
err_msg = "Unexpected error.";
}
}
else {
error = "Cannot complete alignment";
err_msg = "Server failed to complete the alignment service.";
}
if (error != null)
try {
Iterator targ_trks = new_tracks.iterator();
while (targ_trks.hasNext()) {
Integer trk = (Integer) targ_trks.next();
DataStoreUser.getInstance().getSockeyeTrackList().removeTrack(trk.
intValue());
}
_align_op.cancel();
JOptionPane.showMessageDialog(
Sockeye.__frame,
err_msg,
error,
JOptionPane.ERROR_MESSAGE);
}
catch (Exception e) {
Log.printStackTrace(e);
}
}
}
package ca.bcgsc.sockeye.dataretrieval.chinookP2P;
import java.util.List;
import java.util.ArrayList;
import ca.bcgsc.chinook.client.comobj.SequenceCoordinate;
import ca.bcgsc.chinook.p2p.client.discovery.DiscoveryConditionSet;
import ca.bcgsc.sockeye.dataretrieval.DataRetrievalUnit;
import ca.bcgsc.sockeye.datastorage.events.StorageEvent;
import ca.bcgsc.sockeye.trackmanager.TrackRelationshipOrderInterface;
public class AlignmentP2PDataSource
extends ChinookP2PDataSource {
transient public static final String ALIGNMENT_APP_TYPE = "ALIGNMENT";
transient public static final String R_ALIGNMENT_APP_TYPE = "R-ALIGNMENT";
String application_type;
List _regions;
TrackRelationshipOrderInterface _relation;
int _ref_track;
public AlignmentP2PDataSource(int track_id, String app_type,
DiscoveryConditionSet dcs,
SequenceCoordinate[] scs,
List regions,
TrackRelationshipOrderInterface relation,
int ref_track) {
super(track_id, dcs, scs);
_regions = regions;
_relation = relation;
_ref_track = ref_track;
application_type = app_type;
}
public String getDisplayString(){
return "Alignment (P2P)";
}
protected DataRetrievalUnit createDRU() {
ChinookP2PDRU chinookDRU = null;
if (application_type.equals(ALIGNMENT_APP_TYPE)) {
chinookDRU = new AlignmentP2PDRU(_job, getSequenceCoordinates(), _regions, _relation, _ref_track);
} else if (application_type.equals(ALIGNMENT_APP_TYPE)) {
chinookDRU = new RAlignmentP2PDRU(_job, getSequenceCoordinates(), _regions, _relation, _ref_track);
}
this._job_manager.addJobListener(chinookDRU);
return chinookDRU;
}
public void storageEventReceived(StorageEvent ex) {
if (ex.getEventType() == StorageEvent.STORAGE_EVENT_TRACK_DATA_REQUEST &&
( (ArrayList) ex.getAttribute()).contains(application_type)) {
super.storageEventReceived(ex);
}
}
}
package ca.bcgsc.sockeye.dataretrieval.chinookP2P;
import ca.bcgsc.chinook.p2p.client.event.JobEvent;
import ca.bcgsc.chinook.p2p.client.event.JobEventListener;
import ca.bcgsc.chinook.p2p.gui.ds.Job;
import ca.bcgsc.sockeye.dataretrieval.DataRetrievalUnit;
public abstract class ChinookP2PDRU
extends DataRetrievalUnit
implements JobEventListener {
private Job _job;
protected JobEvent _jo;
public ChinookP2PDRU(Job job) {
_job = job;
}
private boolean waiting = true;
protected abstract void deliverData();
protected void retrieveData() {
waitForJobEvent();
}
private synchronized void waitForJobEvent() {
try {
while (waiting) {
wait();
}
}
catch (InterruptedException ie) {
}
}
public void jobEventReceived(JobEvent jo) {
if (jo.getEventType() == JobEvent.JOB_EVENT_JOB_MANAGER_DISCARDED) {
this._jo = jo;
endWaiting();
}
else {
if ( ( (Job) jo.getAttribute()).getJobId().intValue() ==
_job.getJobId().intValue()) {
this._job = (Job) jo.getAttribute();
this._jo = jo;
endWaiting();
}
}
}
public Job getJob() {
return this._job;
}
private synchronized void endWaiting() {
waiting = false;
notify();
}
}
package ca.bcgsc.sockeye.dataretrieval.chinookP2P;
import java.util.Iterator;
import ca.bcgsc.chinook.client.comobj.SequenceCoordinate;
import ca.bcgsc.chinook.p2p.client.ChinookP2PClient;
import ca.bcgsc.chinook.p2p.client.JobManager;
import ca.bcgsc.chinook.p2p.client.P2P;
import ca.bcgsc.chinook.p2p.client.discovery.DiscoveryCondition;
import ca.bcgsc.chinook.p2p.client.discovery.DiscoveryConditionSet;
import ca.bcgsc.chinook.p2p.client.event.JobEvent;
import ca.bcgsc.chinook.p2p.client.event.JobEventListener;
import ca.bcgsc.chinook.p2p.gui.ds.Job;
import ca.bcgsc.chinook.p2p.gui.frames.JobFrame;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.dataretrieval.DataRetrievalUnit;
import ca.bcgsc.sockeye.dataretrieval.DataSource;
import ca.bcgsc.sockeye.datastorage.events.StorageEvent;
public abstract class ChinookP2PDataSource
extends DataSource
implements JobEventListener {
DiscoveryConditionSet _discovery_condition_set;
Job _job;
protected JobManager _job_manager;
StorageEvent _storage_event;
SequenceCoordinate[] _scs;
private jobMonitor jmonitor;
private boolean waiting = true;
private boolean _discarded = false;
private boolean _dialog_done = false;
public ChinookP2PDataSource(int track_id){
super (track_id);
}
public ChinookP2PDataSource(int track_id,
DiscoveryConditionSet discovery_condition_set,
SequenceCoordinate[] scs) {
super(track_id);
initP2P (discovery_condition_set, scs);
}
public void initP2P (DiscoveryConditionSet discovery_condition_set,
SequenceCoordinate[] scs){
_discovery_condition_set = discovery_condition_set;
_scs = scs;
}
public void finalize() {
dispose();
try {
super.finalize();
}
catch (Throwable t) {
t.printStackTrace();
}
}
private synchronized void dispose() {
if (jmonitor != null) {
jmonitor.stopThread();
}
}
public SequenceCoordinate[] getSequenceCoordinates() {
return _scs;
}
public void jobEventReceived(JobEvent jo) {
if (jo.getEventType() == JobEvent.JOB_EVENT_JOB_MANAGER_DISCARDED) {
jmonitor.endWaiting(true);
}
else if (jo.getEventType() == JobEvent.JOB_EVENT_JOB_ADDED) {
Job job = (Job) jo.getAttribute();
this._job = job;
jmonitor.endWaiting(false);
}
}
private synchronized void endWaiting(boolean dialog_done) {
waiting = false;
_dialog_done = dialog_done;
notify();
}
public void storageEventReceived(StorageEvent ex) {
this._storage_event = ex;
if (!P2P.isP2Pstarted()) {
String imgPath = Configuration.USER_DIR + "/" +
Configuration.getQuickImagePath() + "/";
P2P.startP2PShowSplashScreen(
imgPath,
"chinook-splash.jpg");
}
JobFrame.setVisible(true);
ChinookP2PClient cp2pclient = new ChinookP2PClient();
cp2pclient._p2pframe.setDefaultSequenceCoordinates(this._scs);
cp2pclient._p2pframe._job_manager.addJobListener(this);
if (jmonitor != null) {
jmonitor.stopThread();
}
ChinookP2PClient.PLUGIN_MODE_ACTIVATED = true;
_job_manager = cp2pclient._p2pframe._job_manager;
try {
Iterator i = this._discovery_condition_set.iterator();
while (i.hasNext()) {
DiscoveryCondition disco_cond = (DiscoveryCondition) i.next();
cp2pclient._p2pframe._discovery_manager.
discoverServicesByDiscoveryCondition(disco_cond);
}
}
catch (Exception e) {
e.printStackTrace();
}
jmonitor = new jobMonitor(this);
jmonitor.start();
}
protected synchronized void callSuperStorageEvent() {
super.storageEventReceived(this._storage_event);
}
protected abstract DataRetrievalUnit createDRU();
private class jobMonitor
extends Thread {
private ChinookP2PDataSource _cp2pds;
private boolean waiting = true;
private boolean _discarded = false;
private boolean _dialog_done = false;
private boolean stopped = false;
public jobMonitor(ChinookP2PDataSource cp2pds) {
_cp2pds = cp2pds;
}
synchronized public void run() {
while (true) {
waiting = true;
try {
while (waiting) {
wait();
}
if (_dialog_done) {
return;
}
_cp2pds.callSuperStorageEvent();
}
catch (InterruptedException ie) {
}
finally {
stopped = true;
}
}
}
public synchronized void endWaiting(boolean dialog_done) {
waiting = false;
_dialog_done = dialog_done;
notify();
}
public synchronized void stopThread() {
if (!stopped) {
_dialog_done = true;
notify();
}
}
}
}
package ca.bcgsc.sockeye.dataretrieval.chinookP2P;
public class ChinookP2PDataSourceException
extends Exception {
public ChinookP2PDataSourceException(String msg) {
super(msg);
}
}
package ca.bcgsc.sockeye.dataretrieval.chinookP2P;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import ca.bcgsc.chinook.client.comobj.SequenceCoordinate;
import ca.bcgsc.chinook.p2p.gui.ds.Job;
import ca.bcgsc.chinook.server.comobj.MotifDiscoveryHit;
import ca.bcgsc.chinook.server.comobj.Report;
import ca.bcgsc.chinook.server.comobj.SerializableSimpleGFFRecord;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
public class MotifDiscoveryP2PDRU
extends ChinookP2PDRU {
static int _feature_id = 0;
private SequenceCoordinate[] _seq_coord;
public MotifDiscoveryP2PDRU(Job job, SequenceCoordinate[] scs) {
super(job);
this._seq_coord = scs;
}
protected void deliverData() {
System.out.println("MotifDiscoveryDRU: DELIVER DATA called");
if (this.getJob().getStatus().equals(Job.SUCCESS)) {
Report rep = this.getJob().getReport();
List results = rep.getSimpleArray().getArray();
Iterator l = results.iterator();
System.out.println("MotifDiscoveryDRU: Delivering data...");
SequenceCoordinate[] seqCoords = this._seq_coord;
while (l.hasNext()) {
MotifDiscoveryHit motifHit = (MotifDiscoveryHit) l.next();
List records = motifHit.getGffRecord();
for (Iterator itr = records.iterator(); itr.hasNext(); ) {
SerializableSimpleGFFRecord gffr =
(SerializableSimpleGFFRecord) itr.next();
int trk_chinook_pos = new Integer(gffr.getSeqName()).intValue();
int trk_id =
(new Integer(seqCoords[trk_chinook_pos - 1].getName())).intValue();
TrackFeature tf =
createFeature(trk_id, gffr, seqCoords[trk_chinook_pos - 1]);
ArrayList al = new ArrayList();
al.add(tf);
_my_storage_manager.addFeatures(
trk_id,
MotifDiscoveryP2PDataSource.MOTIF_DISCOVERY,
al);
}
}
_my_storage_manager.setFeatureVisibility(
MotifDiscoveryP2PDataSource.MOTIF_DISCOVERY,
true);
System.out.println("MotifDiscoveryDRU: Delivering data DONE!");
}
else {
throw new IllegalStateException("No report available");
}
}
private TrackFeature createFeature(
int trk_id,
SerializableSimpleGFFRecord gffr,
SequenceCoordinate coord) {
try {
int startPos = 0;
int endPos = 0;
int featureStrand = 0;
int strand = new Integer(coord.getStrand()).intValue();
if (strand == 1) {
startPos = gffr.getStart() + coord.getStart();
endPos = gffr.getEnd() + coord.getStart() - 1;
featureStrand = gffr.getStrand() * strand;
} else {
startPos = coord.getEnd() - gffr.getEnd() + 1;
endPos = coord.getEnd() - gffr.getStart();
featureStrand = gffr.getStrand() * strand;
}
if (!((featureStrand == 1) || (featureStrand == -1))) {
throw new Exception("Strand has to be either 1 or -1; strand = " +featureStrand);
}
TrackFeature feature =
new TrackFeature(
gffr.getSeqName(),
_parent_datasource_id == null? gffr.getSource() :_parent_datasource_id.toString(),
MotifDiscoveryP2PDataSource.MOTIF_DISCOVERY,
startPos,
endPos,
gffr.getScore(),
featureStrand,
gffr.getFrame());
feature.setTrackId(trk_id);
feature.setAccessionID(_feature_id++ +" " + gffr.getComment());
DecimalFormat formatter = new DecimalFormat("##.##");
feature.setAttribute("score", String.valueOf(formatter.format(gffr.getScore())));
return feature;
}
catch(Throwable t){
t.printStackTrace();
return null;
}
}
}
package ca.bcgsc.sockeye.dataretrieval.chinookP2P;
import java.util.List;
import ca.bcgsc.chinook.client.comobj.SequenceCoordinate;
import ca.bcgsc.chinook.p2p.client.discovery.DiscoveryConditionSet;
import ca.bcgsc.sockeye.dataretrieval.DataRetrievalUnit;
import ca.bcgsc.sockeye.datastorage.events.StorageEvent;
public class MotifDiscoveryP2PDataSource
extends ChinookP2PDataSource {
public static final String MOTIF_DISCOVERY = "motif_discovery";
private int _track=0;
private SequenceCoordinate[] _scs=null;
public MotifDiscoveryP2PDataSource(
int track_id,
DiscoveryConditionSet dcs,
SequenceCoordinate[] scs) throws ChinookP2PDataSourceException {
super(track_id, dcs, scs);
_track = track_id;
_scs = scs;
}
public void storageEventReceived(StorageEvent ex) {
if (ex.getEventType() == StorageEvent.STORAGE_EVENT_TRACK_DATA_REQUEST &&
( (List) ex.getAttribute()).contains(MOTIF_DISCOVERY)) {
super.storageEventReceived(ex);
}
}
protected DataRetrievalUnit createDRU() {
MotifDiscoveryP2PDRU dru = new MotifDiscoveryP2PDRU(this._job, this.getSequenceCoordinates());
this._job_manager.addJobListener(dru);
return dru;
}
public String getDisplayString() {
return new String("Motif Discovery"
+ "\tTrack: " + _track
+ "\tParameters " + _scs);
}
}
package ca.bcgsc.sockeye.dataretrieval.chinookP2P;
import java.util.ArrayList;
import java.util.List;
import ca.bcgsc.chinook.p2p.gui.ds.Job;
import ca.bcgsc.chinook.server.comobj.Report;
import ca.bcgsc.sockeye.datastorage.TrackUtil;
public class NCCP2PDRU
extends ChinookP2PDRU {
static private double THRESHOLD = 1.4;
static private int SMOOTHING_WINDOW_SIZE = 1;
private double maxScore = 0, minScore = Double.MAX_VALUE;
private int wordSize = 0;
public NCCP2PDRU(Job job) {
super(job);
}
protected void deliverData() {
if (this.getJob().getStatus().equals(Job.SUCCESS)) {
int trk_id = _request_to_process.getTrackId();
Report rep = this.getJob().getReport();
List alRawResult = rep.getSimpleArray().getArray();
System.out.println("NCC DRU: Delivering data...");
ArrayList alSmoothedResult = new ArrayList();
TrackUtil.smoothScore(
alRawResult,
trk_id,
wordSize,
SMOOTHING_WINDOW_SIZE,
THRESHOLD,
_request_to_process.getStart() - 1,
alSmoothedResult);
_my_storage_manager.addFeatures(
trk_id,
NCCP2PDataSource.NCC_SCORE_FWD,
alSmoothedResult);
_my_storage_manager.setFeatureVisibility(
NCCP2PDataSource.NCC_SCORE_FWD,
true);
System.out.println("NCCDRU: Delivering data DONE!");
}
}
}
package ca.bcgsc.sockeye.dataretrieval.chinookP2P;
import java.util.Map;
import java.util.List;
import ca.bcgsc.chinook.client.comobj.SequenceCoordinate;
import ca.bcgsc.chinook.p2p.client.discovery.DiscoveryConditionSet;
import ca.bcgsc.sockeye.dataretrieval.DataRetrievalUnit;
import ca.bcgsc.sockeye.datastorage.events.StorageEvent;
public class NCCP2PDataSource
extends ChinookP2PDataSource {
public static final String NCC_SCORE_FWD = "ncc_score_fwd";
public static final String NCC_SCORE_REV = "ncc_score_rev";
Map _parameters;
public NCCP2PDataSource(
int track_id,
DiscoveryConditionSet dcs,
Map parameters) throws ChinookP2PDataSourceException {
super(track_id, dcs,
(SequenceCoordinate[]) parameters.get("SequenceCoordinates"));
_parameters = parameters;
}
public void storageEventReceived(StorageEvent ex) {
if (ex.getEventType() == StorageEvent.STORAGE_EVENT_TRACK_DATA_REQUEST &&
((List) ex.getAttribute()).contains(NCC_SCORE_FWD)|| ((List) ex.getAttribute()).contains(NCC_SCORE_REV)) {
super.storageEventReceived(ex);
}
}
public String getDisplayString(){
return "NCC Scan (P2P)";
}
protected DataRetrievalUnit createDRU() {
NCCP2PDRU dru = new NCCP2PDRU(this._job);
this._job_manager.addJobListener(dru);
return dru;
}
}
package ca.bcgsc.sockeye.dataretrieval.chinookP2P;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.swing.JOptionPane;
import ca.bcgsc.chinook.client.comobj.SequenceCoordinate;
import ca.bcgsc.chinook.p2p.gui.ds.Job;
import ca.bcgsc.chinook.server.comobj.Report;
import ca.bcgsc.sockeye.analysis.Alignment;
import ca.bcgsc.sockeye.analysis.AlignmentException;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.datastorage.StorageException;
import ca.bcgsc.sockeye.datastorage.Track;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.service.featureloader.common.DistributionContainer;
import ca.bcgsc.sockeye.trackmanager.AlignOperation;
import ca.bcgsc.sockeye.trackmanager.TrackManagerFactory;
import ca.bcgsc.sockeye.trackmanager.TrackRelationshipOrderInterface;
import ca.bcgsc.sockeye.util.Log;
import ca.bcgsc.sockeye.gui.Sockeye;
import ca.bcgsc.sockeye.gui.alignment.MultiAlignmentDialog;
public class RAlignmentP2PDRU extends ChinookP2PDRU {
private AlignOperation a_op = null;
private SequenceCoordinate[] _scs;
private List src_regions;
private TrackRelationshipOrderInterface relation;
private int ref_track = -1;
public RAlignmentP2PDRU(Job job, AlignOperation align_op,
SequenceCoordinate[] scs) {
super(job);
this.a_op = align_op;
this._scs = scs;
}
public RAlignmentP2PDRU(Job job, SequenceCoordinate[] scs,
List regions,
TrackRelationshipOrderInterface relation,
int ref_track) {
super(job);
this._scs = scs;
this.src_regions = regions;
this.relation = relation;
this.ref_track = ref_track;
}
protected void retrieveData() {
super.retrieveData();
if (!_request_to_process.isActive()) {
a_op.cancel();
}
}
protected void deliverData() {
String error = null, err_msg = null;
List new_tracks = new ArrayList();
if (this.getJob().getStatus().equals(Job.SUCCESS)) {
try {
a_op = new AlignOperation(src_regions);
a_op.setCurrentRelationship(relation);
a_op.setReferenceTrack(ref_track);
a_op.setAlignApplication(this.getJob().getService().getService());
a_op.setAlignType(AlignmentP2PDataSource.R_ALIGNMENT_APP_TYPE);
int[] up_tracks = new int[src_regions.size()];
for (int t = 0; t < up_tracks.length; t++) up_tracks[t]
= ((TrackFeature)src_regions.get(t)).getTrackId();
TrackManagerFactory.getInstance().addOperation(a_op, up_tracks);
int new_t_id;
for (int t = 0; t < src_regions.size(); t++) {
TrackFeature src_region = (TrackFeature) src_regions.get(t);
Track new_track = new Track(src_region.getStart(), src_region.getEnd());
new_track.setAttribute("ungapped_end", src_region.getEnd() + "");
new_t_id = DataStoreUser.getInstance().getSockeyeTrackList().
addTrack(new_track);
TrackManagerFactory.getInstance().addTrack(a_op, new_t_id);
new_tracks.add(new Integer(new_t_id));
}
Report rep = this.getJob().getReport();
ArrayList results = rep.getSimpleArray().getArray();
Object head_obj = results.get(0);
if (head_obj instanceof String) throw new AlignmentException((String)head_obj);
List alignments = new ArrayList();
List anchors = new ArrayList();
Map header = (Map)head_obj;
String command_line = (String)header.get("CommandLine");
String output_file_id = (String)header.get("OutputFileID");
Map align, aln_seq_map;
TrackFeature region;
int aln_start, aln_end;
List tmp_gaps, gaps;
List old_anchors = (List)((Map)head_obj).get("Anchors");
for (int i = 1; i < results.size(); i++) {
align = (Map)results.get(i);
Alignment new_align = new Alignment(a_op);
new_align.setID(i);
alignments.add(new_align);
for (int j = 0; j < src_regions.size(); j++) {
boolean inversion = false;
aln_seq_map = (HashMap)align.get(new Integer(j));
aln_start = ((Integer)aln_seq_map.get("Start")).intValue();
aln_end = ((Integer)aln_seq_map.get("End")).intValue();
inversion = ((Boolean)aln_seq_map.get("Inverted")).booleanValue();
tmp_gaps = (List)aln_seq_map.get("Gaps");
if (tmp_gaps == null) tmp_gaps = new ArrayList();
gaps = new ArrayList();
int g_end, g_start;
for (int g = 0; g < tmp_gaps.size(); g += 2) {
g_start = ((Integer) tmp_gaps.get(g)).intValue();
g_end = ((Integer) tmp_gaps.get(g + 1)).intValue();
gaps.add(new DistributionContainer(g_start, g_end, 0));
}
region = (TrackFeature)src_regions.get(j);
boolean reversed = false;
for (int s = 0; s < _scs.length; s++) {
if (_scs[s].getName().equals(region.getTrackId() + "")) {
reversed = _scs[s].getStrand().equals("-1");
break;
}
}
new_align.addSequence(region, aln_start, aln_end, reversed, inversion, gaps);
}
}
Map cur_anchor;
int anc_start, anc_end;
for (int i = 1; i < old_anchors.size(); i++) {
cur_anchor = (Map)old_anchors.get(i);
Alignment new_anchor = new Alignment(a_op);
new_anchor.setID(i);
anchors.add(new_anchor);
for (int j = 0; j < src_regions.size(); j++) {
List coords = (List)cur_anchor.get(new Integer(j));
anc_start = ((Integer)coords.get(0)).intValue();
anc_end = ((Integer)coords.get(1)).intValue();
region = (TrackFeature)src_regions.get(j);
boolean reversed = false;
for (int s = 0; s < _scs.length; s++) {
if (_scs[s].getName().equals(region.getTrackId() + "")) {
reversed = _scs[s].getStrand().equals("-1");
break;
}
}
new_anchor.addSequence(region, anc_start, anc_end, reversed, false, null);
}
}
a_op.addSubalignments(alignments);
a_op.addAnchors(anchors);
a_op.setCommandline(command_line);
a_op.setOutputFileID(output_file_id);
a_op.complete();
try {
MultiAlignmentDialog dialog = new MultiAlignmentDialog(a_op);
} catch (Exception e) {
Log.printStackTrace(e);
}
} catch (AlignmentException e) {
Log.printStackTrace(e);
error = "Cannot complete alignment";
err_msg = "Unable to retrieve alignment data:\n" + e.getMessage();
} catch (StorageException e) {
Log.printStackTrace(e);
error = "Cannot complete alignment";
err_msg =
"Source sequences were deleted before the\noperation could complete.";
} catch (Exception e) {
Log.printStackTrace(e);
error = "Cannot complete alignment";
err_msg = e.getClass().getName() + ": " + e.getMessage();
}
if (error != null)
try {
a_op.cancel();
JOptionPane.showMessageDialog(
Sockeye.__frame,
err_msg,
error,
JOptionPane.ERROR_MESSAGE);
} catch (Exception e) {
Log.printStackTrace(e);
}
}
}
}
package ca.bcgsc.sockeye.dataretrieval.chinookfactory;
import ca.bcgsc.sockeye.dataretrieval.*;
import java.util.List;
public interface ChinookDataSourceFactory {
DataSource getAlignmentDS(List regions);
DataSource getNCCDS(List regions);
DataSource getMotifDiscoveryDS(List regions);
DataSource getMcsDS(List regions);
DataSource getPrimerPredictionDS(List regions);
DataSource getRAlignmentDS(List features);
}
package ca.bcgsc.sockeye.dataretrieval.chinookfactory;
import ca.bcgsc.sockeye.config.Configuration;
public class ChinookDataSourceFactoryMaker {
private static ChinookFactory _chinook_old_style_factory = new ChinookFactory();
private static ChinookP2PFactory _chinook_p2p_style_factory = new ChinookP2PFactory();
public ChinookDataSourceFactoryMaker() {
}
public static ChinookDataSourceFactory getFactory(){
if (Configuration.getUseP2P())
return _chinook_p2p_style_factory;
else
return _chinook_old_style_factory;
}
}
package ca.bcgsc.sockeye.dataretrieval.chinookfactory;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.StringTokenizer;
import java.util.TreeMap;
import javax.swing.JOptionPane;
import ca.bcgsc.chinook.client.comobj.SequenceCoordinate;
import ca.bcgsc.chinook.server.comobj.ApplicationParameter;
import ca.bcgsc.sockeye.analysis.AlignmentException;
import ca.bcgsc.sockeye.analysis.SequenceMatrix;
import ca.bcgsc.sockeye.dataretrieval.DataSource;
import ca.bcgsc.sockeye.dataretrieval.EnsemblDataSource;
import ca.bcgsc.sockeye.dataretrieval.NCCDataSource;
import ca.bcgsc.sockeye.dataretrieval.chinook.AlignmentDataSource;
import ca.bcgsc.sockeye.dataretrieval.chinook.ChinookUser;
import ca.bcgsc.sockeye.dataretrieval.chinook.McsDataSource;
import ca.bcgsc.sockeye.dataretrieval.chinook.MotifDiscoveryDataSource;
import ca.bcgsc.sockeye.dataretrieval.chinook.PrimerPredictionDataSource;
import ca.bcgsc.sockeye.dataretrieval.chinook.client.gui.container.ParameterEntryContainer;
import ca.bcgsc.sockeye.dataretrieval.chinook.client.gui.container.SequenceEntryContainer;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.datastorage.SockeyeTrackList;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.gui.Sockeye;
import ca.bcgsc.sockeye.trackmanager.AlignOperation;
import ca.bcgsc.sockeye.trackmanager.TrackManagerFactory;
import ca.bcgsc.sockeye.trackmanager.TrackRelationshipOrderInterface;
import ca.bcgsc.sockeye.util.Log;
import ca.bcgsc.sockeye.util.StringUtils;
import ca.bcgsc.util.SequenceUtils;
public class ChinookFactory implements ChinookDataSourceFactory {
private static final String NCC_SCAN = "NCC Scan";
private static final String PRIMER_PREDICTION = "Primer Prediction";
private static final String MCS = "MCS Calculation";
public ChinookFactory() {
}
public DataSource getAlignmentDS(List regions) {
return getAlignmentTypeDS(regions, AlignmentDataSource.ALIGNMENT_APP_TYPE);
}
public DataSource getRAlignmentDS(List regions) {
return getAlignmentTypeDS(regions, AlignmentDataSource.R_ALIGNMENT_APP_TYPE);
}
private DataSource getAlignmentTypeDS(List regions, String align_type) {
try {
boolean loop_once = false;
AlignOperation align = new AlignOperation(regions);
while (!loop_once) {
loop_once = true;
TreeMap trk_names = new TreeMap();
TreeMap trk_region = new TreeMap();
int t_trk_id = -1;
for (int i = 0; i < regions.size(); i++) {
TrackFeature region = (TrackFeature) regions.get(i);
t_trk_id = region.getTrackId();
String name = (String) DataStoreUser.getInstance()
.getSockeyeTrackList().getTrackAttribute(t_trk_id, "track_name");
trk_names.put(new Integer(t_trk_id), name);
trk_region.put(new Integer(t_trk_id), region);
}
List align_relations = align.getAllRelationships();
List rel_names_keys = new ArrayList();
Map rel_names = new HashMap();
for (Iterator itr = align_relations.iterator(); itr.hasNext();) {
TrackRelationshipOrderInterface rel = (TrackRelationshipOrderInterface) itr
.next();
String rel_name = rel.getType();
rel_names.put(rel_name, rel);
rel_names_keys.add(rel_name);
}
Object[] rel_objs = rel_names_keys.toArray();
String rel_name = (String) JOptionPane.showInputDialog(Sockeye.__frame,
"Choose an initial track/gene relationship for alignment.",
"Initial Alignment Relationship Dialog",
JOptionPane.OK_CANCEL_OPTION, null, rel_objs, rel_objs[0]);
if (rel_name == null)
break;
TrackRelationshipOrderInterface relation = (TrackRelationshipOrderInterface) rel_names
.get(rel_name);
align.setCurrentRelationship(relation);
int ref_track = -1;
if (!relation.getType().equals(
TrackRelationshipOrderInterface.TYPE_TRACKORDER)) {
ArrayList track_names = new ArrayList(trk_names.values());
String track_name = (String) JOptionPane.showInputDialog(
Sockeye.__frame, "Choose an initial reference track",
"Reference Track Selection Dialog", JOptionPane.OK_CANCEL_OPTION,
null, track_names.toArray(), track_names.get(0));
if (track_name == null)
break;
for (Iterator itr = trk_names.keySet().iterator(); itr.hasNext();) {
Integer trk_id = (Integer) itr.next();
String name = (String) trk_names.get(trk_id);
if (name.equals(track_name)) {
ref_track = trk_id.intValue();
break;
}
}
if (ref_track == -1)
throw new AlignmentException("Unable to determine reference track.");
}
align.setReferenceTrack(ref_track);
List src_tracks_list = align.getSourceTracks();
int[] source_tracks = new int[src_tracks_list.size()];
for (int i = 0; i < source_tracks.length; i++) {
source_tracks[i] = ((Integer) src_tracks_list.get(i)).intValue();
}
ChinookUser cc = new ChinookUser();
List methods = cc.getApplicationNamesForType(align_type);
if (methods == null || methods.size() == 0) {
String extra = align_type
.equals(AlignmentDataSource.R_ALIGNMENT_APP_TYPE) ? "rearrangement"
: "";
JOptionPane.showMessageDialog(Sockeye.__frame,
"The application server has no " + extra
+ " alignment applications available.", "Error",
JOptionPane.ERROR_MESSAGE);
break;
}
HashMap param_map = new HashMap();
for (int i = 0; i < methods.size(); i++) {
String method = (String) methods.get(i);
ArrayList params = new ArrayList(cc.getApplicationParameters(method));
param_map.put(method, params);
}
String align_method = (String) JOptionPane.showInputDialog(
Sockeye.__frame, "Choose an alignment application",
"Application Selection Dialog", JOptionPane.OK_CANCEL_OPTION, null,
methods.toArray(), methods.get(0));
if (align_method == null)
break;
int number_of_req_sequences = cc
.getMinimumNumberOfSequencesForApplicationName(align_method);
int number_of_max_sequences = cc
.getMaximumNumberOfSequencesForApplicationName(align_method);
int number_of_regions = regions.size();
if (number_of_regions < number_of_req_sequences
|| number_of_regions > number_of_max_sequences) {
String msg = align_method + " requires between "
+ number_of_req_sequences + " and " + number_of_max_sequences
+ " input sequences";
if (number_of_req_sequences == number_of_max_sequences) {
msg = align_method + " requires exactly " + number_of_req_sequences
+ " input sequences";
}
throw new RuntimeException(msg);
}
SequenceCoordinate[] seq_coords = new SequenceCoordinate[number_of_regions];
HashMap strand_defaults = new HashMap();
boolean seq4000 = false;
for (int j = 0; j < source_tracks.length; j++) {
int t_id = source_tracks[j];
TrackFeature region = (TrackFeature) trk_region
.get(new Integer(t_id));
String species = "unknown";
String version = "";
String chromosome = "";
List species_list = DataStoreUser.getInstance()
.getDataSourceManager().getTrackSpecies(t_id);
List version_list = DataStoreUser.getInstance()
.getDataSourceManager().getTrackDatabases(t_id);
List chrom_list = DataStoreUser.getInstance().getDataSourceManager()
.getTrackChromosomes(t_id);
if (species_list.size() > 0)
species = StringUtils.getShortSpeciesName((String) species_list
.get(0));
if (version_list.size() > 0)
version = (String) version_list.get(0);
if (chrom_list.size() > 0)
chromosome = (String) chrom_list.get(0);
StringTokenizer tok = new StringTokenizer(version, "_");
version = "";
while (tok.hasMoreTokens()) {
try {
version += "_" + Integer.parseInt(tok.nextToken());
} catch (NumberFormatException e) {
}
}
if (version.length() > 0)
version = version.substring(1);
String track_name = StringUtils.getShortNameForTrackID(t_id);
boolean isCurrentReversed = DataStoreUser.getInstance()
.getSockeyeTrackList().getTrackReverse(t_id);
strand_defaults.put(t_id + "", isCurrentReversed ? "-1" : "1");
String sequence = DataStoreUser.getInstance().getSockeyeTrackList()
.getFeatureSequence(region);
seq_coords[j] = new SequenceCoordinate(track_name, species,
chromosome, region.getStart(), region.getEnd(),
isCurrentReversed ? "-1" : "1", version, sequence);
if ((region.getEnd() - region.getStart() + 1) > 4000)
seq4000 = true;
}
if (align_method.startsWith("CONREAL") && seq4000) {
String msg = "One of the sequences is too long \n";
msg += "Maximum length accepted by CONREAL is 4000 bps";
throw new RuntimeException(msg);
}
int job_id = 0;
SequenceEntryContainer sec = new SequenceEntryContainer(seq_coords);
int sval = JOptionPane.showConfirmDialog(Sockeye.__frame, sec,
"Parameter Entry", JOptionPane.OK_CANCEL_OPTION);
if (sval == JOptionPane.CANCEL_OPTION
|| sval == JOptionPane.CLOSED_OPTION)
break;
SequenceCoordinate[] scs = sec.getSequenceParameters();
for (int k = 0; k < scs.length; k++) {
String species = scs[k].getSpecies();
if (species.endsWith(".gff")) {
String[] split_sp = species.split(" ");
scs[k].setSpecies(SequenceMatrix.getLongSpeciesName(split_sp[0]));
scs[k].setChromosome((split_sp[2].split("-"))[0]);
}
if (align_method.equals("MLAGAN") && species.equals("unknown")) {
species = scs[k].getName().replace('(', '[').replace(')', ']');
scs[k].setSpecies(species);
}
scs[k].setName(source_tracks[k] + "");
String selected_strand = scs[k].getStrand();
String default_strand = (String) strand_defaults
.get(scs[k].getName());
if (!selected_strand.equals(default_strand)) {
scs[k].setSequence(SequenceUtils.reverseComplementSequence(scs[k]
.getSequence()));
}
Log.println("Transmitting the following region-sequence:\n"
+ scs[k].getSequence() + "\n");
}
ArrayList req_parameters = (ArrayList) param_map.get(align_method);
if (sval == JOptionPane.OK_OPTION) {
ParameterEntryContainer pec = new ParameterEntryContainer(
req_parameters);
int val1 = JOptionPane.showConfirmDialog(Sockeye.__frame, pec,
"Parameter Entry", JOptionPane.OK_CANCEL_OPTION);
if (val1 == JOptionPane.CANCEL_OPTION
|| val1 == JOptionPane.CLOSED_OPTION)
break;
if (val1 == JOptionPane.OK_OPTION) {
ApplicationParameter[] parameters = pec.getApplicationParameters();
HashMap parameter_values = new HashMap();
parameter_values.put("ApplicationParameters", parameters);
parameter_values.put("SequenceCoordinates", scs);
int[] new_tracks = new int[regions.size()];
int ds_track = 0;
Date date = new Date();
SockeyeTrackList t_list = DataStoreUser.getInstance()
.getSockeyeTrackList();
for (int i = 0; i < source_tracks.length; i++) {
int src_trk_id = source_tracks[i];
TrackFeature region = (TrackFeature) trk_region.get(new Integer(
src_trk_id));
new_tracks[i] = t_list.cloneTrack(src_trk_id, region.getStart(),
region.getEnd());
t_list.removeFeature(new_tracks[i], "region");
t_list.setTrackAttribute(new_tracks[i], "ungapped_end", region
.getEnd()
+ "");
t_list.setTrackAttribute(new_tracks[i], "track_name", "["
+ align_method + "] Pending...");
t_list.setTrackVisibility(new_tracks[i], false);
if (i == 0) {
ds_track = new_tracks[i];
}
TrackManagerFactory.getInstance().addTrack(align, new_tracks[i]);
}
TrackManagerFactory.getInstance()
.addOperation(align, source_tracks);
AlignmentDataSource chinook_ds = new AlignmentDataSource(ds_track,
align_type, align_method, parameter_values, Boolean
.valueOf(true), cc);
return chinook_ds;
}
}
}
align.cancel();
} catch (Exception e) {
Log.printStackTrace(e);
JOptionPane.showMessageDialog(Sockeye.__frame, "Cannot run alignment ("
+ e.getMessage() + ").", "Warning", JOptionPane.WARNING_MESSAGE);
}
return null;
}
public DataSource getNCCDS(List regions) {
TrackFeature feature = (TrackFeature) regions.get(0);
try {
int t_id = feature.getTrackId();
ChinookUser cu = new ChinookUser();
ArrayList params = new ArrayList(cu.getApplicationParameters(NCC_SCAN));
String species = "", chromosome = "", version = "";
List ds_list = DataStoreUser.getInstance().getSockeyeTrackList()
.getDataSources(t_id);
Iterator ds_it = ds_list.iterator();
while (ds_it.hasNext()) {
DataSource ds = DataStoreUser.getInstance().getDataSourceManager()
.getDataSource(Integer.parseInt(ds_it.next().toString()));
if (ds instanceof EnsemblDataSource) {
species = ((EnsemblDataSource) ds).getSpecies();
chromosome = ((EnsemblDataSource) ds).getChromosome();
version = ((EnsemblDataSource) ds).getVersion();
break;
}
}
boolean isCurrentReversed = DataStoreUser.getInstance()
.getSockeyeTrackList().getTrackReverse(t_id);
String sequence = DataStoreUser.getInstance().getSockeyeTrackList()
.getFeatureSequence(feature);
Log.println("Transmitting the following region-sequence:\n" + sequence
+ "\n");
SequenceCoordinate[] seq_coords = { new SequenceCoordinate(t_id + "",
species, chromosome, feature.getStart(), feature.getEnd(),
isCurrentReversed ? "-1" : "1", version, sequence) };
SequenceEntryContainer sec = new SequenceEntryContainer(seq_coords);
int sval = JOptionPane.showConfirmDialog(Sockeye.__frame, sec,
"Parameter Entry", JOptionPane.OK_CANCEL_OPTION);
SequenceCoordinate[] scs = sec.getSequenceParameters();
for (int k = 0; k < scs.length; k++) {
String sp = seq_coords[k].getSpecies();
if (sp.endsWith(".gff")) {
String[] split_sp = sp.split(" ");
seq_coords[k].setSpecies(SequenceMatrix
.getLongSpeciesName(split_sp[0]));
seq_coords[k].setChromosome((split_sp[2].split("-"))[0]);
}
}
if (sval == JOptionPane.OK_OPTION) {
ParameterEntryContainer pec = new ParameterEntryContainer(params);
int val1 = JOptionPane.showConfirmDialog(Sockeye.__frame, pec,
"Parameter Entry", JOptionPane.OK_CANCEL_OPTION);
NCCDataSource ncc_ds = null;
if (val1 == JOptionPane.OK_OPTION) {
ApplicationParameter[] parameters = pec.getApplicationParameters();
HashMap parameter_values = new HashMap();
parameter_values.put("ApplicationParameters", parameters);
parameter_values.put("SequenceCoordinates", scs);
ncc_ds = null;
}
return ncc_ds;
}
} catch (Throwable e1) {
Log.printStackTrace(e1);
JOptionPane.showMessageDialog(Sockeye.__frame, "Cannot run " + NCC_SCAN
+ ".", "Warning", JOptionPane.WARNING_MESSAGE);
}
return null;
}
public DataSource getMotifDiscoveryDS(List regions) {
try {
ChinookUser cu = new ChinookUser();
List applications = cu.getApplicationNamesForType("MOTIF DISCOVERY");
HashMap param_map = new HashMap();
for (int i = 0; i < applications.size(); i++) {
String method = (String) applications.get(i);
ArrayList params = new ArrayList(cu.getApplicationParameters(method));
param_map.put(method, params);
}
String discovery_method = (String) JOptionPane.showInputDialog(
Sockeye.__frame, "Choose an motif discovery method",
"Discovery Method Selection Dialog", JOptionPane.OK_CANCEL_OPTION,
null, applications.toArray(), applications.get(0));
if (discovery_method == null)
return null;
int number_of_req_sequences = cu
.getMinimumNumberOfSequencesForApplicationName(discovery_method);
int number_of_regions = regions.size();
if (number_of_regions < number_of_req_sequences) {
throw new RuntimeException(
"Need at least two sequences to run the algorithm");
}
SequenceCoordinate[] seq_coords = new SequenceCoordinate[number_of_regions];
int master_track_id = 0;
for (int i = 0; i < regions.size(); i++) {
TrackFeature region = (TrackFeature) regions.get(i);
int t_id = region.getTrackId();
if (i == 0)
master_track_id = t_id;
String species = "", chromosome = "", version = "";
List ds_list = DataStoreUser.getInstance().getSockeyeTrackList()
.getDataSources(t_id);
Iterator ds_it = ds_list.iterator();
while (ds_it.hasNext()) {
DataSource ds = DataStoreUser.getInstance().getDataSourceManager()
.getDataSource(Integer.parseInt(ds_it.next().toString()));
if (ds instanceof EnsemblDataSource) {
species = ((EnsemblDataSource) ds).getSpecies();
chromosome = ((EnsemblDataSource) ds).getChromosome();
version = ((EnsemblDataSource) ds).getVersion();
}
}
boolean isCurrentReversed = DataStoreUser.getInstance()
.getSockeyeTrackList().getTrackReverse(t_id);
String sequence = DataStoreUser.getInstance().getSockeyeTrackList()
.getFeatureSequence(region);
Log.println("Transmitting the following region-sequence:\n" + sequence
+ "\n");
seq_coords[i] = new SequenceCoordinate(t_id + "", species, chromosome,
region.getStart(), region.getEnd(), isCurrentReversed ? "-1" : "1",
version, sequence);
}
SequenceEntryContainer sec = new SequenceEntryContainer(seq_coords);
int sval = JOptionPane.showConfirmDialog(Sockeye.__frame, sec,
"Input Region", JOptionPane.OK_CANCEL_OPTION);
SequenceCoordinate[] scs = sec.getSequenceParameters();
for (int k = 0; k < scs.length; k++) {
String sp = seq_coords[k].getSpecies();
if (sp.endsWith(".gff")) {
String[] split_sp = sp.split(" ");
seq_coords[k].setSpecies(SequenceMatrix
.getLongSpeciesName(split_sp[0]));
seq_coords[k].setChromosome((split_sp[2].split("-"))[0]);
}
}
if (sval == JOptionPane.OK_OPTION) {
String background_model = "";
if (discovery_method.equals("MotifSampler")) {
String[] background = MotifDiscoveryDataSource.background_model;
background_model = (String) JOptionPane.showInputDialog(
Sockeye.__frame, "Choose a background model",
"Discovery Method Selection Dialog",
JOptionPane.OK_CANCEL_OPTION, null, background, background[0]);
if (background_model == null)
return null;
}
ArrayList all_params = (ArrayList) param_map.get(discovery_method);
if (discovery_method.equals("MotifSampler")) {
for (int i = 0; i < all_params.size(); i++) {
ApplicationParameter param = (ApplicationParameter) all_params
.get(i);
if (param.name.equals("BACKGROUND")) {
param.value = background_model;
}
}
}
ParameterEntryContainer pec = new ParameterEntryContainer(all_params);
int val1 = JOptionPane.showConfirmDialog(Sockeye.__frame, pec,
"Parameter Entry", JOptionPane.OK_CANCEL_OPTION);
if (val1 == JOptionPane.OK_OPTION) {
ApplicationParameter[] parameters = pec.getApplicationParameters();
HashMap parameter_values = new HashMap();
parameter_values.put("ApplicationParameters", parameters);
parameter_values.put("SequenceCoordinates", scs);
MotifDiscoveryDataSource motif_ds = new MotifDiscoveryDataSource(
master_track_id, discovery_method, parameter_values,
Boolean.TRUE, cu);
return motif_ds;
}
}
} catch (Throwable e1) {
Log.printStackTrace(e1);
JOptionPane.showMessageDialog(Sockeye.__frame, e1.getMessage(),
"Warning", JOptionPane.WARNING_MESSAGE);
}
return null;
}
public DataSource getPrimerPredictionDS(List regions) {
TrackFeature feature = (TrackFeature) regions.get(0);
try {
int t_id = feature.getTrackId();
ChinookUser cu = new ChinookUser();
ArrayList params = new ArrayList(cu
.getApplicationParameters(PRIMER_PREDICTION));
String species = "", chromosome = "", version = "";
List ds_list = DataStoreUser.getInstance().getSockeyeTrackList()
.getDataSources(t_id);
Iterator ds_it = ds_list.iterator();
while (ds_it.hasNext()) {
DataSource ds = DataStoreUser.getInstance().getDataSourceManager()
.getDataSource(Integer.parseInt(ds_it.next().toString()));
if (ds instanceof EnsemblDataSource) {
species = ((EnsemblDataSource) ds).getSpecies();
chromosome = ((EnsemblDataSource) ds).getChromosome();
version = ((EnsemblDataSource) ds).getVersion();
break;
}
}
boolean isCurrentReversed = DataStoreUser.getInstance()
.getSockeyeTrackList().getTrackReverse(t_id);
String sequence = DataStoreUser.getInstance().getSockeyeTrackList()
.getFeatureSequence(feature);
Log.println("Transmitting the following region-sequence:\n" + sequence
+ "\n");
SequenceCoordinate[] seq_coords = { new SequenceCoordinate(t_id + "",
species, chromosome, feature.getStart(), feature.getEnd(),
isCurrentReversed ? "-1" : "1", version, sequence) };
SequenceEntryContainer sec = new SequenceEntryContainer(seq_coords);
int sval = JOptionPane.showConfirmDialog(Sockeye.__frame, sec,
"Parameter Entry", JOptionPane.OK_CANCEL_OPTION);
SequenceCoordinate[] scs = sec.getSequenceParameters();
for (int k = 0; k < scs.length; k++) {
String sp = seq_coords[k].getSpecies();
if (sp.endsWith(".gff")) {
String[] split_sp = sp.split(" ");
seq_coords[k].setSpecies(SequenceMatrix
.getLongSpeciesName(split_sp[0]));
seq_coords[k].setChromosome((split_sp[2].split("-"))[0]);
}
}
if (sval == JOptionPane.OK_OPTION) {
ParameterEntryContainer pec = new ParameterEntryContainer(params);
int val1 = JOptionPane.showConfirmDialog(Sockeye.__frame, pec,
"Parameter Entry", JOptionPane.OK_CANCEL_OPTION);
PrimerPredictionDataSource pr_ds = null;
if (val1 == JOptionPane.OK_OPTION) {
ApplicationParameter[] parameters = pec.getApplicationParameters();
HashMap parameter_values = new HashMap();
parameter_values.put("ApplicationParameters", parameters);
parameter_values.put("SequenceCoordinates", scs);
pr_ds = new PrimerPredictionDataSource(t_id, PRIMER_PREDICTION,
parameter_values, new Boolean(true), cu);
}
return pr_ds;
}
} catch (Throwable e1) {
Log.printStackTrace(e1);
JOptionPane.showMessageDialog(Sockeye.__frame, "Cannot run "
+ PRIMER_PREDICTION + ".", "Warning", JOptionPane.WARNING_MESSAGE);
}
return null;
}
public DataSource getMcsDS(List regions) {
try {
HashMap region_feature = new HashMap();
for (int i = 0; i < regions.size(); i++) {
TrackFeature region = (TrackFeature) regions.get(i);
int t_trk_id = region.getTrackId();
String name = (String) DataStoreUser.getInstance()
.getSockeyeTrackList().getTrackAttribute(t_trk_id, "track_name");
region_feature.put(name, region);
}
Object[] region_names = region_feature.keySet().toArray();
String reference_track_name = (String) JOptionPane.showInputDialog(
Sockeye.__frame, "Choose a reference track to perform MCS",
"Reference Track Selection Dialog", JOptionPane.OK_CANCEL_OPTION,
null, region_names, region_names[0]);
if (reference_track_name == null) {
return null;
}
SequenceCoordinate[] seq_coords = new SequenceCoordinate[regions.size()];
int master_track_pos = 0;
int master_track_id = 0;
int j = 0;
String ucscCoord = "";
String refSpecie = "";
for (Iterator i = region_feature.keySet().iterator(); i.hasNext();) {
String trackName = (String) i.next();
if (!reference_track_name.equals(trackName)) {
j += 1;
}
TrackFeature region = (TrackFeature) region_feature.get(trackName);
int t_id = region.getTrackId();
String species = "", chromosome = "", version = "";
List ds_list = DataStoreUser.getInstance().getSockeyeTrackList()
.getDataSources(t_id);
Iterator ds_it = ds_list.iterator();
while (ds_it.hasNext()) {
DataSource ds = DataStoreUser.getInstance().getDataSourceManager()
.getDataSource(Integer.parseInt(ds_it.next().toString()));
if (ds instanceof EnsemblDataSource) {
species = ((EnsemblDataSource) ds).getSpecies();
chromosome = ((EnsemblDataSource) ds).getChromosome();
version = ((EnsemblDataSource) ds).getVersion();
break;
}
}
if (reference_track_name.equals(trackName)) {
master_track_id = region.getTrackId();
int ver_int = 0;
if (!version.equals("")) {
String verArray[] = version.split("_");
ver_int = new Integer(verArray[0]).intValue();
}
if ((species.equals("Homo_sapiens") && (ver_int >= 18))
|| ((species.equals("Mus_musculus") && (ver_int >= 18)))) {
ucscCoord = "chr" + chromosome + ":" + region.getStart() + "-"
+ region.getEnd();
refSpecie = species;
} else {
JOptionPane
.showMessageDialog(
Sockeye.__frame,
"Currently MCS can only run on reference track containing" +
" Homo sapiens or Mus musculus"
+ " version 18 or higher", "Warning",
JOptionPane.WARNING_MESSAGE);
return null;
}
}
boolean isCurrentReversed = DataStoreUser.getInstance()
.getSockeyeTrackList().getTrackReverse(t_id);
String sequence = DataStoreUser.getInstance().getSockeyeTrackList()
.getFeatureSequence(region);
Log.println("Transmitting the following region-sequence:\n" + sequence
+ "\n");
if (reference_track_name.equals(trackName))
seq_coords[master_track_pos] = new SequenceCoordinate(t_id + "",
species, chromosome, region.getStart(), region.getEnd(),
isCurrentReversed ? "-1" : "1", version, sequence);
else
seq_coords[master_track_pos + j] = new SequenceCoordinate(t_id + "",
species, chromosome, region.getStart(), region.getEnd(),
isCurrentReversed ? "-1" : "1", version, sequence);
}
SequenceEntryContainer sec = new SequenceEntryContainer(seq_coords);
int sval = JOptionPane.showConfirmDialog(Sockeye.__frame, sec,
"Input Region", JOptionPane.OK_CANCEL_OPTION);
SequenceCoordinate[] scs = sec.getSequenceParameters();
for (int k = 0; k < scs.length; k++) {
String sp = seq_coords[k].getSpecies();
if (sp.endsWith(".gff")) {
String[] split_sp = sp.split(" ");
seq_coords[k].setSpecies(SequenceMatrix
.getLongSpeciesName(split_sp[0]));
seq_coords[k].setChromosome((split_sp[2].split("-"))[0]);
}
}
if (sval == JOptionPane.OK_OPTION) {
ChinookUser cu = new ChinookUser();
ArrayList params = new ArrayList(cu.getApplicationParameters(MCS));
for (Iterator i = params.iterator(); i.hasNext();) {
ApplicationParameter tmpParam = (ApplicationParameter) i.next();
if (tmpParam.name.equals("c"))
tmpParam.value = ucscCoord;
if (tmpParam.name.equals("s"))
tmpParam.value = refSpecie;
}
ParameterEntryContainer pec = new ParameterEntryContainer(params);
int val1 = JOptionPane.showConfirmDialog(Sockeye.__frame, pec,
"Parameter Entry", JOptionPane.OK_CANCEL_OPTION);
if (val1 == JOptionPane.OK_OPTION) {
ApplicationParameter[] parameters = pec.getApplicationParameters();
HashMap parameter_values = new HashMap();
parameter_values.put("ApplicationParameters", parameters);
parameter_values.put("SequenceCoordinates", scs);
McsDataSource mcs_ds = new McsDataSource(master_track_id, MCS,
parameter_values, Boolean.TRUE, cu);
return mcs_ds;
}
}
} catch (Throwable e1) {
Log.printStackTrace(e1);
JOptionPane.showMessageDialog(Sockeye.__frame, "Cannot run " + MCS + ".",
"Warning", JOptionPane.WARNING_MESSAGE);
}
return null;
}
}/*------
package ca.bcgsc.sockeye.dataretrieval.chinookfactory;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import javax.swing.JOptionPane;
import ca.bcgsc.chinook.client.comobj.SequenceCoordinate;
import ca.bcgsc.chinook.p2p.client.discovery.DiscoveryCondition;
import ca.bcgsc.chinook.p2p.client.discovery.DiscoveryConditionSet;
import ca.bcgsc.sockeye.analysis.SequenceMatrix;
import ca.bcgsc.sockeye.dataretrieval.DataSource;
import ca.bcgsc.sockeye.dataretrieval.EnsemblDataSource;
import ca.bcgsc.sockeye.dataretrieval.chinookP2P.AlignmentP2PDataSource;
import ca.bcgsc.sockeye.dataretrieval.chinookP2P.ChinookP2PDataSourceException;
import ca.bcgsc.sockeye.dataretrieval.chinookP2P.MotifDiscoveryP2PDataSource;
import ca.bcgsc.sockeye.dataretrieval.chinookP2P.NCCP2PDataSource;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.gui.Sockeye;
import ca.bcgsc.sockeye.trackmanager.AlignOperation;
import ca.bcgsc.sockeye.trackmanager.TrackManagerFactory;
import ca.bcgsc.sockeye.trackmanager.TrackRelationshipOrderInterface;
import ca.bcgsc.sockeye.util.Log;
public class ChinookP2PFactory
implements ChinookDataSourceFactory {
public DataSource getAlignmentDS(List regions) {
return getAlignmentTypeDS(regions, AlignmentP2PDataSource.ALIGNMENT_APP_TYPE);
}
public DataSource getRAlignmentDS(List regions) {
return getAlignmentTypeDS(regions, AlignmentP2PDataSource.R_ALIGNMENT_APP_TYPE);
}
private DataSource getAlignmentTypeDS(List regions, String align_type) {
TreeMap trk_names = new TreeMap();
TreeMap trk_region = new TreeMap();
int t_trk_id = -1;
for (int i = 0; i < regions.size(); i++) {
TrackFeature region = (TrackFeature) regions.get(i);
t_trk_id = region.getTrackId();
String name = (String) DataStoreUser.getInstance().getSockeyeTrackList().
getTrackAttribute(t_trk_id, "track_name");
trk_names.put(new Integer(t_trk_id), name);
trk_region.put(new Integer(t_trk_id), region);
}
AlignOperation align = new AlignOperation(regions);
boolean one_loop = false;
while (!one_loop) {
one_loop = true;
List align_relations = align.getAllRelationships();
List rel_names_keys = new ArrayList();
Map rel_names = new HashMap();
for (Iterator itr = align_relations.iterator(); itr.hasNext(); ) {
TrackRelationshipOrderInterface rel = (TrackRelationshipOrderInterface)
itr.next();
String rel_name = rel.getType();
rel_names.put(rel_name, rel);
rel_names_keys.add(rel_name);
}
Object[] rel_objs = rel_names_keys.toArray();
String rel_name =
(String) JOptionPane.showInputDialog(
Sockeye.__frame,
"Choose an initial track/gene relationship for alignment.",
"Initial Alignment Relationship Dialog",
JOptionPane.OK_CANCEL_OPTION,
null, rel_objs, rel_objs[0]);
if (rel_name == null) break;
TrackRelationshipOrderInterface relation = (
TrackRelationshipOrderInterface) rel_names.get(rel_name);
align.setCurrentRelationship(relation);
int ref_track = -1;
if (!relation.getType().equals(TrackRelationshipOrderInterface.
TYPE_TRACKORDER)) {
ArrayList track_names = new ArrayList(trk_names.values());
String track_name =
(String) JOptionPane.showInputDialog(
Sockeye.__frame,
"Choose an initial reference track",
"Reference Track Selection Dialog",
JOptionPane.OK_CANCEL_OPTION,
null,
track_names.toArray(),
track_names.get(0));
if (track_name == null) break;
for (Iterator itr = trk_names.keySet().iterator(); itr.hasNext(); ) {
Integer trk_id = (Integer) itr.next();
String name = (String) trk_names.get(trk_id);
if (name.equals(track_name)) {
ref_track = trk_id.intValue();
break;
}
}
if (ref_track == -1) {
align.cancel();
throw new RuntimeException("Unable to determine reference track.");
}
}
align.setReferenceTrack(ref_track);
List src_tracks_list = align.getSourceTracks();
int[] source_tracks = new int[src_tracks_list.size()];
for (int i = 0; i < source_tracks.length; i++) {
source_tracks[i] = ( (Integer) src_tracks_list.get(i)).intValue();
}
int number_of_regions = regions.size();
SequenceCoordinate[] seq_coords = new SequenceCoordinate[
number_of_regions];
for (int j = 0; j < source_tracks.length; j++) {
int t_id = source_tracks[j];
TrackFeature region = (TrackFeature) trk_region.get(new Integer(t_id));
String species = "", chromosome = "", version = "";
List ds_list = DataStoreUser.getInstance().getSockeyeTrackList().
getDataSources(t_id);
Iterator ds_it = ds_list.iterator();
while (ds_it.hasNext()) {
DataSource ds =
DataStoreUser.getInstance().getDataSourceManager().getDataSource(
Integer.parseInt(ds_it.
next().toString()));
if (ds instanceof EnsemblDataSource) {
species = ( (EnsemblDataSource) ds).getSpecies();
chromosome = ( (EnsemblDataSource) ds).getChromosome();
version = ( (EnsemblDataSource) ds).getVersion();
}
}
boolean isCurrentReversed =
DataStoreUser.getInstance().getSockeyeTrackList().getTrackReverse(
t_id);
String sequence = DataStoreUser.getInstance().getSockeyeTrackList().getFeatureSequence(region);
Log.println("Transmitting the following region-sequence:\n" + sequence + "\n");
seq_coords[j] =
new SequenceCoordinate(t_id + "",
species,
chromosome,
region.getStart(),
region.getEnd(),
isCurrentReversed?"-1":"1",
version, sequence);
}
TrackManagerFactory.getInstance().addOperation(align, source_tracks);
DiscoveryConditionSet dcs = new DiscoveryConditionSet();
try {
dcs.addDiscoveryCondition(new DiscoveryCondition(DiscoveryCondition.
DISCOVERY_MODE_BY_MATCHES_APPLICATION_TYPE, align_type));
}
catch (Exception e) {
Log.printStackTrace(e);
align.cancel();
return null;
}
align.cancel();
AlignmentP2PDataSource ap2pds = new AlignmentP2PDataSource(align.
getReferenceTrack(),
align_type,
dcs,
seq_coords,
regions,
relation,
align.getReferenceTrack());
return ap2pds;
}
align.cancel();
return null;
}
public DataSource getNCCDS(List regions) {
TrackFeature feature = (TrackFeature) regions.get(0);
if (feature == null)
throw new IllegalArgumentException("Empty list in parameter");
Map parameter_values = new HashMap();
DiscoveryConditionSet dcs = new DiscoveryConditionSet();
try {
dcs.addDiscoveryCondition(new DiscoveryCondition(DiscoveryCondition.
DISCOVERY_MODE_BY_MATCHES_APPLICATION_TYPE, "REGULATION"));
}
catch (Exception ex) {
Log.printStackTrace(ex);
}
int t_id = feature.getTrackId();
String species = "", chromosome = "", version = "";
DataSource ds = DataStoreUser.getInstance().getDataSourceManager().
getDataSource(t_id);
if (ds instanceof EnsemblDataSource) {
species = ( (EnsemblDataSource) ds).getSpecies();
chromosome = ( (EnsemblDataSource) ds).getChromosome();
version = ( (EnsemblDataSource) ds).getVersion();
}
boolean isCurrentReversed =
DataStoreUser.getInstance().getSockeyeTrackList().getTrackReverse(
t_id);
String sequence = DataStoreUser.getInstance().getSockeyeTrackList().getFeatureSequence(feature);
Log.println("Transmitting the following region-sequence:\n" + sequence + "\n");
SequenceCoordinate[] seq_coords = {
new SequenceCoordinate(
t_id + "",
species,
chromosome,
feature.getStart(),
feature.getEnd(),
isCurrentReversed?"-1":"1", version, sequence)};
parameter_values.put("SequenceCoordinates", seq_coords);
DataSource ncc_ds = null;
try {
ncc_ds = new NCCP2PDataSource(t_id, dcs, parameter_values);
}
catch (ChinookP2PDataSourceException ex) {
ex.printStackTrace();
Log.printStackTrace(ex);
return null;
}
return ncc_ds;
}
public DataSource getMotifDiscoveryDS(List regions) {
DiscoveryConditionSet dcs = new DiscoveryConditionSet();
try {
dcs.addDiscoveryCondition(new DiscoveryCondition(DiscoveryCondition.
DISCOVERY_MODE_BY_MATCHES_APPLICATION_TYPE, "MOTIF DISCOVERY"));
}
catch (Exception e) {
Log.printStackTrace(e);
return null;
}
int number_of_regions = regions.size();
SequenceCoordinate[] seq_coords =
new SequenceCoordinate[number_of_regions];
int master_track_id = 0;
for (int i = 0; i < regions.size(); i++) {
TrackFeature region = (TrackFeature) regions.get(i);
int t_id = region.getTrackId();
if (i == 0)
master_track_id = t_id;
String species = "", chromosome = "", version = "";
List ds_list = DataStoreUser.getInstance().
getSockeyeTrackList().
getDataSources(t_id);
Iterator ds_it = ds_list.iterator();
while (ds_it.hasNext()) {
DataSource ds =
DataStoreUser.getInstance().getDataSourceManager().getDataSource(
Integer.parseInt(ds_it.next().toString()));
if (ds instanceof EnsemblDataSource) {
species = ( (EnsemblDataSource) ds).getSpecies();
chromosome = ( (EnsemblDataSource) ds).getChromosome();
version = ( (EnsemblDataSource) ds).getVersion();
}
}
boolean isCurrentReversed =
DataStoreUser.getInstance().getSockeyeTrackList().getTrackReverse(
t_id);
String sequence = DataStoreUser.getInstance().getSockeyeTrackList().getFeatureSequence(region);
Log.println("Transmitting the following region-sequence:\n" + sequence + "\n");
seq_coords[i] =
new SequenceCoordinate(
t_id + "",
species,
chromosome,
region.getStart(),
region.getEnd(),
isCurrentReversed?"-1":"1", version,
sequence);
}
for (int k = 0; k < seq_coords.length; k++) {
String sp = seq_coords[k].getSpecies();
if (sp.endsWith(".gff")) {
String[] split_sp = sp.split(" ");
seq_coords[k].setSpecies(
SequenceMatrix.getLongSpeciesName(split_sp[0]));
seq_coords[k].setChromosome( (split_sp[2].split("-"))[0]);
}
}
MotifDiscoveryP2PDataSource motif_ds = null;
try {
motif_ds =
new MotifDiscoveryP2PDataSource(
master_track_id,
dcs, seq_coords);
}
catch (ChinookP2PDataSourceException e) {
e.printStackTrace();
Log.printStackTrace(e);
}
return motif_ds;
}
public DataSource getPrimerPredictionDS(List regions) {
return null;
}
public DataSource getMcsDS(List regions) {
return null;
}
}
package ca.bcgsc.sockeye.dataretrieval.junit;
import ca.bcgsc.sockeye.dataretrieval.*;
import junit.framework.*;
public class DataSourceSerializationTest
extends TestCase {
public DataSourceSerializationTest(String s) {
super(s);
}
public void testEnsemblDataSource() {
int track_id = 123;
int track_id_new = 321;
String database = "homo_sapiens_core_16_33";
String chromosome = "1";
String buffer;
EnsemblDataSource eds = new EnsemblDataSource(track_id, database, chromosome);
buffer = eds.toString();
EnsemblDataSource new_ds = (EnsemblDataSource)DataSource.getInstanceFromString(track_id_new, buffer);
assertNotNull("Could not recreate ensembl datasource");
assertEquals("Wrong chromosome after re-creation!", new_ds.getChromosome(), chromosome);
assertEquals("Wrong database after re-creation!",new_ds.getDatabase(), database);
}
public static Test suite() {
TestSuite suite = new TestSuite(DataSourceSerializationTest.class);
return suite;
}
public static void main(String args[]) {
junit.textui.TestRunner.run(suite());
}
}
package ca.bcgsc.sockeye.datastorage;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.StringTokenizer;
import java.util.Vector;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.config.Service;
import ca.bcgsc.sockeye.datastorage.ensembl.CachedChromosomeInfo;
import ca.bcgsc.sockeye.service.featureloader.common.ConnectionManager;
import ca.bcgsc.sockeye.service.featureloader.common.FeatureLoaderService;
import ca.bcgsc.sockeye.service.featureloader.common.FeatureLoaderServiceFactory;
public class ChromosomeInfo
{
private static LinkedHashMap chromosome_name = new LinkedHashMap();
private static LinkedHashMap chromosome_length = new LinkedHashMap();
private static void setChromosome(String current_species)
{
if (chromosome_name.get(current_species) == null)
{
StringTokenizer st = new StringTokenizer(current_species, "_");
st.nextToken();
st.nextToken();
String ensembl_type = st.nextToken();
int version =
ConnectionManager.getEnsemblVersionForDatabase(current_species);
try
{
Class c =
Class.forName(
"ca.bcgsc.sockeye.datastorage.ensembl.ChromInfo_"
+ ensembl_type.toLowerCase()
+ "_"
+ version);
CachedChromosomeInfo chrom = (CachedChromosomeInfo) c.newInstance();
Object[] species_vector = chrom.getSpecies();
Object[] names_vector = chrom.getNames();
Object[] lengths_vector = chrom.getLengths();
for (int index = 0; index < species_vector.length; index++)
{
chromosome_name.put(
(String) species_vector[index],
names_vector[index]);
chromosome_length.put(
(String) species_vector[index],
lengths_vector[index]);
}
if (chromosome_name.get(current_species) == null)
{
getDBChromosomeInfo(current_species);
}
}
catch (ClassNotFoundException e)
{
getDBChromosomeInfo(current_species);
}
catch (InstantiationException e)
{
getDBChromosomeInfo(current_species);
}
catch (IllegalAccessException e)
{
getDBChromosomeInfo(current_species);
}
}
}
private static void getDBChromosomeInfo(String current_species)
{
Vector name_vector = null;
Vector length_vector = new Vector();
FeatureLoaderServiceFactory fac = FeatureLoaderServiceFactory.getInstance();
Service service =
Configuration.getService(FeatureLoaderServiceFactory.FEATURELOADER_SERVICES);
String mode = null;
String remotehost = null;
if (service != null) {
mode = service.getMode();
remotehost = service.getRemotehost();
} else {
throw new RuntimeException("Feature loader service not set up properly.");
}
FeatureLoaderService ser = fac.getService(mode, remotehost);
Map map = ser.getChromosomeInfo(ConnectionManager.getCurrentConnection("Ensembl"),
ConnectionManager.getCurrentDatabaseByType("Ensembl"));
name_vector = new Vector(map.keySet());
Collections.sort(name_vector);
Iterator it = name_vector.listIterator();
while (it.hasNext()) {
String key = (String) it.next();
length_vector.add(map.get(key));
}
chromosome_name.put(current_species, name_vector);
chromosome_length.put(current_species, length_vector);
}
public static String[] getChromosomeName(String database)
{
try
{
if (chromosome_name
.get(database)
== null)
{
setChromosome(database);
}
Vector name_vector = (Vector) chromosome_name.get(database);
int n = name_vector.size();
String[] chrom_name_list = new String[n];
for (int j = 0; j < n; j++)
{
chrom_name_list[j] = (String) name_vector.get(j);
}
return chrom_name_list;
}
catch (Exception e)
{
e.printStackTrace();
return null;
}
}
public static int[] getChromosomeLength(String database)
{
try
{
if (chromosome_length
.get(database)
== null)
{
setChromosome(database);
}
Vector length_vector = (Vector) chromosome_length.get(database);
int n = length_vector.size();
int[] chrom_length_list = new int[n];
for (int j = 0; j < n; j++)
{
chrom_length_list[j] = ((Integer) length_vector.get(j)).intValue();
}
return chrom_length_list;
}
catch (Exception e)
{
return null;
}
}
public static int getChromosomeLength(String database, String chromosome_name)
{
String[] names = getChromosomeName(database);
int index = 0;
for (int i = 0; i < names.length; i++)
{
if (names[i].equalsIgnoreCase(chromosome_name))
{
index = i;
break;
}
}
int[] lengths = getChromosomeLength(database);
return lengths[index];
}
}
package ca.bcgsc.sockeye.datastorage;
import java.util.*;
import java.util.List;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
public interface DataStorageManager {
int rebuildEventListener();
int addTrack (Track t);
List addTracks (List Tl);
Track removeTrack (int t_id);
Collection removeTracks (List tl);
int getTrackCount ();
Set getAllTrackIds();
boolean hasTrack(int t_id);
int cloneTrack (int t_id);
int cloneTrack (int t_id, int start, int end);
void copyTrack (int src_trk, int trg_trk);
void copyTrack (int src_trk, int trg_trk, int start, int end);
public void setTrackVisibility(Collection track_ids,boolean v);
void addDataSourceId (int t_id, int ds_id);
void removeDataSourceId (int t_id, int ds_id);
void removeAllDataSources (int _t_id);
List getDataSources (int t_id);
void removeallTracks();
void setTrackVisibility (int id, boolean v);
boolean getTrackVisibility (int id);
void setFeatureVisibility (Collection features, boolean v);
void setFeatureVisibility (String feature, boolean v);
void setFeatureVisibility (int t_id, String feature_name, String acc_id, boolean v);
boolean getFeatureVisibility (String feature);
boolean getTrackHasFeature (int t_id, String f_name);
void setTrackReverse (int t_id, boolean b);
boolean getTrackReverse (int t_id);
void setTrackAttribute (int t_id, String attrib, Object val);
Object getTrackAttribute (int t_id, String attrib);
void setTrackOffset (int t_id, int offset);
int getTrackOffset (int t_id);
void setTrackDataWindow (int t_id, int start, int end);
int getTrackDataWindowStart (int t_id);
int getTrackDataWindowEnd (int t_id);
int getTrackDataWindowLength (int t_id);
int getFeatureCount (int t_id, String name);
int getFeatureCount (String name);
Collection getFeatures (int track_id, String fname);
TrackFeature getFeature (int track_id, String fname, String acc_id);
Collection getFeatureNames(int track_id);
Collection getFeatures (Collection fnames);
int getVisibleFeatureCount();
void addFeature (int t_id, String feature, TrackFeature tf);
void addFeatures (int t_id, String feature, List tf);
List removeFeature (int t_id, List names);
boolean removeFeature (int t_id, String name);
boolean removeFeature(int t_id, String name, String acc_id);
String getTrackSequence (int t_id);
String getFeatureSequence (TrackFeature tf);
}
package ca.bcgsc.sockeye.datastorage;
import ca.bcgsc.sockeye.dataretrieval.DataSourceManager;
public class DataStoreUser {
static DataStoreUser __instance = new DataStoreUser();
public static DataStoreUser getInstance() {
return __instance;
}
private SockeyeTrackList _track_storage;
private DataSourceManager _source_manager;
private DataStoreUser() {
_track_storage = new SockeyeTrackList();
_source_manager = new DataSourceManager(_track_storage);
}
public DataSourceManager getDataSourceManager() {
return _source_manager;
}
public void setDataSourceManager(DataSourceManager sm){
_source_manager = sm;
}
public SockeyeTrackList getSockeyeTrackList() {
return _track_storage;
}
public void setSockeyeTrackList(SockeyeTrackList ts){
_track_storage = ts;
}
}
package ca.bcgsc.sockeye.datastorage;
import java.util.List;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.config.Connection;
import ca.bcgsc.sockeye.config.Service;
import ca.bcgsc.sockeye.service.featureloader.common.ConnectionManager;
import ca.bcgsc.sockeye.service.featureloader.common.FeatureLoaderService;
import ca.bcgsc.sockeye.service.featureloader.common.FeatureLoaderServiceFactory;
import ca.bcgsc.sockeye.service.featureloader.common.GeneInfo;
import ca.bcgsc.sockeye.util.Log;
public class HitGeneInfo {
private int _gene_start, _gene_end, _gene_strand, _version ;
private String _chromosome, _description = "", _source = "", _database = null, _species, _gene_id;
public HitGeneInfo(String database, String hit_species, String hit_gene_id, Connection connection ) {
_database = database;
_species = hit_species.replaceAll(" ", "_");
_version = ConnectionManager.getEnsemblVersionForDatabase(_database);
_gene_id = hit_gene_id;
FeatureLoaderServiceFactory fac = FeatureLoaderServiceFactory.getInstance();
Service service =
Configuration.getService(FeatureLoaderServiceFactory.FEATURELOADER_SERVICES);
String mode = null;
String remotehost = null;
if (service != null) {
mode = service.getMode();
remotehost = service.getRemotehost();
} else {
throw new RuntimeException("Feature loader service not set up properly.");
}
FeatureLoaderService ser = fac.getService(mode, remotehost);
List all_core_db =
ser.getDatabaseList(
connection, "CORE");
String hit_database = "";
for (int i = 0; i < all_core_db.size(); i++) {
String core_db = (String) all_core_db.get(i);
if (core_db.startsWith(new String(_species.toLowerCase() + "_core_" + _version))) {
hit_database = core_db;
}
}
if( hit_database.equals("") ) return;
GeneInfo gInfo = ser.getGeneInfo(connection,
hit_database,
hit_gene_id);
_gene_start = gInfo.getStart();
_gene_end = gInfo.getEnd();
_gene_strand = gInfo.getStrand();
_chromosome = gInfo.getChromosome();
String d = gInfo.getDescription();
try {
if (d != null){
d = d.replace('[', '=').replace(']', ' ');
_description = d.split("=")[0].replace('.', ' ');
_source = d.split("=")[1].replace('.', ' ');
}
}
catch (Exception e) {
Log.println(e +
" Error in parsing EnsEMBL description string: " +
d);
}
}
public String getHitChrom() {
return _chromosome;
}
public int getHitGeneStart() {
return _gene_start;
}
public int getHitGeneEnd() {
return _gene_end;
}
public String getGeneID() {
return _gene_id;
}
public int getHitGeneStrand() {
return _gene_strand;
}
public String getHitDescription() {
return _description;
}
public String getHitSource() {
return _source;
}
public String getDatabase() {
return _database;
}
public String getSpecies() {
return _species;
}
public int getVersion() {
return _version;
}
}
package ca.bcgsc.sockeye.datastorage;
import java.awt.Color;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.vecmath.Color3f;
import ca.bcgsc.sockeye.service.featureloader.common.DistributionContainer;
public class MultiDimTrackDistribution extends TrackDistribution {
private ArrayList _multi_distribution_info;
private int min_start = -1;
private int max_end = -1;
private List distributionLabel = new ArrayList();
private List thresholdValues = new ArrayList();
private List distributionColors = new ArrayList();
public MultiDimTrackDistribution() {
super();
}
public MultiDimTrackDistribution(int track_id, String feature_id) {
super(track_id, feature_id);
_multi_distribution_info = new ArrayList();
}
public MultiDimTrackDistribution(MultiDimTrackDistribution mtd) {
this(mtd.getDataset(), mtd.getTrackId(), mtd.getFeature());
}
public MultiDimTrackDistribution(
List input_list,
int track_id,
String feature_id) {
super(track_id, feature_id);
addDistributions(input_list);
}
public void addDistributions(List input_list) {
if ((input_list == null) || (input_list.isEmpty())) {
System.out.println("An empty list is not added");
return;
}
distributionLabel = new ArrayList(input_list.size());
thresholdValues = new ArrayList(input_list.size());
distributionColors = new ArrayList(input_list.size());
for (int i = 0; i < input_list.size(); i++) {
distributionLabel.add("");
thresholdValues.add("0");
distributionColors.add(Color.WHITE);
}
if (input_list.get(0) instanceof DistributionContainer) {
_multi_distribution_info.add(input_list);
} else {
for (Iterator i = input_list.iterator(); i.hasNext();) {
_multi_distribution_info.add(i.next());
}
}
this.setStartEnd();
}
public void removeAll() {
_multi_distribution_info.clear();
distributionLabel.clear();
thresholdValues.clear();
max_end = -1;
min_start = -1;
this.setStart(min_start);
this.setEnd(max_end);
}
public int getSize() {
return _multi_distribution_info.size();
}
public double getMax() {
double maximum = -1;
for (int i = 0; i < _multi_distribution_info.size(); i++) {
double tmpMax = this.getMax(i);
if (maximum < tmpMax) {
maximum = tmpMax;
}
}
return maximum;
}
public double getMax(int location) {
double maximum = -1;
ArrayList tmpList = (ArrayList) _multi_distribution_info.get(location);
for (Iterator i = tmpList.iterator(); i.hasNext();) {
DistributionContainer dc = (DistributionContainer) i.next();
if (maximum == -1) {
maximum = dc.getScore();
}
if (dc.getScore() > maximum) {
maximum = dc.getScore();
}
}
return maximum;
}
public List getDataset() {
return _multi_distribution_info;
}
public ArrayList getDataset(int location) {
return (ArrayList) _multi_distribution_info.get(location);
}
public int getGapCount() {
int count = 0;
for (int i = 0; i < _multi_distribution_info.size(); i++) {
count += this.getGapCount(i);
}
return count;
}
public int getGapCount(int location) {
int count = 0;
ArrayList tmpList = (ArrayList) _multi_distribution_info.get(location);
for (Iterator i = tmpList.iterator(); i.hasNext();) {
boolean gap = true;
DistributionContainer dc1 = (DistributionContainer) i.next();
for (Iterator j = tmpList.iterator(); j.hasNext();) {
DistributionContainer dc2 = (DistributionContainer) j.next();
if (dc1.getEnd() == dc2.getStart()) {
gap = false;
break;
}
}
if (gap) {
count++;
}
}
if (!tmpList.isEmpty()) {
count--;
}
return count;
}
public void setStartEnd() {
for (int i = 0; i < _multi_distribution_info.size(); i++) {
this.setStartEnd(i);
}
this.setStart(min_start);
this.setEnd(max_end);
}
public void setStartEnd(int location) {
ArrayList tmpList = (ArrayList) _multi_distribution_info.get(location);
for (Iterator i = tmpList.iterator(); i.hasNext();) {
DistributionContainer dc = (DistributionContainer) i.next();
if (min_start == -1) {
min_start = dc.getStart();
}
if (max_end == -1) {
max_end = dc.getEnd();
}
if (dc.getStart() < min_start) {
min_start = dc.getStart();
}
if (dc.getEnd() > max_end) {
max_end = dc.getEnd();
}
}
this.setStart(min_start);
this.setEnd(max_end);
}
public double getTotalScore() {
double total_score = 0;
for (int i = 0; i < _multi_distribution_info.size(); i++) {
total_score += getMax(i);
}
return total_score;
}
public void setDistributionLabel(int index, String label) {
if (index >= 0 && index < _multi_distribution_info.size())
distributionLabel.set(index, label);
else
System.out.println("Illegal index when setting distribution label!");
}
public String getDistributionLabel(int index) {
Object s = distributionLabel.get(index);
return (s == null ? null : s.toString());
}
public void setDistributionThreshold(int index, float value) {
if (index >= 0 && index < _multi_distribution_info.size())
thresholdValues.set(index, new Float(value));
else
System.out.println("Illegal index when setting distribution label!");
}
public float getDistributionThreshold(int index) {
Object s = thresholdValues.get(index);
return (s == null ? -1 : Float.parseFloat(s.toString()));
}
public void setDistributionColour(int index, Color3f clr) {
if (index >= 0 && index < _multi_distribution_info.size())
distributionColors.set(index, clr);
else
System.out.println("Illegal index when setting distribution label!");
}
public Color3f getDistributionColour(int index) {
try{
Object s = distributionColors.get(index);
return (s == null ? null : (Color3f)s);
}
catch(Throwable e) {
return null;
}
}
}
package ca.bcgsc.sockeye.datastorage;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.Vector;
import ca.bcgsc.sockeye.dataretrieval.DataSource;
import ca.bcgsc.sockeye.datastorage.events.StorageEvent;
import ca.bcgsc.sockeye.datastorage.events.StorageEventListener;
import ca.bcgsc.sockeye.j3d.Visualizer3D;
import ca.bcgsc.sockeye.util.Log;
import ca.bcgsc.util.SequenceUtils;
public class SockeyeTrackList implements DataStorageManager {
transient private List _event_queue = new Vector();
transient private eventDispatcher dispatcher = new eventDispatcher();
private static int _track_id_sequence_number = 0;
private Map _track_map = Collections.synchronizedMap(new TreeMap());
private List track_order = new ArrayList();
private HashMap _query_feature_flags = new HashMap();
transient private static final Integer _FEATURE_GROUP_VISIBILITY_TRUE = new Integer(
1);
transient private static final Integer _FEATURE_GROUP_VISIBILITY_FALSE = new Integer(
0);
transient private static final Integer _FEATURE_GROUP_VISIBILITY_PENDING = new Integer(
2);
transient public static final int NORMALIZE_PERFEATURE_PERTRACK = 1;
transient public static final int NORMALIZE_PERFEATURE_ALLTRACK = 2;
transient public static final int NORMALIZE_ALLFEATURE_PERTRACK = 3;
transient public static final int NORMALIZE_ALLFEATURE_ALLTRACK = 4;
private int _normalizeMechanism = NORMALIZE_PERFEATURE_ALLTRACK;;
transient private static final String[] FEATURES_ALWAYS_ON = { "gap",
"region" };
private Map _track_feature_visibility = new HashMap();
final private int normalize_multiplier = 100;
transient private Visualizer3D _my_vis;
public SockeyeTrackList() {
dispatcher.setDaemon(true);
dispatcher.start();
}
protected void finalize() {
dispose();
}
public void setVisualizer(Visualizer3D v) {
_my_vis = v;
}
public int rebuildEventListener() {
int event_count = 0;
List id_list = getAllOrderedTrackIds();
fireStorageEvent(StorageEvent.STORAGE_EVENT_TRACK_ADD, id_list);
event_count++;
List v_id_list = new ArrayList();
for (int i = 0; i < id_list.size(); i++) {
int id = ((Integer) id_list.get(i)).intValue();
Track t = getTrackReference(id);
boolean visible = getTrackVisibility(id);
if (visible) {
v_id_list.add(new Integer(id));
t.setVisibility(false);
}
List ds_l = t.getDataSources();
for (int j = 0; j < ds_l.size(); j++) {
List l = new ArrayList();
l.add(new Integer(id));
Integer ds_id = new Integer(ds_l.get(j).toString());
l.add(ds_id);
fireStorageEvent(StorageEvent.STORAGE_EVENT_TRACK_ADD_DS, l);
event_count++;
DataSource ds = DataStoreUser.getInstance()
.getDataSourceManager().getDataSource(ds_id.intValue());
addStorageListener(ds);
}
Set features = t.getAllFeatureNames();
for (Iterator it = features.iterator(); it.hasNext();) {
String feature_name = it.next().toString();
List event_attrib = new ArrayList();
event_attrib.add(new Integer(id));
event_attrib.add(feature_name);
event_attrib.addAll(new ArrayList(t.getFeatures(feature_name)));
fireStorageEvent(StorageEvent.STORAGE_EVENT_TRACK_ADD_FEATURES,
event_attrib);
event_count++;
}
}
if (v_id_list.size() != 0) {
setTrackVisibility(v_id_list, true);
event_count = event_count + v_id_list.size();
}
return event_count;
}
public synchronized int addTrack(Track t) {
if (t == null)
throw new IllegalArgumentException("Null argument passed as track!");
List tracks = new ArrayList();
tracks.add(t);
List ids = addTracks(tracks);
assert ids.size() == 1 : "Illegal number of returned ids: "
+ ids.size();
return Integer.parseInt(ids.get(0).toString());
}
public synchronized int addCopyTrack(int old_id, Track t) {
if (t == null)
throw new IllegalArgumentException("Null argument passed as track!");
List tracks = new ArrayList();
tracks.add(t);
List ids = addCopyTracks(old_id, tracks);
assert ids.size() == 1 : "Illegal number of returned ids: "
+ ids.size();
return Integer.parseInt(ids.get(0).toString());
}
public boolean hasTrack(int t_id) {
return _track_map.containsKey(new Integer(t_id));
}
public boolean hasTrackAttributeValue(String attr_name, String attr_value) {
List ids = getAllOrderedTrackIds();
for (int i = 0; i < ids.size(); i++) {
int t_id = Integer.valueOf(ids.get(i).toString()).intValue();
String value = getTrackAttribute(t_id, attr_name).toString();
if (value.equals(attr_value))
return true;
}
return false;
}
public synchronized List addTracks(List tl) {
if (tl == null)
throw new IllegalArgumentException("Null argument passed as track!");
List id_list = new ArrayList();
Iterator insert_tracks = tl.iterator();
while (insert_tracks.hasNext()) {
Track t = ((Track) insert_tracks.next());
int id = generateUniqueTrackId();
Integer id_object = new Integer(id);
System.out.println("Adding new track using id " + id);
t.setId(id);
id_list.add(id_object);
_track_map.put(id_object, t);
track_order.add(id_object);
Map default_feature_vis = new HashMap();
for (int i = 0; i < FEATURES_ALWAYS_ON.length; i++) {
default_feature_vis.put(FEATURES_ALWAYS_ON[i],
_FEATURE_GROUP_VISIBILITY_TRUE);
}
_track_feature_visibility.put(id_object, default_feature_vis);
}
fireStorageEvent(StorageEvent.STORAGE_EVENT_TRACK_ADD, id_list);
for (Iterator id_it = id_list.iterator(); id_it.hasNext();)
this.setTrackVisibility(Integer.parseInt(id_it.next().toString()),
true);
return id_list;
}
public synchronized List addCopyTracks(int old_id, List tl) {
if (tl == null)
throw new IllegalArgumentException("Null argument passed as track!");
List id_list = new ArrayList();
Iterator insert_tracks = tl.iterator();
while (insert_tracks.hasNext()) {
Track t = ((Track) insert_tracks.next());
int id = generateUniqueTrackId();
Integer id_object = new Integer(id);
System.out.println("Adding new track using id " + id);
t.setId(id);
id_list.add(id_object);
_track_map.put(id_object, t);
track_order.add(id_object);
Map default_feature_vis = new HashMap();
for (int i = 0; i < FEATURES_ALWAYS_ON.length; i++) {
default_feature_vis.put(FEATURES_ALWAYS_ON[i],
_FEATURE_GROUP_VISIBILITY_TRUE);
}
_track_feature_visibility.put(id_object, default_feature_vis);
copyTrack(old_id, id, t.getDataStart(), t.getDataEnd());
}
fireStorageEvent(StorageEvent.STORAGE_EVENT_TRACK_ADD, id_list);
for (Iterator id_it = id_list.iterator(); id_it.hasNext();)
this.setTrackVisibility(Integer.parseInt(id_it.next().toString()),
true);
return id_list;
}
public int getVisibleTrackCount() {
int count = 0;
Iterator iter = _track_map.keySet().iterator();
while (iter.hasNext()) {
int t_id = ((Integer) iter.next()).intValue();
if (getTrackVisibility(t_id)) {
count++;
}
}
return count;
}
public List getVisibleTrackIds() {
List ids = new ArrayList();
Iterator iter = _track_map.keySet().iterator();
while (iter.hasNext()) {
Integer t_id = (Integer) iter.next();
if (getTrackVisibility(t_id.intValue())) {
ids.add(t_id);
}
}
return ids;
}
public int getTrackCount() {
return _track_map.size();
}
public void copyTrack(int src_trk, int trg_trk, int start, int end) {
Track source = getTrackReference(src_trk);
int source_offset = source.getOffset();
if (start != -1 && end != -1) {
source = source.subTrack(start, end);
source.setId(src_trk);
}
Track target = getTrackReference(trg_trk);
target.copy(source);
target.setOffset(source_offset);
HashMap newTrackHash = new HashMap();
Map t_vis = (Map) _track_feature_visibility.get(new Integer(src_trk));
if (t_vis != null) {
for (Iterator it = t_vis.keySet().iterator(); it.hasNext();) {
String feat = it.next().toString();
if (target.hasFeature(feat))
newTrackHash.put(feat, t_vis.get(feat));
}
_track_feature_visibility.put(new Integer(trg_trk), newTrackHash);
} else
_track_feature_visibility.remove(new Integer(trg_trk));
List new_features = new ArrayList(target.getAllFeatureNames());
for (Iterator itr = new_features.iterator(); itr.hasNext();) {
String feature_type = (String) itr.next();
List features = new ArrayList(target.getFeatures(feature_type));
List event_attrib = new ArrayList();
event_attrib.add(new Integer(trg_trk));
event_attrib.add(feature_type);
event_attrib.addAll(features);
fireStorageEvent(StorageEvent.STORAGE_EVENT_TRACK_ADD_FEATURES,
event_attrib);
}
target.setVisibility(false);
setTrackVisibility(trg_trk, true);
if (_my_vis != null)
replaceTrack3D(trg_trk, target);
}
public void copyTrack(int src_trk, int trg_trk) {
copyTrack(src_trk, trg_trk, -1, -1);
}
public int cloneTrack(int t_id, int start, int end) {
System.out.println(" >>>> " + start + " " + end);
Track newTrack = new Track(start, end);
newTrack.setDataWindow(start, end);
newTrack.setVisibility(false);
int new_id = addCopyTrack(t_id, newTrack);
System.out.println(" <<<< " + this.getTrackDataWindowStart(new_id)
+ " " + this.getTrackDataWindowEnd(new_id));
return new_id;
}
public synchronized int cloneTrack(int t_id) {
Track t = getTrackReference(t_id);
Track newTrack = new Track(t);
int new_id = addTrack(newTrack);
HashMap newTrackHash = new HashMap();
Map t_vis = (Map) _track_feature_visibility.get(new Integer(t_id));
if (t_vis != null) {
for (Iterator it = t_vis.keySet().iterator(); it.hasNext();) {
String feat = it.next().toString();
newTrackHash.put(feat, t_vis.get(feat));
}
_track_feature_visibility.put(new Integer(new_id), newTrackHash);
} else
_track_feature_visibility.remove(new Integer(new_id));
newTrack.setVisibility(false);
setTrackVisibility(new_id, true);
return new_id;
}
public void addDataSourceId(int t_id, int ds_id) {
Track t = getTrackReference(t_id);
Collection c = (Collection) _query_feature_flags.get(new Integer(t_id));
if (c != null)
c.clear();
t.addDataSourceId(ds_id);
List l = new ArrayList();
l.add(new Integer(t_id));
l.add(new Integer(ds_id));
fireStorageEvent(StorageEvent.STORAGE_EVENT_TRACK_ADD_DS, l);
}
public void removeDataSourceId(int t_id, int ds_id) {
Track t = getTrackReference(t_id);
if (!t.removeDataSourceId(ds_id))
throw new StorageException("Unknown data source id (" + ds_id
+ ") on track: " + t_id, t_id);
List l = new ArrayList();
l.add(new Integer(t_id));
l.add(new Integer(ds_id));
fireStorageEvent(StorageEvent.STORAGE_EVENT_TRACK_REMOVE_DS, l);
}
public void removeAllDataSources(int t_id) {
Track t = getTrackReference(t_id);
List dsl = t.removeAllDatasources();
dsl.add(0, new Integer(t_id));
fireStorageEvent(StorageEvent.STORAGE_EVENT_TRACK_REMOVE_DS, dsl);
}
public List getDataSources(int t_id) {
Track t = getTrackReference(t_id);
return t.getDataSources();
}
public synchronized Track removeTrack(int t_id) {
List l = new ArrayList();
l.add(new Integer(t_id));
Collection ret = removeTracks(l);
assert ret.size() == 1 : "Number of deleted tracks != 1 when trying to delete 1 track("
+ t_id + "): " + ret.size();
return (Track) ((ret.toArray())[0]);
}
public synchronized Collection removeTracks(List tl) {
if (tl == null || tl.isEmpty())
return new ArrayList();
List ret_list = new ArrayList();
Iterator tracks_it = tl.iterator();
while (tracks_it.hasNext()) {
Object id = tracks_it.next();
if (!_track_map.containsKey(id))
throw new StorageException(
"Unknown track id: " + id.toString(), Integer
.parseInt(id.toString()));
}
tracks_it = tl.iterator();
boolean redraw = false;
while (tracks_it.hasNext()) {
Object id = tracks_it.next();
redraw = (removeNormalizedScore(Integer.parseInt(id.toString())) || redraw);
Track t = (Track) _track_map.remove(id);
track_order.remove(id);
if (_my_vis != null)
_my_vis.removeTrack(t.getId());
ret_list.add(t);
}
if (_my_vis != null && redraw)
_my_vis.redrawAllFeatures();
assert tl.size() == ret_list.size() : "Transaction safety violation: "
+ tl.size() + " != " + ret_list.size();
fireStorageEvent(StorageEvent.STORAGE_EVENT_TRACK_REMOVE, tl);
return ret_list;
}
public synchronized void setTrackVisibility(Collection track_ids, boolean v) {
List track_object_list = new ArrayList();
Map visible_feature_map = new HashMap();
for (Iterator it = track_ids.iterator(); it.hasNext();) {
Integer id_obj = new Integer(it.next().toString());
int t_id = id_obj.intValue();
Track t = getTrackReference(t_id);
if (t.getVisibility() != v) {
track_object_list.add(Math.min(track_order.indexOf(id_obj),
track_object_list.size()), t);
t.setVisibility(v);
Map tf_vis_map = (Map) _track_feature_visibility.get(id_obj);
if (tf_vis_map != null) {
Set fs = tf_vis_map.keySet();
Iterator fs_it = fs.iterator();
while (fs_it.hasNext()) {
String feat = fs_it.next().toString();
if (tf_vis_map.get(feat).equals(
_FEATURE_GROUP_VISIBILITY_TRUE)) {
Collection c = getFeatures(t_id, feat);
if (c == null)
continue;
Collection dummy_c = (Collection) visible_feature_map
.get(feat);
if (dummy_c == null) {
dummy_c = new ArrayList();
visible_feature_map.put(feat, dummy_c);
}
dummy_c.addAll(c);
}
}
}
}
}
if (_my_vis != null) {
if (v) {
_my_vis.addTracks(track_object_list);
_my_vis.cancelRegionSelect();
_my_vis.highlightTrack(((Track) track_object_list
.get(track_object_list.size() - 1)).getId());
_my_vis.addFeatures(visible_feature_map);
} else
_my_vis.removeTracks(track_ids);
}
for (Iterator e_it = track_ids.iterator(); e_it.hasNext();) {
List l = new ArrayList();
l.add(e_it.next());
l.add(new Boolean(v));
fireStorageEvent(
StorageEvent.STORAGE_EVENT_TRACK_VISIBILITY_CHANGED, l);
}
}
public synchronized void setTrackVisibility(int t_id, boolean v) {
Track t = getTrackReference(t_id);
if (t.getVisibility() == v) {
return;
}
t.setVisibility(v);
if (_my_vis != null) {
if (v) {
int pos = 0;
for (Iterator ord_it = track_order.iterator(); ord_it.hasNext();) {
int id = Integer.parseInt(ord_it.next().toString());
if (id == t_id)
break;
if (getTrackVisibility(id))
pos++;
}
_my_vis.addTrack(t, pos);
_my_vis.cancelRegionSelect();
_my_vis.highlightTrack(t.getId());
Map tf_vis_map = (Map) (_track_feature_visibility
.get(new Integer(t.getId())));
if (tf_vis_map == null)
return;
Set fs = tf_vis_map.keySet();
Iterator it = fs.iterator();
Map tf_map = new HashMap();
while (it.hasNext()) {
String feat = it.next().toString();
if (tf_vis_map.get(feat).equals(
_FEATURE_GROUP_VISIBILITY_TRUE)) {
Collection c = getFeatures(t_id, feat);
if (c == null)
continue;
tf_map.put(feat, new ArrayList(c));
}
}
_my_vis.addFeatures(tf_map);
} else
_my_vis.removeTrack(t.getId());
}
List l = new ArrayList();
l.add(new Integer(t_id));
l.add(new Boolean(v));
fireStorageEvent(StorageEvent.STORAGE_EVENT_TRACK_VISIBILITY_CHANGED, l);
}
public boolean getTrackVisibility(int t_id) {
Track t = getTrackReference(t_id);
return t.getVisibility();
}
public void setTrackReverse(int t_id, boolean b) {
Track t = getTrackReference(t_id);
t.setReverse(b);
List l = new ArrayList();
l.add(new Integer(t_id));
l.add(new Boolean(b));
fireStorageEvent(
StorageEvent.STORAGE_EVENT_TRACK_REVERSED_STATE_CHANGED, l);
if (_my_vis != null) {
_my_vis.updateTrackReverse(t_id);
}
}
public boolean getTrackReverse(int t_id) {
Track t = getTrackReference(t_id);
return t.isReverse();
}
public void setTrackAttribute(int t_id, String attrib, Object val) {
Track t = getTrackReference(t_id);
t.setAttribute(attrib, val);
List l = new ArrayList();
l.add(new Integer(t_id));
l.add(attrib);
l.add(val);
fireStorageEvent(StorageEvent.STORAGE_EVENT_TRACK_ATTRIBUTE_CHANGED, l);
if (attrib.equals("track_name") || attrib.equals("display_string"))
this.replaceTrack3D(t_id, t);
}
public Object getTrackAttribute(int t_id, String attrib) {
Track t = getTrackReference(t_id);
return t.getAttribute(attrib);
}
public void setTrackDataWindow(int t_id, int start, int end) {
Track t = getTrackReference(t_id);
List query_snippets = t.setDataWindow(start, end);
List event_attrib_dw_changed = new ArrayList();
if (query_snippets != null) {
if ((query_snippets.size() % 2) != 0)
throw new RuntimeException(
"Track returned a list with an odd number of parameters when setting data window!");
for (int i = 0; i < query_snippets.size(); i += 2) {
List event_attrib_query = new ArrayList();
event_attrib_query.add(new Integer(t_id));
event_attrib_query.addAll(1, query_snippets.subList(i, i + 2));
event_attrib_query.addAll(this.getAllVisibleFeatureNames(t_id));
fireStorageEvent(StorageEvent.STORAGE_EVENT_TRACK_DATA_REQUEST,
event_attrib_query);
}
}
event_attrib_dw_changed.add(new Integer(t_id));
event_attrib_dw_changed.add(new Integer(start));
event_attrib_dw_changed.add(new Integer(end));
fireStorageEvent(StorageEvent.STORAGE_EVENT_TRACK_DATA_WINDOW_CHANGED,
event_attrib_dw_changed);
this.replaceTrack3D(t_id, t);
}
public boolean setToFeature(TrackFeature f, boolean fivep, boolean threep,
int extension) {
boolean was_completed = false;
if (!fivep && !threep) {
return was_completed;
}
int f_strand = f.getStrand().getValue();
boolean start = (fivep && (f_strand != -1))
|| (threep && (f_strand == -1));
boolean end = (fivep && (f_strand == -1))
|| (threep && (f_strand != -1));
int f_start = f.getStart();
int f_end = f.getEnd();
int t_id = f.getTrackId();
int t_start = ((Track) getTrackReference(t_id)).getDataWindowStart();
int t_end = ((Track) getTrackReference(t_id)).getDataWindowEnd();
int length = t_end - t_start + 1;
int new_t_start = t_start;
int new_t_end = t_end;
if (extension < 1)
extension = (int) (length * 0.02);
if (f_start < t_start && start) {
new_t_start = (int) (f_start - extension);
was_completed = true;
}
if (f_end > t_end && end) {
new_t_end = (int) (f_end + extension);
was_completed = true;
}
if (was_completed)
setTrackDataWindow(t_id, new_t_start, new_t_end);
return was_completed;
}
public int getTrackDataWindowStart(int t_id) {
Track t = getTrackReference(t_id);
return t.getDataWindowStart();
}
public int getTrackDataWindowLength(int t_id) {
Track t = getTrackReference(t_id);
return t.getWindowLength();
}
public int getTrackDataWindowEnd(int t_id) {
Track t = getTrackReference(t_id);
return t.getDataWindowEnd();
}
public int getTrackDataStart(int t_id) {
Track t = getTrackReference(t_id);
return t.getDataStart();
}
public int getTrackInternalStorageLength(int t_id) {
Track t = getTrackReference(t_id);
return (t.getDataEnd() - t.getDataStart());
}
public int getTrackDataEnd(int t_id) {
Track t = getTrackReference(t_id);
return t.getDataEnd();
}
public boolean getTrackHasFeature(int t_id, String f_name) {
Track t = getTrackReference(t_id);
return t.hasFeature(f_name);
}
public void setTrackOffset(int t_id, int offset) {
List event_attrib = new ArrayList();
if (offset < 0) {
for (Iterator t_it = _track_map.values().iterator(); t_it.hasNext();) {
Track track = (Track) t_it.next();
if (track.getId() == t_id)
continue;
int t_offset = track.getOffset() - offset;
track.setOffset(t_offset);
event_attrib = new ArrayList();
event_attrib.add(new Integer(track.getId()));
event_attrib.add(new Integer(offset));
fireStorageEvent(
StorageEvent.STORAGE_EVENT_TRACK_OFFSET_CHANGED,
event_attrib);
}
}
Track t = getTrackReference(t_id);
int current_offset = t.getOffset();
System.out.println("Setting offset for track " + t_id + " to "
+ Math.max(0, offset) + " (was " + current_offset + ")");
t.setOffset(Math.max(0, offset));
event_attrib.add(new Integer(t_id));
event_attrib.add(new Integer(Math.max(0, offset)));
fireStorageEvent(StorageEvent.STORAGE_EVENT_TRACK_OFFSET_CHANGED,
event_attrib);
if (_my_vis != null)
_my_vis.updateAllTracks();
}
public void changeTrackOffsetBy(int t_id, int delta) {
int current_offset = getTrackOffset(t_id);
int offset = current_offset + delta;
setTrackOffset(t_id, offset);
System.out.println("Offset for track " + t_id + " changed from "
+ current_offset + " to " + offset);
}
public int getTrackOffset(int t_id) {
Track t = getTrackReference(t_id);
return t.getOffset();
}
public void refreshTrackOffsets() {
int min_offset = Integer.MAX_VALUE;
for (Iterator t_it = _track_map.values().iterator(); t_it.hasNext();) {
Track track = (Track) t_it.next();
int offset = track.getOffset();
if (offset < min_offset)
min_offset = offset;
}
for (Iterator t_it = _track_map.values().iterator(); t_it.hasNext();) {
Track track = (Track) t_it.next();
int offset = track.getOffset();
track.setOffset(offset - min_offset);
}
}
public void triggerEvent(int event_type, List eventAttrib) {
fireStorageEvent(event_type, eventAttrib);
}
public int getDataWindowFeatureCount(int t_id, String fname) {
Track t = getTrackReference(t_id);
return t.countFeaturesInDataWindow(fname);
}
public int getFeatureCount(int t_id, String fname) {
Track t = getTrackReference(t_id);
return t.countFeatures(fname);
}
public int getFeatureCount(String fname) {
Collection c = _track_map.values();
int sum = 0;
Iterator i = c.iterator();
while (i.hasNext())
sum += ((Track) i.next()).countFeatures(fname);
return sum;
}
public void addFeatures(int t_id, String feature, List tf) {
if (tf == null || tf.isEmpty()) {
return;
}
Track t = getTrackReference(t_id);
t.addFeatures(feature, tf);
t.setRawScore(feature, tf);
boolean redraw = addNormalizedScore(t_id, feature, tf);
List event_attrib = new ArrayList();
event_attrib.add(new Integer(t_id));
event_attrib.add(feature);
event_attrib.addAll(tf);
fireStorageEvent(StorageEvent.STORAGE_EVENT_TRACK_ADD_FEATURES,
event_attrib);
Map tf_vis_map = (Map) (_track_feature_visibility
.get(new Integer(t_id)));
if (tf_vis_map == null) {
tf_vis_map = new HashMap();
_track_feature_visibility.put(new Integer(t_id), tf_vis_map);
}
Integer fvis = (Integer) tf_vis_map.get(feature);
if (fvis != null && !fvis.equals(_FEATURE_GROUP_VISIBILITY_FALSE)) {
if (fvis.equals(_FEATURE_GROUP_VISIBILITY_PENDING)) {
List vis_event_attrib = new ArrayList();
vis_event_attrib.add(new Boolean(true));
vis_event_attrib.add(feature);
fireStorageEvent(
StorageEvent.STORAGE_EVENT_FEATURE_VISIBILITY_CHANGED,
vis_event_attrib);
tf_vis_map.put(feature, _FEATURE_GROUP_VISIBILITY_TRUE);
}
if (_my_vis != null) {
_my_vis.addFeatures(tf);
}
}
if (_my_vis != null && redraw)
_my_vis.redrawAllFeatures();
}
public Set getAllVisibleFeatureNames(int track_id) {
Map feature_visibility = (Map) _track_feature_visibility
.get(new Integer(track_id));
Set visible_feature_names = new HashSet();
for (Iterator i = feature_visibility.keySet().iterator(); i.hasNext();) {
String feature_name = (String) i.next();
if (!feature_visibility.get(feature_name).equals(
_FEATURE_GROUP_VISIBILITY_FALSE)) {
visible_feature_names.add(feature_name);
}
}
return visible_feature_names;
}
public void addFeature(int t_id, String feature, TrackFeature tf) {
List l = new ArrayList();
l.add(tf);
addFeatures(t_id, feature, l);
}
public List removeFeature(int t_id, List names) {
Track t = getTrackReference(t_id);
List removeFeatures = new ArrayList();
for (Iterator it = names.iterator(); it.hasNext();) {
String feature = it.next().toString();
removeNormalizedScore(t_id, feature);
Collection c = t.getFeatures(feature);
if (c != null)
removeFeatures.addAll(c);
}
List deleted = t.removeFeatures(names);
List event_attrib = new ArrayList();
event_attrib.add(new Integer(t_id));
event_attrib.addAll(deleted);
fireStorageEvent(StorageEvent.STORAGE_EVENT_TRACK_REMOVE_FEATURES,
event_attrib);
if (_my_vis != null) {
_my_vis.removeFeatures(removeFeatures);
}
return deleted;
}
public boolean removeFeature(int t_id, String name) {
Track t = getTrackReference(t_id);
List l = new ArrayList();
l.add(name);
return (removeFeature(t_id, l).size() > 0);
}
public boolean removeFeature(int t_id, String name, String acc_id) {
Track t = getTrackReference(t_id);
TrackFeature tf = t.getFeature(name, acc_id);
if (_my_vis != null) {
_my_vis.removeFeature(t_id, name, acc_id);
}
if (t.removeFeature(name, acc_id)) {
List event_attrib = new ArrayList();
event_attrib.add(new Integer(t_id));
event_attrib.add(name);
fireStorageEvent(StorageEvent.STORAGE_EVENT_TRACK_REMOVE_FEATURES,
event_attrib);
return true;
}
return false;
}
public synchronized void setFeatureVisibility(Collection features, boolean v) {
if (features.contains("Gene text label")) {
features.remove("Gene text label");
setText2dVisibility(v);
}
if (v == false) {
List features_removed = new ArrayList();
Iterator feature_vis_it = _track_feature_visibility.values()
.iterator();
while (feature_vis_it.hasNext()) {
Map feature_map = (Map) feature_vis_it.next();
Iterator feat_it = features.iterator();
while (feat_it.hasNext()) {
String f = feat_it.next().toString();
if (feature_map.containsKey(f))
feature_map.put(f, _FEATURE_GROUP_VISIBILITY_FALSE);
features_removed.add(f);
}
}
if (_my_vis != null && !features_removed.isEmpty())
_my_vis.removeFeatureNames(features_removed);
List event_list = new ArrayList();
Iterator f_it = features.iterator();
event_list.add(new Boolean(v));
event_list.addAll(features_removed);
fireStorageEvent(
StorageEvent.STORAGE_EVENT_FEATURE_VISIBILITY_CHANGED,
event_list);
return;
}
Collection tracks = _track_map.values();
Iterator t_it = tracks.iterator();
Map vis_map = new HashMap();
while (t_it.hasNext()) {
List event_list = new ArrayList();
List query_list = new ArrayList();
Track track = (Track) t_it.next();
Map feature_vis_map = (Map) _track_feature_visibility
.get(new Integer(track.getId()));
if (feature_vis_map == null) {
feature_vis_map = new HashMap();
_track_feature_visibility.put(new Integer(track.getId()),
feature_vis_map);
}
event_list.add(new Boolean(true));
Iterator f_it = features.iterator();
while (f_it.hasNext()) {
String feat = f_it.next().toString();
Integer feat_vis_state = (Integer) feature_vis_map.get(feat);
if (track.hasFeature(feat)) {
event_list.add(feat);
feature_vis_map.put(feat, _FEATURE_GROUP_VISIBILITY_TRUE);
} else if (feat_vis_state == null
|| feat_vis_state
.equals(_FEATURE_GROUP_VISIBILITY_FALSE)) {
feature_vis_map
.put(feat, _FEATURE_GROUP_VISIBILITY_PENDING);
query_list.add(feat);
}
}
if (event_list.size() > 1) {
List fl = event_list.subList(1, event_list.size());
for (Iterator it = fl.iterator(); it.hasNext();) {
String name = it.next().toString();
vis_map.put(name, new ArrayList(getFeatures(name)));
}
fireStorageEvent(
StorageEvent.STORAGE_EVENT_FEATURE_VISIBILITY_CHANGED,
event_list);
}
Collection prev_querried = (Set) _query_feature_flags
.get(new Integer(track.getId()));
if (prev_querried == null) {
prev_querried = new HashSet();
_query_feature_flags.put(new Integer(track.getId()),
prev_querried);
}
query_list.removeAll(prev_querried);
if (!query_list.isEmpty()) {
prev_querried.addAll(query_list);
List event_attrib_query = new ArrayList();
event_attrib_query.add(new Integer(track.getId()));
event_attrib_query.add(new Integer(track.getDataWindowStart()));
event_attrib_query.add(new Integer(track.getDataWindowEnd()));
event_attrib_query.addAll(query_list);
fireStorageEvent(StorageEvent.STORAGE_EVENT_TRACK_DATA_REQUEST,
event_attrib_query);
}
}
if (_my_vis != null) {
int sum = 0;
for (Iterator f = vis_map.keySet().iterator(); f.hasNext();) {
Object name = f.next();
int count = ((Collection) vis_map.get(name)).size();
System.out.println("]----> Handing to visualizer: " + name
+ " (" + count + ")");
sum += count;
}
System.out.println(">>> " + sum + " <<<");
_my_vis.addFeatures(vis_map);
}
}
private void setText2dVisibility(boolean v) {
_my_vis.setShowText2D(v);
if (getFeatureVisibility("gene")) {
setFeatureVisibility("gene", false);
setFeatureVisibility("gene", true);
}
}
public void cropTrack(int t_id) {
Track t = getTrackReference(t_id);
t.crop();
}
public boolean getFeatureVisibility(String feature) {
Iterator feature_vis_it = _track_feature_visibility.values().iterator();
while (feature_vis_it.hasNext()) {
Map feature_map = (Map) feature_vis_it.next();
Integer vis = (Integer) feature_map.get(feature);
if (vis == null || !vis.equals(_FEATURE_GROUP_VISIBILITY_TRUE))
continue;
return true;
}
return false;
}
public Collection getFeatures(String fname) {
Collection c = new ArrayList();
c.add(fname);
return getFeatures(c);
}
public Collection getFeatures(Collection fnames) {
Collection c = new ArrayList();
Collection allTracks = _track_map.values();
for (Iterator t_it = allTracks.iterator(); t_it.hasNext();) {
Track t = (Track) t_it.next();
for (Iterator f_it = fnames.iterator(); f_it.hasNext();) {
Collection l = (Collection) t.getFeatures(f_it.next()
.toString());
if (l != null)
c.addAll(l);
}
}
return c;
}
public Collection getFeatures(int t_id, String fname) {
Track t = getTrackReference(t_id);
return t.getFeatures(fname);
}
public TrackFeature getFeature(int track_id, String fname, String acc_id) {
Track t = getTrackReference(track_id);
return t.getFeatureForceUngap(fname, acc_id);
}
public TrackFeature getNextFeatureIn5PrimeDirection(int t_id,
TrackFeature tf, String fname) {
Collection features = getFeatures(t_id, fname);
if (features == null || features.isEmpty())
return null;
int strand = tf.getStrand().getValue();
TrackFeature tf_return = null;
int location, scan_location, distance;
if (strand != 1) {
location = tf.getEnd();
} else {
location = tf.getStart();
}
int min_distance = Integer.MAX_VALUE;
for (Iterator fit = features.iterator(); fit.hasNext();) {
TrackFeature tf_scan = (TrackFeature) fit.next();
if (tf_scan.getAccessionID().equals(tf.getAccessionID()))
continue;
int s = tf_scan.getStrand().getValue();
if (s != strand && s != 0)
continue;
if (s != 1) {
scan_location = tf_scan.getStart();
} else {
scan_location = tf_scan.getEnd();
}
distance = location - scan_location;
if (strand == -1)
distance = -distance;
if (distance < 0 || distance > min_distance) {
continue;
} else {
min_distance = distance;
tf_return = tf_scan;
}
}
return tf_return;
}
public TrackFeature getNextFeatureIn3PrimeDirection(int t_id,
TrackFeature tf, String fname) {
Collection features = getFeatures(t_id, fname);
if (features == null || features.isEmpty())
return null;
int strand = tf.getStrand().getValue();
TrackFeature tf_return = null;
int location, scan_location, distance;
if (strand != 1) {
location = tf.getStart();
} else {
location = tf.getEnd();
}
int min_distance = 1000000000;
for (Iterator fit = features.iterator(); fit.hasNext();) {
TrackFeature tf_scan = (TrackFeature) fit.next();
int s = tf_scan.getStrand().getValue();
if (s != strand && s != 0)
continue;
if (s != 1) {
scan_location = tf_scan.getEnd();
} else {
scan_location = tf_scan.getStart();
}
distance = scan_location - location;
if (strand == -1)
distance = -distance;
if (distance < 0 || distance > min_distance) {
continue;
} else {
min_distance = distance;
tf_return = tf_scan;
}
}
return tf_return;
}
public Collection getFeatureNames() {
Collection c = this.getAllTrackIds();
Set all_names = new HashSet();
for (Iterator it = c.iterator(); it.hasNext();)
all_names.addAll(this.getFeatureNames((Integer.parseInt(it.next()
.toString()))));
return all_names;
}
public Collection getFeatureNames(int track_id) {
Track t = getTrackReference(track_id);
return new HashSet(t.getAllFeatureNames());
}
public void setFeatureVisibility(String feature, boolean v) {
List l = new ArrayList();
l.add(feature);
setFeatureVisibility(l, v);
}
public void setFeatureVisibility(int t_id, String feature_name,
String acc_id, boolean v) {
if (_my_vis != null) {
if (v) {
Track t = getTrackReference(t_id);
TrackFeature tf = t.getFeature(feature_name, acc_id);
if (tf == null)
throw new StorageException(
"Unknown accsession id when setting feature visible: "
+ acc_id + " (Track id " + t_id
+ ", Feature: " + feature_name);
_my_vis.addFeature(tf);
} else
_my_vis.removeFeature(t_id, feature_name, acc_id);
}
List l = new ArrayList();
l.add(new Boolean(v));
l.add(feature_name);
fireStorageEvent(StorageEvent.STORAGE_EVENT_FEATURE_VISIBILITY_CHANGED,
l);
}
public void setTrackSequenceMode(int t_id, int mode) {
Track t = getTrackReference(t_id);
t.setSequenceMode(mode);
}
public int getTrackSequenceMode(int t_id) {
Track t = getTrackReference(t_id);
return t.getSequenceMode();
}
public String getTrackSequence(int t_id) {
Track t = getTrackReference(t_id);
String seq = t.getSequence();
if (seq == null) {
List event_attrib_query = new ArrayList();
event_attrib_query.add(new Integer(t_id));
event_attrib_query.add(new Integer(t._data_start));
event_attrib_query.add(new Integer(t._data_end));
event_attrib_query.add("sequence");
fireStorageEvent(StorageEvent.STORAGE_EVENT_TRACK_DATA_REQUEST,
event_attrib_query);
}
while (seq == null) {
try {
Thread.sleep(40);
} catch (InterruptedException e) { /* forget it */
}
;
seq = t.getSequence();
}
return seq;
}
public String getTrackSequence(int t_id, int start, int end) {
Track t = getTrackReference(t_id);
int seq_start = Math.max(0, start - t._window_start);
int seq_end = Math.min(t._window_end - t._window_start, end
- t._window_start);
if (seq_end < 0 || seq_start > t._window_end - t._window_start + 1) {
System.out
.println("Region completly outside of track when getting sequence!");
return null;
}
String seq = getTrackSequence(t_id);
return seq.substring(seq_start, seq_end);
}
public String getFeatureSequence(TrackFeature tf) {
Track t = getTrackReference(tf.getTrackId());
int seq_start = Math.max(0, tf.getStart() - t._window_start);
int seq_end = Math.min(t._window_end - t._window_start + 1, tf.getEnd()
- t._window_start + 1);
if (seq_end < 0 || seq_start > t._window_end - t._window_start + 1) {
System.out
.println("Feature completly outside of track when getting sequence!");
return null;
}
String seq = getTrackSequence(tf.getTrackId());
if (seq == null || seq.length() == 0) {
return seq;
}
String feature_seq = "";
String feature_name = tf.getFeature();
if (tf.getStrand() != null
&& tf.getStrand().getValue() == -1
|| (tf.getFeature().equals("region") && getTrackReverse(tf
.getTrackId()))) {
feature_seq = SequenceUtils.reverseComplementSequence(seq
.substring(seq_start, seq_end));
} else {
feature_seq = seq.substring(seq_start, seq_end);
}
return feature_seq;
}
public synchronized Set getAllTrackIds() {
return new HashSet(_track_map.keySet());
}
public synchronized List getAllOrderedTrackIds() {
return track_order;
}
public synchronized void removeallTracks() {
removeTracks(new ArrayList(getAllTrackIds()));
}
public synchronized void moveTrack(int t_id, int new_index) {
Integer track_id_obj = new Integer(t_id);
int index = track_order.indexOf(track_id_obj);
if (index < 0)
throw new IllegalArgumentException(
"Track List: Unknown track id when moving track: " + t_id);
track_order.remove(index);
track_order.add(new_index, track_id_obj);
int index_3d = 0;
for (int i = new_index; i >= 0; i--) {
int t = Integer.parseInt(track_order.get(i).toString());
if (DataStoreUser.getInstance().getSockeyeTrackList()
.getTrackVisibility(t))
index_3d++;
}
_my_vis.moveTrack(t_id, index_3d - 1);
}
public synchronized List sortTrackIDByVisualOrder(Collection ids) {
List ret_list = new ArrayList(track_order);
if (!track_order.containsAll(ids))
throw new IllegalArgumentException(
"Sumbitted unknown track in list for sorting");
ret_list.retainAll(ids);
return ret_list;
}
synchronized public int getVisibleFeatureCount() {
int count = 0;
Iterator track_it = _track_map.values().iterator();
while (track_it.hasNext())
count += ((Track) track_it.next()).countFeatures();
return count;
}
private void replaceTrack3D(int t_id, Track t) {
if (_my_vis == null)
return;
_my_vis.replaceTrack(t_id, t);
Map tf_vis_map = (Map) (_track_feature_visibility.get(new Integer(t
.getId())));
if (tf_vis_map == null)
return;
Set fs = tf_vis_map.keySet();
Iterator it = fs.iterator();
List trackfeatures = new ArrayList();
while (it.hasNext()) {
String feat = it.next().toString();
if (tf_vis_map.get(feat).equals(_FEATURE_GROUP_VISIBILITY_TRUE)) {
Collection tfc = this.getFeatures(t_id, feat);
if (tfc != null)
trackfeatures.addAll(tfc);
}
}
_my_vis.addFeatures(trackfeatures);
}
private boolean addNormalizedScore(int t_id, String feature, List tf) {
if (t_id < 0 || feature == null)
throw new IllegalArgumentException(
"Illegal Arguments in remove normalization method");
Track t = getTrackReference(t_id);
if (t.knownNoScoreFeature(feature))
return false;
double tfMaxScore = 0;
for (Iterator i = tf.iterator(); i.hasNext();) {
TrackFeature f = (TrackFeature) i.next();
String sraw = f.getAttribute("raw_score");
if (sraw == null || sraw == "")
continue;
else {
double tfScore = new Double(sraw).doubleValue();
if (tfScore > tfMaxScore)
tfMaxScore = tfScore;
}
}
if (tfMaxScore == 0)
return false;
if (_normalizeMechanism == NORMALIZE_PERFEATURE_PERTRACK) {
double tScore = t.getMaxScore(feature);
if (tScore > tfMaxScore)
t.setNormFactor(feature, normalize_multiplier / tScore);
else {
t.setMaxScore(feature, tfMaxScore);
t.setNormFactor(feature, normalize_multiplier / tfMaxScore);
return true;
}
}
else if (_normalizeMechanism == NORMALIZE_ALLFEATURE_PERTRACK) {
double tScore = t.getMaxScore();
double fScore = t.getMaxScore(feature);
if (tfMaxScore > fScore)
t.setMaxScore(feature, tfMaxScore);
if (tScore > tfMaxScore)
t.setNormFactor(feature, normalize_multiplier / tScore);
else {
t.setMaxScore(feature, tfMaxScore);
t.setNormFactor(normalize_multiplier / tfMaxScore);
return true;
}
}
else if (_normalizeMechanism == NORMALIZE_PERFEATURE_ALLTRACK) {
double trackMaxScore = t.getMaxScore(feature);
double platformMaxScore = getMaxFeatureScore(feature);
if (tfMaxScore > trackMaxScore)
t.setMaxScore(feature, tfMaxScore);
if (tfMaxScore > platformMaxScore) {
for (Iterator t_it = _track_map.values().iterator(); t_it
.hasNext();) {
Track track = (Track) t_it.next();
track.setNormFactor(feature, normalize_multiplier
/ tfMaxScore);
}
return true;
} else {
t.setNormFactor(feature, normalize_multiplier
/ platformMaxScore);
}
}
else if (_normalizeMechanism == NORMALIZE_ALLFEATURE_ALLTRACK) {
double featureMaxScore = t.getMaxScore(feature);
double platformMaxScore = getMaxPlatformScore();
if (tfMaxScore > featureMaxScore)
t.setMaxScore(feature, tfMaxScore);
if (tfMaxScore > platformMaxScore) {
for (Iterator t_it = _track_map.values().iterator(); t_it
.hasNext();) {
Track track = (Track) t_it.next();
track.setNormFactor(normalize_multiplier / tfMaxScore);
}
return true;
} else {
t.setNormFactor(feature, normalize_multiplier
/ platformMaxScore);
}
}
return false;
}
private boolean removeNormalizedScore(int t_id, String feature) {
if (t_id < 0 || feature == null)
throw new IllegalArgumentException(
"Illegal Arguments in remove normalization method");
Track t = getTrackReference(t_id);
if (t.knownNoScoreFeature(feature))
return false;
if (_normalizeMechanism == NORMALIZE_ALLFEATURE_PERTRACK) {
double oldtfMaxScore = t.getMaxScore();
double tfMaxScore = ((Double) t.removeNormScore(feature))
.doubleValue();
boolean redraw = (oldtfMaxScore == tfMaxScore);
if (redraw) {
double tScore = t.getMaxScore();
if (tScore <= 0)
return false;
t.setNormFactor(normalize_multiplier / tScore);
}
return redraw;
} else if (_normalizeMechanism == NORMALIZE_PERFEATURE_ALLTRACK) {
double oldpfMaxScore = getMaxFeatureScore(feature);
double tfMaxScore = ((Double) t.removeNormScore(feature))
.doubleValue();
boolean redraw = (tfMaxScore == oldpfMaxScore);
if (redraw) {
double pfMaxScore = getMaxFeatureScore(feature);
if (pfMaxScore <= 0)
return false;
for (Iterator t_it = _track_map.values().iterator(); t_it
.hasNext();) {
Track track = (Track) t_it.next();
track.setNormFactor(feature, normalize_multiplier
/ pfMaxScore);
}
return redraw;
}
}
else if (_normalizeMechanism == NORMALIZE_ALLFEATURE_ALLTRACK) {
double oldpMaxScore = getMaxPlatformScore();
double tfMaxScore = ((Double) t.removeNormScore(feature))
.doubleValue();
boolean redraw = (tfMaxScore == oldpMaxScore);
if (redraw) {
double pMaxScore = getMaxPlatformScore();
if (pMaxScore <= 0)
return false;
for (Iterator t_it = _track_map.values().iterator(); t_it
.hasNext();) {
Track track = (Track) t_it.next();
track.setNormFactor(normalize_multiplier / pMaxScore);
}
}
return redraw;
}
return false;
}
private boolean removeNormalizedScore(int t_id) {
if (t_id < 0)
throw new IllegalArgumentException(
"Illegal Arguments in remove normalization method");
Track t = getTrackReference(t_id);
boolean redraw = false;
if (_normalizeMechanism == NORMALIZE_PERFEATURE_ALLTRACK
|| _normalizeMechanism == NORMALIZE_ALLFEATURE_ALLTRACK) {
for (Iterator i = t.getAllFeatureNames().iterator(); i.hasNext();)
redraw = (removeNormalizedScore(t_id, i.next().toString()) || redraw);
}
return redraw;
}
private double getMaxPlatformScore() {
double dmax = 0;
for (Iterator t_it = _track_map.values().iterator(); t_it.hasNext();) {
Track track = (Track) t_it.next();
double dscore = track.getMaxScore();
if (dscore > dmax)
dmax = dscore;
}
return dmax;
}
private double getMaxFeatureScore(String feature) {
double dmax = 0;
for (Iterator t_it = _track_map.values().iterator(); t_it.hasNext();) {
Track track = (Track) t_it.next();
double dscore = track.getMaxScore(feature);
if (dscore > dmax)
dmax = dscore;
}
return dmax;
}
public int getNormalizeMethod() {
return _normalizeMechanism;
}
public void setNormalizeMethod(int method) {
if (!(method == NORMALIZE_PERFEATURE_PERTRACK)
&& (method == NORMALIZE_ALLFEATURE_PERTRACK)
&& (method == NORMALIZE_ALLFEATURE_ALLTRACK)
&& (method == NORMALIZE_PERFEATURE_ALLTRACK)) {
throw new IllegalArgumentException("Unknown normalization method");
}
if (_normalizeMechanism == method)
return;
_normalizeMechanism = method;
if (_normalizeMechanism == NORMALIZE_PERFEATURE_PERTRACK) {
for (Iterator t_it = _track_map.values().iterator(); t_it.hasNext();) {
Track track = (Track) t_it.next();
for (Iterator f_it = track.getAllFeatureNames().iterator(); f_it
.hasNext();) {
String feature = (String) f_it.next();
double dscore = track.getMaxScore(feature);
if (dscore != 0)
track.setNormFactor(feature, normalize_multiplier
/ dscore);
}
}
}
else if (_normalizeMechanism == NORMALIZE_ALLFEATURE_PERTRACK) {
for (Iterator t_it = _track_map.values().iterator(); t_it.hasNext();) {
Track track = (Track) t_it.next();
double dscore = track.getMaxScore();
if (dscore != 0)
track.setNormFactor(normalize_multiplier / dscore);
}
}
else if (_normalizeMechanism == NORMALIZE_PERFEATURE_ALLTRACK) {
Collection fnames = getFeatureNames();
for (Iterator i_fn = fnames.iterator(); i_fn.hasNext();) {
String feature = (String) i_fn.next();
double dscore = getMaxFeatureScore(feature);
if (dscore != 0)
for (Iterator t_it = _track_map.values().iterator(); t_it
.hasNext();) {
Track track = (Track) t_it.next();
track.setNormFactor(feature, normalize_multiplier
/ dscore);
}
}
}
else if (_normalizeMechanism == NORMALIZE_ALLFEATURE_ALLTRACK) {
double dscore = getMaxPlatformScore();
for (Iterator t_it = _track_map.values().iterator(); t_it.hasNext();) {
Track track = (Track) t_it.next();
track.setNormFactor(normalize_multiplier / dscore);
}
}
}
synchronized public final Track getTrackReference(int t_id) {
Object t = _track_map.get(new Integer(t_id));
if (t == null)
throw new StorageException("Unknown track id: " + t_id, t_id);
return (Track) t;
}
synchronized private static final int generateUniqueTrackId() {
return _track_id_sequence_number++;
}
synchronized public void dispose() {
dispatcher.stopDispatcher();
notifyAll();
}
private synchronized void fireStorageEvent(int type, Object attrib) {
StorageEvent se = new StorageEvent(this, type, attrib);
_event_queue.add(se);
notifyAll();
}
private synchronized StorageEvent getEvent() {
while (_event_queue.isEmpty()) {
try {
wait();
} catch (InterruptedException e) {
}
;
}
return (StorageEvent) _event_queue.remove(0);
}
private synchronized boolean testEvent() {
return (!_event_queue.isEmpty());
}
public void addStorageListener(StorageEventListener l) {
dispatcher.addStorageListener(l);
}
public void removeStorageListener(StorageEventListener l) {
dispatcher.removeStorageListener(l);
}
private class eventDispatcher extends Thread {
boolean _running = true;
private List _registered_event_listeners = new Vector();
synchronized public void addStorageListener(StorageEventListener l) {
_registered_event_listeners.add(l);
}
synchronized public void removeStorageListener(StorageEventListener l) {
_registered_event_listeners.remove(l);
}
public void run() {
while (_running) {
StorageEvent e = SockeyeTrackList.this.getEvent();
if (e == null)
continue;
sendEvent(e);
}
while (SockeyeTrackList.this.testEvent()) {
StorageEvent e = SockeyeTrackList.this.getEvent();
sendEvent(e);
}
}
synchronized private void sendEvent(StorageEvent e) {
Iterator listeners = new ArrayList(_registered_event_listeners)
.iterator();
while (listeners.hasNext()) {
try {
((StorageEventListener) listeners.next())
.storageEventReceived(e);
} catch (Exception ex) {
Log.printStackTrace(ex);
ex.printStackTrace(System.out);
}
}
}
public void stopDispatcher() {
_running = false;
}
}
}/*------
package ca.bcgsc.sockeye.datastorage;
public class StorageException extends RuntimeException {
private final int _track_id;
public StorageException() {
_track_id = -1;
}
public StorageException(String message) {
super(message);
_track_id = -1;
}
public StorageException(String message, int t_id) {
super(message);
_track_id = t_id;
}
public StorageException(String message, Throwable cause) {
super(message, cause);
_track_id = -1;
}
public StorageException(Throwable cause) {
super(cause);
_track_id = -1;
}
public int getTrackId(){
return _track_id;
}
}
package ca.bcgsc.sockeye.datastorage;
import java.text.DateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.biojava.bio.program.gff.GFFTools;
public class Track {
transient public static final int SEQ_SOFT_MASKED = 0;
transient public static final int SEQ_HARD_MASKED = 1;
transient public static final int SEQ_UNMASKED = 2;
transient public static final String TRACK_NAME_ATTRIBUTE_KEY = "track_name";
protected int _data_start;
protected int _data_end;
protected int _window_start;
protected int _window_end;
protected int _offset;
protected boolean _visible;
protected boolean _reverse;
protected Map _display_feature;
protected Map _attributes;
protected List _data_sources = new ArrayList();
protected int _my_id;
protected Map _max_feature_score;
protected Map _feature_storage;
protected List _ordered_gaps;
protected StringBuffer _sequence = null;
protected int _seq_mode = SEQ_UNMASKED;
transient protected static String[] gap_split_ignore_list = {
"Conserved Region", "track", "region", "select", };
transient protected static String copy_exclusion_string = "|Conserved Region|region|select|alignment highlight|alignment sequence highlight|vertical alignment sequence highlight|";
static {
Arrays.sort(gap_split_ignore_list);
}
public Track() {
_my_id = -1;
_data_start = -1;
_data_end = -1;
_window_start = -1;
_window_end = -1;
_offset = 0;
_visible = false;
_reverse = false;
_display_feature = new Hashtable();
_attributes = new Hashtable();
_data_sources = new ArrayList();
_feature_storage = new Hashtable();
_ordered_gaps = new ArrayList();
_max_feature_score = new HashMap();
}
public Track(int start, int end) {
this();
if (end <= start)
throw new IllegalArgumentException(
"Problem when creating track object: start (" + start + ") <= end ("
+ end + ")");
_data_start = start;
_data_end = end;
_window_start = start;
_window_end = end;
}
public void copy(Track source) {
_data_start = source._data_start;
_data_end = source._data_end;
_window_start = source._window_start;
_window_end = source._window_end;
_offset = source._offset;
_visible = source._visible;
_reverse = source._reverse;
_display_feature = new Hashtable(source._display_feature);
_attributes = new Hashtable(source._attributes);
_sequence = source._sequence;
_ordered_gaps = new ArrayList(source._ordered_gaps);
resetTrackName();
_feature_storage = new Hashtable();
for (Iterator feature_group_it = source._feature_storage.keySet()
.iterator(); feature_group_it.hasNext();) {
String feature_group = feature_group_it.next().toString();
if (copy_exclusion_string.indexOf("|" + feature_group + "|") > -1)
continue;
HashMap new_feature_map = new HashMap();
_feature_storage.put(feature_group, new_feature_map);
for (Iterator fit = ((Map) source._feature_storage.get(feature_group))
.values().iterator(); fit.hasNext();) {
TrackFeature new_tf = new TrackFeature((TrackFeature) fit.next());
new_tf.setTrackId(getId());
new_feature_map.put(new_tf.getAccessionID(), new_tf);
}
this.resetMaxScoreList(feature_group);
}
}
public Track(Track t) {
_my_id = -1;
copy(t);
}
synchronized public void crop() {
List maps_to_delete = new ArrayList();
for (Iterator it = _feature_storage.keySet().iterator(); it.hasNext();) {
String feature = it.next().toString();
Map orig_feature_map = (Map) _feature_storage.get(feature);
List to_delete = new ArrayList();
for (Iterator f_it = orig_feature_map.values().iterator(); f_it.hasNext();) {
TrackFeature stf = (TrackFeature) f_it.next();
if ((stf.getEnd() < _window_start) || (stf.getStart() > _window_end)) {
to_delete.add(stf);
continue;
}
}
for (Iterator d_it = to_delete.iterator(); d_it.hasNext();)
orig_feature_map.remove(((TrackFeature) d_it.next()).getAccessionID());
if (orig_feature_map.isEmpty())
maps_to_delete.add(feature);
}
for (Iterator m_it = maps_to_delete.iterator(); m_it.hasNext();)
_feature_storage.remove(m_it.next().toString());
_data_start = _window_start;
_data_end = _window_end;
}
synchronized public Track subTrack(int start, int end) {
Track t = new Track(start, end);
t._attributes = new Hashtable(_attributes);
t.resetTrackName();
t._visible = _visible;
t._reverse = _reverse;
t._offset += _offset
+ (!_reverse ? start - _window_start : _window_end - end);
if (_sequence != null && _sequence.length() > end - getDataStart()) {
t._sequence = new StringBuffer(_sequence.substring(
start - getDataStart(), end - getDataStart() + 1));
}
HashMap temp_feature_storage = new HashMap();
for (Iterator it = _feature_storage.keySet().iterator(); it.hasNext();) {
String feature = it.next().toString();
Map orig_feature_map = (Map) _feature_storage.get(feature);
Map new_feature_map = new HashMap();
for (Iterator f_it = orig_feature_map.values().iterator(); f_it.hasNext();) {
TrackFeature stf = (TrackFeature) f_it.next();
TrackFeature tf;
if (stf instanceof MultiDimTrackDistribution)
tf = new MultiDimTrackDistribution((MultiDimTrackDistribution) stf);
else if (stf instanceof TrackDistribution)
tf = new TrackDistribution((TrackDistribution) stf);
else
tf = new TrackFeature(stf);
if (!(tf.getStart() > end || tf.getEnd() < start)) {
new_feature_map.put(tf.getAccessionID(), tf);
}
}
if (!new_feature_map.isEmpty()) {
t._feature_storage.put(feature, new_feature_map);
}
}
return t;
}
synchronized public int getDataWindowStart() {
return _window_start;
}
synchronized public int getDataWindowEnd() {
return _window_end;
}
synchronized public int getDataStart() {
return _data_start;
}
synchronized public int getDataEnd() {
return _data_end;
}
synchronized public List setDataWindow(int start, int end) {
List rangeSnippets = new ArrayList();
if (end < start) {
throw new IllegalArgumentException("setDataWindow: End(" + end
+ ") < Start(" + start + ")");
}
if (start < 1 || end < 1) {
throw new IllegalArgumentException(
"setDataWindow: One of the arguments is smaller than 1!");
}
_window_start = start;
_window_end = end;
if (_data_start < 0 || _data_end < 0) {
_data_start = start;
_data_end = end;
rangeSnippets.add(new Integer(start));
rangeSnippets.add(new Integer(end));
return rangeSnippets;
}
if (start < _data_start) {
rangeSnippets.add(new Integer(start));
rangeSnippets.add(new Integer(_data_start));
_data_start = start;
}
if (end > _data_end) {
rangeSnippets.add(new Integer(_data_end));
rangeSnippets.add(new Integer(end));
_data_end = end;
}
return rangeSnippets;
}
synchronized public int getWindowLength() {
return _window_end - _window_start + 1;
}
synchronized public boolean setReverse(boolean b) {
return _reverse = b;
}
synchronized public boolean isReverse() {
return _reverse;
}
synchronized public boolean isFeatureVisisble(int id) {
return false;
}
synchronized public void setFeatureVisible(int id, boolean visible) {
}
synchronized public void addDataSourceId(int id) {
_data_sources.add(new Integer(id));
}
synchronized public void setAttribute(String attrib, Object value) {
_attributes.put(attrib, value);
}
synchronized public Object getAttribute(String attrib) {
return _attributes.get(attrib);
}
synchronized public Set getAllFeatureNames() {
return _feature_storage.keySet();
}
synchronized public Collection getAllFeatures() {
return _feature_storage.values();
}
synchronized public void setOffset(int offset) {
if (offset < 0) {
throw new IllegalArgumentException(
"setoffset: trying to set negative offset value");
}
_offset = offset;
}
synchronized public int getOffset() {
return _offset;
}
synchronized public boolean removeDataSourceId(int id) {
return _data_sources.remove(new Integer(id));
}
synchronized public List getDataSources() {
return _data_sources;
}
synchronized public List removeAllDatasources() {
List ret_list = new ArrayList(_data_sources);
_data_sources.clear();
return ret_list;
}
synchronized public int countFeatures() {
int count = 0;
for (Iterator i = _feature_storage.values().iterator(); i.hasNext();)
count += ((Map) i.next()).size();
return count;
}
synchronized public int getSequenceMode() {
return this._seq_mode;
}
synchronized public void setSequenceMode(int mode) {
this._seq_mode = mode;
}
synchronized public int countFeaturesInDataWindow(String feature_name) {
int count;
Map feature_map = (Map) _feature_storage.get(feature_name);
if (feature_map == null)
return 0;
count = feature_map.size();
for (Iterator fit = feature_map.values().iterator(); fit.hasNext();) {
TrackFeature f = (TrackFeature) fit.next();
if ((f.getEnd() < _window_start) || (f.getStart() > _window_end))
count--;
}
return count;
}
synchronized public int countFeatures(String feature_name) {
Map feature_map = (Map) _feature_storage.get(feature_name);
if (feature_map == null) {
return 0;
}
return feature_map.size();
}
synchronized private void splitFeaturesOnGaps(List track_features,
List ordered_gaps) {
ArrayList input_features;
TrackFeature current_feature = null;
Collections.sort(ordered_gaps);
Iterator gap_it = ordered_gaps.iterator();
TrackFeature current_gap = null;
int gap_offset = 0;
int gap_start = 0;
int gap_end = 0;
int f_start = 0;
int f_end = 0;
Map acc_id_split_map = new HashMap();
while (gap_it.hasNext()) {
current_gap = (TrackFeature) gap_it.next();
gap_start = current_gap.getStart();
gap_end = current_gap.getEnd();
gap_offset = gap_end - gap_start + 1;
input_features = new ArrayList(track_features);
Collections.sort(input_features);
if (input_features.isEmpty())
return;
for (int f_index = 0; f_index < input_features.size(); f_index++) {
current_feature = (TrackFeature) input_features.get(f_index);
if (current_feature.getAttribute("no_gap_division").length() > 0
|| Arrays.binarySearch(gap_split_ignore_list, current_feature
.getFeature()) >= 0) {
current_feature = null;
continue;
}
f_start = current_feature.getStart();
f_end = current_feature.getEnd();
if (f_end < gap_start) {
continue;
}
Integer split_count_obj = (Integer) acc_id_split_map
.get(current_feature.getAccessionID());
int split_count = split_count_obj == null ? 1 : split_count_obj
.intValue();
if (f_start < gap_start && gap_start < f_end) {
TrackFeature new_feature = new TrackFeature(current_feature);
new_feature.setEnd(gap_start - 1);
f_start = gap_end + 1;
f_end += gap_offset;
current_feature.setStart(f_start);
current_feature.setEnd(f_end);
current_feature.setAttribute("pieces", current_feature
.getAccessionID());
new_feature.setAttribute("pieces", new_feature.getAccessionID());
new_feature.setAccessionID(new_feature.getAccessionID().concat(
"_" + split_count++));
track_features.add(new_feature);
acc_id_split_map.put(current_feature.getAccessionID(), new Integer(
split_count));
continue;
}
if (split_count > 1) {
current_feature.setAccessionID(current_feature.getAccessionID()
.concat("_" + split_count));
}
current_feature.setStart(f_start + gap_offset);
current_feature.setEnd(f_end + gap_offset);
}
}
}
private void insertGapIntoSequence(int start, int end) {
if (_sequence == null)
return;
int rel_start = start - this._data_start;
int rel_end = end - this._data_start;
for (int rel_pos = rel_start; rel_pos <= rel_end; rel_pos++) {
if (rel_pos < 0)
continue;
if (rel_pos < _sequence.length()) {
_sequence.insert(rel_pos, "-");
continue;
}
_sequence.append("-");
}
}
synchronized private void putGapReferenceToOrderedList(TrackFeature gap) {
int new_gap_start = gap.getStart();
int pos;
for (pos = 0; pos < _ordered_gaps.size(); pos++) {
TrackFeature next_gap = (TrackFeature) _ordered_gaps.get(pos);
if (next_gap.equals(gap))
return;
if (new_gap_start < next_gap.getStart())
break;
}
_ordered_gaps.add(pos, gap);
}
synchronized private void putGapReferenceToOrderedList(Collection gaps) {
Iterator it = gaps.iterator();
while (it.hasNext())
putGapReferenceToOrderedList((TrackFeature) it.next());
}
synchronized public void addFeatures(String feature_name, List track_features) {
if (feature_name == null || feature_name.length() == 0) {
throw new IllegalArgumentException(
"illegal argument in track::addFeatures");
}
if (track_features == null) {
return;
}
if (feature_name.equals("gap")) {
List input_features = new ArrayList();
Iterator it = _feature_storage.keySet().iterator();
while (it.hasNext()) {
Object f_name = it.next();
if (Arrays.binarySearch(gap_split_ignore_list, f_name) < 0) {
Hashtable feature_map = new Hashtable((Map) _feature_storage
.get(f_name));
if (!feature_map.isEmpty()) {
input_features.addAll(feature_map.values());
}
}
}
int num_old_features = input_features.size();
splitFeaturesOnGaps(input_features, track_features);
for (int i = num_old_features; i < input_features.size(); i++) {
TrackFeature new_f = (TrackFeature) input_features.get(i);
Map feature_map = (Map) _feature_storage.get(new_f.getFeature());
feature_map.put(new_f.getAccessionID(), new_f);
}
for (int i = 0; i < track_features.size(); i++) {
TrackFeature gap = (TrackFeature) track_features.get(i);
insertGapIntoSequence(gap.getStart(), gap.getEnd());
}
}
else if (_feature_storage.containsKey("gap")) {
splitFeaturesOnGaps(track_features, _ordered_gaps);
}
Map feature_map = (Map) _feature_storage.get(feature_name);
if (feature_map == null) {
feature_map = new HashMap();
_feature_storage.put(feature_name, feature_map);
}
Iterator it = track_features.iterator();
while (it.hasNext()) {
TrackFeature tf = (TrackFeature) it.next();
if (tf.getAccessionID() == null || tf.getAccessionID().length() == 0)
throw new StorageException("Illegal accession id when adding feature "
+ feature_name + " to track " + _my_id);
tf.setTrackId(_my_id);
if (tf.getAccessionID().equals("sequence")) {
String seq = tf.getAttribute("sequence");
if (_sequence == null)
_sequence = new StringBuffer();
boolean firstSequence = _sequence.length() == 0;
if (tf.getStart() == _data_start) {
_sequence.insert(0, seq);
} else {
System.out.println("Sequence snippet (" + seq.length()
+ ") added at end: " + tf.getStart() + " : " + _data_end);
_sequence.append(seq);
}
if (firstSequence && _sequence.length() > 0) {
for (Iterator itr = _ordered_gaps.iterator(); itr.hasNext();) {
TrackFeature gap = (TrackFeature) itr.next();
insertGapIntoSequence(gap.getStart(), gap.getEnd());
}
}
} else {
feature_map.put(tf.getAccessionID(), tf);
}
}
if (feature_name.equals("gap")) {
putGapReferenceToOrderedList(track_features);
}
}
synchronized public void addFeature(String feature_name,
TrackFeature track_feature) {
List l = new ArrayList();
l.add(track_feature);
addFeatures(feature_name, l);
}
synchronized public List removeFeatures(List feature_names) {
List ret_val = new ArrayList();
if (feature_names == null) {
throw new IllegalArgumentException(
"illegal argument in track::removeFeatures");
}
Iterator it = feature_names.iterator();
while (it.hasNext()) {
String fname = it.next().toString();
if (_feature_storage.remove(fname) != null) {
ret_val.add(fname);
}
}
return ret_val;
}
synchronized public boolean removeFeature(String fname, String acc_id) {
Map fmap = (Map) _feature_storage.get(fname);
if (fmap == null) {
return false;
}
return (fmap.remove(acc_id) != null);
}
synchronized public String getSequence() {
String s = (_sequence == null
|| (_sequence.length() < (_data_end - _data_start)) ? null : _sequence
.toString().substring(_window_start - _data_start,
_window_end - _data_start + 1));
return handleMasking(s);
}
synchronized public String getSequence(TrackFeature tf) {
if (_sequence == null)
return null;
return handleMasking(_sequence.substring((int) Math.max(_data_start, tf
.getStart()), (int) Math.min(_data_end, tf.getEnd())));
}
private String handleMasking(String s) {
if (s != null)
switch (_seq_mode) {
case (SEQ_HARD_MASKED):
return s.replaceAll("[a-z]", "N");
case (SEQ_UNMASKED):
return s.toUpperCase();
case (SEQ_SOFT_MASKED):
return s;
}
return null;
}
synchronized public boolean removeFeature(String feature_name) {
List l = new ArrayList();
l.add(feature_name);
return (removeFeatures(l).size() > 0);
}
synchronized public boolean hasFeature(String feature) {
if (feature.equals("sequence"))
return (_sequence != null && _sequence.length() > 0);
else
return _feature_storage.containsKey(feature);
}
synchronized public boolean getVisibility() {
return _visible;
}
synchronized public void setVisibility(boolean v) {
_visible = v;
}
synchronized public int getId() {
return _my_id;
}
synchronized public void setId(int id) {
_my_id = id;
Collection c = _feature_storage.values();
for (Iterator fmap_it = c.iterator(); fmap_it.hasNext();)
for (Iterator tf_it = ((Map) fmap_it.next()).values().iterator(); tf_it
.hasNext();)
((TrackFeature) tf_it.next()).setTrackId(id);
}
synchronized public Collection getFeatures(String fname) {
Map fmap = (Map) _feature_storage.get(fname);
if (fmap == null) {
return null;
}
return fmap.values();
}
synchronized public TrackFeature getFeature(String fname, String acc_id) {
Map fmap = (Map) _feature_storage.get(fname);
if (fmap == null) {
for (Iterator m_it = _feature_storage.values().iterator(); m_it.hasNext();) {
fmap = (Map) m_it.next();
for (Iterator f_it = fmap.values().iterator(); f_it.hasNext();) {
TrackFeature tf = (TrackFeature) f_it.next();
if (tf.getAccessionID() == acc_id && tf.getFeature() == fname)
return tf;
}
}
return null;
}
return (TrackFeature) fmap.get(acc_id);
}
synchronized public TrackFeature getFeatureForceUngap(String fname,
String acc_id) {
return this.ungapFeature(getFeature(fname, acc_id));
}
private TrackFeature ungapFeature(TrackFeature tf) {
TrackFeature ug_tf = null;
int gap_correction = 0;
if (tf == null)
return null;
String root_accession_id = tf.getAttribute("pieces");
if (root_accession_id == null || root_accession_id.length() == 0)
return tf;
ug_tf = new TrackFeature(getFeature(tf.getFeature(), root_accession_id));
if (ug_tf == null)
throw new IllegalArgumentException(
"Error while ungapping feature: Couldn't find last piece with acc id: "
+ root_accession_id);
for (Iterator gip = _ordered_gaps.iterator(); gip.hasNext();) {
TrackFeature gap = (TrackFeature) gip.next();
if (gap.getEnd() <= ug_tf.getStart())
gap_correction += gap.getEnd() - gap.getStart() + 1;
else
break;
}
ug_tf.setStart(ug_tf.getStart() - gap_correction);
ug_tf.setEnd(ug_tf.getEnd() - gap_correction);
TrackFeature piece;
int index = 1;
while ((piece = getFeature(tf.getFeature(), root_accession_id + "_" + index)) != null) {
index++;
ug_tf
.setStart(ug_tf.getStart() - (piece.getEnd() - piece.getStart() + 1));
}
return ug_tf;
}
private void resetTrackName() {
String oldName = (String) getAttribute(TRACK_NAME_ATTRIBUTE_KEY);
if (oldName == null) {
return;
}
try {
int ind_1 = oldName.indexOf('-');
int ind_2 = oldName.indexOf(':');
if (ind_1 != -1 && ind_2 != -1) {
String chromosome = oldName.substring(ind_1 + 1, ind_2);
setAttribute("track_name", computeTrackName(_data_start, _data_end,
chromosome, new Date(), oldName.substring(0, oldName.indexOf('-'))));
} else
setAttribute("track_name", computeTrackName(_data_start, _data_end, "",
new Date(), oldName));
} catch (RuntimeException e) {
return;
}
}
static public String computeTrackName(int start, int end, String chromosome,
Date date, String display_name) {
StringBuffer ret = new StringBuffer();
if (chromosome.indexOf("random") < 0)
if (chromosome.length() > 4) {
char[] letter = new char[1];
letter[0] = chromosome.toCharArray()[0];
String chrom_str = new String(letter);
int num_index = chromosome.length() - 1;
while (chromosome.substring(num_index).matches("([0-9]+)")) {
num_index--;
}
if (num_index != (chromosome.length() - 1)) {
chromosome = chrom_str + chromosome.substring(num_index + 1);
}
}
int index = display_name.indexOf("-" + chromosome);
if (index > -1) {
display_name = display_name.substring(0, index);
}
ret.append(display_name.replaceAll("_", " ") + "-" + chromosome + ":");
ret.append(String.valueOf(start) + "..");
ret.append(String.valueOf(end));
ret.append("="
+ DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.FULL)
.format(date));
String track_name = ret.toString();
return track_name;
}
public void setMaxScore(String feature_name, double newScore) {
_max_feature_score.put(feature_name, new Double(newScore));
}
public void resetMaxScoreList(String feature_name) {
if (knownNoScoreFeature(feature_name))
return;
Collection features = getFeatures(feature_name);
if (features == null)
return;
double score = 0;
for (Iterator i = features.iterator(); i.hasNext();) {
TrackFeature tf = (TrackFeature) i.next();
String sraw = tf.getAttribute("raw_score");
if (sraw == null || sraw.equals(""))
continue;
double draw = new Double(sraw).doubleValue();
if (draw > score)
score = draw;
}
setMaxScore(feature_name, score);
}
public double getMaxScore(String feature_name) {
Double dscore = (Double) _max_feature_score.get(feature_name);
return (dscore != null ? dscore.doubleValue() : 0);
}
public double getMaxScore() {
double dmaxScore = 0;
Set sScore = _max_feature_score.keySet();
for (Iterator i = sScore.iterator(); i.hasNext();) {
double dscore = getMaxScore((String) i.next());
if (dscore > dmaxScore)
dmaxScore = dscore;
}
return dmaxScore;
}
public void setNormFactor(String feature_name, double norm_value) {
if (knownNoScoreFeature(feature_name))
return;
Collection features = getFeatures(feature_name);
if (features == null)
return;
for (Iterator i = features.iterator(); i.hasNext();) {
TrackFeature tf = (TrackFeature) i.next();
String sraw = tf.getAttribute("raw_score");
if (sraw == null || sraw.equals(""))
continue;
double draw = (new Double(sraw).doubleValue() * norm_value);
tf.setAttribute("norm_score", String.valueOf(draw));
tf.setScore(draw);
}
}
public void setNormFactor(double norm_value) {
for (Iterator i = _feature_storage.keySet().iterator(); i.hasNext();) {
String sfname = (String) i.next();
setNormFactor(sfname, norm_value);
}
}
public Object removeNormScore(String feature) {
if (!_max_feature_score.containsKey(feature))
return new Double(0);
return _max_feature_score.remove(feature);
}
public void setRawScore(String feature, List tfList) {
if (knownNoScoreFeature(feature))
return;
for (Iterator i = tfList.iterator(); i.hasNext();) {
TrackFeature tf = (TrackFeature) i.next();
if ((tf.getScore() != GFFTools.NO_SCORE)
&& (tf.getAttribute("raw_score") == ""))
tf.setAttribute("raw_score", String.valueOf(tf.getScore()));
}
}
public boolean knownNoScoreFeature(String feature) {
return (feature.equals("gene") || feature.equals("exon")
|| feature.equals("sequence") || feature.equals("masked_sequence")
|| feature.equals("region") || feature.equals("generic_unscored") || feature
.equals("repeats"));
}
}
package ca.bcgsc.sockeye.datastorage;
import java.util.ArrayList;
import java.util.Iterator;
import org.biojava.bio.seq.StrandParser;
import ca.bcgsc.sockeye.service.featureloader.common.DistributionContainer;
public class TrackDistribution extends TrackFeature{
private ArrayList _distribution_info;
private int _track_id;
protected static boolean _display = false;
protected int _start;
protected int _end;
private double _max_score;
public TrackDistribution() {
}
public TrackDistribution(int track_id, String feature_id) {
setTrackId(track_id);
setAccessionID(feature_id);
setStrand(StrandParser.parseStrand("1"));
}
public TrackDistribution(TrackDistribution td){
this(td.getDistributionInfo(), td.getTrackId(), td.getFeature());
}
public TrackDistribution(ArrayList distribution_info, int track_id,
String feature_id) {
this._distribution_info = distribution_info;
setTrackId(track_id);
setFeature("distribution");
this.setAccessionID(feature_id);
int min_start = -1;
int max_end = -1;
_max_score = 0;
for (Iterator i = distribution_info.iterator(); i.hasNext(); ) {
DistributionContainer dc = (DistributionContainer) i.next();
if (min_start == -1) {
min_start = dc.getStart();
}
if (max_end == -1) {
max_end = dc.getEnd();
}
if (dc.getStart() < min_start) {
min_start = dc.getStart();
}
if (dc.getEnd() > max_end) {
max_end = dc.getEnd();
}
if (dc.getScore() > _max_score) {
_max_score = dc.getScore();
}
}
this._start = min_start;
this._end = max_end;
setStrand(StrandParser.parseStrand("1"));
}
public boolean getDisplay() {
return _display;
}
public void setDisplay(boolean display) {
TrackDistribution._display = _display;
}
public String getParentName() {
return "";
}
public Object getFeatureObject() {
return null;
}
public String toString() {
StringBuffer ret = new StringBuffer();
ret.append("display id=" + _display + "\n");
return ret.toString();
}
public int getTrackId() {
return this._track_id;
}
public void setTrackId(int track_id){
_track_id = track_id;
}
public String getFeatureType() {
return "distribution";
}
public void setEnd(int e){
_end = e;
}
public void setStart(int s){
_start = s;
}
public int getStart() {
return this._start;
}
public ArrayList getDistributionInfo() {
return this._distribution_info;
}
public int getEnd() {
return this._end;
}
public double getMaxScore() {
return this._max_score;
}
}
package ca.bcgsc.sockeye.datastorage;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.biojava.bio.program.gff.SimpleGFFRecord;
import org.biojava.bio.seq.StrandParser;
import ca.bcgsc.chinook.server.comobj.SerializableSimpleGFFRecord;
public class TrackFeature extends SimpleGFFRecord implements Comparable {
private HashMap groupAttachments = new HashMap();
public TrackFeature() {
}
public TrackFeature(String feature_name) {
setFeature(feature_name);
}
public TrackFeature(SimpleGFFRecord rec) {
super(rec);
}
public TrackFeature(String seqname, String source, String feature,
int start, int end, double score, int strand, int frame) {
setSeqName(seqname);
setSource(source);
setFeature(feature);
setStart(start);
setEnd(end);
setScore(score);
StrandParser sp = new StrandParser();
setStrand(StrandParser.parseStrand(String.valueOf(strand)));
setFrame(frame);
}
public TrackFeature(SerializableSimpleGFFRecord gffr, int offset) {
this(gffr.getSeqName(), gffr.getSource(), gffr.getFeature(), gffr
.getStart()
+ offset, gffr.getEnd() + offset, gffr.getScore(), gffr
.getStrand(), gffr.getFrame());
this.setGroupAttributes(gffr.getGroupAttributes());
}
public String getAttribute(String key) {
ArrayList tn = (ArrayList) ((Map) getGroupAttributes()).get(key);
if (tn == null || tn.isEmpty())
return "";
else
return (String) tn.get(0);
}
public List getGroupAttribute(String key) {
return (List) getGroupAttributes().get(key);
}
public void setAttribute(String key, List group) {
getGroupAttributes().put(key, group);
}
public void setAttribute(String key, String value) {
ArrayList temp = new ArrayList();
temp.add(value);
getGroupAttributes().put(key, temp);
}
public Object getAttachment(String key) {
return groupAttachments.get(key);
}
public void setAttachment(String key, Object obj) {
groupAttachments.put(key, obj);
}
public int getTrackId() {
return Integer.parseInt(getAttribute("track_id").toString());
}
public String getAccessionID() {
return getAttribute("ID");
}
public String getSeqName() {
return super.getSeqName();
}
public void setTrackId(int track_id) {
setAttribute("track_id", Integer.toString(track_id));
}
public void setAccessionID(String accession_id) {
setAttribute("ID", accession_id);
}
public int compareTo(Object track_feature) {
TrackFeature tf = (TrackFeature) track_feature;
if (this.getStart() < tf.getStart()) {
return -1;
} else if (this.getStart() > tf.getStart()) {
return 1;
} else {
return 0;
}
}
public String toString() {
return ">>TrackFeature: " + this.getFeature() + ": "
+ this.getAccessionID() + " " + this.getStart() + ".."
+ this.getEnd() + " " + this.getTrackId();
}
}/*------
package ca.bcgsc.sockeye.datastorage;
import java.util.HashMap;
import java.util.List;
import ca.bcgsc.chinook.server.comobj.SerializableSimpleGFFRecord;
public class TrackUtil {
private static final HashMap scaleMap = new HashMap();
static {
scaleMap.put("ncc_score_fwd", new Double(200.0));
}
private TrackUtil() {
}
static int _feature_id = 0;
static public void smoothScore(
List rawResults,
int trk_id,
int wordSize,
int windowSize,
double threshold,
int offset,
List smoothedResults) {
for (int wstart = 0;
wstart < rawResults.size() - windowSize;
wstart++) {
SerializableSimpleGFFRecord tf =
((SerializableSimpleGFFRecord) rawResults.get(wstart));
double average_score = tf.getScore();
int start = tf.getStart();
for (int i = wstart + 1; i < wstart + windowSize; i++) {
tf = (SerializableSimpleGFFRecord) rawResults.get(i);
average_score += tf.getScore();
}
int end = tf.getStart() + wordSize - 1;
average_score = average_score / windowSize;
System.out.println("START : " + start + " AVERAGE SCORE : " + average_score);
if (average_score > threshold) {
TrackFeature feature =
new TrackFeature(
tf.getSeqName(),
tf.getSource(),
tf.getFeature(),
start + offset,
end + offset,
average_score - threshold,
tf.getStrand(),
tf.getFrame());
feature.setTrackId(trk_id);
feature.setAccessionID(String.valueOf(_feature_id++));
feature.setAttribute(
"score",
String.valueOf((float) average_score));
feature.setAttribute(
"threshold",
String.valueOf((float) threshold));
smoothedResults.add(feature);
}
}
scale(smoothedResults);
}
public static void scale(List features) {
for (int i = 0; i < features.size(); i++) {
((TrackFeature) features.get(i)).setScore(
((TrackFeature) features.get(i)).getScore()
}
}
}
package ca.bcgsc.sockeye.datastorage.ensembl;
import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.Reader;
import java.net.JarURLConnection;
import java.net.URL;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.List;
import java.util.StringTokenizer;
import java.util.Vector;
import java.util.jar.JarFile;
import ca.bcgsc.sockeye.util.Log;
import ca.bcgsc.sockeye.util.ResourceLoader;
public abstract class CachedChromosomeInfo {
protected Hashtable chromosome_name;
protected Hashtable chromosome_length;
private final static String _DATA_LOCATION = "resources/chromosome/";
private final static String _EXTENSION = ".data";
public CachedChromosomeInfo() {
chromosome_name = new Hashtable();
chromosome_length = new Hashtable();
fetchChromosomeFile();
}
public String[] getChromosomeName(String species) {
Vector name_vector = (Vector) chromosome_name.get(species);
int size = name_vector.size();
String[] chrom_name_list = new String[size];
for (int j = 0; j < size; j++) {
chrom_name_list[j] = (String) name_vector.get(j);
}
return chrom_name_list;
}
public int[] getChromosomeLength(String species) {
Vector length_vector = (Vector) chromosome_length.get(species);
int size = length_vector.size();
int[] chrom_length_list = new int[size];
for (int j = 0; j < size; j++) {
chrom_length_list[j] = ((Integer) length_vector.get(j)).intValue();
}
return chrom_length_list;
}
public Object[] getSpecies() {
Object[] species_list = chromosome_name.keySet().toArray();
return species_list;
}
public Object[] getLengths() {
Object[] chrom_length_list = chromosome_length.values().toArray();
return chrom_length_list;
}
public Object[] getNames() {
Object[] species_list = chromosome_name.values().toArray();
return species_list;
}
protected void fetchInfo(String species) {
if (!chromosome_name.containsKey(species)) {
Vector length_vector = new Vector();
Vector name_vector = new Vector();
try {
Reader resourceReader =
ResourceLoader.getReader(_DATA_LOCATION + species + _EXTENSION);
if (resourceReader != null && resourceReader.ready()) {
BufferedReader reader = new BufferedReader(resourceReader);
String speciesName = reader.readLine();
String singleLine = reader.readLine();
while (singleLine != null) {
if (!(singleLine.equals(""))) {
StringTokenizer st = new StringTokenizer(singleLine, " ");
String name = st.nextToken();
String length = st.nextToken();
name_vector.add(name);
length_vector.add(new Integer(length));
}
singleLine = reader.readLine();
}
chromosome_name.put(species, name_vector);
chromosome_length.put(species, length_vector);
}
}
catch (IOException e) {
}
}
}
protected void fetchChromosomeFile() {
String[] listofFiles = getListOfCacheFiles();
for (int index = 0; index < listofFiles.length; index++) {
fetchInfo(listofFiles[index].substring(0, listofFiles[index].length() - 5));
}
}
protected String[] getListOfCacheFiles(){
int version = getVersion();
File cachedDataDirectory = new File(_DATA_LOCATION);
List fileNameList = new ArrayList();
boolean isJarFile = false;
String urlStr = null;
Log.println("Differentiating between JAR and local file...");
URL url = this.getClass().getClassLoader().getResource("ca/bcgsc/sockeye/gui/Sockeye.class");
if (url==null){
Log.println("This does not work, trying my luck with file access!!!");
}
else{
urlStr = url.toString();
Log.println("Retrieved URL is : " + urlStr);
if (urlStr.startsWith("jar:")){
Log.println("I think we live in a JAR file!!!");
isJarFile = true;
}
}
if (isJarFile){
try{
int to = urlStr.indexOf("!/") + 2;
String cacheUrlStr = urlStr.substring(0, to);
URL cache_url = new URL(cacheUrlStr);
URL file_url = new URL(cache_url, "user_config.xml");
JarURLConnection connection =
(JarURLConnection) (file_url.openConnection());
connection.setDoInput(true);
connection.setDoOutput(false);
connection.connect();
if (connection instanceof JarURLConnection) {
JarURLConnection jURL = (JarURLConnection) connection;
JarFile jfile = jURL.getJarFile();
Enumeration enum = jfile.entries();
while (enum.hasMoreElements()) {
String entry = enum.nextElement().toString();
if (entry.matches(".*_core_" + version + "_.*")){
String filename = entry.substring(entry.lastIndexOf("/"));
fileNameList.add(filename);
}
}
}
else return null;
}
catch(Exception e){
System.out.println(e.getStackTrace());
}
return (String[])fileNameList.toArray(new String[fileNameList.size()]) ;
}
File[] listofFiles = cachedDataDirectory.listFiles();
if (listofFiles != null) {
for (int index = 0; index < listofFiles.length; index++) {
if (listofFiles[index].isFile()) {
String fileName = listofFiles[index].getName();
boolean match = fileName.matches(".*_core_" + version + "_.*");
if (match) {
fileNameList.add(fileName);
}
}
}
}
return (String[])fileNameList.toArray(new String[fileNameList.size()]) ;
}
protected abstract int getVersion();
}
package ca.bcgsc.sockeye.datastorage.ensembl;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.Reader;
import java.util.ArrayList;
import java.util.Hashtable;
import ca.bcgsc.sockeye.util.Log;
import ca.bcgsc.sockeye.util.ResourceLoader;
public class CachedGeneID{
protected static Hashtable geneID_table= new Hashtable();
private final static String _DATA_LOCATION = "resources/geneID/";
private final static String _EXTENSION = ".data";
public CachedGeneID() {
}
public static ArrayList getGeneID(String species) {
fetchInfo(species);
ArrayList geneID_list = (ArrayList) geneID_table.get(species);
return geneID_list;
}
private static void fetchInfo(String species) {
if (!geneID_table.containsKey(species)) {
ArrayList geneID_list = new ArrayList();
try {
Reader resourceReader =
ResourceLoader.getReader(_DATA_LOCATION + species + _EXTENSION);
if (resourceReader != null && resourceReader.ready()) {
BufferedReader reader = new BufferedReader(resourceReader);
String speciesName = reader.readLine();
String singleLine = reader.readLine();
while (singleLine != null) {
if (!(singleLine.equals(""))) {
geneID_list.add(singleLine);
}
singleLine = reader.readLine();
}
geneID_table.put(species, geneID_list);
}
}
catch (IOException e) {
Log.printStackTrace(e);
e.printStackTrace();
}
}
}
}
package ca.bcgsc.sockeye.datastorage.ensembl;
import java.util.HashMap;
import java.util.Map;
import ca.bcgsc.sockeye.datastorage.HitGeneInfo;
public class CachedOrthologuesInfo {
private static HashMap ortho = new HashMap();
public synchronized static Object getHitGeneInfo(String hit_species, String hit_id) {
return (ortho.get(hit_species) == null)
? null
: ((Map) ortho.get(hit_species)).get(hit_id);
}
public synchronized static void putHitGeneInfo(
String hit_species,
String hit_id,
HitGeneInfo hi) {
Map o = null;
if (ortho.get(hit_species) == null) {
o = new HashMap();
ortho.put(hit_species, o);
} else {
o = (Map) ortho.get(hit_species);
}
o.put(hit_id, hi);
}
}
package ca.bcgsc.sockeye.datastorage.ensembl;
public class ChromInfo_core_14 extends CachedChromosomeInfo
{
public ChromInfo_core_14()
{
super();
}
protected int getVersion() {
return 14;
}
}
package ca.bcgsc.sockeye.datastorage.ensembl;
public class ChromInfo_core_15 extends CachedChromosomeInfo
{
public ChromInfo_core_15()
{
super();
}
protected int getVersion() {
return 15;
}
}
package ca.bcgsc.sockeye.datastorage.ensembl;
public class ChromInfo_core_16 extends CachedChromosomeInfo
{
public ChromInfo_core_16()
{
super();
}
protected int getVersion() {
return 16;
}
}
package ca.bcgsc.sockeye.datastorage.ensembl;
public class ChromInfo_core_17 extends CachedChromosomeInfo
{
public ChromInfo_core_17()
{
super();
}
protected int getVersion() {
return 17;
}
}
package ca.bcgsc.sockeye.datastorage.ensembl;
public class ChromInfo_core_18 extends CachedChromosomeInfo
{
public ChromInfo_core_18()
{
super();
}
protected int getVersion() {
return 18;
}
}
package ca.bcgsc.sockeye.datastorage.ensembl;
public class ChromInfo_core_19 extends CachedChromosomeInfo
{
public ChromInfo_core_19()
{
super();
}
protected int getVersion() {
return 19;
}
}
package ca.bcgsc.sockeye.datastorage.ensembl;
public class ChromInfo_core_20 extends CachedChromosomeInfo
{
public ChromInfo_core_20()
{
super();
}
protected int getVersion() {
return 20;
}
}
package ca.bcgsc.sockeye.datastorage.ensembl;
public class ChromInfo_core_21 extends CachedChromosomeInfo
{
public ChromInfo_core_21()
{
super();
}
protected int getVersion() {
return 21;
}
}
package ca.bcgsc.sockeye.datastorage.ensembl;
public class ChromInfo_core_22 extends CachedChromosomeInfo
{
public ChromInfo_core_22()
{
super();
}
protected int getVersion() {
return 22;
}
}
package ca.bcgsc.sockeye.datastorage.ensembl;
public class ChromInfo_core_27 extends CachedChromosomeInfo
{
public ChromInfo_core_27()
{
super();
}
protected int getVersion() {
return 27;
}
}
package ca.bcgsc.sockeye.datastorage.ensembl;
public class ChromInfo_core_28 {
public ChromInfo_core_28()
{
super();
}
protected int getVersion() {
return 28;
}
}package ca.bcgsc.sockeye.datastorage.ensembl;
public class ChromInfo_core_29 {
public ChromInfo_core_29()
{
super();
}
protected int getVersion() {
return 29;
}
}
package ca.bcgsc.sockeye.datastorage.ensembl;
public class ChromInfo_core_30 extends CachedChromosomeInfo
{
public ChromInfo_core_30()
{
super();
}
protected int getVersion() {
return 30;
}
}
package ca.bcgsc.sockeye.datastorage.events;
import java.util.EventObject;
public class StorageEvent extends EventObject {
public static final int STORAGE_EVENT_TRACK_ADD = 0;
public static final int STORAGE_EVENT_TRACK_REMOVE = 1;
public static final int STORAGE_EVENT_TRACK_VISIBILITY_CHANGED = 2;
public static final int STORAGE_EVENT_TRACK_ADD_FEATURES = 3;
public static final int STORAGE_EVENT_TRACK_REMOVE_FEATURES = 4;
public static final int STORAGE_EVENT_FEATURE_VISIBILITY_CHANGED = 5;
public static final int STORAGE_EVENT_TRACK_ADD_DS = 6;
public static final int STORAGE_EVENT_TRACK_REMOVE_DS = 7;
public static final int STORAGE_EVENT_TRACK_REVERSED_STATE_CHANGED = 8;
public static final int STORAGE_EVENT_TRACK_ATTRIBUTE_CHANGED = 9;
public static final int STORAGE_EVENT_TRACK_DATA_WINDOW_CHANGED = 10;
public static final int STORAGE_EVENT_TRACK_DATA_REQUEST = 11;
public static final int STORAGE_EVENT_TRACK_OFFSET_CHANGED = 12;
private final Object _event_attribute;
private final int _my_type;
public StorageEvent(Object source, int t, Object attrib) {
super(source);
_my_type = t;
_event_attribute = attrib;
}
public StorageEvent(Object source, int t) {
super(source);
_my_type = t;
_event_attribute = null;
}
public int getEventType(){
return _my_type;
}
public Object getAttribute(){
return _event_attribute;
}
}
package ca.bcgsc.sockeye.datastorage.events;
public interface StorageEventListener {
void storageEventReceived(StorageEvent e);
}
package ca.bcgsc.sockeye.datastorage.junit;
import ca.bcgsc.sockeye.datastorage.events.*;
import ca.bcgsc.sockeye.datastorage.*;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import junit.framework.*;
import java.util.*;
public class TrackListTest
extends TestCase
implements StorageEventListener {
private SockeyeTrackList dsm;
private List receivedEvents = new ArrayList();
public TrackListTest(String p0) {
super(p0);
}
public void testAddSingleTrack() {
System.out.println("Testing to add a single track...");
Track t = new Track();
int track_id = dsm.addTrack(t);
assertEquals("Wrong track count reported: " + dsm.getTrackCount(),
1, dsm.getTrackCount());
StorageEvent event = checkEventTypeReceived(StorageEvent.
STORAGE_EVENT_TRACK_ADD);
assertTrue("Event expected but non received!",
event != null);
Object event_attrib = event.getAttribute();
assertTrue("Wrong event attribute type!",
event_attrib instanceof List);
assertEquals("Wrong event attribute list size!",
1, ( (List) event_attrib).size());
assertEquals("Wrong track id in event attribute",
track_id,
Integer.parseInt( ( (List) event_attrib).get(0).toString()));
}
public void testAddMultipleTracks() {
System.out.println("Testing to add multiple tracks...");
final int num_tracks = 10;
List tracks = new ArrayList();
for (int i = 0; i < num_tracks; i++)
tracks.add(new Track());
List ids = dsm.addTracks(tracks);
assertEquals("Wrong track count reported",
num_tracks, dsm.getTrackCount());
StorageEvent event = checkEventTypeReceived(StorageEvent.
STORAGE_EVENT_TRACK_ADD);
assertTrue("Event expected but non received!",
event != null);
Object event_attrib = event.getAttribute();
assertTrue("Wrong event attribute type",
event_attrib instanceof List);
List event_id_list = (List) event_attrib;
List check_for_double_id_list = new ArrayList();
assertEquals("Wrong number of tracks reported in event attributes!",
num_tracks, event_id_list.size());
Iterator it = event_id_list.iterator();
while (it.hasNext()) {
Object obj = it.next();
assertTrue("Wrong event attribute type",
obj instanceof Integer);
assertTrue("Illegal track reported in event!",
ids.contains(obj));
assertTrue("Double event reported!",
!check_for_double_id_list.contains(obj));
check_for_double_id_list.add(obj);
}
}
public void testRemoveSingleTrack() {
System.out.println("Testing to remove a single track...");
final int num_tracks = 10;
List tracks = new ArrayList();
for (int i = 0; i < num_tracks; i++)
tracks.add(new Track());
List ids = dsm.addTracks(tracks);
assertEquals("Wrong number of tracks reported after insert!",
num_tracks, dsm.getTrackCount());
int remove_id = Integer.parseInt(ids.get(num_tracks / 2).toString());
Track t;
try {
t = dsm.removeTrack(remove_id);
assertEquals("Wrong id reported when removing track",
t.getId(), remove_id);
}
catch (StorageException e) {
fail(e.toString());
}
StorageEvent event = checkEventTypeReceived(StorageEvent.
STORAGE_EVENT_TRACK_REMOVE);
assertTrue("Event expected but non caught!",
event != null);
Object event_attrib = event.getAttribute();
assertTrue("Wrong event attribute type!",
event_attrib instanceof List);
assertEquals("Wrong event attribute list size!",
1, ( (List) event_attrib).size());
assertEquals("Wrong track id in event argument",
remove_id,
Integer.parseInt( ( (List) event_attrib).get(0).toString()));
}
public void testRemoveOneUnknownTrack() {
System.out.println("Testing to remove a unknown track...");
Track t = new Track();
int track_id = dsm.addTrack(t);
assertEquals("Wrong track count after inserting track!",
1, dsm.getTrackCount());
try {
dsm.removeTrack(track_id + 1);
fail("No exception thrown!");
}
catch (StorageException e) {}
;
assertEquals("Wrong track count after deleting track!",
1, dsm.getTrackCount());
StorageEvent event = checkEventTypeReceived(StorageEvent.
STORAGE_EVENT_TRACK_REMOVE);
assertNull("No event expected, but got one!",
event);
}
public void testRemoveMultipleTracks() {
System.out.println("Testing removal of multiple tracks...");
final int num_tracks = 10;
List tracks = new ArrayList();
for (int i = 0; i < num_tracks; i++)
tracks.add(new Track());
List ids = dsm.addTracks(tracks);
assertEquals("Wrong number of tracks reported after insert!",
num_tracks, dsm.getTrackCount());
List remove_ids = new ArrayList();
for (int i = 1; i < num_tracks; i += 2)
remove_ids.add(ids.get(i));
Collection tracks_returned;
try {
tracks_returned = dsm.removeTracks(remove_ids);
assertEquals("Wrong number of ids after removal!",
remove_ids.size(), tracks_returned.size());
Iterator it = tracks_returned.iterator();
while (it.hasNext()) {
Object t = it.next();
assertTrue("Wrong return list element type, expected integer!",
t instanceof Track);
assertTrue("Unknown track id returned",
remove_ids.contains(new Integer( ( (Track) t).getId())));
}
}
catch (StorageException e) {
fail(e.toString());
}
StorageEvent event = checkEventTypeReceived(StorageEvent.
STORAGE_EVENT_TRACK_REMOVE);
assertTrue("Event expected, but non caught!",
event != null);
Object event_attrib = event.getAttribute();
assertTrue("Wrong event attribute type!",
event_attrib instanceof List);
assertEquals("Wrong size of event attribute list!",
remove_ids.size(), ( (List) event_attrib).size());
assertTrue("Illegal element in list!",
remove_ids.containsAll( (List) event_attrib));
}
public void testAddAndRemoveDataSource() {
System.out.println(
"Testing adding and removal of a data source id to a track...");
Track t = new Track();
int t_id = dsm.addTrack(t);
final int ds_id = 231;
dsm.addDataSourceId(t_id, ds_id);
StorageEvent event = checkEventTypeReceived(StorageEvent.
STORAGE_EVENT_TRACK_ADD_DS);
assertTrue("Expected event, but none caught!", event != null);
Object d = event.getAttribute();
assertTrue("Wrong event argument type!", d instanceof List);
assertEquals("Wrong event argument list size!", 2, ( (List) d).size());
assertEquals("Illegal track id in event argument", t_id,
Integer.parseInt( ( (List) d).get(0).toString()));
assertEquals("Illegal datasource id in event argument", ds_id,
Integer.parseInt( ( (List) d).get(1).toString()));
List all_ds = dsm.getDataSources(t_id);
assertTrue("No datasources returned!", all_ds != null);
assertEquals("Wrong return list size!", 1, all_ds.size());
assertEquals("Wrong datasource id returned!", ds_id,
Integer.parseInt(all_ds.get(0).toString()));
try {
dsm.removeDataSourceId(t_id, 10);
fail("No exception thrown when removing unknown datasource id!");
}
catch (StorageException e) {
assertEquals("Wrong track id in exception!", t_id, e.getTrackId());
}
event = checkEventTypeReceived(StorageEvent.STORAGE_EVENT_TRACK_REMOVE_DS);
assertNull("No event expected, but caught one!", event);
dsm.removeDataSourceId(t_id, ds_id);
assertTrue("Data sourced didn't get deleted!",
dsm.getDataSources(t_id).isEmpty());
event = checkEventTypeReceived(StorageEvent.STORAGE_EVENT_TRACK_REMOVE_DS);
assertTrue("No event caught, but exspected one!", event != null);
d = event.getAttribute();
assertTrue("Wrong event parameter type!", d instanceof List);
assertEquals("Wrong event parameter list size!", 2, ( (List) d).size());
assertEquals("Wrong track id in event parameter!", t_id,
Integer.parseInt( ( (List) d).get(0).toString()));
assertEquals(ds_id, Integer.parseInt( ( (List) d).get(1).toString()));
}
public void testGetAndRemoveAllDataSources() {
System.out.println("Testing to get and remove all datasources...");
final int num_ds = 34;
Track t = new Track();
int t_id = dsm.addTrack(t);
for (int i = 0; i < num_ds; i++)
dsm.addDataSourceId(t_id, i);
assertEquals("Wrong number of datasources inserted!", num_ds,
dsm.getDataSources(t_id).size());
dsm.removeAllDataSources(t_id);
assertTrue("Not all datasources removed!", dsm.getDataSources(t_id).isEmpty());
StorageEvent event = checkEventTypeReceived(StorageEvent.
STORAGE_EVENT_TRACK_REMOVE_DS);
assertTrue("Expected event, but didn't catch one!", event != null);
Object d = event.getAttribute();
assertTrue("Wrong event parameter type", d instanceof List);
assertEquals("Wrong number of data sources in event attributes: " +
(num_ds + 1) + " / " + ( (List) d).size(),
num_ds + 1, ( (List) d).size());
assertEquals("Wrong track id!", t_id,
Integer.parseInt( ( (List) d).get(0).toString()));
for (int i = 0; i < num_ds; i++)
assertEquals("Wrong data source id!", i,
Integer.parseInt( ( (List) d).get(1 + i).toString()));
}
public void testSetTrackVisibility() {
System.out.println("Testing to set track visibility...");
Track t = new Track();
int t_id = dsm.addTrack(t);
try {
dsm.setTrackVisibility(t_id + 1, false);
fail("Exception expected when setting unknown tracks visibility");
}
catch (StorageException e) {
assertEquals("Wrong track id in exception!", t_id + 1, e.getTrackId());
}
StorageEvent event = checkEventTypeReceived(StorageEvent.
STORAGE_EVENT_TRACK_VISIBILITY_CHANGED);
assertTrue(
"There should a track-visibility-changed event when adding a track!",
event!=null);
dsm.setTrackVisibility(t_id, false);
assertEquals("Wrong track visibility after setting!", false,
dsm.getTrackVisibility(t_id));
event = checkEventTypeReceived(StorageEvent.
STORAGE_EVENT_TRACK_VISIBILITY_CHANGED);
assertTrue("No event caught, but exspected one!", event != null);
Object d = event.getAttribute();
assertTrue("Wrong event parameter type!", d instanceof List);
assertEquals("Wrong event paramter list size!", 2, ( (List) d).size());
assertEquals("Wrong track id in event parameter!",
t_id, Integer.parseInt( ( (List) d).get(0).toString()));
assertEquals("Wrong value in argument: Expected <false>, is: *" +
( (List) d).get(1).toString() + "*",
Boolean.toString(false), ( (List) d).get(1).toString());
dsm.setTrackVisibility(t_id, true);
assertEquals("Wrong track visibility after setting!", true,
dsm.getTrackVisibility(t_id));
event = checkEventTypeReceived(StorageEvent.
STORAGE_EVENT_TRACK_VISIBILITY_CHANGED);
assertTrue("No event caught, but exspected one!", event != null);
d = event.getAttribute();
assertTrue("Wrong event parameter type!", d instanceof List);
assertEquals("Wrong event paramter list size!", 2, ( (List) d).size());
assertEquals("Wrong track id in event parameter!", t_id,
Integer.parseInt( ( (List) d).get(0).toString()));
assertEquals("Wrong value in argument: Expected <true>, is: *" +
( (List) d).get(1).toString() + "*",
Boolean.toString(true), ( (List) d).get(1).toString());
}
public void testSetTrackReverseState() {
System.out.println("Testing to set a tracks reverse state...");
Track t = new Track();
int t_id = dsm.addTrack(t);
try {
dsm.setTrackReverse(t_id + 1, false);
fail("Exception expected when setting unknown tracks reverse state");
}
catch (StorageException e) {
assertEquals("Wrong track id in exception!", t_id + 1, e.getTrackId());
}
StorageEvent event = checkEventTypeReceived(StorageEvent.
STORAGE_EVENT_TRACK_REVERSED_STATE_CHANGED);
assertNull(
"There should be no event when setting unknown tracks reverse state",
event);
dsm.setTrackReverse(t_id, true);
assertEquals("Wrong track reverse state after setting!", true,
dsm.getTrackReverse(t_id));
event = checkEventTypeReceived(StorageEvent.
STORAGE_EVENT_TRACK_REVERSED_STATE_CHANGED);
assertTrue("No event caught, but exspected one!", event != null);
Object d = event.getAttribute();
assertTrue("Wrong event parameter type!", d instanceof List);
assertEquals("Wrong event paramter list size!", 2, ( (List) d).size());
assertEquals("Wrong track id in event parameter!",
t_id, Integer.parseInt( ( (List) d).get(0).toString()));
assertEquals("Wrong value in argument: Expected <true>, is: *" +
( (List) d).get(1).toString() + "*",
Boolean.toString(true), ( (List) d).get(1).toString());
dsm.setTrackReverse(t_id, false);
assertEquals("Wrong track reverse state after setting!", false,
dsm.getTrackReverse(t_id));
event = checkEventTypeReceived(StorageEvent.
STORAGE_EVENT_TRACK_REVERSED_STATE_CHANGED);
assertTrue("No event caught, but exspected one!", event != null);
d = event.getAttribute();
assertTrue("Wrong event parameter type!", d instanceof List);
assertEquals("Wrong event paramter list size!", 2, ( (List) d).size());
assertEquals("Wrong track id in event parameter!", t_id,
Integer.parseInt( ( (List) d).get(0).toString()));
assertEquals("Wrong value in argument: Expected <false>, is: *" +
( (List) d).get(1).toString() + "*",
false, Boolean.getBoolean( ( (List) d).get(1).toString()));
}
public void testSetDataWindow() {
System.out.println("Testing to set data windows...");
Track t = new Track();
int t_id = dsm.addTrack(t);
StorageEvent event;
try {
dsm.setTrackDataWindow(t_id + 1, 100, 100000);
fail("Exception expected when setting unknown tracks reverse state");
}
catch (StorageException e) {
assertEquals("Wrong track id in exception!", t_id + 1, e.getTrackId());
}
try {
dsm.setTrackDataWindow(t_id, 0, 1);
fail("Exception expected when setting tracks illegal window size");
}
catch (IllegalArgumentException e) {
}
event = checkEventTypeReceived(StorageEvent.
STORAGE_EVENT_TRACK_DATA_WINDOW_CHANGED);
assertNull("We should not have gotten a window chang event!", event);
event = checkEventTypeReceived(StorageEvent.
STORAGE_EVENT_TRACK_DATA_REQUEST);
assertEquals("We should not have gotten a data request event!", event, null);
try {
dsm.setTrackDataWindow(t_id, 553, 123456);
}
catch (IllegalArgumentException e) {
fail("There should be no exception thrown here!");
}
assertEquals("Wrong start value set (first time)", 553,
dsm.getTrackDataWindowStart(t_id));
assertEquals("Wrong end value set (first time)", 123456,
dsm.getTrackDataWindowEnd(t_id));
event = checkEventTypeReceived(StorageEvent.
STORAGE_EVENT_TRACK_DATA_WINDOW_CHANGED);
Object d = event.getAttribute();
assertTrue("Wrong event parameter type!", d instanceof List);
assertEquals("Wrong event paramter list size!", 3, ( (List) d).size());
assertEquals("Wrong track id in event parameter!",
t_id, Integer.parseInt( ( (List) d).get(0).toString()));
assertEquals("Wrong start value in event parameter!",
553, Integer.parseInt( ( (List) d).get(1).toString()));
assertEquals("Wrong end value in event parameter!",
123456, Integer.parseInt( ( (List) d).get(2).toString()));
event = checkEventTypeReceived(StorageEvent.
STORAGE_EVENT_TRACK_DATA_REQUEST);
assertTrue("Expecting an event, but got none!", event != null);
d = event.getAttribute();
assertTrue("Wrong event parameter type!", d instanceof List);
assertEquals("Wrong event paramter list size!", 3, ( (List) d).size());
assertEquals("Wrong track id in event parameter!",
t_id, Integer.parseInt( ( (List) d).get(0).toString()));
assertEquals("Wrong start value in event parameter!",
553, Integer.parseInt( ( (List) d).get(1).toString()));
assertEquals("Wrong end value in event parameter!",
123456, Integer.parseInt( ( (List) d).get(2).toString()));
try {
dsm.setTrackDataWindow(t_id, 1000, 100000);
}
catch (IllegalArgumentException e) {
fail("There should be no exception thrown here!");
}
assertEquals("Wrong start value set (zoom in)", 1000,
dsm.getTrackDataWindowStart(t_id));
assertEquals("Wrong end value set (zoom in)", 100000,
dsm.getTrackDataWindowEnd(t_id));
event = checkEventTypeReceived(StorageEvent.
STORAGE_EVENT_TRACK_DATA_WINDOW_CHANGED);
d = event.getAttribute();
assertTrue("Wrong event parameter type!", d instanceof List);
assertEquals("Wrong event paramter list size!", 3, ( (List) d).size());
assertEquals("Wrong track id in event parameter!",
t_id, Integer.parseInt( ( (List) d).get(0).toString()));
assertEquals("Wrong start value in event parameter!",
1000, Integer.parseInt( ( (List) d).get(1).toString()));
assertEquals("Wrong end value in event parameter!",
100000, Integer.parseInt( ( (List) d).get(2).toString()));
event = checkEventTypeReceived(StorageEvent.
STORAGE_EVENT_TRACK_DATA_REQUEST);
assertNull("No data request event expected, but got one!", event);
try {
dsm.setTrackDataWindow(t_id, 10, 50000);
}
catch (IllegalArgumentException e) {
fail("There should be no exception thrown here!");
}
assertEquals("Wrong start value set (extend left)", 10,
dsm.getTrackDataWindowStart(t_id));
assertEquals("Wrong end value set (extend left)", 50000,
dsm.getTrackDataWindowEnd(t_id));
event = checkEventTypeReceived(StorageEvent.
STORAGE_EVENT_TRACK_DATA_WINDOW_CHANGED);
d = event.getAttribute();
assertTrue("Wrong event parameter type!", d instanceof List);
assertEquals("Wrong event paramter list size!", 3, ( (List) d).size());
assertEquals("Wrong track id in event parameter!",
t_id, Integer.parseInt( ( (List) d).get(0).toString()));
assertEquals("Wrong start value in event parameter!",
10, Integer.parseInt( ( (List) d).get(1).toString()));
assertEquals("Wrong end value in event parameter!",
50000, Integer.parseInt( ( (List) d).get(2).toString()));
event = checkEventTypeReceived(StorageEvent.
STORAGE_EVENT_TRACK_DATA_REQUEST);
d = event.getAttribute();
assertTrue("Wrong event parameter type!", d instanceof List);
assertEquals("Wrong event paramter list size!", 3, ( (List) d).size());
assertEquals("Wrong track id in event parameter!",
t_id, Integer.parseInt( ( (List) d).get(0).toString()));
assertEquals("Wrong start value in event parameter!",
10, Integer.parseInt( ( (List) d).get(1).toString()));
assertEquals("Wrong end value in event parameter!",
553, Integer.parseInt( ( (List) d).get(2).toString()));
try {
dsm.setTrackDataWindow(t_id, 50, 200000);
}
catch (IllegalArgumentException e) {
fail("There should be no exception thrown here!");
}
assertEquals("Wrong start value set (extend right)", 50,
dsm.getTrackDataWindowStart(t_id));
assertEquals("Wrong end value set (extend right)", 200000,
dsm.getTrackDataWindowEnd(t_id));
event = checkEventTypeReceived(StorageEvent.
STORAGE_EVENT_TRACK_DATA_WINDOW_CHANGED);
d = event.getAttribute();
assertTrue("Wrong event parameter type!", d instanceof List);
assertEquals("Wrong event paramter list size!", 3, ( (List) d).size());
assertEquals("Wrong track id in event parameter!",
t_id, Integer.parseInt( ( (List) d).get(0).toString()));
assertEquals("Wrong start value in event parameter!",
50, Integer.parseInt( ( (List) d).get(1).toString()));
assertEquals("Wrong end value in event parameter!",
200000, Integer.parseInt( ( (List) d).get(2).toString()));
event = checkEventTypeReceived(StorageEvent.
STORAGE_EVENT_TRACK_DATA_REQUEST);
d = event.getAttribute();
assertTrue("Wrong event parameter type!", d instanceof List);
assertEquals("Wrong event paramter list size!", 3, ( (List) d).size());
assertEquals("Wrong track id in event parameter!",
t_id, Integer.parseInt( ( (List) d).get(0).toString()));
assertEquals("Wrong start value in event parameter!",
123456, Integer.parseInt( ( (List) d).get(1).toString()));
assertEquals("Wrong end value in event parameter!",
200000, Integer.parseInt( ( (List) d).get(2).toString()));
try {
dsm.setTrackDataWindow(t_id, 1, 200010);
}
catch (IllegalArgumentException e) {
fail("There should be no exception thrown here!");
}
assertEquals("Wrong start value set (zoom out)", 1,
dsm.getTrackDataWindowStart(t_id));
assertEquals("Wrong end value set (zoom out)", 200010,
dsm.getTrackDataWindowEnd(t_id));
event = checkEventTypeReceived(StorageEvent.
STORAGE_EVENT_TRACK_DATA_WINDOW_CHANGED);
d = event.getAttribute();
assertTrue("Wrong event parameter type!", d instanceof List);
assertEquals("Wrong event paramter list size!", 3, ( (List) d).size());
assertEquals("Wrong track id in event parameter!",
t_id, Integer.parseInt( ( (List) d).get(0).toString()));
assertEquals("Wrong start value in event parameter!",
1, Integer.parseInt( ( (List) d).get(1).toString()));
assertEquals("Wrong end value in event parameter!",
200010, Integer.parseInt( ( (List) d).get(2).toString()));
event = checkEventTypeReceived(StorageEvent.
STORAGE_EVENT_TRACK_DATA_REQUEST);
StorageEvent event2 = checkEventTypeReceived(StorageEvent.
STORAGE_EVENT_TRACK_DATA_REQUEST);
assertTrue("Event expected, but got none", event != null);
assertTrue("Second event expected, but got none", event2 != null);
d = event.getAttribute();
Object d2 = event2.getAttribute();
assertTrue("Wrong event parameter type!", d instanceof List);
assertTrue("Wrong event parameter type!", d2 instanceof List);
assertEquals("Wrong event paramter list size!", 3, ( (List) d).size());
assertEquals("Wrong event paramter list size!", 3, ( (List) d2).size());
assertEquals("Wrong track id in event parameter!",
t_id, Integer.parseInt( ( (List) d).get(0).toString()));
assertEquals("Wrong track id in event parameter!",
t_id, Integer.parseInt( ( (List) d2).get(0).toString()));
int start1 = Integer.parseInt( ( (List) d).get(1).toString());
int end1 = Integer.parseInt( ( (List) d).get(2).toString());
int start2 = Integer.parseInt( ( (List) d2).get(1).toString());
int end2 = Integer.parseInt( ( (List) d2).get(2).toString());
if (! ( (start1 == 1 && end1 == 10) || (start2 == 1 && end2 == 10)))
fail("Sticking out front part not present!");
if (! ( (start1 == 200000 && end1 == 200010) ||
(start2 == 200000 && end2 == 200010)))
fail("Sticking out end part not present!");
}
public void testSetTrackAttribute() {
System.out.println("Testing to set a tracks attributes...");
Track t = new Track();
final int t_id = dsm.addTrack(t);
final String attrib = "Attrib1";
final List a_value = new ArrayList();
try {
dsm.setTrackAttribute(t_id + 1, attrib, a_value);
fail("Exception expected when setting unknown tracks attribute");
}
catch (StorageException e) {
assertEquals("Wrong track id in exception!", t_id + 1, e.getTrackId());
}
StorageEvent event = checkEventTypeReceived(StorageEvent.
STORAGE_EVENT_TRACK_ATTRIBUTE_CHANGED);
assertEquals(
"There should be no event when setting unknown tracks attribute",
event, null);
dsm.setTrackAttribute(t_id, attrib, a_value);
assertEquals("track attribute not stored after setting!", a_value,
dsm.getTrackAttribute(t_id, attrib));
event = checkEventTypeReceived(StorageEvent.
STORAGE_EVENT_TRACK_ATTRIBUTE_CHANGED);
assertTrue("No event caught, but exspected one!", event != null);
Object d = event.getAttribute();
assertTrue("Wrong event parameter type!", d instanceof List);
assertEquals("Wrong event paramter list size!", 3, ( (List) d).size());
assertEquals("Wrong track id in event parameter!",
t_id, Integer.parseInt( ( (List) d).get(0).toString()));
assertEquals("Wrong attribute in event parameterargument!",
attrib, ( (List) d).get(1).toString());
assertEquals("Wrong attribute value in event parameter argument!",
a_value, ( (List) d).get(2));
}
public void testSetTrackOffset(){
System.out.println("Testing to set a tracks offset...");
Track t = new Track();
final int t_id = dsm.addTrack(t);
try {
dsm.setTrackOffset(t_id + 1, 123);
fail("Exception expected when setting unknown tracks attribute");
}
catch (StorageException e) {
assertEquals("Wrong track id in exception!", t_id + 1, e.getTrackId());
}
StorageEvent event = checkEventTypeReceived(StorageEvent.STORAGE_EVENT_TRACK_OFFSET_CHANGED);
assertEquals(
"There should be no event when setting unknown tracks attribute",
event, null);
dsm.setTrackOffset(t_id, 123);
assertEquals("track offset not stored after setting!", 123,
dsm.getTrackOffset(t_id));
event = checkEventTypeReceived(StorageEvent.STORAGE_EVENT_TRACK_OFFSET_CHANGED);
assertTrue("No event caught, but exspected one!", event != null);
Object d = event.getAttribute();
assertTrue("Wrong event parameter type!", d instanceof List);
assertEquals("Wrong event paramter list size!", 2, ( (List) d).size());
assertEquals("Wrong track id in event parameter!",
t_id, Integer.parseInt( ( (List) d).get(0).toString()));
assertEquals("Wrong attribute in event parameterargument!",
123, Integer.parseInt( ((List) d).get(1).toString()));
}
public void testAddFeaturesAsList(){
System.out.println("Testing to set a tracks offset...");
Track t = new Track();
final int t_id = dsm.addTrack(t);
final int num_features = 10;
final String feature_name = "DEMO";
List flist = new ArrayList();
for (int i=0; i < num_features; i++){
TrackFeature tf = new TrackFeature();
tf.setAccessionID("Testfeature " + Integer.toString(i));
flist.add(tf);
}
try {
dsm.addFeatures(t_id + 1, feature_name, flist);
fail("Exception expected when setting unknown tracks attribute");
}
catch (StorageException e) {
assertEquals("Wrong track id in exception!", t_id + 1, e.getTrackId());
}
dsm.addFeatures(t_id, feature_name, flist);
assertEquals (num_features, dsm.getFeatureCount(t_id, feature_name));
assertEquals (num_features, dsm.getFeatureCount(feature_name));
}
protected synchronized void setUp() {
dsm = new SockeyeTrackList();
dsm.addStorageListener(this);
}
protected void tearDown() {
dsm.dispose();
dsm = null;
try {
Thread.sleep(300);
}
catch (InterruptedException e) {}
receivedEvents.clear();
}
private synchronized StorageEvent checkEventTypeReceived(int t) {
Iterator it = receivedEvents.iterator();
while (it.hasNext()) {
StorageEvent e = (StorageEvent) it.next();
if (e.getEventType() == t) {
receivedEvents.remove(e);
return e;
}
}
for (int i = 0; i < 20; i++) {
try {
wait(100);
}
catch (InterruptedException e) {}
it = receivedEvents.iterator();
while (it.hasNext()) {
StorageEvent e = (StorageEvent) it.next();
if (e.getEventType() == t) {
receivedEvents.remove(e);
return e;
}
}
}
return null;
}
public synchronized void storageEventReceived(StorageEvent e) {
receivedEvents.add(e);
}
public static Test suite() {
TestSuite suite = new TestSuite(TrackListTest.class);
return suite;
}
public static void main(String args[]) {
junit.textui.TestRunner.run(suite());
}
}
package ca.bcgsc.sockeye.gui;
import java.awt.BorderLayout;
import java.awt.Frame;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.net.URL;
import java.net.URLConnection;
import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.JTextField;
import javax.swing.JTextPane;
import ca.bcgsc.sockeye.config.Configuration;
public class AskUsQuestionDialog extends JDialog {
private JPanel p_bottom = new JPanel();
private JButton b_send = new JButton("Send");
private JButton b_cancel = new JButton("Cancel");
private JPanel p_center = new JPanel();
private JLabel l_email = new JLabel(" Type your e-mail:");
private static JTextField tf_email = new JTextField();
private JTextPane tp_about = new JTextPane();
private JScrollPane sp_question = new JScrollPane();
private JTextArea ta_question = new JTextArea();
public AskUsQuestionDialog(Frame parent) {
super(parent, "Ask us question", true);
try {
init();
setLocationRelativeTo(null);
show();
} catch (Exception e) {
e.printStackTrace();
}
}
private void init() throws Exception {
this.setSize(400, 400);
this.setResizable(false);
this.getContentPane().setLayout(new BorderLayout());
setBackground(Configuration.gui_blue);
getContentPane().setBackground(Configuration.gui_blue);
p_center.setLayout(new GridBagLayout());
p_center.setBackground(Configuration.gui_blue);
tp_about.setBorder(BorderFactory.createEtchedBorder(1));
tp_about.setBackground(Configuration.gui_blue);
tp_about.setEditable(false);
tp_about.setText(
" We want to help you discovering the powers of sockeye. \n If you have "
+ "a question or suggestion, please send it to us using the\n following "
+ "form. \n Please include an email address so that we can respond. \n We "
+ "will get back to you immediately.\n\n Your Sockeye Team");
getContentPane().add(p_bottom, BorderLayout.SOUTH);
p_bottom.setBackground(Configuration.gui_blue);
p_bottom.add(b_send, null);
b_send.setEnabled(false);
getRootPane().setDefaultButton(b_send);
b_send.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
try {
b_send_actionPerformed();
} catch (Exception ex) {
}
}
});
p_bottom.add(b_cancel, null);
b_cancel.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
dispose();
}
});
l_email.setBackground(Configuration.gui_blue);
tf_email.addKeyListener(new KeyListener() {
public void keyPressed(KeyEvent e) {
}
public void keyReleased(KeyEvent e) {
setButtonSend();
}
public void keyTyped(KeyEvent e) {
setButtonSend();
}
});
ta_question.addKeyListener(new KeyListener() {
public void keyPressed(KeyEvent e) {
}
public void keyReleased(KeyEvent e) {
setButtonSend();
}
public void keyTyped(KeyEvent e) {
setButtonSend();
}
});
getContentPane().add(p_center, BorderLayout.CENTER);
p_center.add(
l_email,
new GridBagConstraints(
0,
1,
1,
1,
0.0,
0.0,
GridBagConstraints.CENTER,
GridBagConstraints.NONE,
new Insets(5, 5, 5, 5),
0,
0));
p_center.add(
tf_email,
new GridBagConstraints(
1,
1,
1,
1,
0.0,
0.0,
GridBagConstraints.CENTER,
GridBagConstraints.BOTH,
new Insets(5, 5, 5, 5),
0,
0));
p_center.add(
tp_about,
new GridBagConstraints(
0,
0,
2,
1,
1.0,
0.0,
GridBagConstraints.CENTER,
GridBagConstraints.BOTH,
new Insets(5, 5, 10, 5),
0,
0));
p_center.add(
sp_question,
new GridBagConstraints(
0,
2,
2,
1,
0.0,
1.0,
GridBagConstraints.CENTER,
GridBagConstraints.BOTH,
new Insets(0, 5, 0, 5),
0,
0));
sp_question.getViewport().add(ta_question, null);
}
private void setButtonSend() {
if (ta_question.getText().length() != 0) {
if (tf_email.getText().length() != 0)
b_send.setEnabled(true);
else
b_send.setEnabled(false);
} else
b_send.setEnabled(false);
}
private void b_send_actionPerformed() {
Thread thread = new Thread(new Runnable() {
public void run() {
try {
String mail = tf_email.getText();
if (mail.indexOf("@") == -1
|| mail.indexOf(" ") != -1
|| mail.split("@")[1].indexOf(".") == -1) {
JOptionPane.showMessageDialog(
Sockeye.__frame,
"Check your e-mail string",
"Format error",
JOptionPane.ERROR_MESSAGE);
return;
}
String address = Configuration.getHelpEmail();
dispose();
System.getProperties().put("mail.host", address.split("@")[1]);
URL u = new URL("mailto:" + address);
URLConnection c = u.openConnection();
c.setDoInput(false);
c.setDoOutput(true);
c.connect();
PrintWriter out =
new PrintWriter(new OutputStreamWriter(c.getOutputStream()));
out.print("From: ");
out.println(mail);
out.print("To: ");
out.println(address);
out.print("Subject: ");
out.println("Message from Sockeye dialog");
out.println();
out.println(ta_question.getText());
out.close();
JOptionPane.showMessageDialog(
Sockeye.__frame,
"Your message sent to " + address + ".",
"Information",
JOptionPane.INFORMATION_MESSAGE);
} catch (Exception e) {
JOptionPane.showMessageDialog(
Sockeye.__frame,
"Your message has not been sent.",
"Error",
JOptionPane.ERROR_MESSAGE);
}
}
});
thread.start();
}
}
package ca.bcgsc.sockeye.gui;
import java.awt.BorderLayout;
import java.awt.Frame;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JButton;
import javax.swing.JDialog;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JSplitPane;
import javax.swing.JTextPane;
import ca.bcgsc.sockeye.dataretrieval.CisREDConnection;
import ca.bcgsc.genereg.utils.*;
public class AtomicMotifDialog extends JDialog {
private final static int _MAX_WIDTH = 300;
private final static int _MAX_HEIGHT = 300;
private static List _instances = new ArrayList();
private JSplitPane sp_center = new JSplitPane();
private JScrollPane sp_motif = new JScrollPane();
private JTextPane tp_motif = new JTextPane();
private JScrollPane sp_logo = new JScrollPane();
private JPanel p_logo;
private JPanel p_bottom = new JPanel();
private JButton b_close = new JButton("Close");
private int[][] matrix;
public static void showDialog(Frame frame, String motif_name) {
for (int i = 0; i < _instances.size(); i++) {
AtomicMotifDialog instance = (AtomicMotifDialog) _instances.get(i);
if (instance.getTitle().endsWith(motif_name)){
instance.setVisible(true);
return;
}
}
_instances.add(new AtomicMotifDialog(frame, motif_name));
}
public AtomicMotifDialog(Frame frame, String motif_name) {
super(frame, "Atomic Motif cisRED id: " + motif_name);
toFront();
setLocationRelativeTo(frame);
setResizable(false);
getContentPane().setLayout(new BorderLayout());
getContentPane().add(sp_center, BorderLayout.CENTER);
getContentPane().add(p_bottom, BorderLayout.SOUTH);
p_bottom.add(b_close);
b_close.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
_instances.remove(AtomicMotifDialog.this);
dispose();
}
});
tp_motif.setFont(new java.awt.Font("Courier New", 1, 12));
tp_motif.setEditable(false);
CisREDConnection con = new CisREDConnection();
ResultSet res = con.getSitesequenceByFeatureId(motif_name);
List seq_list = new ArrayList();
if (res != null) {
try {
StringBuffer sb = new StringBuffer();
while (res.next()) {
String seq = res.getString("sequence");
seq_list.add(seq);
sb.append(seq + " \n");
}
tp_motif.setText(sb.toString());
} catch (SQLException e) {
e.printStackTrace();
}
}
con.closeConnection();
sp_center.setOrientation(JSplitPane.HORIZONTAL_SPLIT);
sp_motif.getViewport().add(tp_motif);
BuildLogo logo = new BuildLogo(seq_list, BuildLogo.__WITH_SEQ_SITES_OPTION);
sp_logo.setPreferredSize(logo.getSize());
sp_logo.getViewport().add(logo.createSeqLogo());
sp_center.add(sp_motif, JSplitPane.LEFT);
sp_center.add(sp_logo, JSplitPane.RIGHT);
pack();
show();
}
}
package ca.bcgsc.sockeye.gui;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.Image;
import java.awt.event.ActionEvent;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JDialog;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTextField;
import ca.bcgsc.sockeye.util.Log;
public class CreateViewDialog extends JDialog {
private JPanel jpanel = new JPanel();
private JLabel jlabel = new JLabel("Enter View Name:");
private JTextField jtextfield = new JTextField();
private JButton ok_button = new JButton("OK");
private JButton cancel_button = new JButton("Cancel");
public CreateViewDialog(JFrame parent) {
super(parent, "Save Current View", true);
try {
jbInit();
initHelp();
} catch (Exception e) {
Log.printStackTrace(e);
}
}
void jbInit() {
this.setSize(150, 180);
this.setLocationRelativeTo(null);
this.setResizable(false);
final Image thumbnail = MainFrame.getVis3D().captureCanvas(50, 50);
ImageIcon icon = new ImageIcon(thumbnail);
JLabel icon_label = new JLabel(icon);
jlabel.setPreferredSize(new Dimension(120, 20));
jtextfield.setPreferredSize(new Dimension(100, 20));
ok_button.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
ok_button_actionPerformed(e, thumbnail);
}
});
cancel_button.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
cancel_button_actionPerformed(e);
}
});
jpanel.setLayout(new FlowLayout());
jpanel.add(icon_label);
jpanel.add(jlabel);
jpanel.add(jtextfield);
jpanel.add(ok_button);
jpanel.add(cancel_button);
this.getContentPane().add(jpanel);
this.show();
}
void initHelp() {
}
void ok_button_actionPerformed(ActionEvent e, Image thumbnail) {
boolean saved = SockeyeMenubar.addUserView(jtextfield.getText(), thumbnail);
if (saved) close_dialog();
}
void cancel_button_actionPerformed(ActionEvent e) {
close_dialog();
}
void close_dialog() {
Sockeye.__frame.setVisible(true);
Sockeye.__frame.setEnabled(true);
dispose();
}
}
package ca.bcgsc.sockeye.gui;
import java.awt.BorderLayout;
import java.awt.Frame;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.event.ActionEvent;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.ArrayList;
import java.util.List;
import javax.swing.DefaultListModel;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextField;
import org.xmlbio.jdas.datamodel.Feature;
import org.xmlbio.jdas.datamodel.Type;
import ca.bcgsc.sockeye.config.Connection;
import ca.bcgsc.sockeye.dataretrieval.DASDataSource;
import ca.bcgsc.sockeye.dataretrieval.DASServer;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.gui.scomponents.ComboBoxRenderer;
import ca.bcgsc.sockeye.service.featureloader.common.ConnectionManager;
public class DASAnnotationsDialog extends JDialog {
private static String _NOT_AVAILABLE = "Not available";
private JPanel p_center = new JPanel();
private JLabel l_ds = new JLabel("Data sources:");
private JComboBox cb_ds = new JComboBox();
private JLabel l_chromosome = new JLabel("Chromosome:");
private JComboBox cb_chromosome = new JComboBox();
private JLabel l_start = new JLabel("Start:");
private JLabel l_end = new JLabel("End:");
private JTextField tf_start = new JTextField();
private JTextField tf_end = new JTextField();
private JLabel b_features = new JLabel("Available features:");
private JPanel p_bottom = new JPanel();
private JButton b_load = new JButton("Load");
private JButton b_close = new JButton("Close");
private DefaultListModel feature_list_model = new DefaultListModel();
private JScrollPane sp_feature_list = new JScrollPane();
private JList list_features = new JList(feature_list_model);
private JLabel l_servers = new JLabel("Servers:");
private JComboBox cb_servers = new JComboBox();
private JTextField tp_descr = new JTextField();
private JLabel l_descr = new JLabel("Description:");
private DASDataSource das_ds;
private boolean action = true;
int track_id;
private String species;
public DASAnnotationsDialog(
Frame parent,
int track_id_,
int start,
int end,
String species_) {
super(parent);
toFront();
try {
track_id = track_id_;
species = species_;
jbInit(start, end);
setLocationRelativeTo(parent);
show();
} catch (Exception e) {
e.printStackTrace();
}
}
private void jbInit(int start, int end) throws Exception {
setSize(500, 400);
setTitle("DAS Annotations");
p_center.setLayout(new GridBagLayout());
cb_servers =
new JComboBox(
ConnectionManager
.getConnectionNames(DASDataSource.__DAS_TYPE)
.toArray());
tf_start.setText(String.valueOf(start));
tf_end.setText(String.valueOf(end));
tf_start.setEditable(false);
tf_end.setEditable(false);
b_load.setEnabled(false);
tp_descr.setEditable(false);
this.getContentPane().add(p_center, BorderLayout.CENTER);
sp_feature_list.getViewport().add(list_features);
p_center.add(
l_ds,
new GridBagConstraints(
0,
2,
1,
1,
0.3,
0.0,
GridBagConstraints.EAST,
GridBagConstraints.NONE,
new Insets(0, 5, 5, 5),
0,
0));
p_center.add(
l_chromosome,
new GridBagConstraints(
0,
4,
1,
2,
0.0,
0.0,
GridBagConstraints.EAST,
GridBagConstraints.NONE,
new Insets(5, 5, 5, 5),
0,
0));
p_center.add(
cb_chromosome,
new GridBagConstraints(
1,
4,
2,
1,
0.0,
0.0,
GridBagConstraints.CENTER,
GridBagConstraints.BOTH,
new Insets(5, 5, 0, 5),
0,
0));
p_center.add(
l_start,
new GridBagConstraints(
0,
6,
1,
1,
0.0,
0.0,
GridBagConstraints.EAST,
GridBagConstraints.NONE,
new Insets(5, 5, 5, 5),
0,
0));
p_center.add(
l_end,
new GridBagConstraints(
0,
7,
1,
1,
0.0,
0.0,
GridBagConstraints.EAST,
GridBagConstraints.NONE,
new Insets(5, 5, 5, 5),
0,
0));
p_center.add(
tf_start,
new GridBagConstraints(
1,
6,
2,
1,
0.0,
0.0,
GridBagConstraints.CENTER,
GridBagConstraints.BOTH,
new Insets(5, 5, 5, 5),
0,
0));
p_center.add(
tf_end,
new GridBagConstraints(
1,
7,
2,
1,
0.0,
0.0,
GridBagConstraints.CENTER,
GridBagConstraints.BOTH,
new Insets(5, 5, 5, 5),
0,
0));
p_center.add(
b_features,
new GridBagConstraints(
0,
8,
1,
1,
0.0,
0.0,
GridBagConstraints.NORTHEAST,
GridBagConstraints.NONE,
new Insets(5, 5, 5, 5),
0,
0));
p_center.add(
sp_feature_list,
new GridBagConstraints(
1,
8,
2,
1,
0.0,
1.5,
GridBagConstraints.CENTER,
GridBagConstraints.BOTH,
new Insets(5, 5, 5, 5),
0,
0));
p_center.add(
l_servers,
new GridBagConstraints(
0,
0,
1,
2,
0.0,
0.0,
GridBagConstraints.EAST,
GridBagConstraints.NONE,
new Insets(5, 5, 5, 5),
0,
0));
p_center.add(
cb_servers,
new GridBagConstraints(
1,
0,
1,
1,
0.0,
0.0,
GridBagConstraints.CENTER,
GridBagConstraints.BOTH,
new Insets(5, 5, 5, 5),
0,
0));
p_center.add(
cb_ds,
new GridBagConstraints(
1,
2,
1,
1,
1.7,
0.0,
GridBagConstraints.CENTER,
GridBagConstraints.BOTH,
new Insets(5, 5, 0, 5),
0,
0));
p_center.add(
tp_descr,
new GridBagConstraints(
1,
3,
1,
1,
0.0,
0.0,
GridBagConstraints.CENTER,
GridBagConstraints.BOTH,
new Insets(5, 5, 5, 5),
0,
0));
p_center.add(
l_descr,
new GridBagConstraints(
0,
3,
1,
1,
0.0,
0.0,
GridBagConstraints.NORTHEAST,
GridBagConstraints.NONE,
new Insets(5, 5, 5, 5),
0,
0));
this.getContentPane().add(p_bottom, BorderLayout.SOUTH);
p_bottom.add(b_load, null);
p_bottom.add(b_close, null);
addMouseListener(new MouseListener() {
public void mouseClicked(MouseEvent e) {
list_features.clearSelection();
}
public void mouseEntered(MouseEvent e) {
}
public void mouseReleased(MouseEvent e) {
}
public void mousePressed(MouseEvent e) {
}
public void mouseExited(MouseEvent e) {
}
});
tf_start.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
cb_chromosome_actionPerformed(e);
}
});
tf_end.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
cb_chromosome_actionPerformed(e);
}
});
b_load.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
b_load_actionPerformed(e);
}
});
b_close.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
dispose();
}
});
cb_servers.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
cb_servers_actionPerformed(e);
}
});
cb_ds.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
cb_ds_actionPerformed(e);
}
});
cb_chromosome.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
cb_chromosome_actionPerformed(e);
}
});
das_ds = DASDataSource.getDASDataSource(null, null, track_id, start, end);
if (das_ds == null) {
String sel_server_name = getPreselectedServerName(species);
if (sel_server_name != null)
cb_servers.setSelectedItem(sel_server_name);
else
cb_servers.setSelectedIndex(0);
} else {
String server_name = das_ds.getServerName();
String ds_name = das_ds.getJDASDataSourceName();
String chrom = das_ds.getSelectedChromosome();
Object[] features = null;
try {
features = das_ds.getFeaturesNames(chrom);
} catch (Exception e) {
}
action = false;
if (server_name != null) {
cb_servers.setSelectedItem(server_name);
if (ds_name != null) {
cb_ds.setSelectedItem(ds_name);
if (chrom != null) {
cb_chromosome.setSelectedItem(chrom);
if (features != null)
setFeaturesListEnabled(features.length != 0);
for (int i = 0; i < features.length; i++) {
feature_list_model.addElement(features[i]);
}
action = true;
}
}
}
}
}
public void cb_chromosome_actionPerformed(ActionEvent e) {
if (!action)
return;
b_load.setEnabled(false);
Object sel_server = cb_servers.getSelectedItem();
Object ds_name = cb_ds.getSelectedItem();
Object chrom = cb_chromosome.getSelectedItem();
String start = tf_start.getText();
String end = tf_end.getText();
if (sel_server != null
&& !sel_server.equals("")
&& ds_name != null
&& !ds_name.equals("")
&& chrom != null
&& !chrom.equals("")) {
if (start.equals("") || end.equals("")) {
JOptionPane.showMessageDialog(this, "Specify start and end");
return;
}
if (chrom.toString().toString().equals(_NOT_AVAILABLE))
return;
try {
Object[] features = das_ds.getFeaturesNames(chrom.toString());
setFeaturesListEnabled(features.length != 0);
for (int i = 0; i < features.length; i++) {
feature_list_model.addElement(features[i]);
}
} catch (Exception ex) {
setFeaturesListEnabled(false);
}
}
}
public void b_load_actionPerformed(ActionEvent e) {
Object sel_server = cb_servers.getSelectedItem();
Object ds_name = cb_ds.getSelectedItem();
Object chrom = cb_chromosome.getSelectedItem();
Object[] sel_features = list_features.getSelectedValues();
if (sel_server != null
&& !sel_server.equals("")
&& ds_name != null
&& !ds_name.equals("")
&& chrom != null
&& !chrom.equals("")) {
if (sel_features == null || sel_features.length == 0) {
sel_features = feature_list_model.toArray();
}
try {
das_ds.getFeaturesToLoad(sel_features, chrom.toString());
List features_to_display = new ArrayList();
for (int i = 0; i < sel_features.length; i++) {
features_to_display.add(sel_features[i].toString());
}
DataStoreUser.getInstance().getSockeyeTrackList().addStorageListener(
das_ds);
DataStoreUser.getInstance().getDataSourceManager().addDataSource(
das_ds);
DataStoreUser.getInstance().getSockeyeTrackList().setFeatureVisibility(
features_to_display,
true);
} catch (Exception ex) {
JOptionPane.showMessageDialog(
this,
ex.getMessage(),
"Error",
JOptionPane.ERROR_MESSAGE);
}
}
}
public void cb_ds_actionPerformed(ActionEvent e) {
Object sel_server = cb_servers.getSelectedItem();
Object ds_name = cb_ds.getSelectedItem();
if (sel_server != null
&& !sel_server.equals("")
&& ds_name != null
&& !ds_name.equals("")) {
if (ds_name.toString().equals(_NOT_AVAILABLE))
return;
try {
das_ds =
DASDataSource.getDASDataSource(
sel_server.toString(),
ds_name.toString(),
track_id,
Integer.parseInt(tf_start.getText()),
Integer.parseInt(tf_end.getText()));
String descr = das_ds.getDataSourceDescription();
if (descr.length() > 50)
descr = descr.substring(0, 50) + "...";
tp_descr.setText(descr);
Object[] chrom = das_ds.getChromosomeNames();
if (chrom != null && chrom.length != 0) {
setChromosomeListEnabled(true);
for (int i = 0; i < chrom.length; i++) {
cb_chromosome.addItem(chrom[i]);
}
} else {
setChromosomeListEnabled(false);
}
} catch (Exception ex) {
ex.printStackTrace();
setChromosomeListEnabled(false);
JOptionPane.showMessageDialog(
this,
ex.getMessage(),
"Error",
JOptionPane.ERROR_MESSAGE);
}
}
}
public void cb_servers_actionPerformed(ActionEvent e) {
Object sel_server = cb_servers.getSelectedItem();
if (sel_server != null && !sel_server.equals("")) {
try {
Object[] ds_list_names =
DASServer.getServer(sel_server.toString()).getJDASDataSourceNames();
String[] ds_list_desc =
DASServer.getServer(
sel_server.toString()).getJDASDataSourceDescriptions(
ds_list_names);
cb_ds.setRenderer(new ComboBoxRenderer(ds_list_desc));
if (ds_list_names != null && ds_list_names.length != 0) {
setDSListEnabled(true);
for (int i = 0; i < ds_list_names.length; i++) {
cb_ds.addItem(ds_list_names[i].toString());
}
String presel_ds =
DASServer.getServer(
sel_server.toString()).getPreselectedJDASDataSourceName(
species);
if (presel_ds != null)
cb_ds.setSelectedItem(presel_ds);
} else {
setDSListEnabled(false);
}
} catch (OutOfMemoryError oum) {
setDSListEnabled(false);
JOptionPane.showMessageDialog(
this,
"Range is too large to load data",
"Out Of Memory Error",
JOptionPane.ERROR_MESSAGE);
} catch (Exception ex) {
ex.printStackTrace();
setDSListEnabled(false);
if (this.isVisible())
JOptionPane.showMessageDialog(
this,
"Connection to server " + sel_server.toString() + " is failed",
"Error",
JOptionPane.ERROR_MESSAGE);
}
}
}
private void setChromosomeListEnabled(boolean enabled) {
cb_chromosome.setEnabled(enabled);
cb_chromosome.removeAllItems();
if (!enabled)
cb_chromosome.addItem(_NOT_AVAILABLE);
setFeaturesListEnabled(enabled);
}
private void setFeaturesListEnabled(boolean enabled) {
feature_list_model.removeAllElements();
if (!enabled)
feature_list_model.addElement(_NOT_AVAILABLE);
list_features.setEnabled(enabled);
b_load.setEnabled(enabled);
}
private void setDSListEnabled(boolean enabled) {
cb_ds.removeAllItems();
cb_ds.setEnabled(enabled);
if (!enabled) {
cb_ds.addItem(_NOT_AVAILABLE);
tp_descr.setText("");
}
setChromosomeListEnabled(enabled);
}
public String getPreselectedServerName(String species) {
if (species == null)
return null;
List sources =
ConnectionManager.getConnectionList(DASDataSource.__DAS_TYPE);
for (int i = 0; i < sources.size(); i++) {
Connection source = (Connection) sources.get(i);
String subtype = source.getSubtype();
if (subtype != null) {
String[] species_arr = subtype.split(",");
for (int j = 0; j < species_arr.length; j++) {
String sp = species_arr[j].replaceAll(" ", "");
if (sp.equals(species)) {
return source.getName();
}
}
}
}
return null;
}
private void outputFeatures(java.util.List features) {
System.out.println("Total Number of Features: " + features.size());
for (int i = 0; i < features.size(); i++) {
Feature feature = (Feature) features.get(i);
Type type = feature.getType();
String name = type.getName();
System.out.println("Feature #" + i);
System.out.println("... Name: " + name);
System.out.println("... Accsession ID: " + feature.getId());
System.out.println(
"... Location: " + feature.getStart() + " - " + feature.getEnd());
}
}
}/*------
package ca.bcgsc.sockeye.gui;
import java.io.File;
public class ExtensionFilter
extends javax.swing.filechooser.FileFilter {
protected String desc;
protected String[] extensions;
public ExtensionFilter(String desc, String[] extensions) {
this.desc = desc;
this.extensions = (String[]) extensions.clone();
}
public boolean accept(File f) {
if (f.isDirectory()) {
return true;
}
String name = f.getName();
int length = name.length();
for (int i = 0; i < extensions.length; i++) {
String ext = extensions[i];
if (name.endsWith(ext) && name.charAt(length - ext.length()) == '.') {
return true;
}
}
return false;
}
public String getDescription() {
return desc;
}
}
package ca.bcgsc.sockeye.gui;
import helma.xmlrpc.XmlRpcClient;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.Frame;
import java.awt.Rectangle;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Vector;
import javax.help.CSH;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.ButtonGroup;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JRadioButton;
import javax.swing.JScrollPane;
import javax.swing.JTextField;
import javax.swing.JTextPane;
import javax.swing.SwingConstants;
import javax.swing.border.TitledBorder;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.util.gui.scomponents.SockeyeButton;
import ca.bcgsc.sockeye.util.Log;
public class FeedbackDialog
extends JDialog {
private static FeedbackDialog dialog;
private static JTextPane p_comments = new JTextPane();
private static JTextPane p_exception = new JTextPane();
private static String[] text = {
"Name", "Email", "Subject"};
private static JTextField[] tf = new JTextField[text.length];
private static String classification = "Other";
private static String diagnostics = "";
SockeyeButton b_help = new SockeyeButton(Configuration.help_icon);
private static String TITLE = "Send feedback to BCGSC";
private static JCheckBox jb_send_hw = new JCheckBox(
"Allow us to collect your general hardware info", true);
public static void show(Component comp, String diagnostics) {
Frame frame = JOptionPane.getFrameForComponent(comp);
dialog = new FeedbackDialog(frame, diagnostics);
dialog.setLocationRelativeTo(null);
dialog.setVisible(true);
}
public FeedbackDialog(Frame frame, String diagnostics) {
super(frame, TITLE, true);
FeedbackDialog.diagnostics = diagnostics;
JButton b_send = new JButton("Send");
JButton b_cancel = new JButton("Cancel");
b_help.setBounds(new Rectangle(205, 420, b_help.getWidth(), b_help.getHeight()));
b_cancel.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
b_cancel_actionPerformed(e);
}
});
b_send.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
b_send_actionPerformed(e);
}
});
getRootPane().setDefaultButton(b_send);
JPanel p_optional = new JPanel();
p_optional.setBackground(Configuration.gui_blue);
TitledBorder titled_border = new TitledBorder(Configuration.gui_blue_border,
"Optional information");
p_optional.setBounds(new Rectangle(0, 10, 410, 180));
p_optional.setBorder(titled_border);
p_optional.setLayout(null);
int y = 0;
for (int i = 0; i < text.length; i++) {
JLabel l = new JLabel(text[i]);
l.setBounds(new Rectangle(0, (y += 30), 60, 20));
l.setHorizontalAlignment(SwingConstants.RIGHT);
tf[i] = new JTextField(20);
tf[i].setBounds(new Rectangle(70, y, 320, 20));
l.setLabelFor(tf[i]);
p_optional.add(l);
p_optional.add(tf[i]);
}
int x = -50;
String[] button = {
"Problem", "Suggestion", "Other"};
ButtonGroup bg = new ButtonGroup();
for (int i = 0; i < button.length; i++) {
JRadioButton rb = new JRadioButton(button[i]);
if (i == 0 && !diagnostics.equals("")) {
rb.setSelected(true);
}
rb.setBounds(new Rectangle( (x += 100), 120, 90, 20));
p_optional.add(rb);
bg.add(rb);
rb.setBackground(Configuration.gui_blue);
rb.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
rb_actionPerformed(e);
}
});
rb.setActionCommand(button[i]);
}
jb_send_hw.setBounds(50, 150, 300, 20);
jb_send_hw.setBackground(Configuration.gui_blue);
p_optional.add(jb_send_hw);
JPanel p_info = new JPanel();
p_info.setLayout(null);
p_info.add(p_optional);
p_info.setPreferredSize(new Dimension(410, 200));
JPanel p_edit = new JPanel();
p_edit.setLayout(new BoxLayout(p_edit, BoxLayout.Y_AXIS));
if (!diagnostics.equals("")) {
p_edit.setPreferredSize(new Dimension(240, 340));
}
else {
p_edit.setPreferredSize(new Dimension(240, 170));
}
p_comments.setPreferredSize(new Dimension(220, 110));
JScrollPane scroll_comments = new JScrollPane(p_comments);
scroll_comments.setVerticalScrollBarPolicy(JScrollPane.
VERTICAL_SCROLLBAR_ALWAYS);
TitledBorder border_comments = new TitledBorder(BorderFactory.
createEtchedBorder(),
"Please describe the issue in detail");
scroll_comments.setBorder(border_comments);
p_edit.add(scroll_comments, BorderLayout.NORTH);
if (!diagnostics.equals("")) {
p_exception.setBackground(new Color(230, 230, 230));
p_exception.setEditable(false);
p_exception.setText(diagnostics);
p_exception.setPreferredSize(new Dimension(220, 110));
JScrollPane scroll_exception = new JScrollPane(p_exception);
scroll_exception.setVerticalScrollBarPolicy(JScrollPane.
VERTICAL_SCROLLBAR_ALWAYS);
scroll_exception.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
TitledBorder border_exception = new TitledBorder(
BorderFactory.createEtchedBorder(),
"Diagnostics (created automatically)");
scroll_exception.setBorder(border_exception);
p_edit.add(Box.createRigidArea(new Dimension(0, 10)));
p_edit.add(scroll_exception, BorderLayout.SOUTH);
}
JPanel p_button = new JPanel();
p_button.setLayout(new BoxLayout(p_button, BoxLayout.X_AXIS));
p_button.setBorder(BorderFactory.createEmptyBorder(0, 10, 10, 10));
p_button.add(Box.createHorizontalGlue());
p_button.add(b_send);
p_button.add(Box.createRigidArea(new Dimension(10, 0)));
p_button.add(b_cancel);
p_button.add(Box.createRigidArea(new Dimension(10, 0)));
Container content_pane = getContentPane();
content_pane.add(p_info, BorderLayout.NORTH);
content_pane.add(p_edit, BorderLayout.CENTER);
content_pane.add(p_button, BorderLayout.SOUTH);
pack();
initHelp();
}
protected void initHelp() {
CSH.setHelpIDString(b_help, "intro_help_contacts_feedback");
<mapID target="intro_help_contacts_feedback" url="content/introduction/intro_help_contacts_feedback.html" />
}
private void rb_actionPerformed(ActionEvent e) {
classification = e.getActionCommand();
}
private void b_cancel_actionPerformed(ActionEvent e) {
FeedbackDialog.dialog.setVisible(false);
}
private void b_send_actionPerformed(ActionEvent e) {
try {
XmlRpcClient xrc = new XmlRpcClient(
"http:
String[] params = new String[12];
params[0] = tf[2].getText();
params[1] = tf[1].getText();
params[2] = tf[0].getText();
if (classification.equals("Problem")) {
classification = "Bug";
}
if (classification.equals("Suggestion")) {
classification = "Feature";
}
params[3] = classification;
params[4] = "medium";
params[5] = "";
params[6] = Configuration.getVersion();
params[7] = System.getProperty("os.name");
params[8] = "";
StringBuffer description = new StringBuffer();
description.append("Description: \n");
description.append(p_comments.getText());
if (!diagnostics.equals("")) {
description.append("Exception:\n");
description.append(p_exception.getText());
}
if (jb_send_hw.isSelected()) {
try {
description.append("\n\nHardware and Software properties:\n");
description.append("java.class.path=" + System.getProperty("java.class.path") + "\n");
description.append("java.class.version=" + System.getProperty("java.class.version") + "\n");
description.append("java.home=" + System.getProperty("java.home") + "\n");
description.append("java.vendor=" + System.getProperty("java.vendor") + "\n");
description.append("java.version=" + System.getProperty("java.version") + "\n");
description.append("os.arch=" + System.getProperty("os.arch") + "\n");
description.append("os.name=" + System.getProperty("os.name") + "\n");
description.append("os.version=" + System.getProperty("os.version") + "\n");
description.append("sun.cpu.isalist=" + System.getProperty("sun.cpu.isalist") + "\n");
}
catch (SecurityException se) {
javax.swing.JOptionPane.showMessageDialog(null,
"SecurityException prevents access to general System Properties. " + se.toString(),
"XML Connection Failed",
javax.swing.JOptionPane.INFORMATION_MESSAGE);
}
}
params[9] = description.toString();
params[10] = "";
params[11] = "NO";
Vector parameters = new Vector();
for (int i = 0; i < params.length; i++) {
if (params[i] == null) {
params[i] = "";
}
parameters.add(params[i]);
}
xrc.execute("addIssue", parameters);
for (int i = 0; i < tf.length; i++) {
tf[i].setText("");
}
p_comments.setText("");
p_exception.setText("");
dialog.setVisible(false);
dialog = null;
StringBuffer message = new StringBuffer();
message.append("Thank-you for sending feedback to BCGSC.\n\n");
JOptionPane.showMessageDialog(null, message.toString(),
"Thank-you", JOptionPane.WARNING_MESSAGE);
}
catch (Exception ex) {
dialog.setVisible(false);
dialog = null;
StringBuffer message = new StringBuffer();
message.append("For some reason, communication with BCGSC failed.\n");
message.append("Thank-you for trying to send feedback.\n\n");
message.append("Please send an email to bomge@bcgsc.ca");
JOptionPane.showMessageDialog(null, message.toString(),
"Thank-you", JOptionPane.WARNING_MESSAGE);
Log.printStackTrace(ex);
}
}
}
package ca.bcgsc.sockeye.gui;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Container;
import java.awt.FlowLayout;
import java.awt.Frame;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.Timer;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.util.StringUtils;
import ca.bcgsc.util.SequenceUtils;
public class FindSequenceDialog extends JDialog {
private static FindSequenceDialog dialog;
private static int accessionID = 0;
private final String SEARCH_COMPLETED = "Search Complete.";
private final String SEARCH_HITS = "search hits";
private String sequence = "";
private ArrayList features;
private JLabel l_pattern = new JLabel("Pattern:");
private JTextField tf_pattern = new JTextField("", 30);
private JCheckBox cb_posStrand = new JCheckBox("Search on positive strand");
private JCheckBox cb_negStrand = new JCheckBox("Search on negative strand");
private JLabel l_numMismatch = new JLabel(" mismatches allowed");
private JTextField tf_numMismatch = new JTextField("0", 2);
private JCheckBox cb_ignoreCase = new JCheckBox("Ignore case");
private JCheckBox cb_normal = new JCheckBox("As is");
private JCheckBox cb_complement = new JCheckBox("Complement");
private JCheckBox cb_reverse = new JCheckBox("Reverse");
private JCheckBox cb_reverseComplement = new JCheckBox("Reverse Complement");
private JButton b_find = new JButton("Find");
private JButton b_clear = new JButton("Clear Pattern");
private JButton b_cancel = new JButton("Cancel");
private JPanel panel_progress = new JPanel(new BorderLayout());
private static JLabel l_progress = new JLabel(" ");
private static JLabel l_hits = new JLabel(" ");
public FindSequenceDialog(Frame frame, String title, boolean modal) {
super(frame, title, modal);
cb_posStrand.setSelected(true);
cb_negStrand.setSelected(true);
cb_ignoreCase.setSelected(true);
cb_normal.setSelected(true);
b_find.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
b_find_actionPerformed(e);
}
});
b_clear.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
tf_pattern.setText("");
}
});
b_cancel.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
b_cancel_actionPerformed(e);
}
});
JPanel panel_top = new JPanel();
panel_top.setBorder(BorderFactory.createEtchedBorder());
panel_top.setLayout(new FlowLayout(FlowLayout.CENTER));
panel_top.add(l_pattern);
panel_top.add(tf_pattern);
Box box_mismatch = Box.createHorizontalBox();
box_mismatch.add(tf_numMismatch);
box_mismatch.add(l_numMismatch);
JPanel panel_middleleft = new JPanel(new GridBagLayout());
GridBagConstraints gbc = new GridBagConstraints();
gbc.anchor = GridBagConstraints.WEST;
gbc.gridx = 0;
panel_middleleft.setBorder(BorderFactory.createTitledBorder("Options:"));
panel_middleleft.add(cb_posStrand,gbc);
panel_middleleft.add(cb_negStrand,gbc);
panel_middleleft.add(cb_ignoreCase,gbc);
panel_middleleft.add(box_mismatch,gbc);
JPanel panel_middleright = new JPanel(new GridBagLayout());
panel_middleright.setBorder(BorderFactory.createTitledBorder("Search for pattern:"));
panel_middleright.add(cb_normal,gbc);
panel_middleright.add(cb_complement,gbc);
panel_middleright.add(cb_reverse,gbc);
panel_middleright.add(cb_reverseComplement,gbc);
JPanel panel_middle = new JPanel(new GridLayout(1,2));
panel_middle.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
panel_middle.setBorder(BorderFactory.createEtchedBorder());
panel_middle.add(panel_middleleft);
panel_middle.add(panel_middleright);
JPanel panel_bottom = new JPanel();
panel_bottom.add(Box.createHorizontalGlue());
panel_bottom.add(b_find);
panel_bottom.add(b_clear);
panel_bottom.add(b_cancel);
panel_bottom.add(Box.createHorizontalGlue());
l_progress.setAlignmentX(Component.LEFT_ALIGNMENT);
l_hits.setAlignmentX(Component.RIGHT_ALIGNMENT);
panel_progress.setBorder(BorderFactory.createBevelBorder(5));
panel_progress.add(l_progress, BorderLayout.WEST);
panel_progress.add(l_hits, BorderLayout.EAST);
Box all = Box.createVerticalBox();
all.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
all.add(panel_top, BorderLayout.NORTH);
all.add(panel_middle, BorderLayout.CENTER);
all.add(panel_bottom, BorderLayout.SOUTH);
all.add(panel_progress);
Container contentPane = getContentPane();
contentPane.add(all);
pack();
}
private void b_cancel_actionPerformed(ActionEvent e) {
FindSequenceDialog.dialog.setVisible(false);
}
private void b_find_actionPerformed(ActionEvent e) {
new Thread() {
public void run() {
timer.start();
SequenceUtils.resetSearchHits();
l_progress.setText("Search in progress ..");
l_hits.setText("0 " + SEARCH_HITS);
String pattern = tf_pattern.getText().replaceAll(" ","");
if (!isValidPattern(pattern))
return;
int numMismatch = 0;
if (tf_numMismatch.getText() == null ||
tf_numMismatch.getText().equals("") ||
!tf_numMismatch.getText().replaceAll(" ","").matches("\\d*")) {
displayErrorDialog("Please enter a valid number of mismatches allowed.","Invalid number of mismatches.");
return;
}
else {
numMismatch = Integer.valueOf(tf_numMismatch.getText()).intValue();
if (numMismatch > pattern.length()) {
displayErrorDialog("Number of mismatches is greater than the pattern length.","Invalid number of mismatches.");
return;
}
}
for (int j = 0; j < features.size(); j++) {
TrackFeature feature = (TrackFeature)features.get(j);
sequence = DataStoreUser.getInstance().getSockeyeTrackList().getFeatureSequence(feature);
if (DataStoreUser.getInstance().getSockeyeTrackList().getTrackReverse(feature.getTrackId())) {
sequence = new String(SequenceUtils.reverseComplementSequence(sequence));
}
if (cb_ignoreCase.isSelected()) {
pattern = pattern.toUpperCase();
sequence = sequence.toUpperCase();
}
if (cb_normal.isSelected())
searchAndDisplay(feature, sequence, pattern, numMismatch);
if (cb_complement.isSelected())
searchAndDisplay(feature, sequence, SequenceUtils.complementIUPACSequence(pattern), numMismatch);
if (cb_reverse.isSelected())
searchAndDisplay(feature, sequence, SequenceUtils.reverseSequence(pattern), numMismatch);
if (cb_reverseComplement.isSelected())
searchAndDisplay(feature, sequence, SequenceUtils.reverseIUPACComplementSequence(pattern), numMismatch);
}
timer.stop();
l_progress.setText(SEARCH_COMPLETED);
l_hits.setText(SequenceUtils.getSearchHits() + " " + SEARCH_HITS);
}
}.start();
}
private void searchAndDisplay(TrackFeature feature, String sequence, String pattern, int numMismatch) {
List results = null;
List results_rev = null;
if (cb_posStrand.isSelected()) {
results = SequenceUtils.searchForPattern(
sequence, pattern, numMismatch);
}
if (cb_negStrand.isSelected()) {
results_rev = SequenceUtils.searchForPattern(
SequenceUtils.complementSequence(sequence),
SequenceUtils.reverseSequence(pattern),
numMismatch);
}
ArrayList trackfeatures = new ArrayList();
if (results != null) {
for (Iterator itr = results.iterator(); itr.hasNext();) {
int i = ((Integer) itr.next()).intValue();
double score = 1.0 - ((Integer) itr.next()).doubleValue() / pattern.length();
trackfeatures.add(CreateDisplayTrackFeature(
feature,"search_result_forward",1,i,pattern.length(),score));
}
}
if (results_rev != null) {
for (Iterator itr = results_rev.iterator(); itr.hasNext();) {
int i = ((Integer) itr.next()).intValue();
double score = 1.0 - ((Integer) itr.next()).doubleValue() / pattern.length();
trackfeatures.add(CreateDisplayTrackFeature(
feature,"search_result_reverse",-1,i,pattern.length(),score));
}
}
String strandString = "";
if (cb_posStrand.isSelected() && cb_negStrand.isSelected()) {
strandString = " both strands";
} else if (cb_posStrand.isSelected()) {
strandString = " + strand";
} else if (cb_negStrand.isSelected()) {
strandString = " - strand";
}
String ignoreCase = "case sensitive";
if (cb_ignoreCase.isSelected()) {
ignoreCase = "case insensitive";
}
int start = feature.getStart();
int end = feature.getEnd();
int t_id = feature.getTrackId();
String track_disp = StringUtils.getShortNameForTrackID(feature.getTrackId());
List chromosomes = (List) DataStoreUser.getInstance().getDataSourceManager().getTrackChromosomes(t_id);
String nodename = "Search \""+pattern+"\" (mismatches:"+numMismatch+", "+strandString+", "+ignoreCase+") " + "on " + track_disp + ": " + start + ".." + end;
DataStoreUser.getInstance().getSockeyeTrackList().addFeatures(feature.getTrackId(), nodename, trackfeatures);
DataStoreUser.getInstance().getSockeyeTrackList().setFeatureVisibility(nodename,true);
}
private TrackFeature CreateDisplayTrackFeature(
TrackFeature feature,
String s,
int strand,
int offset,
int patternLength,
double score) {
TrackFeature tf =
new TrackFeature(
"sequence",
"Sockeye",
s,
feature.getStart() + offset,
feature.getStart() + offset + patternLength - 1,
score,
strand,
0);
tf.setAccessionID("search_result_" + accessionID);
accessionID++;
return tf;
}
private Timer timer = new Timer(500, new ActionListener() {
public void actionPerformed(ActionEvent evt) {
l_hits.setText(SequenceUtils.getSearchHits() + " " + SEARCH_HITS);
}
});
private boolean isValidPattern(String pattern) {
pattern = pattern.toLowerCase();
if (pattern.equals("")) {
displayErrorDialog("Please enter a search pattern.","Invalid search pattern.");
return false;
}
Pattern p = Pattern.compile("[a|c|t|g|m|r|w|s|y|k|v|h|d|b|n]");
Matcher m = null;
for(int i=0; i<pattern.length(); i++) {
String ch = String.valueOf(pattern.charAt(i));
m = p.matcher(ch);
if (!m.matches()) {
displayErrorDialog("There are invalid IUPAC characters in the Pattern specified. Please check the pattern.","Invalid search pattern.");
}
}
return true;
}
public static void show(Component comp, TrackFeature ft, ArrayList fts) {
if (dialog == null) {
dialog = new FindSequenceDialog(Sockeye.__frame, "Find Sequence", false);
dialog.setLocationRelativeTo(null);
}
dialog.setFeatures(fts);
dialog.setVisible(true);
}
public ArrayList getFeatures() {
return features;
}
public void setFeatures(ArrayList features) {
this.features = features;
}
private void displayErrorDialog(String msg1, String msg2) {
JOptionPane.showMessageDialog(null,msg1,msg2,javax.swing.JOptionPane.INFORMATION_MESSAGE);
l_progress.setText(SEARCH_COMPLETED);
}
}
package ca.bcgsc.sockeye.gui;
import java.awt.BorderLayout;
import java.awt.Frame;
import java.awt.event.ActionEvent;
import java.io.File;
import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import javax.swing.JDialog;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.parser.AlignmentParser;
import ca.bcgsc.sockeye.parser.ParserManager;
public class ImportAlignmentPanel
extends JDialog {
JFileChooser fc;
public ImportAlignmentPanel(Frame parent, String path) {
super(parent, "Import Alignment ", true);
fc = new JFileChooser(path);
fc.setApproveButtonText("Import");
jbInit();
}
private void jbInit() {
setSize(600, 600);
this.setResizable(false);
this.setLocationRelativeTo(null);
this.getContentPane().add(fc, BorderLayout.CENTER);
fc.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
if (e.getActionCommand().equals("ApproveSelection")) {
File file = fc.getSelectedFile();
String extension = (file.getName().substring(
file.getName().length() - 3));
String class_name = ParserManager.getClassNameForAlignmentExtension(
extension);
if (class_name != null) {
String gff_track_name = file.getName();
AlignmentParser parser;
try {
Class[] parameters = new Class[1];
parameters[0] = File.class;
Constructor con = Class.forName(class_name).getConstructor(
parameters);
Object[] obj = new Object[1];
obj[0] = (Object) file;
parser = (AlignmentParser) con.newInstance(obj);
java.util.List gaps = parser.getAlignmentResults();
Iterator i = gaps.iterator();
while (i.hasNext()) {
ArrayList tfs_a = (ArrayList) i.next();
Object[] tfs = tfs_a.toArray();
Arrays.sort(tfs);
String track_name;
if (tfs.length > 0) {
}
else {
track_name = "NO NAME";
}
int _total_gap_length = 0;
for (int m = 0; m < tfs.length; m++) {
TrackFeature gap = (TrackFeature) tfs[m];
_total_gap_length += (gap.getEnd() - gap.getStart()) + 1;
}
}
}
catch (Exception ex) {
JOptionPane.showMessageDialog(getParent(),
"Sockeye has no registered parser for " +
(file.getName().substring(file.getName().length() - 3)) +
"\n Try another file extension (ie. gff)",
"Invalid Filename",
JOptionPane.ERROR_MESSAGE);
ex.printStackTrace();
return;
}
}
else {
JOptionPane.showMessageDialog(getParent(),
"Sockeye has no registered parser for " +
(file.getName().substring(file.getName().length() - 3)) +
"\n Try another file extension (ie. gff)",
"Invalid Filename",
JOptionPane.ERROR_MESSAGE);
return;
}
}
else {
dispose();
}
}
});
show();
}
}
package ca.bcgsc.sockeye.gui;
import java.awt.AWTEvent;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsEnvironment;
import java.awt.Toolkit;
import java.awt.event.WindowEvent;
import java.util.List;
import javax.media.j3d.GraphicsConfigTemplate3D;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JSplitPane;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.datastorage.SockeyeTrackList;
import ca.bcgsc.sockeye.gui.navigation.FeaturePanel;
import ca.bcgsc.sockeye.gui.navigation.HorizontalNavigationBar;
import ca.bcgsc.sockeye.gui.navigation.NZControlPanel;
import ca.bcgsc.sockeye.gui.navigation.TrackPanel;
import ca.bcgsc.sockeye.gui.navigation.VerticalNavigationBar;
import ca.bcgsc.sockeye.gui.retrievaldialog.RetrievalWizard;
import ca.bcgsc.sockeye.gui.session.SessionManager;
import ca.bcgsc.sockeye.j3d.Visualizer3D;
import ca.bcgsc.sockeye.service.featureloader.common.ConnectionManager;
import ca.bcgsc.sockeye.util.ResourceLoader;
public class MainFrame extends JFrame {
private static Visualizer3D __vis;
private static String OPENGL_WIN_HACK = "openglwin";
private JSplitPane sp_top = new JSplitPane();
private JPanel view_result = new JPanel();
private HorizontalNavigationBar __p_and_s_bar = new HorizontalNavigationBar();
private VerticalNavigationBar __vert_nav_bar = new VerticalNavigationBar();
private JSplitPane sp_side = new JSplitPane(JSplitPane.VERTICAL_SPLIT);
private JSplitPane sp_side_bottom = new JSplitPane(JSplitPane.VERTICAL_SPLIT);
private SockeyeMenubar menubar;
private TrackPanel p_track = new TrackPanel();
private FeaturePanel p_feature = new FeaturePanel();
private NZControlPanel p_nz = new NZControlPanel();
private int width;
private int height;
MainFrame() {
enableEvents(AWTEvent.WINDOW_EVENT_MASK);
jbInit();
DataStoreUser.getInstance().getSockeyeTrackList().setVisualizer(__vis);
}
public void setVisualizer() {
DataStoreUser.getInstance().getSockeyeTrackList().setVisualizer(__vis);
}
private void jbInit() {
menubar = new SockeyeMenubar(this);
this.setJMenuBar(menubar);
Dimension dim = Toolkit.getDefaultToolkit().getScreenSize();
width = (int) dim.getWidth();
height = (int) dim.getHeight();
this.setSize(new Dimension(width - width / 10, height - height / 10));
sp_side.setPreferredSize(new Dimension(20 * width / 100, height));
this.setTitle("Sockeye");
this.getContentPane().setLayout(new BorderLayout());
this.getContentPane().add(sp_top, BorderLayout.CENTER);
makeCanvas();
sp_top.setContinuousLayout(true);
sp_top.setDividerSize(10);
sp_top.setOneTouchExpandable(false);
sp_top.add(view_result, JSplitPane.RIGHT);
sp_top.add(sp_side, JSplitPane.LEFT);
sp_side.setContinuousLayout(true);
sp_side.setPreferredSize(new Dimension(250, 250));
sp_side.setMinimumSize(new Dimension(150, 150));
p_track.setMinimumSize(new Dimension(150, 150));
p_track.setPreferredSize(new Dimension(250, 250));
p_feature.setMinimumSize(new Dimension(150, 150));
p_feature.setPreferredSize(new Dimension(250, 250));
sp_side.setDividerSize(10);
sp_side.setOneTouchExpandable(false);
setEventListeners();
__vis.addEventListener(p_track);
__vis.addEventListener(p_nz);
sp_side.add(p_track, JSplitPane.TOP);
sp_side.add(sp_side_bottom, JSplitPane.BOTTOM);
sp_side_bottom.setContinuousLayout(true);
sp_side_bottom.setDividerSize(10);
sp_side_bottom.setResizeWeight(1.0);
sp_side_bottom.add(p_feature, JSplitPane.TOP);
}
public void setEventListeners() {
DataStoreUser.getInstance().getSockeyeTrackList().addStorageListener(
p_track);
DataStoreUser.getInstance().getSockeyeTrackList().addStorageListener(
p_feature);
DataStoreUser.getInstance().getSockeyeTrackList().addStorageListener(
menubar);
if (SessionManager.getInstance() != null)
DataStoreUser.getInstance().getSockeyeTrackList().addStorageListener(
SessionManager.getInstance());
QueryManager qm =
new QueryManager(
this,
DataStoreUser.getInstance().getDataSourceManager());
sp_side_bottom.add(qm, JSplitPane.BOTTOM);
qm.setMinimumSize(new Dimension(150, 85));
qm.setPreferredSize(new Dimension(250, 85));
}
public void registerNewStorageManager(SockeyeTrackList stl) {
menubar.registerNewStorageManager(stl);
}
public void manualLoadEnsemblTrack(
String database,
String chrom,
int start,
int end) {
ConnectionManager.setCurrentDatabase("Ensembl", database);
RetrievalWizard rwz = new RetrievalWizard(null);
rwz.start_query_track(start, end, chrom, database);
}
public void manualSetFeatureVisibility(List l) {
DataStoreUser.getInstance().getSockeyeTrackList().setFeatureVisibility(
l,
true);
}
protected void processWindowEvent(WindowEvent e) {
if (e.getID() == WindowEvent.WINDOW_CLOSING) {
closeFrame();
}
}
private void closeFrame() {
menubar.mi_exit_actionPerformed(null);
}
private void makeCanvas() {
int openGL = 0;
if (ResourceLoader.getReader(OPENGL_WIN_HACK) != null) {
openGL = 1;
}
if (openGL == 1 && System.getProperty("os.name").startsWith("Win")) {
__vis =
new Visualizer3D(
com
.sun
.j3d
.utils
.universe
.SimpleUniverse
.getPreferredConfiguration());
} else {
GraphicsConfigTemplate3D devconfig = new GraphicsConfigTemplate3D();
devconfig.setSceneAntialiasing(GraphicsConfigTemplate3D.PREFERRED);
GraphicsConfiguration config =
GraphicsEnvironment
.getLocalGraphicsEnvironment()
.getDefaultScreenDevice()
.getBestConfiguration(devconfig);
__vis = new Visualizer3D(config);
}
view_result.setLayout(new BorderLayout());
view_result.setMinimumSize(new Dimension(100, 100));
view_result.add("Center", __vis);
view_result.add("North", p_nz);
view_result.add("South", __p_and_s_bar);
view_result.add("West", __vert_nav_bar);
}
public static Visualizer3D getVis3D() {
return __vis;
}
}
package ca.bcgsc.sockeye.gui;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Rectangle;
import java.awt.event.ActionEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.BufferedReader;
import java.io.IOException;
import java.util.Hashtable;
import java.util.StringTokenizer;
import javax.swing.JButton;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.popup.BrowserLauncher;
import ca.bcgsc.sockeye.util.Log;
import ca.bcgsc.sockeye.util.ResourceLoader;
public class MainFrame_AboutBox extends JDialog {
private JPanel p_center = new JPanel();
private JPanel p_buttons = new JPanel();
private JPanel p_insets = new JPanel();
private JPanel p_logo = new JPanel();
private JButton b_ok = new JButton("OK");
JLabel l_logo = new JLabel(Configuration.sockeye_logo_small);
JLabel l_version;
JLabel l_buildDate;
JLabel l_copyright = new JLabel("(c) 2003 Genome Sciences Centre");
JLabel l_licensing = new JLabel("All rights reserved");
JEditorPane acknowledge;
public MainFrame_AboutBox(JFrame parent) {
super(parent, "About", true);
String version = getVersion();
l_version = new JLabel("Sockeye " + version);
l_buildDate = new JLabel(getBuildDate());
jbInit();
}
private void jbInit() {
this.setSize(325, 195);
this.setLocationRelativeTo(null);
p_center.setLayout(new BorderLayout());
p_buttons.setLayout(null);
p_logo.setLayout(null);
l_version.setBounds(new Rectangle(100, 20, 500, 20));
l_buildDate.setBounds(new Rectangle(100, 40, 270, 20));
l_copyright.setBounds(new Rectangle(100, 60, 270, 20));
l_licensing.setBounds(new Rectangle(100, 80, 300, 20));
l_logo.setBounds(new Rectangle(10, 20, 76, 62));
final String fontName = l_copyright.getFont().getName();
acknowledge =
new JEditorPane(
"text/html",
"<u><font size=3 face=\""
+ fontName
+ "\" color=blue>Acknowledgements</font></u>");
if (java.lang.System.getProperty("os.name").startsWith(("Windows"))) {
acknowledge.setBounds(new Rectangle(100, 100, 114, 20));
}
else {
acknowledge.setBounds(new Rectangle(100, 100, 140, 20));
}
acknowledge.setEditable(false);
acknowledge.setEnabled(false);
acknowledge.setDragEnabled(false);
acknowledge.addMouseListener(new MouseAdapter() {
public void mousePressed(MouseEvent e) {
acknowledge.setText(
"<u><font size=3 face="
+ fontName
+ " color=red>Acknowledgements</font></u>");
}
public void mouseReleased(MouseEvent e) {
acknowledge.setText(
"<u><font size=3 face="
+ fontName
+ " color=blue>Acknowledgements</font></u>");
}
public void mouseClicked(MouseEvent e) {
try {
BrowserLauncher.openURL(
"http:
}
catch (IOException e1) {
Log.printStackTrace(e1);
}
}
});
this.getContentPane().setBackground(Color.white);
p_center.add(p_buttons, BorderLayout.CENTER);
p_buttons.add(l_version, null);
p_buttons.add(l_copyright, null);
p_buttons.add(l_licensing, null);
p_buttons.add(l_buildDate, null);
p_buttons.add(l_logo, null);
p_buttons.add(acknowledge);
p_buttons.setBackground(Color.white);
p_center.add(p_insets, BorderLayout.SOUTH);
p_center.setBackground(Color.white);
p_insets.add(b_ok, null);
p_insets.setBackground(Color.white);
this.getContentPane().add(p_center, BorderLayout.CENTER);
b_ok.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
dispose();
}
});
setResizable(true);
this.show();
}
private String getVersion() {
String version = "";
Hashtable buildVersion = new Hashtable();
try {
BufferedReader reader =
new BufferedReader(
ResourceLoader.getReader("resources/version/build.txt"));
String singleLine = reader.readLine();
while (singleLine != null) {
if (!(singleLine.equals(""))) {
StringTokenizer strToken = new StringTokenizer(singleLine, "=\t");
if (strToken.countTokens() == 2) {
String key = strToken.nextToken();
String value = strToken.nextToken();
buildVersion.put(key, value);
}
}
singleLine = reader.readLine();
}
String retrieveVersion = (String) buildVersion.get("version");
String retrieveMinor = (String) buildVersion.get("minor");
String retrieveBuild = (String) buildVersion.get("build");
if (retrieveVersion != null
&& retrieveMinor != null
&& retrieveBuild != null) {
version =
"V"
+ retrieveVersion
+ "."
+ retrieveMinor
+ " Build "
+ retrieveBuild;
}
else {
version = "V?.";
}
}
catch (IOException e) {
e.printStackTrace();
}
return version;
}
private String getBuildDate() {
String buildDate = "(run with ant to see build date)";
try {
BufferedReader reader =
new BufferedReader(
ResourceLoader.getReader("resources/version/buildDate.txt"));
buildDate = reader.readLine();
} catch (Throwable t){
}
return buildDate;
}
}
package ca.bcgsc.sockeye.gui;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Container;
import java.awt.FlowLayout;
import java.awt.Frame;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JDialog;
import javax.swing.JFileChooser;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JRadioButton;
import javax.swing.JTextField;
import org.biojava.bio.program.gff.GFFTools;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.gui.setoperationdialog.SetOperationPanel;
import ca.bcgsc.sockeye.io.FASTAExporter;
import ca.bcgsc.sockeye.util.Log;
import ca.bcgsc.util.gui.scomponents.SockeyeFileChooser;
public class MarkRegionDialog extends JDialog implements ActionListener {
static MarkRegionDialog dialog;
private int start= 0, end= 0;
private String region_id= "";
private JButton b_cancel= new JButton("Cancel");
private JButton b_ok= new JButton("OK");
private StartEndPanel p_five_prime=
new StartEndPanel("Regions 5' end", -1000);
private StartEndPanel p_three_prime= new StartEndPanel("Regions 3' end", 0);
private JCheckBox cb_mark= new JCheckBox("Mark region(s)");
private JCheckBox cb_select= new JCheckBox("Select region(s)");
private JCheckBox cb_fasta= new JCheckBox("Export (multi)FASTA");
private JCheckBox cb_reverse=
new JCheckBox("Reverse-complement sequence(s), if feature on reverse strand");
private JCheckBox cb_stop_coding=
new JCheckBox("Stop at closest feature boundary");
private JCheckBox cb_skip_coding= new JCheckBox("Skip coding region(s)");
private JCheckBox cb_stop_undefined=
new JCheckBox("Stop at closest undefined sequence");
private JCheckBox cb_skip_undefined=
new JCheckBox("Skip undefined region(s)");
private JRadioButton rb_five_prime=
new JRadioButton(" relative to \n 5' end of the feature", true);
private JRadioButton rb_three_prime=
new JRadioButton(" relative to \n 3' end of the feature", false);
private List _marked_regions= new ArrayList();
private boolean warning;
private int response= JOptionPane.NO_OPTION;
private Map offsets= new HashMap();
private Frame parent= null;
private JLabel _measurement_bars_label=
new JLabel(Configuration.mark_region_bar1);
private static Component _comp= null;
private static final String _ACTION_START_REL_5= "__startrel5__";
private static final String _ACTION_START_REL_3= "__startrel3__";
private static final String _ACTION_END_REL_5= "__endrel5__";
private static final String _ACTION_END_REL_3= "__endtrel3__";
public static void show(
Component comp,
ArrayList features,
boolean set_operation) {
if (set_operation)
_comp= comp;
else
_comp= null;
Frame frame= JOptionPane.getFrameForComponent(comp);
dialog= new MarkRegionDialog(frame, features);
dialog.setLocationRelativeTo(comp);
dialog.setVisible(true);
}
public MarkRegionDialog(Frame frame, ArrayList track_features) {
super(frame, "Mark region");
warning= false;
JPanel p_regions= new JPanel(new GridLayout(2, 1));
p_regions.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
JPanel p_start_end= new JPanel(new GridLayout(1, 2));
p_start_end.add(p_five_prime);
p_start_end.add(p_three_prime);
p_five_prime.set3PrimeCheckBoxActionCommand(_ACTION_START_REL_3);
p_five_prime.set5PrimeCheckBoxActionCommand(_ACTION_START_REL_5);
p_three_prime.set3PrimeCheckBoxActionCommand(_ACTION_END_REL_3);
p_three_prime.set5PrimeCheckBoxActionCommand(_ACTION_END_REL_5);
p_five_prime.addActionListener(this);
p_three_prime.addActionListener(this);
GridBagLayout diag_gbl= new GridBagLayout();
GridBagConstraints diag_gbc= new GridBagConstraints();
JPanel diagram= new JPanel(diag_gbl);
diag_gbc.gridx= 0;
diagram.add(new JLabel(Configuration.mark_region_diagram), diag_gbc);
diagram.add(_measurement_bars_label, diag_gbc);
diagram.setBorder(BorderFactory.createEtchedBorder());
GridBagLayout tf_gbl= new GridBagLayout();
GridBagConstraints tf_gbc= new GridBagConstraints();
JPanel p_textfields= new JPanel(tf_gbl);
tf_gbc.anchor= GridBagConstraints.WEST;
tf_gbc.gridx= 0;
p_textfields.add(diagram, tf_gbc);
p_textfields.add(Box.createVerticalStrut(5), tf_gbc);
p_textfields.add(cb_stop_coding, tf_gbc);
if (_comp == null)
p_textfields.add(cb_stop_undefined, tf_gbc);
p_regions.add(p_start_end);
p_regions.add(p_textfields);
if (_comp != null)
setModal(true);
parent= frame;
warning= false;
final ArrayList features= track_features;
p_regions.setBorder(
BorderFactory.createTitledBorder(
BorderFactory.createEtchedBorder(),
"Region(s) boundaries"));
JPanel p_actions= new JPanel(new GridLayout(3, 1));
p_actions.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
p_actions.add(cb_mark);
cb_mark.setSelected(true);
p_actions.add(cb_fasta);
p_actions.add(cb_reverse);
p_actions.setBorder(
BorderFactory.createTitledBorder(
BorderFactory.createEtchedBorder(),
"Action(s)"));
cb_reverse.setEnabled(false);
cb_fasta.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
if (cb_fasta.isSelected()) {
cb_reverse.setEnabled(true);
}
else {
cb_reverse.setEnabled(false);
}
}
});
JPanel p_buttons= new JPanel(new FlowLayout());
p_buttons.add(b_ok);
p_buttons.add(b_cancel);
getRootPane().setDefaultButton(b_ok);
p_buttons.setBackground(Configuration.gui_blue);
Container content_pane= getContentPane();
JPanel all= new JPanel(new BorderLayout());
all.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
all.setBackground(Configuration.gui_blue);
all.add(p_regions, BorderLayout.NORTH);
if (_comp == null)
all.add(p_actions, BorderLayout.CENTER);
all.add(p_buttons, BorderLayout.SOUTH);
content_pane.add(all);
pack();
b_cancel.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
dialog.setVisible(false);
}
});
b_ok.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
if (_comp != null) {
List regions= new ArrayList();
for (int i= 0; i < features.size(); i++) {
TrackFeature feature= (TrackFeature) features.get(i);
if (setRegionCoordinates(feature) < 0) {
return;
}
int track_id= feature.getTrackId();
String track_name=
(String) DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackAttribute(
track_id,
"track_name");
region_id=
track_name.split(":")[0] + new String(":" + start + ".." + end);
TrackFeature region=
new TrackFeature(
region_id,
track_name,
"region",
start,
end,
GFFTools.NO_SCORE,
1,
GFFTools.NO_FRAME);
region.setAccessionID(region_id);
region.setTrackId(feature.getTrackId());
regions.add(region);
}
((SetOperationPanel) _comp).addTrackFeaturesToResultSetTable(regions);
dialog.setVisible(false);
return;
}
if (!cb_mark.isSelected() && !cb_fasta.isSelected()) {
dialog.setVisible(false);
return;
}
for (int i= 0; i < features.size(); i++) {
TrackFeature feature= (TrackFeature) features.get(i);
if (setRegionCoordinates(feature) < 0) {
return;
}
if (cb_mark.isSelected()) {
markRegion(feature);
}
}
int max_offset= 0;
for (Iterator it= offsets.values().iterator(); it.hasNext();) {
int o= ((Integer) it.next()).intValue();
if (o > max_offset)
max_offset= o;
}
for (Iterator it=
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getAllTrackIds()
.iterator();
it.hasNext();
) {
int t_id= Integer.parseInt(it.next().toString());
Object o= offsets.get(new Integer(t_id));
int offset= max_offset;
if (o != null)
offset= max_offset - ((Integer) o).intValue();
offset
+= DataStoreUser.getInstance().getSockeyeTrackList().getTrackOffset(
t_id);
DataStoreUser.getInstance().getSockeyeTrackList().setTrackOffset(
t_id,
offset);
}
DataStoreUser.getInstance().getSockeyeTrackList().refreshTrackOffsets();
if (cb_fasta.isSelected()) {
String file_name= Configuration.getUserPath() + "export.fasta";
SockeyeFileChooser export_toFASTA_dialog=
SockeyeFileChooser.getSockeyeFileChooser("FASTAExport");
export_toFASTA_dialog.setDialogTitle("Save Sequences As...");
int result=
export_toFASTA_dialog.showSaveDialog(
Sockeye.__frame,
"fasta",
new File(file_name));
try {
file_name=
export_toFASTA_dialog.getSelectedFile().getCanonicalPath();
}
catch (java.io.IOException ex) {
Log.printStackTrace(ex);
System.out.println("Cannot handle file!!!!!");
return;
}
if (result == JFileChooser.APPROVE_OPTION) {
FASTAExporter.exportToMultiFASTA(
_marked_regions,
file_name,
cb_reverse.isSelected() ? 0 : 1);
}
}
dialog.setVisible(false);
}
});
}
private int setRegionCoordinates(TrackFeature feature) {
int feature_start= feature.getStart();
int feature_end= feature.getEnd();
int strand= feature.getStrand().getValue();
String track_name=
(String) DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackAttribute(
feature.getTrackId(),
"track_name");
TrackFeature next5c= null, next3c= null;
if (DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getFeatureNames(feature.getTrackId())
.contains("gene")) {
next5c=
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getNextFeatureIn5PrimeDirection(
feature.getTrackId(),
feature,
"gene");
next3c=
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getNextFeatureIn3PrimeDirection(
feature.getTrackId(),
feature,
"gene");
}
else if (cb_stop_coding.isSelected()) {
JOptionPane.showMessageDialog(
parent,
"There are no genes on track "
+ track_name
+ ".\nStop at closest coding region selection will be ignored.",
"Warning",
JOptionPane.WARNING_MESSAGE);
}
else if (cb_skip_coding.isSelected()) {
JOptionPane.showMessageDialog(
parent,
"There are no genes on track "
+ track_name
+ ".\nSkip coding region(s) selection will be ignored.",
"Warning",
JOptionPane.WARNING_MESSAGE);
}
TrackFeature next5u= null, next3u= null;
int t_id= feature.getTrackId();
if (DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getFeatureNames(t_id)
.contains("undefined_sequence")) {
next5u=
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getNextFeatureIn5PrimeDirection(t_id, feature, "undefined_sequence");
next3u=
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getNextFeatureIn3PrimeDirection(t_id, feature, "undefined_sequence");
}
else if (cb_stop_undefined.isSelected()) {
JOptionPane.showMessageDialog(
parent,
"There are no undefined sequence(s) on track "
+ track_name
+ ".\nStop at closest undefined_sequence selection will be ignored.",
"Warning",
JOptionPane.WARNING_MESSAGE);
}
else if (cb_skip_undefined.isSelected()) {
JOptionPane.showMessageDialog(
parent,
"There are no undefined_sequence(s) on track "
+ track_name
+ ".\nSkip undefined sequence(s) selection will be ignored.",
"Warning",
JOptionPane.WARNING_MESSAGE);
}
if (strand != -1) {
if (p_five_prime.isRelativeToFivePrime()) {
start= feature_start + p_five_prime.getValue();
}
else {
start= feature_end + p_five_prime.getValue() + 1;
}
if (p_three_prime.isRelativeToFivePrime()) {
end= feature_start + p_three_prime.getValue() - 1;
}
else {
end= feature_end + p_three_prime.getValue();
}
if (cb_stop_coding.isSelected()) {
if (next5c != null) {
start= Math.max(start, next5c.getEnd());
}
if (next3c != null) {
end= Math.min(end, next3c.getStart());
}
}
if (cb_stop_undefined.isSelected()) {
if (next5u != null) {
start= Math.max(start, next5u.getEnd());
}
if (next3u != null) {
end= Math.min(end, next3u.getStart());
}
}
}
else {
if (p_five_prime.isRelativeToFivePrime()) {
end= feature_end - p_five_prime.getValue();
}
else {
end= feature_start - p_five_prime.getValue() - 1;
}
if (p_three_prime.isRelativeToFivePrime()) {
start= feature_end - p_three_prime.getValue() + 1;
}
else {
start= feature_start - p_three_prime.getValue();
}
if (cb_stop_coding.isSelected()) {
if (next5c != null) {
end= Math.min(end, next5c.getStart());
}
if (next3c != null) {
start= Math.max(start, next3c.getEnd());
}
}
if (cb_stop_undefined.isSelected()) {
if (next5u != null) {
end= Math.min(end, next5u.getStart());
}
if (next3u != null) {
start= Math.max(start, next3u.getEnd());
}
}
}
if (start > end) {
JOptionPane.showMessageDialog(
parent,
"Uncorrect 5'/3' ends for the region.",
"Warning",
JOptionPane.WARNING_MESSAGE);
return -1;
}
start= (start < 1 ? 1 : start);
int track_start=
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackDataWindowStart(
t_id);
int track_end=
DataStoreUser.getInstance().getSockeyeTrackList().getTrackDataWindowEnd(
t_id);
if ((start < track_start || end > track_end)) {
if (!warning) {
String message=
"Click 'Yes' to extend the window and mark the full region. \n"
+ "Click 'No' to mark a shorter region that fits the current window.";
response=
JOptionPane.showConfirmDialog(
parent,
message,
"Requested region(s) is outside the current window",
JOptionPane.YES_NO_OPTION,
JOptionPane.WARNING_MESSAGE);
warning= true;
}
if (response == JOptionPane.YES_OPTION) {
DataStoreUser.getInstance().getSockeyeTrackList().setTrackDataWindow(
t_id,
Math.min(start, track_start),
Math.max(end, track_end));
int s= track_start - start;
if (s > 0) {
offsets.put(new Integer(t_id), new Integer(s));
}
s= end - track_end;
if (s > 0
&& DataStoreUser.getInstance().getSockeyeTrackList().getTrackReverse(
t_id)) {
offsets.put(new Integer(t_id), new Integer(s));
}
}
else {
start= Math.max(start, track_start);
end= Math.min(end, track_end);
}
}
return 0;
}
private void markRegion(TrackFeature feature) {
System.out.println(feature.toString());
int track_id= feature.getTrackId();
String track_name=
(String) DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackAttribute(
track_id,
"track_name");
region_id= track_name.split(":")[0] + new String(":" + start + ".." + end);
TrackFeature region=
new TrackFeature(
region_id,
track_name,
"region",
start,
end,
GFFTools.NO_SCORE,
1, GFFTools.NO_FRAME);
region.setAccessionID(region_id);
region.setTrackId(feature.getTrackId());
System.out.println(region.toString());
DataStoreUser.getInstance().getSockeyeTrackList().addFeature(
track_id,
"region",
region);
_marked_regions.add(region);
DataStoreUser.getInstance().getSockeyeTrackList().setFeatureVisibility(
track_id,
"region",
region.getAccessionID(),
true);
}
public void actionPerformed(ActionEvent e) {
boolean a= p_five_prime.isRelativeToFivePrime();
boolean b= p_three_prime.isRelativeToFivePrime();
if (a && b)
_measurement_bars_label.setIcon(Configuration.mark_region_bar1);
else if (!a && b)
_measurement_bars_label.setIcon(Configuration.mark_region_bar3);
else if (a && !b)
_measurement_bars_label.setIcon(Configuration.mark_region_bar2);
else
_measurement_bars_label.setIcon(Configuration.mark_region_bar5);
}
}
class StartEndPanel extends JPanel {
private JTextField tf= new JTextField(10);
private JRadioButton rb_five_prime=
new JRadioButton("5' end of the feature", true);
private JRadioButton rb_three_prime=
new JRadioButton("3' end of the feature", false);
protected StartEndPanel(String boundary, int v) {
this.setLayout(new GridLayout(4, 1));
this.setBorder(
BorderFactory.createTitledBorder(
BorderFactory.createEtchedBorder(),
boundary));
tf.setText(String.valueOf(v));
this.add(tf);
this.add(new JLabel("Relative to"));
this.add(rb_five_prime);
this.add(rb_three_prime);
ButtonGroup bgroup= new ButtonGroup();
bgroup.add(rb_five_prime);
bgroup.add(rb_three_prime);
}
protected void set5PrimeCheckBoxActionCommand(String c) {
rb_five_prime.setActionCommand(c);
}
protected void set3PrimeCheckBoxActionCommand(String c) {
rb_three_prime.setActionCommand(c);
}
protected void addActionListener(ActionListener al) {
rb_three_prime.addActionListener(al);
rb_five_prime.addActionListener(al);
}
protected int getValue() {
return Integer.parseInt(tf.getText());
}
protected boolean isRelativeToFivePrime() {
return rb_five_prime.isSelected();
}
}
package ca.bcgsc.sockeye.gui;
import ca.bcgsc.sockeye.gui.navigation.HorizontalNavigationBar;
public class MemoryUsage
extends Thread {
protected int rate;
public MemoryUsage(int rate) {
this.rate = rate;
}
public void run() {
for (; ; ) {
try {
synchronized (this) {
Thread.sleep(rate);
Runtime runtime = Runtime.getRuntime();
runtime.gc();
long total = runtime.totalMemory();
int totalK = (int) ( (total + 1023) / 1024);
long free = runtime.freeMemory();
int usageK = (int) ( (total - free + 1023) / 1024);
HorizontalNavigationBar.memory.setText(String.valueOf(usageK) + "K/" + totalK + " K");
}
}
catch (InterruptedException ioe) {
continue;
}
}
}
}
package ca.bcgsc.sockeye.gui;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.Frame;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.Vector;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.JButton;
import javax.swing.JDialog;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.JTextArea;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import javax.swing.filechooser.FileFilter;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableColumn;
import ca.bcgsc.chinook.server.comobj.MotifDiscoveryHit;
import ca.bcgsc.chinook.server.comobj.MotifMatrix;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.io.TRANSFACExporter;
public class MotifDiscoveryDialog extends JDialog {
JTextArea matrix_txt = new JTextArea();
DefaultTableModel model = new ConsensusTableModel();
JTable consensus_tbl = new JTable(model);
JButton save_jb = new JButton("Save");
JButton close_jb = new JButton("Close");
JFileChooser chooser = new JFileChooser(Configuration.USER_DIR);
private static Hashtable _consensus_pwm = new Hashtable();
public MotifDiscoveryDialog(Frame parent) {
super(parent, "Retrieve Data", true);
this.setResizable(true);
this.setDefaultCloseOperation(JDialog.HIDE_ON_CLOSE);
this.setSize(600, 400);
this.setLocationRelativeTo(null);
jbinit();
}
void jbinit() {
JPanel p = new JPanel(new GridBagLayout());
GridBagConstraints c = new GridBagConstraints();
TableColumn tc1 = consensus_tbl.getColumnModel().getColumn(0);
tc1.setMaxWidth(20);
JScrollPane tableView = new JScrollPane(consensus_tbl);
tableView.setPreferredSize(new Dimension(200, 300));
consensus_tbl
.getSelectionModel()
.addListSelectionListener(new ListSelectionListener() {
public void valueChanged(ListSelectionEvent e) {
if (e.getSource() == consensus_tbl.getSelectionModel()) {
int idx = consensus_tbl.getSelectionModel().getAnchorSelectionIndex();
String seq = (String) model.getValueAt(idx, 1);
MotifDiscoveryHit hit = (MotifDiscoveryHit) _consensus_pwm.get(seq);
if (hit == null)
matrix_txt.setText("");
else {
StringBuffer sb = new StringBuffer();
sb.append("A \tC \tG \tT\n\n");
sb.append(hit.getPWM().toString());
matrix_txt.setText(new String(sb));
}
}
}
});
c.gridx = 0;
c.gridy = 0;
c.gridheight = 2;
c.gridwidth = 1;
c.anchor = GridBagConstraints.NORTH;
p.add(tableView, c);
JScrollPane matrixView = new JScrollPane(matrix_txt);
matrixView.setPreferredSize(new Dimension(320, 250));
matrix_txt.setEnabled(false);
c.gridx = 1;
c.gridy = 0;
c.gridheight = 1;
c.gridwidth = 2;
c.insets = new Insets(0, 20, 0, 0);
c.anchor = GridBagConstraints.NORTH;
p.add(matrixView, c);
save_jb.setEnabled(false);
save_jb.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
saveActionPerformed();
}
});
close_jb.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
close();
}
});
Box b = Box.createHorizontalBox();
b.add(save_jb);
b.add(Box.createHorizontalStrut(5));
b.add(close_jb);
c.gridx = 2;
c.gridy = 1;
c.gridheight = 1;
c.gridwidth = 1;
c.insets = new Insets(0, 0, 0, 0);
c.anchor = GridBagConstraints.SOUTHEAST;
p.add(b, c);
p.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
getContentPane().add(p, BorderLayout.CENTER);
}
public void addConsensus(MotifDiscoveryHit hit) {
if (_consensus_pwm.get(hit.getConsensus()) == null) {
Vector tmp = new Vector();
tmp.addElement(new Boolean(false));
tmp.addElement(hit.getConsensus());
model.addRow(tmp);
MotifMatrix matrix = hit.getPWM();
if (matrix == null) {
matrix = pattern2MotivMatrix(hit.getConsensus());
hit.setPWM(matrix);
}
matrix_txt.setEnabled(true);
StringBuffer sb = new StringBuffer();
sb.append(" A \tC \tG \tT\n\n");
sb.append(matrix.toString());
String pwm_output = new String(sb);
_consensus_pwm.put(hit.getConsensus(), hit);
matrix_txt.setText(pwm_output);
save_jb.setEnabled(true);
}
}
public void close() {
this.setVisible(false);
}
public void saveActionPerformed() {
FileFilter filter =
new ExtensionFilter("Transfac File (*.transfac)",
new String[] { ".transfac" });
chooser.addChoosableFileFilter(filter);
if (chooser.showSaveDialog(this) != JFileChooser.APPROVE_OPTION)
return;
File file = chooser.getSelectedFile();
if (!file.getName().endsWith(".transfac")){
JOptionPane.showMessageDialog(
null,
"Please use .transfac extension",
"Specify File Extension",
JOptionPane.WARNING_MESSAGE);
return;
}
ArrayList exportHits = new ArrayList();
for (int i = 0; i < _consensus_pwm.size(); i++) {
if ((Boolean) model.getValueAt(i, 0) == Boolean.TRUE) {
String seq = (String) model.getValueAt(i, 1);
MotifDiscoveryHit hit = (MotifDiscoveryHit) _consensus_pwm.get(seq);
exportHits.add(hit);
}
}
TRANSFACExporter tex = new TRANSFACExporter();
tex.exportToTRANSFAC(exportHits, file);
}
public static MotifMatrix pattern2MotivMatrix(String pattern) {
MotifMatrix m = new MotifMatrix();
pattern = pattern.toUpperCase();
float[] a_row = new float[] {
1, 0, 0, 0};
float[] c_row = new float[] {
0, 1, 0, 0};
float[] g_row = new float[] {
0, 0, 1, 0};
float[] t_row = new float[] {
0, 0, 0, 1};
float[] dot_row = new float[] {
0.25f, 0.25f, 0.25f, 0.25f};
for (int i = 0; i < pattern.length(); i++) {
char letter = pattern.charAt(i);
if (letter == 'A') {
m.addPWMRow(a_row);
continue;
}
if (letter == 'C') {
m.addPWMRow(c_row);
continue;
}
if (letter == 'G') {
m.addPWMRow(g_row);
continue;
}
if (letter == 'T') {
m.addPWMRow(t_row);
continue;
}
if (letter == '.') {
m.addPWMRow(dot_row);
continue;
}
return null;
}
return m;
}
public static class ConsensusTableModel extends DefaultTableModel {
public ConsensusTableModel() {
this.addColumn("");
this.addColumn("Consensus");
}
public Class getColumnClass(int col) {
if (col == 0) {
return Boolean.class;
} else {
return String.class;
}
}
public boolean isCellEditable(int row, int col) {
return (col < 1);
}
}
}
package ca.bcgsc.sockeye.gui;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Container;
import java.awt.Frame;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.List;
import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JTextField;
import ca.bcgsc.sockeye.dataretrieval.DataSource;
import ca.bcgsc.sockeye.dataretrieval.NCCDataSource;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.datastorage.SockeyeTrackList;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.datastorage.events.StorageEvent;
public class NCCScanDialog extends JDialog {
private static NCCScanDialog dialog = null;
private JTextField tf_threshold = new JTextField(10);
private JTextField tf_window_size = new JTextField(10);
private static final String[] MOTIF_SIZES = { "6", "7", "8", "9", "10" };
private JComboBox cb_motif_size = new JComboBox(MOTIF_SIZES);
;
public static void show(Component comp, ArrayList features) {
Frame frame = JOptionPane.getFrameForComponent(comp);
dialog = new NCCScanDialog(frame, features);
dialog.setLocationRelativeTo(comp);
dialog.setVisible(true);
}
public NCCScanDialog(Frame frame, ArrayList track_features) {
super(frame, "NCC Scan");
final ArrayList features = track_features;
int motif_size = 6;
JPanel p = new JPanel(new GridLayout(4, 2, 5, 5));
p.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
JLabel l_motif_size = new JLabel("Motif size");
p.add(l_motif_size, BorderLayout.WEST);
p.add(cb_motif_size, BorderLayout.EAST);
int window_size = motif_size + 1;
JLabel l_window_size = new JLabel("Window size");
p.add(l_window_size, BorderLayout.WEST);
p.add(tf_window_size, BorderLayout.EAST);
tf_window_size.setText(String.valueOf(window_size));
double threshold = 1.4;
JLabel l_threshold = new JLabel("Threshold");
tf_threshold.setSize(tf_threshold.getSize().width, 20);
p.add(l_threshold, BorderLayout.WEST);
p.add(tf_threshold, BorderLayout.EAST);
tf_threshold.setText(String.valueOf(threshold));
JButton b_scan = new JButton("Scan");
b_scan.setSelected(true);
JButton b_cancel = new JButton("Cancel");
p.add(b_scan);
p.add(b_cancel);
b_scan.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
boolean format_exception = false;
double threshold = 0.;
try {
threshold = Double.parseDouble(tf_threshold.getText());
} catch (NumberFormatException nfe) {
nfe.printStackTrace();
format_exception = true;
}
if (format_exception || threshold < 0.) {
JOptionPane.showMessageDialog(
null,
"Format error in 'threshold' text field - it should be a non negative real number.\n"
+ "Please correct your entry.",
"Warning",
JOptionPane.WARNING_MESSAGE);
return;
}
int motif_size = Integer.parseInt(MOTIF_SIZES[0]);
motif_size = Integer.parseInt((String) cb_motif_size.getSelectedItem());
int window_size = motif_size + 1;
try {
window_size = Integer.parseInt(tf_window_size.getText());
} catch (NumberFormatException nfe) {
nfe.printStackTrace();
format_exception = true;
}
if (format_exception || window_size < 0) {
JOptionPane.showMessageDialog(
null,
"Format error in 'Motif size' text field - it should be a non negative integer number.\n"
+ "Please correct your entry.",
"Warning",
JOptionPane.WARNING_MESSAGE);
return;
}
for (int i = 0; i < features.size(); i++) {
TrackFeature feature = (TrackFeature) features.get(i);
int t_id = feature.getTrackId();
DataSource ncc_ds =
(DataSource) new NCCDataSource(t_id,
threshold,
motif_size,
window_size);
if (ncc_ds == null)
return;
int ds_id =
DataStoreUser.getInstance().getDataSourceManager().addDataSource(
ncc_ds);
DataStoreUser.getInstance().getSockeyeTrackList().addStorageListener(
ncc_ds);
DataStoreUser
.getInstance()
.getDataSourceManager()
.setSingleShotSource(
ds_id,
true);
DataStoreUser.getInstance().getSockeyeTrackList().addDataSourceId(
t_id,
ds_id);
List event_attrib = new ArrayList();
event_attrib.add(new Integer(t_id));
event_attrib.add(new Integer(feature.getStart()));
event_attrib.add(new Integer(feature.getEnd()));
event_attrib.add(NCCDataSource.NCC_SCORE_FWD);
event_attrib.add(NCCDataSource.NCC_SCORE_REV);
(
(SockeyeTrackList) DataStoreUser
.getInstance()
.getSockeyeTrackList())
.triggerEvent(
StorageEvent.STORAGE_EVENT_TRACK_DATA_REQUEST,
event_attrib);
}
}
});
b_cancel.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
dialog.setVisible(false);
}
});
Container content_pane = getContentPane();
content_pane.add(p);
pack();
}
}
package ca.bcgsc.sockeye.gui;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Frame;
import java.awt.Toolkit;
import java.awt.datatransfer.StringSelection;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.List;
import java.util.Iterator;
import java.util.HashMap;
import java.util.Map;
import javax.swing.BorderFactory;
import javax.swing.JDialog;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.JToolBar;
import ca.bcgsc.chinook.client.comobj.SequenceCoordinate;
import ca.bcgsc.chinook.server.comobj.ApplicationParameter;
import ca.bcgsc.chinook.server.comobj.SerializableSimpleGFFRecord;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.util.gui.scomponents.SockeyeButton;
import ca.bcgsc.util.gui.scomponents.SockeyeFileChooser;
public class PrimerPredictionReportPanel extends JDialog {
private static int ROW_HEIGHT;
private static Font TEXTAREA_FONT;
private static int PANEL_WIDTH = 500;
private static int PANEL_LENGTH = 800;
private static int MAX_BP_SPACES = 60;
JTextArea ta = new JTextArea();
JScrollPane textScrollPaneImpl = new JScrollPane();
JPanel toolPanel = new JPanel();
TrackFeature tf;
private static Map primer3Map = new HashMap();
private static Map epcrMap = new HashMap();
static {
primer3Map.put("fstart", "TARGET START(ABSOLUTE):\t\t");
primer3Map.put("fend", "TARGET END(ABSOLUTE):\t\t");
primer3Map.put("gcClamp", "GC CLAMP:\t\t\t");
primer3Map.put("gcPercent", "GC PERCENT:\t\t\t");
primer3Map.put("neighbourhood", "NEIGHBOUR REGION (*):\t\t");
primer3Map.put("primerSize", "OPTIMAL PRIMER SIZE:\t\t");
primer3Map.put("qual", "PRIMER PAIR QUALITY MIN:\t");
primer3Map.put("sets", "NUMBER OF RESULT SETS:\t\t");
primer3Map.put("sizerange", "SIZE RANGE(*):\t\t\t");
primer3Map.put("tm", "OPTIMAL TM:\t\t\t");
epcrMap.put("margin", "ALLOWED PRODUCT SIZE RANGE:\t");
epcrMap.put("mismatch", "NUM PRIMER MISMATCHES ALLOWED:\t");
epcrMap.put("wordSize", "SEARCH WORD SIZE:\t\t");
}
public PrimerPredictionReportPanel(
Frame frame,
String title,
boolean modal,
TrackFeature tf) {
super(frame, title, modal);
this.tf = tf;
this.setTitle("Primer Prediction Report Panel");
this.getContentPane().setLayout(new BorderLayout());
this.setSize(PANEL_LENGTH, PANEL_WIDTH);
this.setLocation(200, 200);
if (java.lang.System.getProperty("os.name").startsWith("Windows")) {
ROW_HEIGHT = 17;
TEXTAREA_FONT = new Font("Monospaced", Font.PLAIN, 12);
} else if (java.lang.System.getProperty("os.name").startsWith("Linux")) {
ROW_HEIGHT = 15;
TEXTAREA_FONT = new Font("Monospaced", Font.PLAIN, 12);
} else {
ROW_HEIGHT = 15;
TEXTAREA_FONT = new Font("Monospaced", Font.PLAIN, 14);
}
this.textScrollPaneImpl.setVerticalScrollBarPolicy(
JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
this.textScrollPaneImpl.setHorizontalScrollBarPolicy(
JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
this.textScrollPaneImpl.setViewportView(ta);
this.textScrollPaneImpl.getViewport().setViewSize(new Dimension(800, 250));
SockeyeButton b_copy =
new SockeyeButton(
Configuration.copy_icon,
"Copy selected section of Report to clipboard");
SockeyeButton b_export =
new SockeyeButton(
Configuration.export_icon,
"Export selected section of Report to File");
SockeyeButton b_save =
new SockeyeButton(Configuration.save_icon, "Save entire Report to File");
b_copy.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
copy_actionPerformed();
}
});
b_export.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
save_actionPerformed();
}
});
b_save.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
save_actionPerformed();
}
});
JToolBar toolBar = new JToolBar("GFF Toolbar");
toolBar.setBorder(BorderFactory.createRaisedBevelBorder());
toolBar.add(b_copy);
toolBar.add(b_export);
toolBar.add(b_save);
ta.setFont(TEXTAREA_FONT);
ta.setBackground(Color.white);
ta.setSelectedTextColor(Color.BLUE);
ta.setSelectionColor(Color.RED);
ta.setEditable(false);
ta.addMouseListener(new MouseListener() {
public void mouseClicked(MouseEvent evt) {
}
public void mouseEntered(MouseEvent evt) {
}
public void mouseExited(MouseEvent evt) {
}
public void mousePressed(MouseEvent evt) {
}
public void mouseReleased(MouseEvent evt) {
}
});
populateTextArea();
this.getContentPane().add(toolBar, BorderLayout.PAGE_START);
this.getContentPane().add(textScrollPaneImpl, BorderLayout.CENTER);
this.show();
}
private void copy_actionPerformed() {
String export_text = ta.getSelectedText();
if (export_text == null || export_text.length() == 0) {
JOptionPane.showMessageDialog(this, "Nothing was selected");
} else {
file :
Toolkit.getDefaultToolkit().getSystemClipboard().setContents(
(new StringSelection("Primer Prediction Results Report:\n\n"
+ export_text)),
null);
}
}
private void save_actionPerformed() {
SockeyeFileChooser myFileChooser =
(SockeyeFileChooser) SockeyeFileChooser.getSockeyeFileChooser("PrimerPredictionReportPanel");
myFileChooser.setDialogTitle("Save Primer Prediction Report As...");
String export_text = ta.getSelectedText();
if (export_text == null) {
export_text = ta.getText();
}
myFileChooser.showSaveDialog(Sockeye.__frame, "txt", export_text);
}
private void populateTextArea() {
HashMap params = (HashMap) tf.getAttachment("Chinook Parameters");
SequenceCoordinate[] seqCoords =
(SequenceCoordinate[]) params.get("SequenceCoordinates");
ApplicationParameter[] app_params =
(ApplicationParameter[]) params.get("ApplicationParameters");
ta.append("PRIMER PREDICTION RUN\n====================\n");
ta.append("" + tf.getAttachment("Date Time") + "\n");
ta.append("\n\n");
ta.append("Primer3 INPUT PARAMETERS\n========================\n");
int fstart = 0;
int fend = 0;
for (int i = 0; i < app_params.length; i++) {
if (app_params[i].name.equals("fstart")) {
fstart = Integer.valueOf(app_params[i].value).intValue();
}
if (app_params[i].name.equals("fend")) {
fend = Integer.valueOf(app_params[i].value).intValue();
}
if (primer3Map.get(app_params[i].name) != null) {
ta.append(
primer3Map.get(app_params[i].name) + app_params[i].value + "\n");
}
}
int targRelStart = fstart - seqCoords[0].getStart() + 1;
int targRelEnd = fend - seqCoords[0].getStart() + 1;
int targLength = fend - fstart + 1;
ta.append("\n");
ta.append("TARGET START(RELATIVE):\t\t" + targRelStart + "\n");
ta.append("TARGET END(RELATIVE):\t\t" + targRelEnd + "\n");
ta.append("TARGET LENGTH:\t\t\t" + targLength + "\n");
ta.append("NEIGHBOUR REGION START(*):\t" + seqCoords[0].getStart() + "\n");
ta.append("NEIGHBOUR REGION END(*):\t" + seqCoords[0].getEnd() + "\n");
ta.append("\n\n");
ta.append("e-PCR INPUT PARAMETERS\n========================\n");
for (int i = 0; i < app_params.length; i++) {
if (epcrMap.get(app_params[i].name) != null) {
ta.append(epcrMap.get(app_params[i].name) + app_params[i].value + "\n");
}
}
ta.append("\n\n");
ta.append("Primer3 & ePCR RESULTS\n===============\n");
List results = (List) tf.getAttachment("Primer Prediction Report");
Iterator l = results.iterator();
l = results.iterator();
if (results.size() == 0) {
ta.append(
"No acceptable primers were found. Try relaxing input parameters.");
return;
}
String startTab = "\t";
String endTab = "\t";
if(seqCoords[0].getStart() > 9999999) {
startTab += "\t";
}
if(seqCoords[0].getEnd() > 9999999) {
endTab += "\t";
}
ta.append("SET\tFEATURE\t\t\tSTART"+startTab+"END"+endTab+"LENGTH\tTM\tSEQUENCE\n");
int count = 1;
while (l.hasNext()) {
String tm = "";
String sequence = "";
String ePCR = "";
SerializableSimpleGFFRecord gffr = (SerializableSimpleGFFRecord) l.next();
if (gffr.getFeature().equals("amplicon")) {
Iterator iterator = gffr.getGroupAttributes().entrySet().iterator();
while (iterator.hasNext()) {
Map.Entry entry = (Map.Entry) iterator.next();
if (((Object[]) entry.getValue()).length == 0) {
continue;
}
if (entry.getKey().equals("e-PCR_products")) {
ePCR = ((Object[]) entry.getValue())[0].toString();
}
}
int productSize = gffr.getEnd() - gffr.getStart() + 1;
ta.append(" \t");
ta.append(
"PRODUCT SIZE: "
+ productSize
+ ", "
+ "PRIMER PAIR QUALITY(*): "
+ gffr.getScore()
+ ", "
+ "e-PCR PRODUCTS(*): "
+ ePCR);
ta.append("\n\n");
count++;
continue;
}
Map m = gffr.getGroupAttributes();
Iterator iterator = m.entrySet().iterator();
StringBuffer attrib = new StringBuffer();
while (iterator.hasNext()) {
Map.Entry entry = (Map.Entry) iterator.next();
if (((Object[]) entry.getValue()).length == 0) {
continue;
}
if (entry.getKey().equals("tm")) {
tm = ((Object[]) entry.getValue())[0].toString();
}
if (entry.getKey().equals("primer")) {
sequence = ((Object[]) entry.getValue())[0].toString();
}
}
if (gffr.getFeature().equals("forward_primer")) {
ta.append(" " + count + "\t");
} else {
ta.append(" \t");
}
int length = gffr.getEnd() - gffr.getStart() + 1;
ta.append(
gffr.getFeature()
+ "\t\t"
+ gffr.getStart()
+ "\t"
+ gffr.getEnd()
+ "\t"
+ length
+ "\t"
+ tm
+ "\t"
+ sequence);
ta.append("\n");
}
ta.append("\n\n");
ta.append("NOTES (*)\n=========\n");
ta.append("1. Neighbourhood Region is ignored and set to 0 for \"Primers Inside Target\".\n");
ta.append("2. Size range is calculated from neighbourhood value.\n");
ta.append("3. Lower Primer pair quality value is better.\n");
ta.append("4. e-PCR is currently run on the neighbouring region.\n");
ta.append("\n\n");
ta.append("REFERENCES\n=========\n");
ta.append("Steve Rozen and Helen J. Skaletsky (2000) Primer3 on the WWW for general users and for biologist programmers.\n");
ta.append("In: Krawetz S, Misener S (eds) Bioinformatics Methods and Protocols: Methods in Molecular Biology. Humana Press, Totowa, NJ, pp 365-386\n");
ta.append("Source code available at http:
}
private String getScore(SerializableSimpleGFFRecord gffr) {
String score = "" + gffr.getScore();
if ((score == null) || (score.equals("-Infinity"))) {
return ".";
}
return score;
}
private String getStrand(SerializableSimpleGFFRecord gffr) {
int strand = gffr.getStrand();
if (strand == 0) {
return ".";
} else if (strand == -1) {
return "-";
}
return "+";
}
private String getFrame(SerializableSimpleGFFRecord gffr) {
int frame = gffr.getFrame();
if (frame == -1) {
return ".";
}
return "" + frame;
}
}
package ca.bcgsc.sockeye.gui;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.Frame;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Date;
import javax.swing.JButton;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JProgressBar;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.util.Log;
public class ProgressBar extends JDialog {
private static final int _MIN = 0;
private static final int _MAX = 100;
private static final int _WIDTH = 300;
private static int _split = 10;
private JLabel l_info = new JLabel(".....");
private JButton b_cancel = new JButton("Cancel");
private JButton b_details = new JButton("Details");
private JPanel p_buttons = new JPanel();
private JPanel p_labels = new JPanel();
private JPanel p_top = new JPanel();
private JLabel l_icon = new JLabel(Configuration.infor_icon);
private JProgressBar pb = new JProgressBar(_MIN, _MAX);
private String info;
private boolean stop = false;
private boolean done = false;
private String details = null;
public ProgressBar(String info_, Frame f, int length) {
super(f);
info = info_;
p_buttons.add(b_cancel);
p_buttons.add(b_details);
b_details.setEnabled(false);
p_top.setLayout(new BorderLayout());
getContentPane().add(p_top, BorderLayout.NORTH);
p_labels.add(l_icon, BorderLayout.WEST);
p_labels.add(l_info, BorderLayout.CENTER);
p_top.add(p_labels, BorderLayout.NORTH);
p_top.add(p_buttons, BorderLayout.SOUTH);
p_top.add(pb, BorderLayout.CENTER);
setTitle("Progress information...");
l_info.setPreferredSize(new Dimension(_WIDTH, 30));
setInfo(info);
pack();
setLocationRelativeTo(f);
final int pause = length;
Runnable wait = new Runnable() {
public void run() {
int i = 1;
while (i <= _split && !stop) {
try {
Thread.sleep(pause);
if (done)
i = _MAX / _split;
if (i == _split)
setDoneResult();
pb.setValue(i * _split);
i++;
} catch (Exception e) {
e.printStackTrace();
Log.printStackTrace(e);
}
}
}
};
setVisible(true);
Thread thread = new Thread(wait);
thread.start();
b_cancel.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
stop(" canceled.", null);
}
});
b_details.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
JScrollPane sp_details = new JScrollPane();
JTextArea ta_details = new JTextArea();
ta_details.setEditable(false);
ta_details.setText(details);
getContentPane().add(sp_details, BorderLayout.CENTER);
sp_details.getViewport().add(ta_details, null);
ta_details.setBackground(l_info.getBackground());
sp_details.setPreferredSize(new Dimension(_WIDTH, 100));
pack();
}
});
}
public void cancel() {
}
public void processDone() {
b_cancel.setEnabled(false);
done = true;
}
public void setInfo(String info) {
l_info.setText(" " + info);
}
public void done() {
done = true;
}
private void close(boolean pause) {
if (pause) {
long start = (new Date()).getTime();
while ((new Date()).getTime() - start < 2000) {
};
}
dispose();
}
private void setDoneResult() {
setInfo(info + " completed successfully.");
b_cancel.setEnabled(false);
b_details.setEnabled(false);
close(true);
}
public boolean isStop() {
return stop;
}
public boolean isDone() {
return done;
}
public void stop(String message_, String details_) {
stop = true;
setInfo(info + message_);
b_cancel.setEnabled(false);
details = details_;
b_details.setEnabled(details != null);
if (details == null)
close(true);
else {
l_icon.setIcon(Configuration.error_icon);
cancel();
}
}
}
package ca.bcgsc.sockeye.gui;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import ca.bcgsc.sockeye.dataretrieval.DataSourceManager;
import ca.bcgsc.sockeye.dataretrieval.DataRequest;
import ca.bcgsc.sockeye.config.Configuration;
import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;
import java.lang.Thread;
public class QueryManager extends JPanel implements MouseListener {
private JLabel label1;
private JLabel label2;
private JLabel label3;
private JDialog dialog;
private DataSourceManager data_source_manager;
private QueryChecker checker = new QueryChecker();
private Thread checkThread = new Thread(checker);
private boolean newDialog = false;
JComponent processListPane = new ProcessPane();
public QueryManager(Frame parent, DataSourceManager data_source_manager) {
dialog = new JDialog(parent, "Query Status");
this.data_source_manager = data_source_manager;
setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
label1 = new JLabel(Configuration.working_query_icon, JLabel.CENTER);
label1.setDisabledIcon(Configuration.static_query_icon);
label2 =
new JLabel(
data_source_manager.countActiveRequests() + " request(s) active",
JLabel.CENTER);
label3 = new JLabel("Click for details...", JLabel.CENTER);
label1.setEnabled(false);
label2.setEnabled(false);
label3.setEnabled(false);
setBackground(java.awt.Color.white);
addMouseListener(this);
add(label1);
add(label2);
add(label3);
checkThread.start();
this.doLayout();
}
public void setList(List inputList) {
label2.setText(
data_source_manager.countActiveRequests() + " request(s) active");
if (data_source_manager.countActiveRequests() < 1) {
label1.setEnabled(false);
label2.setEnabled(false);
label3.setEnabled(false);
} else {
label1.setEnabled(true);
label2.setEnabled(true);
label3.setEnabled(true);
}
((ProcessPane) processListPane).setList(inputList);
}
private void mouseDeleteProcess(Object item) {
data_source_manager.killActiveRequest((DataRequest) item);
}
public void mousePressed(MouseEvent e) {
}
public void mouseClicked(MouseEvent e) {
if ((data_source_manager.countActiveRequests() > 0) && (!newDialog)) {
newDialog = true;
dialog.setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);
processListPane.setOpaque(true);
dialog.setContentPane(processListPane);
dialog.setLocationRelativeTo(null);
dialog.pack();
dialog.setVisible(true);
} else {
if ((data_source_manager.countActiveRequests() > 0)
&& (!dialog.isVisible())) {
dialog.setVisible(true);
}
}
}
public void mouseEntered(MouseEvent e) {
}
public void mouseExited(MouseEvent e) {
}
public void mouseReleased(MouseEvent e) {
}
class QueryChecker implements Runnable {
public void run() {
int lastVal = 0;
while (true) {
lastVal = data_source_manager.waitForActiveRequestChange(lastVal);
setList(data_source_manager.getActiveRequests());
}
}
}
class ProcessPane extends JPanel {
private static final String okString = "OK";
private static final String stopString = "STOP";
private JFrame frame;
private DefaultListModel listModel = new DefaultListModel();
private JList list;
private ArrayList processList;
JButton stopButton = new JButton(stopString);
public ProcessPane() {
super(new BorderLayout());
list = new JList(listModel);
list.setPreferredSize(new Dimension(300, 200));
list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
list.setSelectedIndex(0);
list.setVisibleRowCount(5);
JScrollPane listScrollPane = new JScrollPane(list);
JButton okButton = new JButton(okString);
okButton.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
dialog.setVisible(false);
}
});
stopButton.setEnabled(false);
stopButton.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
int index = list.getSelectedIndex();
if (index >= listModel.getSize() || (index < 0)) {
return;
}
int n =
JOptionPane.showConfirmDialog(
ProcessPane.this,
"Sure you want to stop \n" + listModel.getElementAt(index) + "?",
"Confirm Stop",
JOptionPane.YES_NO_OPTION);
if (n == JOptionPane.YES_OPTION)
mouseDeleteProcess(processList.get(index));
}
});
JPanel buttonPane = new JPanel();
buttonPane.setLayout(new BoxLayout(buttonPane, BoxLayout.LINE_AXIS));
buttonPane.add(okButton);
buttonPane.add(Box.createHorizontalGlue());
buttonPane.add(stopButton);
buttonPane.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
add(listScrollPane);
add(buttonPane, BorderLayout.PAGE_END);
}
public void setList(List inputList) {
processList = (ArrayList) inputList;
listModel.clear();
for (Iterator i = inputList.iterator(); i.hasNext();) {
DataRequest item = (DataRequest) i.next();
int id = item.getId();
int start = item.getStart();
int end = item.getEnd();
String inputString =
("Request: " + id + " Start: " + start + " End: " + end);
listModel.addElement(inputString);
}
if (listModel.getSize() > 0)
stopButton.setEnabled(true);
else
stopButton.setEnabled(false);
}
}
}
package ca.bcgsc.sockeye.gui;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Frame;
import java.awt.Point;
import java.awt.Toolkit;
import java.awt.datatransfer.StringSelection;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.List;
import javax.swing.AbstractAction;
import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JFileChooser;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JScrollPane;
import javax.swing.JSlider;
import javax.swing.JTextArea;
import javax.swing.JTextField;
import javax.swing.JToolBar;
import javax.swing.JWindow;
import javax.swing.SwingUtilities;
import javax.swing.Timer;
import javax.swing.event.CaretEvent;
import javax.swing.event.CaretListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.text.SimpleAttributeSet;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.datastorage.DataStorageManager;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.datastorage.events.StorageEvent;
import ca.bcgsc.sockeye.datastorage.events.StorageEventListener;
import ca.bcgsc.sockeye.io.FASTAExporter;
import ca.bcgsc.sockeye.util.Log;
import ca.bcgsc.util.gui.scomponents.SockeyeButton;
import ca.bcgsc.util.gui.scomponents.SockeyeFileChooser;
public class SequencePanel extends JDialog implements StorageEventListener {
final int CHARS_PER_SEC = 10;
final int CHARS_PER_LINE = 100;
public final String panelID;
int block_size = 50000;
int overlap = 0;
String[] text_blocks = new String[3000];
String sequence;
String defaultFastaHeader;
int array_size = 0;
int text_size;
int num_of_blocks = 0;
int currentBlock = 0;
int currentBlockRowCount = 0;
int startLoc = -1;
int endLoc;
int strand;
int active_track_id = -1;
private static int ROW_HEIGHT;
private static Font TEXTAREA_FONT;
TextArea ta_seq;
JScrollPane textScrollPaneImpl = new JScrollPane();
PropertiesPanel propertiesPanelImpl = new PropertiesPanel();
ColumnHeader columnHeader = new ColumnHeader();
SequenceSlider sequenceSlider = new SequenceSlider();
RowLabel rowTable;
TextFormatter textFormatter = new TextFormatter();
private DataStorageManager _my_dsm;
private TrackFeature _track_feature_to_show = null;
public SequencePanel(
String fastaHeader,
String sequence,
Frame parent,
int startLocation,
int endLocation,
int strand) {
super(parent);
if (java.lang.System.getProperty("os.name").startsWith("Windows")) {
ROW_HEIGHT = 17;
TEXTAREA_FONT = new Font("Monospaced", Font.PLAIN, 12);
}
else if (java.lang.System.getProperty("os.name").startsWith("Linux")) {
ROW_HEIGHT = 15;
TEXTAREA_FONT = new Font("Monospaced", Font.PLAIN, 12);
}
else {
ROW_HEIGHT = 15;
TEXTAREA_FONT = new Font("Monospaced", Font.PLAIN, 14);
}
this.setTitle("Sequence Panel");
this.panelID = fastaHeader;
this.getContentPane().setLayout(new BorderLayout());
this.setSize(1000, 300);
this.startLoc = startLocation;
this.endLoc = endLocation;
this.strand = strand;
this.defaultFastaHeader = fastaHeader;
rowTable = new RowLabel();
ta_seq = new TextArea();
this.textScrollPaneImpl.setVerticalScrollBarPolicy(
JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
this.textScrollPaneImpl.setHorizontalScrollBarPolicy(
JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
if (sequence == null || sequence.length() == 0)
this.ta_seq.setText("No sequence has been retrieved.");
else
this.addText(sequence);
this.textScrollPaneImpl.setViewportView(ta_seq);
this.textScrollPaneImpl.setRowHeaderView(rowTable);
this.textScrollPaneImpl.getViewport().setViewSize(new Dimension(800, 250));
this.textScrollPaneImpl.getRowHeader().setSize(new Dimension(150, 300));
this.getContentPane().add(textScrollPaneImpl, BorderLayout.CENTER);
this.getContentPane().add(propertiesPanelImpl, BorderLayout.SOUTH);
this.getContentPane().add(columnHeader, BorderLayout.NORTH);
this.getContentPane().add(sequenceSlider, BorderLayout.EAST);
this.setFastaHeader(fastaHeader);
this.setLocation(200, 200);
this.show();
}
public void setTrack(int id) {
active_track_id = id;
}
public void setDataStorageManager(DataStorageManager d) {
_my_dsm = d;
}
public void setFeature(TrackFeature tf) {
_track_feature_to_show = tf;
}
public void setSequence(String sequence) {
if (sequence == null || sequence.length() == 0)
this.ta_seq.setText("Sequence is beeing retrieved - please stand by");
else
this.addText(sequence);
}
public void storageEventReceived(StorageEvent e) {
if (e.getEventType() == StorageEvent.STORAGE_EVENT_TRACK_ADD_FEATURES) {
List attrib = (List) e.getAttribute();
int t_id = Integer.parseInt(attrib.get(0).toString());
String feature = attrib.get(1).toString();
if (t_id != active_track_id)
return;
if (feature.equals("sequence"))
if (_track_feature_to_show == null)
this.addText(_my_dsm.getTrackSequence(t_id));
else
this.addText(_my_dsm.getFeatureSequence(_track_feature_to_show));
}
}
String formatText(String sequence) {
StringBuffer seq_buffer = new StringBuffer(sequence);
final int BLOCK_SIZE = 10;
int insertLocal = BLOCK_SIZE;
for (int i = 1; i <= (sequence.length() / 10); i++) {
if ((i % 10) == 0)
seq_buffer.insert(insertLocal, " \n");
else
seq_buffer.insert(insertLocal, " ");
insertLocal = insertLocal + (this.CHARS_PER_SEC + 2);
}
return seq_buffer.toString();
}
final int CHARS_PER_LINE = 80;
int insertLocal = this.CHARS_PER_LINE;
sequence = sequence.toUpperCase();
StringBuffer seq_buffer = new StringBuffer(sequence);
for (int i = 1; i <= (sequence.length() / this.CHARS_PER_LINE); i++) {
seq_buffer.insert(insertLocal, "\n");
insertLocal += (this.CHARS_PER_LINE + 1);
}
return seq_buffer.toString();
}*/
class WorkerThread extends Thread {
int CHARS_PER_LINE;
String sequence;
public WorkerThread(String nonFormattedSequence, int charsPerLine) {
this.sequence = nonFormattedSequence.toUpperCase();
this.CHARS_PER_LINE = charsPerLine;
}
public void run() {
int insertLocal = this.CHARS_PER_LINE;
StringBuffer seq_buffer = new StringBuffer(sequence);
for (int i = 1; i <= (sequence.length() / this.CHARS_PER_LINE); i++) {
seq_buffer.insert(insertLocal, "\n");
insertLocal += (this.CHARS_PER_LINE + 1);
}
this.sequence = seq_buffer.toString();
}
public String getFormattedSequence() {
return this.sequence;
}
}
int formatBlock = 100000;
int num_of_threads = sequence.length() / formatBlock;
WorkerThread[] threads = new WorkerThread[num_of_threads];
for (int i = 0; i < num_of_threads - 1; i++) {
threads[i] =
new WorkerThread(
sequence.substring((i * formatBlock), ((i + 1) * formatBlock)),
this.CHARS_PER_LINE);
threads[i].start();
}
threads[num_of_threads - 1] =
new WorkerThread(
sequence.substring(
((num_of_threads - 1) * formatBlock),
sequence.length()),
this.CHARS_PER_LINE);
threads[num_of_threads - 1].start();
sequence = new String();
try {
for (int i = 0; i < num_of_threads; i++) {
threads[i].join();
}
}
catch (InterruptedException exc) {
exc.printStackTrace();
}
for (int i = 0; i < num_of_threads; i++) {
sequence += threads[i].getFormattedSequence();
}
return sequence;
}*/
public void addText(String textToAdd) {
int actualSize = 0;
int start = 0;
int stop = 0;
if (textToAdd == null)
return;
else {
this.sequence = textToAdd;
this.text_size = textToAdd.length();
for (this.num_of_blocks = 0; stop < this.text_size; num_of_blocks++) {
start = this.num_of_blocks * (this.block_size - this.overlap);
stop =
(this.num_of_blocks + 1) * (this.block_size - this.overlap)
+ this.overlap;
if (stop <= this.text_size) {
this.text_blocks[this.num_of_blocks] =
textToAdd.substring(start, stop);
}
else {
this.text_blocks[this.num_of_blocks] =
textToAdd.substring(start, this.text_size);
}
}
this.num_of_blocks--;
this.currentBlock = 0;
this.currentBlockRowCount =
(this.text_blocks[this.currentBlock].length()
+ this.CHARS_PER_LINE
- 1)
/ this.CHARS_PER_LINE;
this.sequenceSlider.activate();
this.columnHeader.setLocationText();
this.ta_seq.setText(formatText(this.text_blocks[this.currentBlock]));
rowTable.updateValues();
}
}
public void setFeatureInformation(String featureType, String featureID) {
this.propertiesPanelImpl.setFeatureInformation(featureID);
}
void setFastaHeader(String fastaHeader) {
this.columnHeader.setFastaHeaderText(fastaHeader);
}
public void saveToClipboard() {
String export_text = SequencePanel.this.ta_seq.getSelectedText();
if (export_text == null || export_text.length() == 0) {
JOptionPane.showMessageDialog(this, "Nothing was selected");
}
else {
file :
Toolkit.getDefaultToolkit().getSystemClipboard().setContents(
(new StringSelection(getFastaHeader() + "\n" + export_text)),
null);
}
}
public void warnFeatureCut() {
JOptionPane.showMessageDialog(
this,
"The feature is cut in 3D. Only the sequence for the part of the feature that is visible is shown.");
}
public String getFastaHeader() {
int select_start = SequencePanel.this.ta_seq.getSelectionStart();
int select_end = SequencePanel.this.ta_seq.getSelectionEnd();
if (select_start == select_end) {
return this.defaultFastaHeader;
}
int blockOffset =
SequencePanel.this.currentBlock
int start_blank = 0;
int end_blank = 0;
if (select_start % 12 == 10 || select_start % 12 == 11) {
start_blank = select_start % 12 - 10;
}
if (select_end % 12 == 10 || select_end % 12 == 11) {
end_blank = select_end % 12 - 10;
}
int select_startLocation =
select_start
- ((int) Math.floor(select_start / 12)) * 2
- start_blank
+ blockOffset;
int select_stopLocation =
select_end
- ((int) Math.floor(select_end / 12)) * 2
- end_blank
+ blockOffset
- 1;
int start = (select_startLocation + startLoc);
int end = (select_stopLocation + startLoc);
int length = end - start + 1;
String rev = defaultFastaHeader.indexOf("reverse complement") > -1 ? "(reverse complement)" : "";
int index = defaultFastaHeader.lastIndexOf(":");
if (index == -1) return defaultFastaHeader;
String header = defaultFastaHeader.substring(0, index + 1);
header += start + ".." + end + " (" + length + "bp)" + rev;
return header;
}
protected void saveToFile(String file_type) {
SockeyeFileChooser myFileChooser =
SockeyeFileChooser.getSockeyeFileChooser("FASTAExport");
myFileChooser.setDialogTitle("Save Sequences As...");
String export_text = ta_seq.getSelectedText();
if (export_text == null) {
export_text = new String();
for (int i = 0; i <= num_of_blocks; i++)
export_text += text_blocks[i];
}
if (file_type.equals("Fasta")) {
String file_name = "exported_sequence.fasta";
int result =
myFileChooser.showSaveDialog(
Sockeye.__frame,
"fasta",
new File(file_name));
try {
file_name =
myFileChooser.getSelectedFile().getCanonicalPath();
if (result == JFileChooser.APPROVE_OPTION) {
FASTAExporter.exportToFASTA(
getFastaHeader(),
export_text,
file_name);
}
} catch (java.io.IOException ex) {
Log.printStackTrace(ex);
JOptionPane.showMessageDialog(this, "Unable to save file.", "File Output Error", JOptionPane.ERROR_MESSAGE);
return;
}
}
if (file_type.equals("Raw")) {
myFileChooser.showSaveDialog(SequencePanel.this, "raw", export_text);
}
}
class TextArea extends JTextArea implements CaretListener {
SimpleAttributeSet styleAttributeSetOne = new SimpleAttributeSet();
SimpleAttributeSet styleAttributeSetTwo = new SimpleAttributeSet();
public TextArea() {
super();
this.setFont(TEXTAREA_FONT);
this.setBackground(Color.white);
this.setSelectedTextColor(Color.BLUE);
this.setSelectionColor(Color.RED);
this.setEditable(false);
this.addCaretListener(this);
this.addMouseListener(new PopupMenuListener());
}
public void setSelectionStart(int startSelectionIndex) {
if (startSelectionIndex > this.getText().length())
startSelectionIndex = this.getText().length();
SequencePanel.this.ta_seq.setCaretPosition(startSelectionIndex);
}
public void setSelectionEnd(int endSelectionIndex) {
if (endSelectionIndex > this.getText().length())
endSelectionIndex = this.getText().length();
SequencePanel.this.ta_seq.moveCaretPosition(endSelectionIndex);
}
public String getSelectedText() {
return super.getSelectedText();
}
public void caretUpdate(CaretEvent event) {
if (event.getMark() == event.getDot()
|| (event.getMark() + 1) == event.getDot()
|| (event.getMark() - 1) == event.getDot()) {
if (event.getMark() > event.getDot()) {
propertiesPanelImpl.setRelativeLocation(event.getMark());
propertiesPanelImpl.setAbsoluteLocation(event.getMark());
}
else {
propertiesPanelImpl.setRelativeLocation(event.getDot());
propertiesPanelImpl.setAbsoluteLocation(event.getDot());
}
}
else {
propertiesPanelImpl.setRelativeLocation(
event.getMark(),
event.getDot());
propertiesPanelImpl.setAbsoluteLocation(
event.getMark(),
event.getDot());
}
}
}
class SequenceSlider
extends JSlider
implements ChangeListener, MouseListener {
JLabel windowLabelTwo = new JLabel();
JWindow window = new JWindow();
Point windowLocation = new Point();
int startLocation = 0;
int stopLocation = SequencePanel.this.currentBlock;
public SequenceSlider() {
this.setOrientation(JSlider.VERTICAL);
this.setValue(0);
this.setInverted(true);
this.setSnapToTicks(true);
this.windowLabelTwo.setBorder(
BorderFactory.createCompoundBorder(
BorderFactory.createTitledBorder("Sequence Location: "),
BorderFactory.createLoweredBevelBorder()));
}
public void activate() {
this.setMaximum(SequencePanel.this.num_of_blocks);
this.setMinimum(0);
this.setPaintTicks(true);
this.setMajorTickSpacing(1);
this.addChangeListener(this);
this.addMouseListener(this);
}
public void stateChanged(ChangeEvent evt) {
this.windowLocation = SequencePanel.this.getLocation();
this.windowLocation.x -= (this.window.getSize().width + 250);
this.windowLocation.y += 20;
SwingUtilities.convertPointToScreen(this.windowLocation, this);
this.startLocation =
(((JSlider) evt.getSource()).getValue())
this.stopLocation =
((((JSlider) evt.getSource()).getValue()))
+ SequencePanel.this.block_size;
this.windowLabelTwo.setText(
String.valueOf(this.startLocation)
+ "bp - "
+ String.valueOf(this.stopLocation)
+ "bp");
if (!this.getValueIsAdjusting()) {
}
this.window.getContentPane().setLayout(
new BoxLayout(this.window.getContentPane(), BoxLayout.Y_AXIS));
this.window.getContentPane().add(this.windowLabelTwo);
this.window.pack();
this.window.setLocation(this.windowLocation);
this.window.setVisible(true);
this.window.show();
}
public void mouseClicked(MouseEvent evt) {
}
public void mouseEntered(MouseEvent evt) {
}
public void mouseExited(MouseEvent evt) {
this.window.setVisible(false);
}
public void mousePressed(MouseEvent evt) {
}
public void mouseReleased(MouseEvent evt) {
SequencePanel.this.ta_seq.setText(null);
SequencePanel.this.currentBlock = this.getValue();
SequencePanel.this.currentBlockRowCount =
(SequencePanel
.this
.text_blocks[SequencePanel
.this
.currentBlock]
.length()
+ SequencePanel.this.CHARS_PER_LINE
- 1)
/ SequencePanel.this.CHARS_PER_LINE;
SequencePanel.this.ta_seq.setText(
formatText(
SequencePanel.this.text_blocks[SequencePanel.this.currentBlock]));
SequencePanel.this.rowTable.updateValues();
SequencePanel.this.columnHeader.setLocationText();
SequencePanel.this.sequenceSlider.setValue(
SequencePanel.this.currentBlock);
}
public void finalize() {
while (((ChangeListener[]) (this.getListeners(ChangeListener.class)))
.length
> 0) {
this.removeChangeListener(
((ChangeListener[]) (this.getListeners(ChangeListener.class)))[0]);
}
while (((MouseListener[]) (this.getListeners(MouseListener.class)))
.length
> 0) {
this.removeMouseListener(
((MouseListener[]) (this.getListeners(MouseListener.class)))[0]);
}
}
}
class PopupMenuListener extends AbstractAction implements MouseListener {
JPopupMenu popupMenu = new JPopupMenu();
Component eventOriginator;
public PopupMenuListener() {
createPopup();
}
public void mouseClicked(MouseEvent evt) {
this.eventOriginator = evt.getComponent();
if (evt.getButton() > 1)
displayPopup(evt.getPoint());
}
public void mouseEntered(MouseEvent evt) {
}
public void mouseExited(MouseEvent evt) {
}
public void mousePressed(MouseEvent evt) {
}
public void mouseReleased(MouseEvent evt) {
}
public void actionPerformed(ActionEvent evt) {
saveToFile(evt.getActionCommand());
}
void createPopup() {
JMenu m_save_as = new JMenu("Save As");
JMenuItem mi_fasta = new JMenuItem("Fasta Format");
mi_fasta.setActionCommand("Fasta");
mi_fasta.addActionListener(this);
JMenuItem mi_raw = new JMenuItem("Raw Format");
mi_raw.setActionCommand("Raw");
mi_raw.addActionListener(this);
JMenuItem mi_copy = new JMenuItem("Copy");
mi_copy.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
saveToClipboard();
}
});
m_save_as.add(mi_fasta);
m_save_as.add(mi_raw);
this.popupMenu.add(m_save_as);
this.popupMenu.add(mi_copy);
}
void displayPopup(Point point) {
this.popupMenu.show(this.eventOriginator, point.x, point.y);
}
}
class PropertiesPanel extends JPanel {
JLabel absoluteLocationLabel = new JLabel(" Absolute Location:");
JLabel relativeLocationLabel = new JLabel(" Relative Location:");
JLabel featureIDLabel = new JLabel(" Feature Accession ID:");
JTextField absoluteLocationTextField = new JTextField(12);
JTextField relativeLocationTextField = new JTextField(8);
JTextField featureIDTextField = new JTextField(12);
public PropertiesPanel() {
this.setLayout(new BoxLayout(this, BoxLayout.X_AXIS));
this.absoluteLocationTextField.setBackground(Color.white);
this.absoluteLocationTextField.setBorder(
BorderFactory.createEtchedBorder());
this.absoluteLocationTextField.setEditable(false);
this.relativeLocationTextField.setBackground(Color.white);
this.relativeLocationTextField.setBorder(
BorderFactory.createEtchedBorder());
this.relativeLocationTextField.setEditable(false);
this.featureIDTextField.setBackground(Color.white);
this.featureIDTextField.setBorder(BorderFactory.createEtchedBorder());
this.featureIDTextField.setEditable(false);
this.add(featureIDLabel);
this.add(featureIDTextField);
this.add(absoluteLocationLabel);
this.add(absoluteLocationTextField);
this.add(relativeLocationLabel);
this.add(relativeLocationTextField);
}
public void setAbsoluteLocation(int startLocation, int stopLocation) {
if (startLoc != -1) {
int absoluteOffset = startLoc;
int blockOffset =
SequencePanel.this.currentBlock
if (strand == 1) {
startLocation =
startLocation
- (startLocation / 12) * 2
+ blockOffset
+ absoluteOffset;
stopLocation =
stopLocation
- (stopLocation / 12) * 2
+ blockOffset
+ absoluteOffset
- 1;
if (startLocation > stopLocation) {
startLocation--;
stopLocation++;
}
}
else if (strand == -1) {
startLocation =
endLoc - (startLocation - (startLocation / 12) * 2 + blockOffset);
stopLocation =
endLoc - (stopLocation - (stopLocation / 12) * 2 + blockOffset);
if (startLocation > stopLocation) {
stopLocation++;
}
else if (startLocation < stopLocation) {
startLocation++;
}
}
this.absoluteLocationTextField.setText(
String.valueOf(startLocation + " to " + stopLocation));
}
}
public void setAbsoluteLocation(int location) {
if (startLoc != -1) {
int blockOffset =
SequencePanel.this.currentBlock
location = location - (location / 12) * 2 + blockOffset;
if (strand == 1) {
this.absoluteLocationTextField.setText(
String.valueOf(location + startLoc - 1));
}
else if (strand == -1) {
this.absoluteLocationTextField.setText(
String.valueOf(endLoc - location));
}
}
}
public void setRelativeLocation(int startLocation, int stopLocation) {
int blockOffset =
SequencePanel.this.currentBlock
startLocation =
startLocation - (startLocation / 12) * 2 + 1 + blockOffset;
stopLocation = stopLocation - (stopLocation / 12) * 2 + blockOffset;
this.relativeLocationTextField.setText(
String.valueOf(startLocation + " to " + stopLocation));
}
public void setRelativeLocation(int location) {
int blockOffset =
SequencePanel.this.currentBlock
location = location - (location / 12) * 2 + blockOffset;
this.relativeLocationTextField.setText(String.valueOf(location));
}
public void setFeatureInformation(String featureID) {
propertiesPanelImpl.featureIDTextField.setText(featureID);
}
}
class ColumnHeader extends JToolBar implements ActionListener {
SockeyeButton b_copy =
new SockeyeButton(
Configuration.copy_icon,
"Copy selected sequence to clipboard");
SockeyeButton b_export =
new SockeyeButton(
Configuration.export_icon,
"Export selected sequence to File");
SockeyeButton b_save =
new SockeyeButton(
Configuration.save_icon,
"Save entire Sequence to File");
SockeyeButton b_back =
new SockeyeButton(
Configuration.back_icon,
"Scroll Back towards sequence beginning");
SockeyeButton b_forward =
new SockeyeButton(
Configuration.forward_icon,
"Scroll Forward towards sequence end");
FastaTextField fasta_header = new FastaTextField();
LocationTextField tf_location = new LocationTextField();
public ColumnHeader() {
super("Sequence Toolbar", JToolBar.HORIZONTAL);
this.setBorder(BorderFactory.createRaisedBevelBorder());
this.setLayout(new BoxLayout(this, BoxLayout.X_AXIS));
this.setAlignmentY(JComponent.CENTER_ALIGNMENT);
b_copy.addActionListener(this);
b_copy.setActionCommand("Copy");
b_export.addActionListener(this);
b_export.setActionCommand("Export");
b_save.addActionListener(this);
b_save.setActionCommand("Save");
b_back.addActionListener(this);
b_back.setActionCommand("Backward");
b_forward.addActionListener(this);
b_forward.setActionCommand("Forward");
this.add(b_export);
this.add(b_copy);
this.addSeparator();
this.add(new JLabel(" FASTA Header >"));
this.add(fasta_header);
this.add(b_back);
this.add(b_forward);
this.add(tf_location);
}
protected void setFastaHeaderText(String fastaHeaderText) {
this.fasta_header.setText(fastaHeaderText);
}
protected String getText() {
return (">" + fasta_header.getText() + "\n");
}
class LocationTextField extends JTextField {
public LocationTextField() {
super(6);
super.setHorizontalAlignment(JTextField.CENTER);
super.setEditable(false);
}
public Dimension getMaximumSize() {
int width = (int) super.getPreferredSize().getWidth();
int height = (int) super.getMaximumSize().getHeight();
return new Dimension(width, height);
}
}
protected void setLocationText() {
this.tf_location.setText(
(SequencePanel.this.currentBlock + 1)
+ " of "
+ (SequencePanel.this.num_of_blocks + 1));
}
protected void disableAll() {
this.b_copy.setEnabled(false);
this.b_export.setEnabled(false);
this.b_save.setEnabled(false);
this.b_back.setEnabled(false);
this.b_forward.setEnabled(false);
}
protected void enableAll() {
this.b_copy.setEnabled(true);
this.b_export.setEnabled(true);
this.b_save.setEnabled(true);
this.b_back.setEnabled(true);
this.b_forward.setEnabled(true);
}
class FastaTextField extends JTextField {
public FastaTextField() {
super();
this.setHorizontalAlignment(JTextField.LEFT);
this.setEditable(true);
this.setToolTipText(
"Enter the FASTA Header you want to appear in exported Fasta File");
}
public Dimension getMaximumSize() {
int width = (int) super.getMaximumSize().getWidth();
int height = (int) super.getPreferredSize().getHeight();
return new Dimension(width, height);
}
}
public void actionPerformed(ActionEvent evt) {
SockeyeFileChooser myFileChooser =
(SockeyeFileChooser) SockeyeFileChooser.getSockeyeFileChooser("SequencePanel");
String export_text;
if (evt.getActionCommand().equals("Forward")) {
if (SequencePanel.this.currentBlock
< SequencePanel.this.num_of_blocks) {
SequencePanel.this.ta_seq.setText(null);
SequencePanel.this.currentBlock++;
SequencePanel.this.currentBlockRowCount =
(SequencePanel
.this
.text_blocks[SequencePanel
.this
.currentBlock]
.length()
+ SequencePanel.this.CHARS_PER_LINE
- 1)
/ SequencePanel.this.CHARS_PER_LINE;
SequencePanel.this.ta_seq.setText(
formatText(
SequencePanel.this.text_blocks[SequencePanel.this.currentBlock]));
SequencePanel.this.rowTable.updateValues();
this.setLocationText();
SequencePanel.this.sequenceSlider.setValue(
SequencePanel.this.currentBlock);
}
}
if (evt.getActionCommand().equals("Backward")) {
if (SequencePanel.this.currentBlock > 0) {
SequencePanel.this.ta_seq.setText(null);
SequencePanel.this.currentBlock--;
SequencePanel.this.currentBlockRowCount =
(SequencePanel
.this
.text_blocks[SequencePanel
.this
.currentBlock]
.length()
+ SequencePanel.this.CHARS_PER_LINE
- 1)
/ SequencePanel.this.CHARS_PER_LINE;
SequencePanel.this.ta_seq.setText(
formatText(
SequencePanel.this.text_blocks[SequencePanel.this.currentBlock]));
SequencePanel.this.rowTable.updateValues();
this.setLocationText();
SequencePanel.this.sequenceSlider.setValue(
SequencePanel.this.currentBlock);
}
}
b_copy.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
saveToClipboard();
}
});
if (evt.getActionCommand().equals("Export")) {
saveToFile("Fasta");
}
}
}
class RowLabel extends JTextArea {
public RowLabel() {
this.setBackground(Color.lightGray);
this.setFont(SequencePanel.TEXTAREA_FONT);
this.setEnabled(false);
setLineWrap(false);
this.setDisabledTextColor(Color.black);
setDragEnabled(false);
}
public Dimension getPreferredSize() {
return new Dimension(70, (currentBlockRowCount + 1) * 17);
}
public void updateValues() {
String text = "";
int blockOffset =
SequencePanel.this.currentBlock
for (int index = 0; index < currentBlockRowCount; index++) {
text += (index * 100 + 1 + blockOffset) + "\n";
}
this.setText(text);
}
public boolean isEditable() {
return false;
}
}
class TextFormatter {
final int DELAY = 500;
final int PROGRESS_DISPLAY_DELAY = 100;
String sequence;
String fastaHeader;
File outputFile;
volatile boolean cancelled = false;
volatile boolean finished = false;
StringBuffer sequenceBuffer;
Activity activity;
javax.swing.ProgressMonitor progressMonitor;
ActivityMonitor activityMonitor;
javax.swing.Timer timer;
public void setSequence(String sequence) {
this.sequence = sequence;
}
public void setOutputFile(File outputFile) {
this.outputFile = outputFile;
}
public void setFastaHeader(String fastaHeader) {
this.fastaHeader = fastaHeader;
}
public void start() {
this.progressMonitor =
new javax.swing.ProgressMonitor(null, "Saving Sequence:", "", 0, 100);
this.progressMonitor.setMillisToDecideToPopup(PROGRESS_DISPLAY_DELAY);
this.progressMonitor.setMillisToPopup(PROGRESS_DISPLAY_DELAY);
this.activity = new Activity();
this.activity.start();
this.activityMonitor = new ActivityMonitor();
this.timer = new Timer(DELAY, this.activityMonitor);
this.timer.start();
}
class Activity extends Thread {
int formatBlock = 100000;
int numOfBlocks = sequence.length() / formatBlock;
int progress = 0;
FileWriter fwrite;
String formattedTextBlock;
public void run() {
try {
SequencePanel.this.columnHeader.disableAll();
fwrite = new FileWriter(TextFormatter.this.outputFile);
fwrite.write(TextFormatter.this.fastaHeader + "\n");
for (int i = 0;
(i < numOfBlocks) && (!TextFormatter.this.cancelled);
i++) {
if (i < numOfBlocks - 1) {
formattedTextBlock =
fastaFormat(
TextFormatter.this.sequence.substring(
(i * formatBlock),
((i + 1) * formatBlock)),
SequencePanel.this.CHARS_PER_LINE);
fwrite.write(formattedTextBlock);
}
else {
formattedTextBlock =
fastaFormat(
TextFormatter.this.sequence.substring(
((numOfBlocks - 1) * formatBlock),
sequence.length()),
SequencePanel.this.CHARS_PER_LINE);
fwrite.write(formattedTextBlock);
}
this.progress = ((i + 1) * 100) / numOfBlocks;
}
fwrite.close();
SequencePanel.this.columnHeader.enableAll();
TextFormatter.this.finished = true;
}
catch (FileNotFoundException exc) {
exc.printStackTrace();
}
catch (IOException exc) {
exc.printStackTrace();
}
}
String fastaFormat(String sequence, int charsPerLine) {
int insertLocal = charsPerLine;
StringBuffer seq_buffer = new StringBuffer(sequence);
for (int i = 1; i <= (sequence.length() / charsPerLine); i++) {
seq_buffer.insert(insertLocal, "\n");
insertLocal += (charsPerLine + 1);
}
return sequence = seq_buffer.toString();
}
public int getProgress() {
return this.progress;
}
}
class ActivityMonitor implements ActionListener {
public void actionPerformed(ActionEvent evt) {
int progress = TextFormatter.this.activity.getProgress();
TextFormatter.this.progressMonitor.setProgress(progress);
if (TextFormatter.this.progressMonitor.isCanceled()
|| TextFormatter.this.finished) {
TextFormatter.this.cancelled = true;
TextFormatter.this.progressMonitor.close();
TextFormatter.this.cancelled = false;
TextFormatter.this.finished = false;
TextFormatter.this.timer.stop();
}
}
}
}
}
package ca.bcgsc.sockeye.gui;
import java.awt.Dimension;
import java.awt.Frame;
import java.awt.Toolkit;
import java.util.List;
import javax.swing.JPopupMenu;
import javax.swing.ToolTipManager;
import javax.swing.UIManager;
import javax.swing.UnsupportedLookAndFeelException;
import javax.swing.plaf.metal.MetalLookAndFeel;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.parser.ParserManager;
import ca.bcgsc.sockeye.service.featureloader.common.ConnectionManager;
import ca.bcgsc.sockeye.util.Log;
public class Sockeye {
private boolean packFrame = false;
public static MainFrame __frame;
private static Frame splash_screen;
private static SplashScreen splash;
public Sockeye() {
Configuration.initUI();
ConnectionManager.initialize();
ParserManager.initialize();
__frame = new MainFrame();
if (packFrame) {
__frame.pack();
} else {
__frame.validate();
}
Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
Dimension frameSize = __frame.getSize();
if (frameSize.height > screenSize.height) {
frameSize.height = screenSize.height;
}
if (frameSize.width > screenSize.width) {
frameSize.width = screenSize.width;
}
__frame.setLocation((screenSize.width - frameSize.width) / 2,
(screenSize.height - frameSize.height) / 2);
splash.setFinishLoadingTrue();
__frame.setVisible(true);
}
public void manualLoadEnsemblTrack(String db, String chrom, int start,
int end, List features) {
__frame.manualLoadEnsemblTrack(db, chrom, start, end);
if (features != null)
__frame.manualSetFeatureVisibility(features);
}
public void parseCommandLineParameters(String[] cmdl) {
if (cmdl.length == 0)
return;
String db = null;
String crom = null;
String flist = null;
int conn = 0;
int start = -1;
int end = -1;
try {
for (int i = 0; i < cmdl.length; i++) {
if (cmdl[i].startsWith("-database")) {
db = cmdl[i].substring("-database".length()).trim();
if (db.length() == 0 && i < cmdl.length - 1)
db = cmdl[++i];
continue;
}
if (cmdl[i].startsWith("-chromosome")) {
crom = cmdl[i].substring("-chromosome".length()).trim();
if (crom.length() == 0 && i < cmdl.length - 1)
crom = cmdl[++i];
continue;
}
if (cmdl[i].startsWith("-start")) {
String number = cmdl[i].substring("-start".length()).trim();
if (number.length() == 0 && i < cmdl.length - 1)
number = cmdl[++i];
start = Integer.parseInt(number);
continue;
}
if (cmdl[i].startsWith("-end")) {
String number = cmdl[i].substring("-end".length()).trim();
if (number.length() == 0 && i < cmdl.length - 1)
number = cmdl[++i];
end = Integer.parseInt(number);
continue;
}
if (cmdl[i].startsWith("-features")) {
flist = cmdl[i].substring("-features".length()).trim();
if (flist.length() == 0 && i < cmdl.length - 1)
flist = cmdl[++i];
continue;
}
if (cmdl[i].startsWith("-connection")) {
flist = cmdl[i].substring("-connection".length()).trim();
if (flist.length() == 0 && i < cmdl.length - 1)
conn = Integer.parseInt(cmdl[++i]);
continue;
}
}
} catch (Throwable e) {
Log
.println("Format error when parsing command line string, ignoring command line!");
Log.printStackTrace(e);
}
Log.println("Loading track from command line: \n" + " database..: "
+ db + "\n" + " chromosome: " + crom + "\n" + " start.....: "
+ start + "\n" + " end.......: " + end + "\n"
+ " conn.......: " + conn);
if (db == null || crom == null || start < 0 || end < 0) {
Log
.println("Insufficient command line parameters to load track, ignoring command line");
return;
}
List visibleFeatures = null;
if (flist != null && flist.length() > 0) {
String[] features = flist.split(",");
visibleFeatures = java.util.Arrays.asList(features);
}
ConnectionManager.setCurrentConnectionByIndex(conn);
manualLoadEnsemblTrack(db, crom, start, end, visibleFeatures);
}
public static void main(String[] args) {
JPopupMenu.setDefaultLightWeightPopupEnabled(false);
ToolTipManager.sharedInstance().setLightWeightPopupEnabled(false);
try {
Configuration.quick_read();
} catch (ExceptionInInitializerError e) {
e.printStackTrace();
return;
}
String splash_image = Configuration.getSplashImage();
splash = new SplashScreen(splash_image, splash_screen, 4000);
String os = (String) System.getProperty("os.name");
if ((os != null)
&& (os.startsWith("Windows") || os.startsWith("LINUX"))) {
try {
if (Configuration.getLookAndFeel().equals("metouia"))
UIManager
.setLookAndFeel(new net.sourceforge.mlf.metouia.MetouiaLookAndFeel());
else if (Configuration.getLookAndFeel().equals("kunststoff"))
UIManager
.setLookAndFeel(new com.incors.plaf.kunststoff.KunststoffLookAndFeel());
else
UIManager.setLookAndFeel(new MetalLookAndFeel());
} catch (UnsupportedLookAndFeelException ex) {
}
}
MemoryUsage memory_usage = new MemoryUsage(30000);
memory_usage.start();
Sockeye sockeye = new Sockeye();
sockeye.parseCommandLineParameters(args);
}
}/*------
package ca.bcgsc.sockeye.gui;
import java.awt.Color;
import java.awt.Frame;
import java.awt.Image;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.io.File;
import java.util.ArrayList;
import java.util.List;
import javax.help.CSH;
import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JDialog;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JSlider;
import javax.swing.KeyStroke;
import javax.swing.SwingUtilities;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.datastorage.SockeyeTrackList;
import ca.bcgsc.sockeye.datastorage.events.StorageEvent;
import ca.bcgsc.sockeye.datastorage.events.StorageEventListener;
import ca.bcgsc.sockeye.gui.exportimagedialog.ExportImageDialog;
import ca.bcgsc.sockeye.gui.navigation.FeaturePanel;
import ca.bcgsc.sockeye.gui.optionsdialog.OptionsDialog;
import ca.bcgsc.sockeye.gui.retrievaldialog.RetrievalWizard;
import ca.bcgsc.sockeye.gui.session.NewSessionDialog;
import ca.bcgsc.sockeye.gui.session.OpenSessionDialog;
import ca.bcgsc.sockeye.gui.session.SessionManager;
import ca.bcgsc.sockeye.gui.setoperationdialog.SetOperationDialog;
import ca.bcgsc.sockeye.popup.BrowserLauncher;
import ca.bcgsc.sockeye.popup.PopupMenuURL;
import ca.bcgsc.sockeye.util.Log;
import ca.bcgsc.util.gui.scomponents.SockeyeButton;
public class SockeyeMenubar extends JMenuBar implements StorageEventListener {
private Frame parent;
private JMenu m_session = new JMenu("Sessions");
private JMenuItem mi_new = new JMenuItem("New");
private JMenuItem mi_open = new JMenuItem("Open");
private JMenuItem mi_save = new JMenuItem("Save");
private JMenuItem mi_save_as = new JMenuItem("Save as...");
private JMenuItem mi_rename = new JMenuItem("Rename...");
private JMenuItem mi_close = new JMenuItem("Close");
private JMenuItem mi_exit = new JMenuItem("Exit");
private JMenu m_data = new JMenu("Data");
private JMenuItem mi_query_ensembl =
new JMenuItem("Query Database / Import Data...");
private JMenuItem mi_print3D = new JMenuItem("Export 3D image to JPG...");
private JMenu m_edit = new JMenu("Edit");
private JMenuItem mi_options = new JMenuItem("Options...");
private static JMenu m_view = new JMenu("View");
private JCheckBoxMenuItem mi_enable_horiz_rotation =
new JCheckBoxMenuItem("Enable Horizontal Rotation");
private JCheckBoxMenuItem mi_enable_vert_rotation =
new JCheckBoxMenuItem("Enable Vertical Rotation");
private JMenuItem mi_setview =
new JMenuItem("Set View Relative to Platform...");
private JMenuItem mi_saveview = new JMenuItem("Save Current View...");
private JMenuItem mi_qv_top = new JMenuItem("Top View");
private JMenuItem mi_qv_top45 = new JMenuItem("45 Degree Angle View");
private JMenuItem mi_qv_34start = new JMenuItem("Three-Quarter View: Start");
private JMenuItem mi_qv_34end = new JMenuItem("Three-Quarter View: End");
private JMenuItem mi_qv_endonstart = new JMenuItem("End-on View: Start");
private JMenuItem mi_qv_endonend = new JMenuItem("End-on View: End");
private JMenu m_tools = new JMenu("Tools");
private JMenuItem mi_soi = new JMenuItem("Set-Operation Dialog");
private JMenuItem mi_report_bug = new JMenuItem("Suggestion/problem...");
private JMenu m_help = new JMenu("Help");
private JMenuItem mi_about = new JMenuItem("About");
private JMenuItem mi_cont_help = new JMenuItem("Contents...");
private JMenuItem mi_ask_us_question = new JMenuItem("Ask us question...");
private JMenuItem mi_show_tutorial = new JMenuItem("Show tutorial...");
SockeyeButton b_help = new SockeyeButton(Configuration.whatsthis_icon);
RetrievalWizard query_dialog = null;
SetOperationDialog sod =
new SetOperationDialog(
Sockeye.__frame,
DataStoreUser.getInstance().getSockeyeTrackList());
private static ArrayList user_views = new ArrayList();
public SockeyeMenubar(Frame parent) {
this.parent = parent;
jbInit();
initHelp();
}
private void jbInit() {
mi_close.setEnabled(false);
mi_save.setEnabled(false);
mi_save_as.setEnabled(false);
mi_rename.setEnabled(false);
mi_about.setEnabled(true);
mi_cont_help.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
try {
BrowserLauncher.openURL(
"http:
} catch (Throwable t) {
t.printStackTrace();
}
}
});
mi_ask_us_question.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
new AskUsQuestionDialog(Sockeye.__frame);
}
});
mi_show_tutorial.addActionListener(
new PopupMenuURL(Configuration.getTutorial()));
mi_soi.setAccelerator(KeyStroke.getKeyStroke("F5"));
mi_soi.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
if (!sod.isVisible()) {
sod.pack();
sod.setLocationRelativeTo(null);
}
sod.show();
}
});
mi_enable_horiz_rotation.setSelected(true);
mi_enable_horiz_rotation
.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
mi_enable_horiz_rotation_actionPerformed(e);
}
});
mi_enable_vert_rotation.setSelected(true);
mi_enable_vert_rotation
.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
mi_enable_vert_rotation_actionPerformed(e);
}
});
mi_setview.setEnabled(true);
mi_saveview.setEnabled(true);
mi_qv_top.addActionListener(new SockeyeMenubar_mi_qv_ActionListener("top"));
mi_qv_top45.addActionListener(
new SockeyeMenubar_mi_qv_ActionListener("top45"));
mi_qv_34start.addActionListener(
new SockeyeMenubar_mi_qv_ActionListener("34start"));
mi_qv_34end.addActionListener(
new SockeyeMenubar_mi_qv_ActionListener("34end"));
mi_qv_endonstart.addActionListener(
new SockeyeMenubar_mi_qv_ActionListener("endonstart"));
mi_qv_endonend.addActionListener(
new SockeyeMenubar_mi_qv_ActionListener("endonend"));
this.add(m_session);
this.add(m_data);
this.add(m_edit);
this.add(m_view);
this.add(m_tools);
this.add(m_help);
m_session.add(mi_new);
m_session.add(mi_open);
m_session.add(mi_save);
m_session.add(mi_save_as);
m_session.add(mi_rename);
m_session.add(mi_close);
m_session.addSeparator();
m_session.add(mi_exit);
m_edit.add(mi_options);
m_data.add(mi_query_ensembl);
m_data.addSeparator();
m_data.add(mi_print3D);
m_tools.add(mi_soi);
m_tools.add(mi_report_bug);
m_help.add(mi_about);
m_help.addSeparator();
m_help.add(mi_cont_help);
m_help.add(mi_ask_us_question);
m_help.add(mi_show_tutorial);
m_view.add(mi_enable_horiz_rotation);
m_view.add(mi_enable_vert_rotation);
m_view.addSeparator();
m_view.add(mi_setview);
m_view.addSeparator();
m_view.add(mi_saveview);
m_view.addSeparator();
m_view.add(mi_qv_top);
m_view.add(mi_qv_top45);
m_view.add(mi_qv_34start);
m_view.add(mi_qv_34end);
m_view.add(mi_qv_endonstart);
m_view.add(mi_qv_endonend);
m_view.addSeparator();
mi_new.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
mi_new_actionPerformed(e);
}
});
mi_query_ensembl.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
mi_query_ensembl_actionPerformed(e);
}
});
mi_options.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
mi_options_actionPerformed(e);
}
});
mi_exit.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
mi_exit_actionPerformed(e);
}
});
mi_print3D.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
mi_print3D_actionPerformed(e);
}
});
mi_about.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
mi_about_actionPerformed(e);
}
});
mi_report_bug.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
mi_report_bug_actionPerformed(e);
}
});
mi_save.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
mi_save_actionPerformed(e, false);
}
});
mi_save_as.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
mi_save_as_actionPerformed(e);
}
});
mi_rename.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
mi_rename_actionPerformed(e);
}
});
mi_open.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
mi_open_actionPerformed(e);
}
});
mi_close.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
mi_close_actionPerformed(e, true);
}
});
mi_setview.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
mi_setview_actionPerformed(e);
}
});
mi_saveview.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
mi_saveview_actionPerformed(e);
}
});
}
public void storageEventReceived(StorageEvent e) {
if (e.getEventType() == StorageEvent.STORAGE_EVENT_TRACK_ADD
|| e.getEventType() == StorageEvent.STORAGE_EVENT_TRACK_REMOVE) {
if (DataStoreUser.getInstance().getSockeyeTrackList().getTrackCount()
== 0) {
mi_save.setEnabled(false);
mi_save_as.setEnabled(false);
} else {
mi_save.setEnabled(true);
mi_save_as.setEnabled(true);
}
}
}
void mi_query_ensembl_actionPerformed(ActionEvent e) {
if (query_dialog == null)
query_dialog = new RetrievalWizard(Sockeye.__frame);
query_dialog.setVisible(true);
}
void mi_close_actionPerformed(ActionEvent e, boolean ask_about_saving) {
if ((SessionManager.getInstance() != null
&& SessionManager.getInstance().isNewDataAdded())
|| (DataStoreUser.getInstance().getSockeyeTrackList().getTrackCount()
!= 0)) {
if (ask_about_saving)
saveCurrentData(e, true, false);
}
if (SessionManager.getInstance() != null)
SessionManager.getInstance().closeSession();
else {
DataStoreUser.getInstance().getSockeyeTrackList().removeallTracks();
}
resetMenuBar();
}
void mi_save_actionPerformed(ActionEvent e, boolean close) {
if (SessionManager.getInstance() == null) {
int option =
NewSessionDialog.show(
Sockeye.__frame,
"Save data to a new session",
"Save to...",
true,
false);
if (option == NewSessionDialog.__CREATE_OPTION)
mi_close.setEnabled(true);
else
mi_close.setEnabled(false);
} else {
try {
SessionManager.getInstance().saveSession(close, false);
} catch (Exception ex) {
ex.printStackTrace();
Log.printStackTrace(ex);
}
}
mi_rename.setEnabled(true);
}
void mi_save_as_actionPerformed(ActionEvent e) {
int option =
NewSessionDialog.show(
Sockeye.__frame,
"Save data to a new session",
"Save to...",
true,
false);
if (option == NewSessionDialog.__CREATE_OPTION)
mi_close.setEnabled(true);
else
mi_close.setEnabled(false);
mi_rename.setEnabled(true);
}
void mi_rename_actionPerformed(ActionEvent e) {
String name =
JOptionPane.showInputDialog(
Sockeye.__frame,
"Input new name",
"Rename the session ",
JOptionPane.OK_CANCEL_OPTION);
if (name != null) {
if (name.length() != 0) {
try {
SessionManager.getInstance().setNewName(name);
} catch (Exception ex) {
JOptionPane.showMessageDialog(
Sockeye.__frame,
"Error occurs to set new session name./n" + ex.getMessage(),
"Unable to save session name",
JOptionPane.ERROR_MESSAGE);
}
}
}
}
void resetMenuBar() {
mi_close.setEnabled(false);
mi_open.setEnabled(true);
mi_new.setEnabled(true);
mi_rename.setEnabled(false);
}
boolean saveCurrentData(
ActionEvent e,
boolean ask_about_saving,
boolean clear) {
String title = "Do you want to save changes in this session?";
boolean new_session = false;
if (DataStoreUser.getInstance().getSockeyeTrackList().getTrackCount()
!= 0) {
if (SessionManager.getInstance() == null) {
title = "Do you want to save current data to a new session?";
new_session = true;
} else if (!SessionManager.getInstance().isNewDataAdded())
return true;
int save = -1;
if (ask_about_saving)
save =
JOptionPane.showConfirmDialog(
Sockeye.__frame,
title,
"Confirmation",
JOptionPane.YES_NO_OPTION);
else
save = 0;
if (save == 0) {
if (new_session)
createNewSession("Save data to new session", "Save data...", clear);
if (SessionManager.getInstance() != null)
mi_save_actionPerformed(e, false);
} else if (SessionManager.getInstance() != null)
SessionManager.getInstance().closeSession();
}
return true;
}
void loadSessionFromJar(){
if (SessionManager.getInstance() != null) {
if (SessionManager.getInstance().isNewDataAdded()) {
saveCurrentData(null, true, true);
}
} else if (
DataStoreUser.getInstance().getSockeyeTrackList().getTrackCount() != 0)
saveCurrentData(null, true, false);
try {
SessionManager.resetConfig(
"resources"
+ Configuration.SEP
+ "sessions"
+ Configuration.SEP
+ "TestSession.sks");
if (SessionManager.getInstance() != null) {
DataStoreUser.getInstance().getSockeyeTrackList().addStorageListener(
SessionManager.getInstance());
mi_save.setEnabled(true);
mi_save_as.setEnabled(true);
mi_rename.setEnabled(true);
mi_close.setEnabled(true);
mi_open.setEnabled(true);
mi_new.setEnabled(true);
}
} catch (Exception es) {
es.printStackTrace();
Log.printStackTrace(es);
}
}
void mi_open_actionPerformed(ActionEvent e) {
if (SessionManager.getInstance() != null) {
if (SessionManager.getInstance().isNewDataAdded()) {
saveCurrentData(e, true, true);
}
} else if (
DataStoreUser.getInstance().getSockeyeTrackList().getTrackCount() != 0)
saveCurrentData(e, true, false);
OpenSessionDialog fc =
new OpenSessionDialog(
Configuration.USER_DIR
+ Configuration.SEP
+ SessionManager.__SESSION_FOLDER
+ Configuration.SEP);
if (fc.showOpenDialog(Sockeye.__frame) == JFileChooser.APPROVE_OPTION) {
mi_close_actionPerformed(e, false);
try {
SessionManager.resetConfig(
fc.getSelectedFile(),
false,
FeaturePanel.getTree());
if (SessionManager.getInstance() != null) {
DataStoreUser.getInstance().getSockeyeTrackList().addStorageListener(
SessionManager.getInstance());
mi_save.setEnabled(true);
mi_save_as.setEnabled(true);
mi_rename.setEnabled(true);
mi_close.setEnabled(true);
mi_open.setEnabled(true);
mi_new.setEnabled(true);
}
} catch (Exception es) {
es.printStackTrace();
Log.printStackTrace(es);
}
}
}
void mi_enable_horiz_rotation_actionPerformed(ActionEvent e) {
MainFrame.getVis3D().setZAxisRotationEnable(
mi_enable_horiz_rotation.isSelected());
}
public void registerNewStorageManager(SockeyeTrackList stl) {
sod.registerNewStorageManager(stl);
}
void mi_enable_vert_rotation_actionPerformed(ActionEvent e) {
MainFrame.getVis3D().setXAxisRotationEnable(
mi_enable_vert_rotation.isSelected());
}
void mi_options_actionPerformed(ActionEvent e) {
OptionsDialog opt_dlg = new OptionsDialog(Sockeye.__frame);
}
void mi_import_alignment_actionPerformed(ActionEvent e) {
new ImportAlignmentPanel(Sockeye.__frame, Configuration.getGFFPath());
}
void mi_setview_actionPerformed(ActionEvent e) {
SetViewDialog setViewDialog = new SetViewDialog(Sockeye.__frame);
}
void mi_saveview_actionPerformed(ActionEvent e) {
CreateViewDialog createViewDialog = new CreateViewDialog(Sockeye.__frame);
}
void mi_exit_actionPerformed(ActionEvent e) {
if (SessionManager.getInstance() != null) {
if (SessionManager.getInstance().isNewDataAdded()) {
exit(e, true);
} else
exit(e, false);
} else if (
DataStoreUser.getInstance().getSockeyeTrackList().getTrackCount() != 0)
exit(e, true);
else
exit(e, false);
}
void exit(ActionEvent e, boolean save_data) {
if (save_data) {
int confirm =
JOptionPane.showConfirmDialog(
Sockeye.__frame,
"Do you want to save any changes before exit?",
"Confirmation",
JOptionPane.YES_NO_CANCEL_OPTION);
if (confirm == JOptionPane.YES_OPTION) {
if (SessionManager.getInstance() == null)
saveCurrentData(e, false, true);
else
try {
SessionManager.getInstance().saveSession(true, true);
} catch (Exception es) {
es.printStackTrace();
Log.printStackTrace(es);
}
System.exit(0);
} else if (confirm == JOptionPane.NO_OPTION) {
System.exit(0);
}
} else {
int confirm =
JOptionPane.showConfirmDialog(
Sockeye.__frame,
"Exit Sockeye?",
"Confirmation",
JOptionPane.YES_NO_OPTION);
if (confirm == JOptionPane.YES_OPTION)
System.exit(0);
}
}
void mi_print3D_actionPerformed(ActionEvent e) {
ExportImageDialog export_image_dialog =
new ExportImageDialog(Configuration.USER_DIR);
int result = export_image_dialog.showSaveDialog(Sockeye.__frame);
if (result == JFileChooser.APPROVE_OPTION) {
JOptionPane.showMessageDialog(
Sockeye.__frame,
"Please leave your computer idle while the image is being taken.");
try {
Thread.sleep(1000);
} catch (InterruptedException err) {
}
File output_file = export_image_dialog.getSelectedFile();
int selected_size = export_image_dialog.getSelectedSize();
if (selected_size == ExportImageDialog.__1024x768) {
MainFrame.getVis3D().captureCanvas(1024, 768, output_file);
}
else if (selected_size == ExportImageDialog.__current_canvas) {
MainFrame.getVis3D().captureCanvas(output_file);
}
}
}
void mi_about_actionPerformed(ActionEvent e) {
MainFrame_AboutBox about_dlg = new MainFrame_AboutBox(Sockeye.__frame);
}
protected void initHelp() {
CSH.setHelpIDString(m_session, "file_menu");
CSH.setHelpIDString(m_edit, "edit_menu");
CSH.setHelpIDString(m_view, "view_menu");
CSH.setHelpIDString(m_tools, "tools_menu");
CSH.setHelpIDString(m_help, "help_menu");
CSH.setHelpIDString(this, "main_menu");
<mapID target="main_menu" url="content/work_env/menus/main_menu.html" />
<mapID target="file_menu" url="content/work_env/menus/file_menu.html" />
<mapID target="edit_menu" url="content/work_env/menus/edit_menu.html" />
<mapID target="view_menu" url="content/work_env/menus/view_menu.html" />
<mapID target="tools_menu" url="content/work_env/menus/tools_menu.html" />
<mapID target="help_menu" url="content/work_env/menus/help_menu.html" />
}
void mi_report_bug_actionPerformed(ActionEvent e) {
FeedbackDialog.show(this, "");
}
void mi_new_actionPerformed(ActionEvent e) {
if ((SessionManager.getInstance() != null
&& SessionManager.getInstance().isNewDataAdded())
|| (DataStoreUser.getInstance().getSockeyeTrackList().getTrackCount()
!= 0)) {
saveCurrentData(e, true, false);
}
createNewSession("New Sockeye session", "Create", true);
}
void createNewSession(String title, String text_button, boolean clear) {
int option =
NewSessionDialog.show(Sockeye.__frame, title, text_button, false, false);
if (option == NewSessionDialog.__CREATE_OPTION) {
mi_save.setEnabled(true);
mi_save_as.setEnabled(true);
mi_rename.setEnabled(true);
mi_close.setEnabled(true);
mi_open.setEnabled(true);
mi_new.setEnabled(true);
if (clear)
DataStoreUser.getInstance().getSockeyeTrackList().removeallTracks();
}
}
static public List getUserViews() {
return new ArrayList(user_views);
}
static public boolean addUserView(String view_name, Image thumbnail) {
if (view_name == null || view_name.length() == 0) {
JOptionPane.showMessageDialog(
Sockeye.__frame,
"Custom view must have a name.",
"Unable to save custom view",
JOptionPane.ERROR_MESSAGE);
return false;
}
for (int i = 0; i < user_views.size(); i++) {
UserView check = (UserView) user_views.get(i);
if (check.getViewName().equals(view_name)) {
JOptionPane.showMessageDialog(
Sockeye.__frame,
"There is already a custom view with that name.",
"Unable to save custom view",
JOptionPane.ERROR_MESSAGE);
return false;
}
}
UserView userview =
new UserView(view_name, MainFrame.getVis3D().getViewValues(), thumbnail);
user_views.add(userview);
m_view.add(userview.getJMenuItem());
return true;
}
static public void removeUserView(String view_name) {
UserView userview;
for (int i = 0; i < user_views.size(); i++) {
userview = (UserView) user_views.get(i);
if (userview.view_name.equals(view_name)) {
m_view.remove(userview.getJMenuItem());
user_views.remove(i);
}
}
}
static public void setToUserView(String view_name) {
UserView userview;
for (int i = 0; i < user_views.size(); i++) {
userview = (UserView) user_views.get(i);
if (userview.view_name.equals(view_name)) {
MainFrame.getVis3D().setViewValues(userview.getViewMatrix());
break;
}
}
}
}
class SockeyeMenubar_mi_qv_ActionListener
implements java.awt.event.ActionListener {
String desired_view;
SockeyeMenubar_mi_qv_ActionListener(String desired_view) {
this.desired_view = desired_view;
}
public void actionPerformed(ActionEvent e) {
if (desired_view == "top") {
MainFrame.getVis3D().setViewValues(0f, 0f, 0f, 0f, 7f);
} else if (desired_view == "34start") {
MainFrame.getVis3D().setViewValues(60f, 295f, -0.85f, -0.85f, 4.23f);
} else if (desired_view == "34end") {
MainFrame.getVis3D().setViewValues(60f, 65f, 0.5f, -0.6f, 4f);
} else if (desired_view == "top45") {
MainFrame.getVis3D().setViewValues(45f, 0f, 0f, 0f, 7f);
} else if (desired_view == "endonstart") {
MainFrame.getVis3D().setViewValues(80f, 270f, 0f, -0.3f, 4f);
} else if (desired_view == "endonend") {
MainFrame.getVis3D().setViewValues(80f, 90f, 0f, -0.3f, 4f);
}
}
}
class SockeyeMenubar_mi_userview_MouseListener implements MouseListener {
String userview_name;
SockeyeMenubar_mi_userview_MouseListener(String userview_name) {
this.userview_name = userview_name;
}
public void mouseClicked(MouseEvent mouseEvent) {
}
public void mousePressed(MouseEvent mouseEvent) {
}
public void mouseDragged(MouseEvent mouseEvent) {
}
public void mouseEntered(MouseEvent mouseEvent) {
}
public void mouseExited(MouseEvent mouseEvent) {
}
public void mouseReleased(MouseEvent mouseEvent) {
if (SwingUtilities.isLeftMouseButton(mouseEvent)) {
SockeyeMenubar.setToUserView(userview_name);
} else if (SwingUtilities.isRightMouseButton(mouseEvent)) {
String message = "Delete View \"" + userview_name + "\"?";
int response =
JOptionPane.showConfirmDialog(
Sockeye.__frame,
message,
"Delete View",
JOptionPane.YES_NO_OPTION,
JOptionPane.QUESTION_MESSAGE);
if (response == JOptionPane.YES_OPTION) {
SockeyeMenubar.removeUserView(userview_name);
}
}
}
}
class SetViewDialog extends JDialog {
private JPanel jpanel = new JPanel();
private JSlider vertAngleSlider = new JSlider();
private JLabel vertAngleLabel = new JLabel("Vertical Angle");
private JSlider horizAngleSlider = new JSlider();
private JLabel horizAngleLabel = new JLabel("Horizontal Angle");
public SetViewDialog(JFrame parent) {
super(parent, "Set View Angle Relative to Platform");
try {
jbInit();
initHelp();
} catch (Exception e) {
Log.printStackTrace(e);
}
}
void jbInit() {
this.setSize(300, 140);
this.setLocationRelativeTo(null);
int currHorizAngle = (int) MainFrame.getVis3D().getZAxisAngle();
int currVertAngle = (int) MainFrame.getVis3D().getXAxisAngle();
jpanel.setLayout(new BoxLayout(jpanel, BoxLayout.Y_AXIS));
horizAngleSlider.setMajorTickSpacing(45);
horizAngleSlider.setMinorTickSpacing(1);
horizAngleSlider.setMaximum(360);
horizAngleSlider.setMinimum(0);
horizAngleSlider.setPaintLabels(true);
horizAngleSlider.setBackground(Color.orange);
horizAngleSlider.setFont(new java.awt.Font("Dialog", 0, 5));
horizAngleSlider.setForeground(Color.darkGray);
horizAngleSlider.setBorder(BorderFactory.createEtchedBorder());
horizAngleSlider.setToolTipText(String.valueOf(currHorizAngle));
horizAngleSlider.setValue(currHorizAngle);
horizAngleSlider.setSnapToTicks(true);
horizAngleSlider.addChangeListener(new horizAngleSliderListener());
vertAngleSlider.setMajorTickSpacing(45);
vertAngleSlider.setMinorTickSpacing(1);
vertAngleSlider.setMaximum(360);
vertAngleSlider.setMinimum(0);
vertAngleSlider.setPaintLabels(true);
vertAngleSlider.setBackground(Color.orange);
vertAngleSlider.setFont(new java.awt.Font("Dialog", 0, 5));
vertAngleSlider.setForeground(Color.darkGray);
vertAngleSlider.setBorder(BorderFactory.createEtchedBorder());
vertAngleSlider.setToolTipText(String.valueOf(currVertAngle));
vertAngleSlider.setValue(currVertAngle);
vertAngleSlider.setSnapToTicks(true);
vertAngleSlider.addChangeListener(new vertAngleSliderListener());
jpanel.add(horizAngleLabel);
jpanel.add(horizAngleSlider);
jpanel.add(vertAngleLabel);
jpanel.add(vertAngleSlider);
this.getContentPane().add(jpanel);
this.show();
}
void initHelp() {
}
class vertAngleSliderListener implements ChangeListener {
public void stateChanged(ChangeEvent e) {
JSlider source = (JSlider) e.getSource();
if (!source.getValueIsAdjusting()) {
int vertAngleSlidervalue = source.getValue();
MainFrame.getVis3D().setXAxisAngle(vertAngleSlidervalue);
vertAngleSlider.setToolTipText(
String.valueOf(vertAngleSlider.getValue()));
}
}
}
class horizAngleSliderListener implements ChangeListener {
public void stateChanged(ChangeEvent e) {
JSlider source = (JSlider) e.getSource();
if (!source.getValueIsAdjusting()) {
int horizAngleSlidervalue = source.getValue();
MainFrame.getVis3D().setZAxisAngle(horizAngleSlidervalue);
horizAngleSlider.setToolTipText(
String.valueOf(horizAngleSlider.getValue()));
}
}
}
}
package ca.bcgsc.sockeye.gui;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.Frame;
import java.awt.Toolkit;
import javax.swing.JLabel;
import javax.swing.JProgressBar;
import javax.swing.JWindow;
import javax.swing.SwingUtilities;
import javax.swing.Timer;
import ca.bcgsc.sockeye.gui.util.ImageLoader;
import ca.bcgsc.sockeye.util.Log;
public class SplashScreen extends JWindow {
private volatile boolean finishLoading = false;
public SplashScreen(String filename, Frame f, int waitTime) {
super(f);
JLabel l = new JLabel(ImageLoader.quickLoadIcon(filename));
final JProgressBar waiter = new JProgressBar(0, 100);
Timer timer;
getContentPane().add(l, BorderLayout.CENTER);
getContentPane().add(waiter, BorderLayout.SOUTH);
pack();
Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
Dimension labelSize = l.getPreferredSize();
setLocation(
screenSize.width / 2 - (labelSize.width / 2),
screenSize.height / 2 - (labelSize.height / 2));
final int pause = waitTime;
final Runnable closerRunner = new Runnable() {
public void run() {
setVisible(false);
dispose();
}
};
Runnable waitRunner = new Runnable() {
public void run() {
int i = 1;
while (!finishLoading) {
try {
Thread.sleep(pause / 10);
if (i <= 10) {
waiter.setValue(i * 10);
i++;
}
if (finishLoading)
SwingUtilities.invokeAndWait(closerRunner);
}
catch (Exception e) {
Log.printStackTrace(e);
}
}
}
};
setVisible(true);
Thread splashThread = new Thread(waitRunner, "SplashThread");
splashThread.start();
}
public void setFinishLoadingTrue() {
finishLoading = true;
}
}
package ca.bcgsc.sockeye.gui;
import java.awt.Dialog;
import java.awt.Dimension;
import java.awt.Frame;
import java.awt.GraphicsConfiguration;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.text.DecimalFormat;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JDialog;
import javax.swing.JTextField;
import javax.swing.JPanel;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.text.NumberFormatter;
public class TrackReBinDialog
extends JDialog
implements DocumentListener {
private JTextField sizeValueField;
private JComboBox trackMetrics = new JComboBox();
private JButton okButton = new JButton ("OK");
private JButton cancelButton = new JButton ("Cancel");
private JPanel panel = new JPanel();
private int trackLength = -1;
private int returnBinSize = -1;
private boolean exitOK = false;
public TrackReBinDialog(Frame owner) {
super(owner, "Set new histogram bin size");
initDialog();
}
public TrackReBinDialog(Frame owner, boolean modal) {
super(owner, "Set new histogram bin size", modal);
initDialog();
}
public TrackReBinDialog(Frame owner, String title) {
super(owner, title);
initDialog();
}
public TrackReBinDialog(Frame owner, String title, boolean modal) {
super(owner, title, modal);
initDialog();
}
public TrackReBinDialog(Frame owner, String title, boolean modal, GraphicsConfiguration gc) {
super(owner, title, modal, gc);
initDialog();
}
public TrackReBinDialog(Dialog owner) {
super(owner);
initDialog();
}
public TrackReBinDialog(Dialog owner, String title) {
super(owner, title);
initDialog();
}
public TrackReBinDialog(Dialog owner, String title, boolean modal) {
super(owner, title, modal);
initDialog();
}
public TrackReBinDialog(Dialog owner, String title, boolean modal, GraphicsConfiguration gc) {
super(owner, title, modal, gc);
initDialog();
}
public void setBinSizeMetricValues(String[] s, int sel){
trackMetrics.removeAllItems();
for (int i=0; i< s.length; i++)
trackMetrics.addItem(s[i]);
trackMetrics.setSelectedIndex(sel);
}
public int getSelectedBinSizeMetric(){
return trackMetrics.getSelectedIndex();
}
public void setBinSizeValue(int v){
if (sizeValueField != null)
sizeValueField.setText(new Integer(v).toString());
}
public int getBinSizeValue(){
return returnBinSize;
}
public void setTrackLength(int t){
trackLength = t;
}
public boolean getExitOK(){
return exitOK;
}
private void initDialog(){
panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
Box buttonBox = Box.createHorizontalBox();
Box inputBox = Box.createHorizontalBox();
DecimalFormat decimalFormat = new DecimalFormat("#");
final NumberFormatter textFormatter = new NumberFormatter(decimalFormat);
textFormatter.setMinimum(new Integer(1));
textFormatter.setAllowsInvalid(true);
textFormatter.setOverwriteMode(true);
textFormatter.setCommitsOnValidEdit(true);
sizeValueField = new JTextField();
sizeValueField.setText (new Integer(2).toString());
sizeValueField.getDocument().addDocumentListener(this);
this.getRootPane().setDefaultButton(okButton);
okButton.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
int i = trackMetrics.getSelectedIndex();
int v = Integer.parseInt(sizeValueField.getText().toString());
returnBinSize = (i==0 ? v : (int)Math.ceil(trackLength/v));
exitOK = true;
dispose();
}
});
cancelButton.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
dispose();
}
});
Dimension d = sizeValueField.getPreferredSize();
d.width *= 12.0;
sizeValueField.setPreferredSize(d);
buttonBox.add(Box.createHorizontalGlue());
buttonBox.add(sizeValueField);
buttonBox.add(trackMetrics);
buttonBox.add(Box.createHorizontalGlue());
inputBox.add(Box.createHorizontalGlue());
inputBox.add(okButton);
inputBox.add(cancelButton);
inputBox.add(Box.createHorizontalGlue());
panel.add(buttonBox);
panel.add(Box.createVerticalStrut(10));
panel.add(inputBox);
panel.setBorder(BorderFactory.createEmptyBorder(30,30,30,30));
panel.doLayout();
trackMetrics.setActionCommand("tmChanged");
trackMetrics.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e){
if (trackLength == -1)
return;
int i = trackMetrics.getSelectedIndex();
int v = Integer.parseInt(sizeValueField.getText().toString());
int n = (int)Math.ceil(trackLength/v);
sizeValueField.setText(new Integer(n).toString());
}});
this.setLocationRelativeTo(null);
this.getContentPane().add(panel);
this.setDefaultCloseOperation(JDialog.HIDE_ON_CLOSE);
this.pack();
}
public void insertUpdate(DocumentEvent e) {
checkValue(e);
}
public void removeUpdate(DocumentEvent e) {
checkValue(e);
}
public void changedUpdate(DocumentEvent e) {
}
private void checkValue(DocumentEvent e) {
try {
if (Integer.parseInt(sizeValueField.getText()) < 2)
okButton.setEnabled(false);
else
okButton.setEnabled(true);
}
catch (java.lang.NumberFormatException n){
okButton.setEnabled(false);
}
}
}
package ca.bcgsc.sockeye.gui;
import java.awt.Image;
import javax.swing.ImageIcon;
import javax.swing.JMenuItem;
public class UserView {
String view_name;
float[] view_matrix;
Image thumbnail;
JMenuItem menu_item;
UserView(String view_name, float[] view_matrix, Image thumbnail) {
this.view_name = view_name;
this.thumbnail = thumbnail;
this.menu_item = new JMenuItem(view_name);
menu_item.addMouseListener(
new SockeyeMenubar_mi_userview_MouseListener(view_name));
menu_item.setIcon(new ImageIcon(thumbnail.getScaledInstance(20, -1, 0)));
this.view_matrix = view_matrix;
}
public JMenuItem getJMenuItem() {
return menu_item;
}
public float[] getViewMatrix() {
return view_matrix;
}
public Image getViewThumbnail() {
return thumbnail;
}
public String getViewName() {
return view_name;
}
}
package ca.bcgsc.sockeye.gui.alignment;
import java.awt.Color;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Shape;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;
import java.awt.geom.AffineTransform;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.ButtonGroup;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JSeparator;
import javax.swing.JSlider;
import javax.swing.SwingUtilities;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import ca.bcgsc.sockeye.analysis.Alignment;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.service.featureloader.common.DistributionContainer;
import ca.bcgsc.sockeye.trackmanager.AlignOperation;
import ca.bcgsc.sockeye.util.Log;
import ca.bcgsc.sockeye.util.StringUtils;
import ca.bcgsc.util.CoordinateUtils;
import ca.bcgsc.util.SequenceUtils;
import ca.bcgsc.util.gui.PositionLayout;
import ca.bcgsc.util.gui.scomponents.SockeyeButton;
public abstract class AlignmentGraph extends JPanel
implements AlignmentHighlightListener, WindowListener, MouseListener, MouseMotionListener {
protected List axis_sequence[] = {new ArrayList(), new ArrayList()};
protected int[] sequences;
protected List alignments;
protected AlignOperation align_op;
protected Alignment cur_align;
protected List anchors;
protected boolean gapped_mode = false;
protected boolean square_mode = false;
protected boolean anchor_mode = false;
protected float scale_x, scale_y;
protected int range_x_max, range_x_min, range_y_max, range_y_min;
protected int seq_start_x, seq_start_y, seq_end_x, seq_end_y;
protected int offset_x = 0, offset_y = 0;
protected float zoom = 1;
protected int width, height, plot_width, plot_height;
protected int margin_x = 95;
protected int margin_y = 50;
protected boolean invert_yaxis = false;
protected Point mouse_pos = new Point();
protected JLabel mouse_loc = new JLabel();
protected JMenu view_menu = new JMenu("View");
protected JSlider zoom_slider = new JSlider();
protected JLabel zoom_label = new JLabel("1x");
private HashMap pick_map = new HashMap();
Color bg_colour = Configuration.gui_blue;
Color graph_bg_colour = Color.white;
Color inactive_graph_bg_colour = Color.LIGHT_GRAY;
Color ruler_colour = Color.black;
Color aln_colour = new Color(0,0,255);
Color highlight_colour = new Color(0, 0, 255);
Color anchor_colour = Color.red;
Color gap_colour = Color.black;
Color pick_highlight_colour = new Color(0, 0, 255, 10);
private static int _FONT_WIDTH = 12;
private static Font _DEFAULT_LABEL_FONT = new Font("Dialog", Font.PLAIN, _FONT_WIDTH);
static {
if (java.lang.System.getProperty("os.name").startsWith(("Windows"))) {
}
else {
_FONT_WIDTH = 10;
_DEFAULT_LABEL_FONT = new Font("Dialog", Font.PLAIN, _FONT_WIDTH);
}
}
protected int drag_mode;
private Point drag_anchor = null;
private Point click_anchor = null;
private Rectangle zoom_select_rect = null;
protected int cur_tool = MOVE_TOOL;
static final int MOVE_TOOL = 0;
static final int ZOOM_TOOL = 1;
static final int ZOOM_MOUSE = 2;
protected Map highlight_rectangles = new HashMap();
protected Map highlight_colours = new HashMap();
static final int MAX_PIXELS_PER_BP = 40;
protected Cursor cur_cursor;
static final int XAXIS = 0;
static final int YAXIS = 1;
static final double _ZOOM_THRESHOLD = 20;
protected boolean threaded_paint_mode = false;
protected boolean do_paint = true;
protected static int FPS = 15;
static NumberFormat numberformatter = NumberFormat.getNumberInstance();
static {
numberformatter.setMaximumFractionDigits(2);
}
public AlignmentGraph(List alignments, List anchors, boolean gapped, boolean square) {
if (alignments == null || alignments.size() == 0) {
Log.println("Not opening AlignmentGraph because no alignments given.");
return;
}
this.alignments = alignments;
this.cur_align = (Alignment)alignments.get(0);
this.align_op = cur_align.getParentOperation();
this.anchors = anchors;
setLayout(new PositionLayout());
gapped_mode = gapped;
square_mode = square;
addMouseListener(this);
addMouseMotionListener(this);
sequences = cur_align.getSequenceIDs();
mouse_loc.setHorizontalAlignment(JLabel.LEFT);
add((margin_x + 5) + "," + (margin_y - 17) + ", " + (margin_x + 300) + "," + (margin_y), mouse_loc);
JMenuBar menu_bar = new JMenuBar();
menu_bar.setBorder(BorderFactory.createRaisedBevelBorder());
add("0, 0, 100%, " + 30, menu_bar);
final JMenu xaxis_menu = new JMenu("X Axis...");
ButtonGroup x_but_group = new ButtonGroup();
for (int i = 0; i < sequences.length; i++) {
String seq_name = StringUtils.getShortNameForTrackID(align_op.getSourceTrack(sequences[i]));
JRadioButtonMenuItem seq = new JRadioButtonMenuItem(seq_name, i == 0);
x_but_group.add(seq);
xaxis_menu.add(seq);
seq.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
JRadioButtonMenuItem item = (JRadioButtonMenuItem)e.getSource();
int seq_index = -1;
for (int j = 0; j < xaxis_menu.getItemCount(); j++) {
if (xaxis_menu.getItem(j) == item) {
seq_index = j;
break;
}
}
if (sequences[seq_index] == ((Integer)axis_sequence[YAXIS].get(0)).intValue()) {
JOptionPane.showMessageDialog(AlignmentGraph.this, "The same sequence is now plotted on both axes.");
}
axis_sequence[XAXIS].clear();
axis_sequence[XAXIS].add(new Integer(sequences[seq_index]));
setSequences();
}
});
}
view_menu.add(xaxis_menu);
final JMenu yaxis_menu = new JMenu("Y Axis...");
ButtonGroup y_but_group = new ButtonGroup();
for (int i = 0; i < sequences.length; i++) {
String seq_name = StringUtils.getShortNameForTrackID(align_op.getSourceTrack(sequences[i]));
JRadioButtonMenuItem seq = new JRadioButtonMenuItem(seq_name, i == 1);
y_but_group.add(seq);
yaxis_menu.add(seq);
seq.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
JRadioButtonMenuItem item = (JRadioButtonMenuItem)e.getSource();
int seq_index = -1;
for (int j = 0; j < yaxis_menu.getItemCount(); j++) {
if (yaxis_menu.getItem(j) == item) {
seq_index = j;
break;
}
}
if (sequences[seq_index] == ((Integer)axis_sequence[XAXIS].get(0)).intValue()) {
JOptionPane.showMessageDialog(AlignmentGraph.this, "The same sequence is now plotted on both axes.");
}
axis_sequence[YAXIS].clear();
axis_sequence[YAXIS].add(new Integer(sequences[seq_index]));
setSequences();
}
});
}
view_menu.add(yaxis_menu);
view_menu.setPreferredSize(new Dimension(40, 20));
view_menu.setMinimumSize(new Dimension(40, 20));
menu_bar.add(view_menu);
view_menu.add(new JSeparator());
final JCheckBoxMenuItem y_flip_box = new JCheckBoxMenuItem("Flip Y-Axis", invert_yaxis);
y_flip_box.addChangeListener(new ChangeListener() {
public void stateChanged(ChangeEvent e) {
invert_yaxis = y_flip_box.isSelected();
requestPaint();
}
});
view_menu.add(y_flip_box);
final JCheckBoxMenuItem preserve_option = new JCheckBoxMenuItem("Preserve sequence scale", square_mode);
preserve_option.addChangeListener(new ChangeListener() {
public void stateChanged(ChangeEvent e) {
square_mode = preserve_option.isSelected();
updateRange();
range_x_max++;
range_y_max++;*/
requestPaint();
}
});
view_menu.add(preserve_option);
if (anchors != null) {
final JCheckBoxMenuItem anchor_option = new JCheckBoxMenuItem("Show anchors", anchor_mode);
if (anchors.size() == 0) anchor_option.setEnabled(false);
anchor_option.addChangeListener(new ChangeListener() {
public void stateChanged(ChangeEvent e) {
anchor_mode = anchor_option.isSelected();
requestPaint();
}
});
view_menu.add(anchor_option);
}
final SockeyeButton move_button = new SockeyeButton(Configuration.movehand_icon, "Move Tool: Click and drag to position the graph area.");
final SockeyeButton zoom_button = new SockeyeButton(Configuration.mag_track_icon, "Zoom Tool: Click and drag to select an area to zoom to.");
move_button.setEnabled(false);
move_button.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
move_button.setEnabled(false);
zoom_button.setEnabled(true);
cur_tool = MOVE_TOOL;
}
});
menu_bar.add(move_button);
zoom_button.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
zoom_button.setEnabled(false);
move_button.setEnabled(true);
cur_tool = ZOOM_TOOL;
}
});
menu_bar.add(zoom_button);
menu_bar.add(new JSeparator(JSeparator.VERTICAL));
JPanel zoom_panel = new JPanel();
zoom_panel.setLayout(new BoxLayout(zoom_panel, BoxLayout.X_AXIS));
zoom_slider.setMinimum(1);
zoom_slider.setToolTipText("Adjusts the zoom level of the graph.");
zoom_slider.setMajorTickSpacing(100);
zoom_slider.setPreferredSize(new Dimension(100, 25));
zoom_slider.addChangeListener(new ChangeListener() {
public void stateChanged(ChangeEvent e) {
setZoom(zoom_slider, zoom_slider.getValue());
}
});
Font zoom_font = new Font("Arial", Font.PLAIN, 15);
JLabel neg_label = new JLabel(" - ");
if (java.lang.System.getProperty("os.name").startsWith(("Windows"))) {
neg_label.setText(" \u2013 ");
}
neg_label.setFont(zoom_font);
JLabel pos_label = new JLabel(" + ");
pos_label.setFont(zoom_font);
zoom_panel.add(new JLabel("Zoom:"));
zoom_panel.add(neg_label);
zoom_panel.add(zoom_slider);
zoom_panel.add(pos_label);
zoom_label.setPreferredSize(new Dimension(60, 20));
zoom_panel.add(zoom_label);
menu_bar.add(zoom_panel);
axis_sequence[XAXIS].add(new Integer(sequences[0]));
axis_sequence[YAXIS].add(new Integer(sequences[1]));
setSequences();
setVisible(true);
}
protected void setSequences() {
updateRange();
seq_start_x = range_x_min;
seq_start_y = range_y_min;
seq_end_x = range_x_max;
seq_end_y = range_y_max;
setZoom("setSequences", 1);
requestPaint();
}
public Point getCentre() {
Point diag_start = basePairToPixel(new Point(seq_start_x, seq_start_y));
Point diag_end = basePairToPixel(new Point(seq_end_x, seq_end_y));
int w = Math.min(plot_width, diag_end.x - diag_start.x);
int h = Math.min(plot_height, Math.abs(diag_end.y - diag_start.y));
int x_centre = Math.round(w / 2.0f) + margin_x;
int y_centre = y_coord(Math.round(h / 2.0f));
return pixelToBasePair(new Point(x_centre, y_centre));
}
public void setCentre(Point centre) {
offset_x = centre.x - range_x_min - (int)(plot_width / 2.0f / scale_x);
offset_y = centre.y - range_y_min - (int)(plot_height / 2.0f / scale_y);
}
protected void addPickableArea(int left, int top, int a_width, int a_height, Object obj) {
pick_map.put(new Rectangle(left, top, a_width, a_height), obj);
}
protected void setPickableArea(int left, int top, int width, int height, Object obj) {
if (!pick_map.containsValue(obj)) {
addPickableArea(left, top, width, height, obj);
return;
}
Rectangle rect;
List keys = new ArrayList(pick_map.keySet());
for (int i = 0; i < keys.size(); i++) {
rect = (Rectangle)keys.get(i);
if (pick_map.get(rect).equals(obj)) {
pick_map.remove(rect);
pick_map.put(new Rectangle(left, top, width, height), obj);
break;
}
}
}
protected void removePickableAreas() {
pick_map = new HashMap();
}
protected void updateRange() {
range_x_min = Integer.MAX_VALUE;
range_x_max = Integer.MIN_VALUE;
TrackFeature region;
for (Iterator itr = axis_sequence[XAXIS].iterator(); itr.hasNext();) {
region = cur_align.getSourceRegion(((Integer)itr.next()).intValue());
if (region == null) continue;
if (region.getStart() < range_x_min) range_x_min = region.getStart();
if (region.getEnd() > range_x_max) range_x_max = region.getEnd();
}
range_y_min = Integer.MAX_VALUE;
range_y_max = Integer.MIN_VALUE;
for (Iterator itr = axis_sequence[YAXIS].iterator(); itr.hasNext();) {
region = cur_align.getSourceRegion(((Integer)itr.next()).intValue());
if (region == null) continue;
if (region.getStart() < range_y_min) range_y_min = region.getStart();
if (region.getEnd() > range_y_max) range_y_max = region.getEnd();
}
}
private void updateCoordinateLabel() {
if (mouse_pos == null) {
mouse_loc.setText("");
return;
}
Point bp = ungapCoordinate(pixelToBasePair(mouse_pos));
mouse_loc.setText("(" + CoordinateUtils.getAsUnitString(bp.x, "Kb", 3) + ", " +
CoordinateUtils.getAsUnitString(bp.y, "Kb", 3) + ")");
}
private void updateSelectRect(Point anchor) {
if (zoom_select_rect != null) {
int x = (int)anchor.getX();
int y = (int)anchor.getY();
float x_diff = Math.abs(x - (int)zoom_select_rect.getCenterX());
float y_diff = Math.abs(y - (int)zoom_select_rect.getCenterY());
float radius = (float)Math.sqrt(x_diff * x_diff + y_diff * y_diff);
zoom_select_rect.setRect((int)zoom_select_rect.getCenterX() - radius, (int)zoom_select_rect.getCenterY() - radius, radius * 2, radius * 2);
}
requestPaint();
}
private void evaluateScale() {
width = getWidth();
height = getHeight();
plot_width = width - margin_x - margin_x / 2;
plot_height = height - margin_y * 2;
if (square_mode) {
int x_range = range_x_max - range_x_min;
int y_range = range_y_max - range_y_min;
if (x_range > y_range) range_y_max += x_range - y_range;
else if (y_range > x_range) range_x_max += y_range - x_range;
}
if (zoom < 1) setZoom("evaluateScale <1", 1);
else {
float zoom_limit = getMaxZoom();
if (zoom > zoom_limit) setZoom("evaluateScale >max", zoom_limit);
}
float range_length_x = range_x_max - range_x_min;
float range_length_y = range_y_max - range_y_min;
scale_x = plot_width / range_length_x * zoom;
scale_y = plot_height / range_length_y * zoom;
int x_boundary = range_x_max + 1;
int y_boundary = range_y_max + 1 ;
if (square_mode) {
scale_x = Math.min(scale_x, scale_y);
scale_y = scale_x;
if (plot_height > plot_width) {
y_boundary += (plot_height - plot_width) / scale_y;
} else if (plot_width > plot_height) {
x_boundary += (plot_width - plot_height) / scale_x;
}
}
if (range_x_min + offset_x + (int)(plot_width / scale_x) > x_boundary) {
offset_x = x_boundary - (int)(plot_width / scale_x) - range_x_min;
}
if (offset_x < 0)offset_x = 0;
if (range_y_min + offset_y + (int)(plot_height / scale_y) > y_boundary) {
offset_y = y_boundary - (int)(plot_height / scale_y) - range_y_min;
}
if (offset_y < 0)offset_y = 0;
}
protected void setZoom(Object src, float z) {
zoom = z;
zoom_label.setText(numberformatter.format(zoom) + "x");
if (src == zoom_slider) {
Point centre = getCentre();
evaluateScale();
setCentre(centre);
requestPaint();
} else {
ChangeListener[] listeners = zoom_slider.getChangeListeners();
for (int i = 0; i < listeners.length; i++) zoom_slider.removeChangeListener(listeners[i]);
zoom_slider.setMaximum((int)getMaxZoom());
zoom_slider.setValue(Math.max(1,Math.round(zoom)));
for (int i = 0; i < listeners.length; i++) zoom_slider.addChangeListener(listeners[i]);
}
}
protected void paintComponent(Graphics g) {
evaluateScale();
g.setColor(bg_colour);
g.fillRect(0, 0, width, height);
g.setFont(_DEFAULT_LABEL_FONT);
g.setColor(inactive_graph_bg_colour);
g.fillRect(margin_x, height - margin_y - plot_height, plot_width, plot_height);
updateCoordinateLabel();
g.setColor(ruler_colour);
plotLabels(g);
plotAxis(g);
g.setClip(margin_x, height - margin_y - plot_height, plot_width, plot_height);
g.setColor(graph_bg_colour);
Point start_corner = new Point(seq_start_x, seq_start_y);
Point end_corner = new Point(seq_end_x, seq_end_y);
Point diag_start = basePairToPixel(start_corner);
Point diag_end = basePairToPixel(new Point(end_corner.x + 2, end_corner.y + 2));
int a_width = diag_end.x - diag_start.x + 1;
int a_height = Math.abs(diag_end.y - diag_start.y + 1);
g.fillRect(diag_start.x, invert_yaxis ? diag_start.y : diag_start.y - a_height, a_width, a_height);
plotDiagonal(g, start_corner, end_corner);
plotAlignments(g);
if (anchor_mode) {
g.setColor(anchor_colour);
plotAnchors(g);
}
plotHighlights(g);
if (zoom_select_rect != null) {
g.setColor(Color.red);
g.drawRect(zoom_select_rect.x, zoom_select_rect.y,
zoom_select_rect.width - 1, zoom_select_rect.height - 1);
}
if (mouse_pos != null) {
Rectangle smallest = null;
int min_area = Integer.MAX_VALUE;
int r_height, r_width;
Point cursor = pixelToBasePair(mouse_pos);
for (Iterator a_itr = pick_map.keySet().iterator(); a_itr.hasNext();) {
Rectangle rect = (Rectangle)a_itr.next();
if (rect.contains(cursor)) {
if ((rect.width * rect.height) < min_area) {
smallest = rect;
min_area = rect.width * rect.height;
}
}
}
if (smallest != null) {
Point bp_corner1 = smallest.getLocation();
Point bp_corner2 = new Point((int)smallest.getMaxX(), (int)smallest.getMaxY());
Point corner1 = basePairToPixel(bp_corner1);
Point corner2 = basePairToPixel(bp_corner2);
r_width = Math.abs(corner2.x - corner1.x);
r_height = Math.abs(corner2.y - corner1.y);
g.setColor(pick_highlight_colour);
int y_adjusted = corner1.y;
if (!invert_yaxis) {
y_adjusted = corner1.y - r_height;
}
g.fill3DRect(corner1.x, y_adjusted, r_width, r_height, true);
Point top_left_corner = smallest.getLocation();
if (!invert_yaxis) top_left_corner.y += smallest.height - 1;
Point bp = ungapCoordinate(top_left_corner);
String coord_label = "(" + CoordinateUtils.getAsUnitString((int)bp.getX(), null, 3) + ", " +
CoordinateUtils.getAsUnitString((int)bp.getY(), null, 3) + ")";
int font_size = (int)(r_width / coord_label.length() * 1.5f);
if (font_size > 8) {
g.setColor(Color.BLUE);
font_size = Math.min(font_size, 16);
g.setFont(new Font("Arial", Font.BOLD, font_size));
g.drawString(coord_label, corner1.x + 5, y_adjusted - 5);
}
}
}
g.setClip(0, 0, width, height);
}
protected void plotDiagonal(Graphics g, Point start_corner, Point end_corner) {
Point diag_start = basePairToPixel(start_corner);
Point diag_end = basePairToPixel(end_corner);
g.setColor(Color.LIGHT_GRAY);
int seq1 = ((Integer)axis_sequence[XAXIS].get(0)).intValue();
int seq2 = ((Integer)axis_sequence[YAXIS].get(0)).intValue();
boolean flip_diagonal = cur_align.onNegativeStrand(seq1) ^ cur_align.onNegativeStrand(seq2);
int off_x = Math.round(scale_x) / 2;
int off_y = Math.round(scale_y) / 2 * (invert_yaxis ? -1 : 1);
if (flip_diagonal) {
g.drawLine(diag_start.x + off_x, diag_end.y - off_y, diag_end.x + off_x, diag_start.y - off_y);
} else {
g.drawLine(diag_start.x + off_x, diag_start.y - off_y, diag_end.x + off_x, diag_end.y - off_y);
}
}
protected void plotLabels(Graphics g) {
Integer seq_x = (Integer)axis_sequence[XAXIS].get(0);
Integer seq_y = (Integer)axis_sequence[YAXIS].get(0);
int coord_x_s = seq_start_x + offset_x;
int coord_y_s = seq_start_y + offset_y;
int coord_x_e = Math.min(seq_end_x, coord_x_s + Math.round(plot_width / scale_x) - 1);
int coord_y_e = Math.min(seq_end_y, coord_y_s + Math.round(plot_height / scale_y) - 1);
Point pixel_coord = basePairToPixel(new Point(coord_x_e, coord_y_e));
Point start_label_coord = ungapCoordinate(new Point(coord_x_s, coord_y_s));
Point end_label_coord = ungapCoordinate(new Point(coord_x_e, coord_y_e));
int x_diff = getBpInRange(seq_x.intValue(), coord_x_s, coord_x_e);
int y_diff = getBpInRange(seq_y.intValue(), coord_y_s, coord_y_e);
String length_x = "<" + CoordinateUtils.getAsUnitString(x_diff, null, 1) + ">";
String length_y = "<" + CoordinateUtils.getAsUnitString(y_diff, null, 1) + ">";
String scale_str_x = length_x.replaceAll("[0123456789.<>]*","");
String scale_str_y = length_y.replaceAll("[0123456789.<>]*","");
int end_x = Math.min(Math.round(pixel_coord.x + scale_x), margin_x + plot_width);
int end_y = Math.max(Math.round(pixel_coord.y - scale_y), margin_y);
int decimal = 1;
String x_label = CoordinateUtils.getAsUnitString(start_label_coord.x, scale_str_x, decimal);
int text_offset = SwingUtilities.computeStringWidth( g.getFontMetrics(), x_label) / 2;
g.drawString(x_label, margin_x - text_offset, height - margin_y + 25);
String y_label = CoordinateUtils.getAsUnitString(start_label_coord.y, scale_str_y, decimal);
text_offset = SwingUtilities.computeStringWidth( g.getFontMetrics(), y_label);
int y_coord = y_coord(0) + (invert_yaxis ? _FONT_WIDTH : 0);
g.drawString(y_label, margin_x - text_offset - 20, y_coord);
text_offset = SwingUtilities.computeStringWidth( g.getFontMetrics(), length_x);
int mid_pos = (end_x - margin_x) / 2;
int mid_label_x = margin_x + mid_pos;
if (mid_pos > text_offset) g.drawString(length_x, mid_label_x - text_offset / 2, height - margin_y + 25);
text_offset = SwingUtilities.computeStringWidth( g.getFontMetrics(), length_y);
mid_pos = Math.abs( (invert_yaxis ? end_y : height - end_y) - margin_y) / 2;
int mid_label_y = y_coord(mid_pos);
if (((invert_yaxis ? end_y : height - end_y) - margin_y) / 2 > text_offset)
drawVerticalString(g, length_y, margin_x - 20, mid_label_y + text_offset / 2);
x_label = CoordinateUtils.getAsUnitString(end_label_coord.x, scale_str_x, decimal);
text_offset = SwingUtilities.computeStringWidth( g.getFontMetrics(), x_label);
g.drawString(x_label, end_x - text_offset / 2, height - margin_y + 25);
y_label = CoordinateUtils.getAsUnitString(end_label_coord.y, scale_str_y, decimal);
text_offset = SwingUtilities.computeStringWidth( g.getFontMetrics(), y_label);
y_coord = end_y + (invert_yaxis ? 0 : _FONT_WIDTH);
g.drawString(y_label, margin_x - text_offset - 20, y_coord);
int seq_id;
String seq_name;
boolean negative;
int level = 0;
for (int x_seq = 0; x_seq < axis_sequence[XAXIS].size(); x_seq++) {
seq_id = ((Integer)axis_sequence[XAXIS].get(x_seq)).intValue();
int src_seq_id = align_op.getSourceTrack(seq_id);
seq_name = StringUtils.getShortNameForTrackID(src_seq_id);
if (alignments.size() > 1)
negative = cur_align.fromNegativeSourceStrand(seq_id);
else
negative = cur_align.onNegativeStrand(seq_id);
seq_name = (negative ? "(-) " : "(+) ") + seq_name;
text_offset = SwingUtilities.computeStringWidth( g.getFontMetrics(), seq_name);
g.drawString(seq_name, Math.max(margin_x + 20, mid_label_x - text_offset / 2)
, height - margin_y + 40 + (12 * level++));
}
level = 0;
for (int y_seq = 0; y_seq < axis_sequence[YAXIS].size(); y_seq++) {
seq_id = ((Integer)axis_sequence[YAXIS].get(y_seq)).intValue();
int src_seq_id = align_op.getSourceTrack(seq_id);
seq_name = StringUtils.getShortNameForTrackID(src_seq_id);
if (alignments.size() > 1)
negative = cur_align.fromNegativeSourceStrand(seq_id);
else
negative = cur_align.onNegativeStrand(seq_id);
seq_name = (negative ? "(-) " : "(+) ") + seq_name;
text_offset = SwingUtilities.computeStringWidth( g.getFontMetrics(), seq_name);
if (text_offset > mid_pos * 2 - 2 * _FONT_WIDTH) {
int diff = (text_offset - mid_pos) / _FONT_WIDTH * 2;
seq_name = seq_name.substring(0, Math.max(3, seq_name.length() - diff - 3)) + "...";
text_offset = SwingUtilities.computeStringWidth( g.getFontMetrics(), seq_name);
}
drawVerticalString(g, seq_name, margin_x - 40 - (_FONT_WIDTH * level++), mid_label_y + text_offset / 2);
}
}
protected abstract void plotAlignments(Graphics g);
protected abstract void pickArea(Object obj);
private void plotAxis(Graphics g) {
Shape last_clip = g.getClip();
int level = 0;
int level_height = _FONT_WIDTH;
int start_pos;
int p_start = 0, p_length = 0;
int seq1, seq2, start, end;
DistributionContainer gap_obj;
for (int x_seq = 0; x_seq < axis_sequence[XAXIS].size(); x_seq++) {
for (int y_seq = 0; y_seq < axis_sequence[YAXIS].size(); y_seq++) {
seq1 = ((Integer)axis_sequence[XAXIS].get(x_seq)).intValue();
seq2 = ((Integer)axis_sequence[YAXIS].get(y_seq)).intValue();
g.setClip(margin_x, height - margin_y, plot_width, margin_y);
if (scale_x >= 1) {
String visible_sequence = null;
start = seq_start_x + offset_x;
end = Math.min(seq_end_x, start + Math.round(plot_width / scale_x)) + 1;
if (gapped_mode) {
String full_sequence = cur_align.getSequence(seq1, true);
try {
end = Math.min(end, full_sequence.length() + seq_start_x);
visible_sequence = full_sequence.substring(start - seq_start_x, end - seq_start_x);
} catch (StringIndexOutOfBoundsException e) {
}
} else {
TrackFeature src_region = cur_align.getSourceRegion(seq1);
String full_sequence = cur_align.getInputRegionSequence(seq1);
end = Math.min(end, full_sequence.length() + src_region.getStart());
try {
visible_sequence = full_sequence.substring(start - src_region.getStart(), end - src_region.getStart());
} catch (StringIndexOutOfBoundsException e) {
}
}
if (visible_sequence != null && visible_sequence.length() > 0) {
if (cur_align.onNegativeStrand(seq1) && alignments.size() <= 1)
visible_sequence = SequenceUtils.complementSequence(visible_sequence);
int box_width = Math.round(scale_x);
char ch;
for (int pos = 0; pos < visible_sequence.length(); pos++) {
ch = visible_sequence.charAt(pos);
switch (ch) {
case 'A' : g.setColor(Color.RED); break;
case 'T' : g.setColor(Color.GREEN); break;
case 'C' : g.setColor(Color.CYAN); break;
case 'G' : g.setColor(Color.ORANGE); break;
case '-' : continue;
}
start_pos = height - margin_y + (level * level_height);
Point p_point = basePairToPixel(new Point(start + pos, 0));
p_start = p_point.x;
g.fillRect(p_start, start_pos, box_width, level_height);
if (box_width >= _FONT_WIDTH) {
g.setColor(gap_colour);
g.drawString(ch + "", p_start + box_width / 2 - 4, start_pos + level_height - 2);
}
}
}
}
if (gapped_mode) {
g.setColor(gap_colour);
List gaps_x = cur_align.getGaps(seq1);
start_pos = height - margin_y + (level * level_height);
for (int x = 0; x < gaps_x.size(); x++) {
gap_obj = (DistributionContainer)gaps_x.get(x);
start = gap_obj.getStart();
end = gap_obj.getEnd();
p_start = margin_x + (int)((start - offset_x) * scale_x);
p_length = (int)((end - start + 1) * scale_x);
if (p_length == 0) p_length = 1;
g.fillRect(p_start, start_pos, p_length, level_height);
}
}
g.setClip(0, height - margin_y - plot_height, margin_x, plot_height);
int box_height = Math.round(scale_y);
if (scale_y >= 1) {
String visible_sequence = null;
start = seq_start_y + offset_y;
end = (int)Math.min(seq_end_y, start + plot_height / scale_y) + 1;
if (gapped_mode) {
String full_sequence = cur_align.getSequence(seq2, true);
try {
end = Math.min(end, full_sequence.length() + seq_start_y);
visible_sequence = full_sequence.substring(start - seq_start_y, end - seq_start_y);
} catch (StringIndexOutOfBoundsException e) {
Log.printStackTrace(e);
}
} else {
TrackFeature src_region = cur_align.getSourceRegion(seq2);
String full_sequence = cur_align.getInputRegionSequence(seq2);
end = Math.min(end, full_sequence.length() + src_region.getStart());
try {
visible_sequence = full_sequence.substring(start - src_region.getStart(), end - src_region.getStart());
} catch (StringIndexOutOfBoundsException e) {
}
}
if (visible_sequence != null && visible_sequence.length() > 0) {
if (cur_align.onNegativeStrand(seq2) && alignments.size() <= 1) {
visible_sequence = SequenceUtils.complementSequence(visible_sequence);
}
char ch;
for (int pos = 0; pos < visible_sequence.length(); pos++) {
ch = visible_sequence.charAt(pos);
switch (ch) {
case 'A' : g.setColor(Color.RED); break;
case 'T' : g.setColor(Color.GREEN); break;
case 'C' : g.setColor(Color.CYAN); break;
case 'G' : g.setColor(Color.ORANGE); break;
case '-' : continue;
}
start_pos = margin_x - level_height * (level + 1);
Point p_point = basePairToPixel(new Point(0, start + pos));
p_start = (invert_yaxis ? p_point.y : p_point.y - box_height);
g.fillRect(start_pos, p_start,
level_height, box_height);
if (box_height > _FONT_WIDTH) {
g.setColor(gap_colour);
g.drawString(ch + "", start_pos + level_height / 2 - 4, p_start + box_height / 2 + 4);
}
}
}
}
if (gapped_mode) {
g.setColor(gap_colour);
List gaps_y = cur_align.getGaps(seq2);
start_pos = margin_x - (level * level_height);
for (int y = 0; y < gaps_y.size(); y ++) {
gap_obj = (DistributionContainer)gaps_y.get(y);
start = gap_obj.getStart();
end = gap_obj.getEnd();
p_length = (int)((end - start + 1) * scale_y);
Point p_point = basePairToPixel(new Point(0, start + cur_align.getStart(seq2)));
p_start = (invert_yaxis ? p_point.y : p_point.y - p_length);
if (p_length <= 0) p_length = 1;
g.fillRect(start_pos - level_height, p_start, level_height, p_length);
}
}
level++;
}
}
g.setClip(last_clip);
}
private void plotAnchors(Graphics g) {
if (anchors == null || anchors.size() == 0) return;
int seq1, seq2, start_x, start_y, end_x, end_y;
g.setColor(this.anchor_colour);
for (int anc_index = 0; anc_index < anchors.size(); anc_index++) {
Alignment anchor = (Alignment)anchors.get(anc_index);
for (int x_seq = 0; x_seq < axis_sequence[XAXIS].size(); x_seq++) {
for (int y_seq = 0; y_seq < axis_sequence[YAXIS].size(); y_seq++) {
seq1 = ((Integer)axis_sequence[XAXIS].get(x_seq)).intValue();
seq2 = ((Integer)axis_sequence[YAXIS].get(y_seq)).intValue();
start_x = anchor.getStartInvert(seq1);
end_x = anchor.getEndInvert(seq1);
start_y = anchor.getStartInvert(seq2);
end_y = anchor.getEndInvert(seq2);
Point pixel_start = basePairToPixel(new Point(start_x, start_y));
Point pixel_end = basePairToPixel(new Point(end_x + 1, end_y + 1));
start_x = pixel_start.x;
end_x = pixel_end.x;
start_y = pixel_start.y;
end_y = pixel_end.y;
drawThickLine(g, start_x, start_y, end_x, end_y, 4);
}
}
}
}
protected void plotHighlights(Graphics g) {
int x_index = 0, y_index = 0;
int cur_seq_x = ((Integer)axis_sequence[XAXIS].get(0)).intValue();
int cur_seq_y = ((Integer)axis_sequence[YAXIS].get(0)).intValue();
int[] seqs = ((Alignment)alignments.get(0)).getSequenceIDs();
for (int i = 0; i < seqs.length; i++) {
if (cur_seq_x == seqs[i]) x_index = i;
if (cur_seq_y == seqs[i]) y_index = i;
}
for (Iterator itr = highlight_rectangles.values().iterator(); itr.hasNext();) {
Rectangle rect_arr[][] = (Rectangle[][])itr.next();
Rectangle rect = rect_arr[x_index][y_index];
Color color = (Color)highlight_colours.get(rect_arr);
g.setColor(color);
Point corner = basePairToPixel(rect.getLocation());
int h_width = 1 + (int)(rect.width * scale_x + 0.5f);
int h_height = 1 + (int)(rect.height * scale_y + 0.5f);
corner.y = (invert_yaxis ? corner.y : corner.y - h_height);
int length = (int)Math.sqrt(h_width * h_width + h_height * h_height);
if (length < _ZOOM_THRESHOLD) {
int mid_x = corner.x + Math.round(h_width / 2.0f);
int mid_y = corner.y + Math.round(h_height / 2.0f);
g.fillOval(mid_x - 11, mid_y - 11, 20, 20);
continue;
}
g.fill3DRect(corner.x, corner.y, h_width, h_height, true);
}
}
protected int y_coord(int y) {
if (invert_yaxis) {
return height - margin_y - plot_height + y;
} else {
return height - margin_y - y;
}
}
protected Point pixelToBasePair(Point p) {
float y_value = p.y;
if (invert_yaxis) {
y_value = y_value - (height - margin_y - plot_height);
} else {
y_value = (height - margin_y - y_value);
}
int bp_offset_x = -Math.round(scale_x / 2);
int bp_offset_y = -Math.round(scale_y / 2);
int pos1 = offset_x + range_x_min + Math.round((p.x - margin_x + bp_offset_x) / scale_x);
int pos2 = offset_y + range_y_min + Math.round((y_value + bp_offset_y) / scale_y);
return new Point(pos1, pos2);
}
protected Point basePairToPixel(Point b) {
int x = (int)((b.x - offset_x - range_x_min) * scale_x + 0.5f);
int y = (int)((b.y - offset_y - range_y_min) * scale_y + 0.5f);
x += margin_x;
if (invert_yaxis) {
y = height - plot_height - margin_y + y;
} else {
y = height - margin_y - y;
}
return new Point(x, y);
}
private int getBpInRange(int seq_id, int start, int end) {
int count = end - start + 1;
if (!gapped_mode) return count;
start -= cur_align.getStart(seq_id);
end -= cur_align.getStart(seq_id);
List gaps_x = cur_align.getGaps(seq_id);
if (gaps_x.size() == 0) return count;
int g_start, g_end;
for (int x = 0; x < gaps_x.size(); x ++) {
DistributionContainer gap = (DistributionContainer)gaps_x.get(x);
g_start = gap.getStart();
g_end = gap.getEnd();
if (g_end >= start && g_start <= end) {
count -= Math.min(g_end, end) - Math.max(start, g_start) + 1;
}
}
return count;
}
private Point ungapCoordinate(Point coord) {
if (!gapped_mode) return coord;
Point ungapped = new Point(0,0);
Integer seq1_Int = (Integer)axis_sequence[XAXIS].get(0);
Integer seq2_Int = (Integer)axis_sequence[YAXIS].get(0);
int seq1 = seq1_Int.intValue();
int seq2 = seq2_Int.intValue();
int g_start, g_end;
Point relative_b = new Point(coord.x - cur_align.getStart(seq1), coord.y - cur_align.getStart(seq2));
int total = 0;
List gaps_x = cur_align.getGaps(seq1);
for (int x = 0; x < gaps_x.size(); x ++) {
DistributionContainer gap = (DistributionContainer)gaps_x.get(x);
g_start = gap.getStart();
g_end = gap.getEnd();
if (g_end < relative_b.x) {
total += g_end - g_start + 1;
} else if (g_start <= relative_b.x) {
total = coord.x + 1;
break;
} else break;
}
ungapped.x = coord.x - total;
total = 0;
List gaps_y = cur_align.getGaps(seq2);
for (int y = 0; y < gaps_y.size(); y++) {
DistributionContainer gap = (DistributionContainer)gaps_y.get(y);
g_start = gap.getStart();
g_end = gap.getEnd();
if (g_end < relative_b.y) {
total += g_end - g_start + 1;
} else if (g_start <= relative_b.y) {
total = coord.y + 1;
} else break;
}
ungapped.y = coord.y - total;
return ungapped;
}
protected boolean inGraph(Point p) {
if (p.getX() >= margin_x && p.getX() <= margin_x + plot_width &&
height - p.getY() >= margin_y && height - p.getY() <= margin_y + plot_height) {
return true;
}
return false;
}
protected void drawThickLine(Graphics g, int x1, int y1, int x2, int y2, int thickness) {
y1 -= Math.round(thickness / 2.0f);
y2 -= Math.round(thickness / 2.0f);
for (int i = 0; i < thickness; i++) {
g.drawLine(x1, y1 + i, x2, y2 + i);
}
}
protected void drawVerticalString(Graphics g, String str, int x , int y) {
Graphics2D g2d = (Graphics2D)g;
AffineTransform saveAT = g2d.getTransform();
AffineTransform at = new AffineTransform();
at.translate(x, y);
at.rotate(-Math.PI/2.0f);
g2d.transform(at);
g2d.drawString(str, 0, 0);
g2d.setTransform(saveAT);
}
protected void requestPaint() {
if (threaded_paint_mode) {
do_paint = true;
} else {
repaint();
}
}
protected void addHighlightArea(Object source, Rectangle[][] area, Color clr) {
highlight_rectangles.put(source, area);
highlight_colours.put(area, clr);
requestPaint();
}
protected Rectangle[][] removeHighlightArea(Object source) {
Rectangle[][] rect_arr = (Rectangle[][])highlight_rectangles.remove(source);
if (rect_arr != null) highlight_colours.remove(rect_arr);
requestPaint();
return rect_arr;
}
public void handleAlignmentHighlight(AlignmentHighlightEvent e) {
Alignment aln = e.getAlignment();
if (!alignments.contains(aln)) return;
int[] seqs = aln.getSequenceIDs();
int cur_seq_x = ((Integer)axis_sequence[XAXIS].get(0)).intValue();
int cur_seq_y = ((Integer)axis_sequence[YAXIS].get(0)).intValue();
Rectangle[][] rect_arr = new Rectangle[seqs.length][seqs.length];
for (int x = 0; x < seqs.length; x++) {
for (int y = 0; y < seqs.length; y++) {
int seq_x = seqs[x];
int seq_y = seqs[y];
int start_x = e.getHighlightStart(seq_x);
int end_x = e.getHighlightEnd(seq_x);
int start_y = e.getHighlightStart(seq_y);
int end_y = e.getHighlightEnd(seq_y);
if (Math.min(start_x, start_y) > -1 &&
Math.min(end_x, end_y) > -1) {
int r_width = end_x - start_x + 1;
int r_height = end_y - start_y + 1;
Rectangle rect =
new Rectangle(start_x, start_y, r_width, r_height);
rect_arr[x][y] = rect;
if (seq_x == cur_seq_x && seq_y == cur_seq_y) {
setCentre(new Point((int)rect.getCenterX(), (int)rect.getCenterY()));
}
}
}
}
addHighlightArea(e.getSource(), rect_arr, highlight_colour);
requestPaint();
}
protected Rectangle[][] captureAlignmentAreas(Alignment aln) {
int[] seqs = aln.getSequenceIDs();
Rectangle[][] rect_arr = new Rectangle[seqs.length][seqs.length];
for (int x = 0; x < seqs.length; x++) {
for (int y = 0; y < seqs.length; y++) {
int seq_x = seqs[x];
int seq_y = seqs[y];
int start_x = aln.getStart(seq_x);
int end_x = aln.getEnd(seq_x);
int start_y = aln.getStart(seq_y);
int end_y = aln.getEnd(seq_y);
if (Math.min(start_x, start_y) > -1 &&
Math.min(end_x, end_y) > -1) {
int r_width = end_x - start_x + 1;
int r_height = end_y - start_y + 1;
Rectangle rect =
new Rectangle(start_x, start_y, r_width, r_height);
rect_arr[x][y] = rect;
}
}
}
return rect_arr;
}
public void mouseClicked(MouseEvent e) {
Point anchor = e.getPoint();
int clicks = e.getClickCount();
if (clicks == 1) {
Rectangle picked = null;
Point cursor = pixelToBasePair(anchor);
int area = Integer.MAX_VALUE;
for (Iterator a_itr = pick_map.keySet().iterator(); a_itr.hasNext();) {
Rectangle rect = (Rectangle)a_itr.next();
if (rect.contains(cursor) && rect.width * rect.height < area) {
picked = rect;
area = rect.width * rect.height;
}
}
if (picked != null) pickArea(pick_map.get(picked));
}
}
public void mouseEntered(MouseEvent e) {
}
public void mouseExited(MouseEvent e) {
}
public void mousePressed(MouseEvent e) {
cur_cursor = new Cursor(Cursor.HAND_CURSOR);
if (inGraph(e.getPoint())) {
setCursor(cur_cursor);
drag_anchor = e.getPoint();
click_anchor = pixelToBasePair(drag_anchor);
drag_mode = MOVE_TOOL;
if (SwingUtilities.isMiddleMouseButton(e)) {
drag_mode = ZOOM_MOUSE;
setCentre(click_anchor);
requestPaint();
} else if ( (cur_tool == ZOOM_TOOL) ^ e.isControlDown() ) {
drag_mode = ZOOM_TOOL;
}
if (drag_mode == ZOOM_TOOL) {
zoom_select_rect = new Rectangle((int)e.getPoint().getX() - 25, (int)e.getPoint().getY() - 25, 50, 50);
}
} else {
drag_anchor = null;
}
}
public void mouseReleased(MouseEvent e) {
cur_cursor = new Cursor(Cursor.CROSSHAIR_CURSOR);
if (inGraph(e.getPoint())) setCursor(cur_cursor);
if (drag_mode == ZOOM_TOOL) {
updateSelectRect(e.getPoint());
Point centre = pixelToBasePair(new Point((int)zoom_select_rect.getCenterX(), (int)zoom_select_rect.getCenterY()));
double area = zoom_select_rect.getWidth() * (float)zoom_select_rect.getHeight();
if (area > 10) {
zoom = zoom / ((float)zoom_select_rect.getWidth() / plot_width);
setZoom("Squarezoom", zoom);
evaluateScale();
setCentre(centre);
}
zoom_select_rect = null;
requestPaint();
}
drag_mode = -1;
}
public void mouseDragged(MouseEvent e) {
Point anchor = e.getPoint();
if (drag_anchor != null && drag_mode == MOVE_TOOL && zoom > 1) {
mouse_pos = anchor;
float diff = (float)(anchor.getX() - drag_anchor.getX());
if (scale_x >= 5) {
if (Math.abs(diff) > 1) {
if (diff < 0) offset_x++;
else offset_x--;
}
} else if (Math.abs(diff) > 0) {
diff /= scale_x;
if (Math.abs(diff) < 1) diff = (diff < 0 ? -1 : 1);
offset_x -= diff;
}
diff = (float)(anchor.getY() - drag_anchor.getY());
if (scale_y >= 5) {
if (Math.abs(diff) > 1) {
if ((diff < 0) ^ invert_yaxis) offset_y--;
else offset_y++;
}
} else if (Math.abs(diff) > 0) {
diff = diff * (invert_yaxis ? 1 : -1) / scale_y;
if (Math.abs(diff) < 1) diff = (diff < 0 ? -1 : 1);
offset_y -= diff;
}
requestPaint();
} else if (drag_mode == ZOOM_TOOL){
updateSelectRect(anchor);
setCursor(cur_cursor);
requestPaint();
} else if (drag_mode == ZOOM_MOUSE && drag_anchor != null) {
float diff = anchor.y - drag_anchor.y;
float abs_diff = Math.abs(diff);
if (abs_diff > 0.001f) {
abs_diff = (float)Math.sqrt(zoom) - 0.99f;
if (diff > 0) {
setZoom("mousescroll_up", zoom + abs_diff);
} else {
setZoom("mousescroll_down", zoom - abs_diff);
}
evaluateScale();
setCentre(click_anchor);
requestPaint();
}
} else {
mouseMoved(e);
}
drag_anchor = anchor;
}
public void mouseMoved(MouseEvent e) {
Point last_anchor = mouse_pos;
Point anchor = e.getPoint();
if (inGraph(anchor)) {
mouse_pos = anchor;
setCursor(cur_cursor);
if (pick_map.size() > 0) requestPaint();
else updateCoordinateLabel();
} else {
mouse_pos = null;
setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
if (pick_map.size() > 0 && last_anchor != null && inGraph(last_anchor) && !inGraph(anchor)) requestPaint();
else updateCoordinateLabel();
}
}
public void windowClosing(WindowEvent e) {
threaded_paint_mode = false;
}
public void windowActivated(WindowEvent e) {
}
public void windowClosed(WindowEvent e) {
}
public void windowDeactivated(WindowEvent e) {
}
public void windowDeiconified(WindowEvent e) {
}
public void windowIconified(WindowEvent e) {
}
public void windowOpened(WindowEvent e) {
threaded_paint_mode = true;
Thread t_paint = new Thread("AlignmentGraph_PaintThread:" + align_op.getAlignID()) {
public void run() {
while (threaded_paint_mode) try {
Thread.sleep(1000 / FPS);
if (do_paint) {
repaint();
do_paint = false;
}
} catch (Exception e) {
Log.printStackTrace(e);
}
}
};
t_paint.setDaemon(true);
t_paint.start();
}
private float getMaxZoom() {
return MAX_PIXELS_PER_BP * (range_x_max - range_x_min) / (float)plot_width;
}
}
package ca.bcgsc.sockeye.gui.alignment;
import java.util.EventObject;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import ca.bcgsc.sockeye.analysis.Alignment;
public class AlignmentHighlightEvent extends EventObject {
Alignment alignment;
Map regions = new HashMap();
private class Range {
public int start, end;
public Range(int s, int e) {
start = s;
end = e;
}
}
public AlignmentHighlightEvent(Object source, Alignment aln) {
super(source);
alignment = aln;
}
public Alignment getAlignment() {
return alignment;
}
public void addRegion(int seq_id, int start, int end) {
regions.put(new Integer(seq_id), new Range(start, end));
}
public int getHighlightStart(int seq_id) {
Range range = (Range)regions.get(new Integer(seq_id));
if (range == null) return -1;
return range.start;
}
public int getHighlightEnd(int seq_id) {
Range range = (Range)regions.get(new Integer(seq_id));
if (range == null) return -1;
return range.end;
}
public int[] getSequences() {
int[] result = new int[regions.size()];
int index = 0;
for (Iterator itr = regions.keySet().iterator(); itr.hasNext();) {
result[index++] = ((Integer)itr.next()).intValue();
}
return result;
}
}
package ca.bcgsc.sockeye.gui.alignment;
public interface AlignmentHighlightListener {
public void handleAlignmentHighlight(AlignmentHighlightEvent e);
}
package ca.bcgsc.sockeye.gui.alignment;
import java.awt.BorderLayout;
import java.awt.Container;
import java.awt.Dimension;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;
import javax.swing.JDialog;
import ca.bcgsc.sockeye.analysis.Alignment;
import ca.bcgsc.sockeye.analysis.scprofile.SCProfileException;
import ca.bcgsc.sockeye.analysis.scprofile.SCProfileList;
import ca.bcgsc.sockeye.analysis.scprofile.SubsetGenerator;
import ca.bcgsc.sockeye.gui.Sockeye;
import ca.bcgsc.sockeye.trackmanager.AlignOperation;
import ca.bcgsc.sockeye.util.Log;
public class MultiAlignmentDialog extends JDialog implements Runnable {
protected AlignOperation align_op;
protected List alignments;
protected MultiAlignmentGraph aln_graph;
protected static Map open_windows = new Hashtable();
public MultiAlignmentDialog(AlignOperation align_op) {
super(Sockeye.__frame, "Alignment result", false);
MultiAlignmentDialog cur_window = (MultiAlignmentDialog)open_windows.get(align_op);
if (cur_window != null) {
cur_window.requestFocus();
return;
} else {
open_windows.put(align_op, this);
}
this.align_op = align_op;
alignments = align_op.getSubalignments();
String align_app = align_op.getAlignApplication();
int align_id = align_op.getAlignID();
(new Thread(this)).start();
aln_graph = new MultiAlignmentGraph(alignments, align_op.getAnchors());
addWindowListener(aln_graph);
setTitle(align_app + " alignment " + align_id + ": sub-alignments");
this.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);
jbInit();
}
using a separate thread */
public void run() {
for (int i = 1; i < alignments.size(); i++) {
Alignment aln = (Alignment)alignments.get(i);
SCProfileList scpl = aln.getSCProfileList();
if (scpl == null) try {
scpl = new SCProfileList(aln, align_op.getReferenceTrack(), align_op.getTrackRelationship(), SCProfileList.__DEFAULT_WINDOW_SIZE, SubsetGenerator.__SET_DISTANCE, null);
aln.setSCProfileList(scpl);
if (aln_graph != null) aln_graph.requestPaint();
} catch (SCProfileException e) {
Log.printStackTrace(e);
}
}
}
private void jbInit() {
setLocationRelativeTo(getParent());
setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);
Container contentPane = this.getContentPane();
contentPane.setLayout(new BorderLayout());
contentPane.add(aln_graph);
setSize(new Dimension(400,400));
show();
}
public void dispose() {
open_windows.remove(align_op);
super.dispose();
}
public static void close(AlignOperation aln_to_close) {
JDialog dialog_to_close = (JDialog)open_windows.get(aln_to_close);
if (dialog_to_close != null) dialog_to_close.dispose();
}
}
package ca.bcgsc.sockeye.gui.alignment;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JPopupMenu;
import javax.swing.JSeparator;
import javax.swing.SwingUtilities;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import ca.bcgsc.sockeye.analysis.Alignment;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.gui.Sockeye;
import ca.bcgsc.sockeye.trackmanager.AlignOperation;
public class MultiAlignmentGraph extends AlignmentGraph {
boolean show_numbers = true;
static Color aln_highlight_colour = new Color(255, 255, 0, 100);
static Color aln3D_highlight_colour = new Color(255, 0, 0, 50);
static Map opened_graphs = new HashMap();
public MultiAlignmentGraph(List alignments, List anchors) {
super(alignments, anchors, false, false);
List keys = new ArrayList(opened_graphs.keySet());
for (int i = 0; i < keys.size(); i++) {
AlignOperation a_op = (AlignOperation)keys.get(i);
MultiAlignmentGraph mag = (MultiAlignmentGraph)opened_graphs.get(a_op);
if (!SwingUtilities.getWindowAncestor(mag).isActive()) {
opened_graphs.remove(a_op);
}
}
opened_graphs.put(align_op, this);
final JCheckBoxMenuItem number_option = new JCheckBoxMenuItem("Show alignment numbers", show_numbers);
number_option.addChangeListener(new ChangeListener() {
public void stateChanged(ChangeEvent e) {
show_numbers = number_option.isSelected();
requestPaint();
}
});
view_menu.add(number_option);
Alignment aln_3d = align_op.get3DSubalignment();
Rectangle[][] rect_arr = captureAlignmentAreas(aln_3d);
addHighlightArea("Select3D", rect_arr, aln3D_highlight_colour);
List single_dialogs = SingleAlignmentDialog.getOpenWindows(align_op);
if (single_dialogs != null) for (int i = 0; i < single_dialogs.size(); i++) {
SingleAlignmentDialog s_dialog = (SingleAlignmentDialog)single_dialogs.get(i);
singleAlignmentDialogOpened(s_dialog);
}
}
public void setSequences(){
Object[] x_seq_obj = axis_sequence[XAXIS].toArray();
Object[] y_seq_obj = axis_sequence[YAXIS].toArray();
int[] x_sequences = new int[x_seq_obj.length];
int[] y_sequences = new int[y_seq_obj.length];
for (int i = 0; i < x_seq_obj.length; i++) {
x_sequences[i] = ((Integer)x_seq_obj[i]).intValue();
y_sequences[i] = ((Integer)y_seq_obj[i]).intValue();
}
removePickableAreas();
for (Iterator itr = alignments.iterator(); itr.hasNext();) {
Alignment aln = (Alignment)itr.next();
int start_x, start_y, end_x, end_y, w, h;
for (int x = 0; x < x_sequences.length; x++) {
for (int y = 0; y < y_sequences.length; y++) {
start_x = aln.getStart(x_sequences[x]);
start_y = aln.getStart(y_sequences[y]);
end_x = aln.getEnd(x_sequences[x]);
end_y = aln.getEnd(y_sequences[y]);
w = Math.abs(end_x - start_x) + 1;
h = Math.abs(end_y - start_y) + 1;
addPickableArea(start_x, start_y, w, h, aln);
}
}
}
super.setSequences();
}
protected void plotAlignments(Graphics g) {
Font old_font = g.getFont();
g.setFont(new Font("Arial", Font.BOLD, 12));
int seq1, seq2, start_x, start_y, end_x, end_y, start1bp, start2bp, end1bp, end2bp;
for (int aln_index = 0; aln_index < alignments.size(); aln_index++) {
Alignment alignment = (Alignment)alignments.get(aln_index);
for (int x_seq = 0; x_seq < axis_sequence[XAXIS].size(); x_seq++) {
for (int y_seq = 0; y_seq < axis_sequence[YAXIS].size(); y_seq++) {
seq1 = ((Integer)axis_sequence[XAXIS].get(x_seq)).intValue();
seq2 = ((Integer)axis_sequence[YAXIS].get(y_seq)).intValue();
boolean inversion = alignment.onNegativeStrand(seq1) ^ alignment.onNegativeStrand(seq2);
float avg = alignment.getAverageConservation(seq1, seq2);
Color aln_clr = Color.BLACK;
if (avg >= 0) {
avg = (1.0f - avg);
int max_clr = 200;
int red = aln_colour.getRed() + (int)(Math.max(max_clr - aln_colour.getRed(), 0) * avg);
int green = aln_colour.getGreen() + (int)(Math.max(max_clr - aln_colour.getGreen(),0) * avg);
int blue = aln_colour.getBlue() + (int)(Math.max(max_clr - aln_colour.getBlue(),0) * avg);
if (green > max_clr) green = max_clr;
if (blue > max_clr) blue = max_clr;*/
aln_clr = new Color(red, green, blue);
}
start1bp = alignment.getStartInvert(seq1);
end1bp = alignment.getEndInvert(seq1);
start2bp = alignment.getStartInvert(seq2);
end2bp = alignment.getEndInvert(seq2);
Point pixel_start = basePairToPixel(new Point(start1bp, start2bp));
Point pixel_end = basePairToPixel(new Point(end1bp + 1, end2bp + 1));
start_x = pixel_start.x;
end_x = pixel_end.x;
start_y = pixel_start.y;
end_y = pixel_end.y;
float x_diff = end_x - start_x;
float y_diff = end_y - start_y;
double length = Math.sqrt( y_diff * y_diff + x_diff * x_diff);
if (show_numbers) {
g.setColor(Color.BLACK);
g.drawString(alignment.getID() + "", (inversion ? start_x - 12 : end_x + 6),
(inversion ? start_y: end_y) + 12 * (invert_yaxis ? 1 : -1));
}
g.setColor(aln_clr);
if (length < _ZOOM_THRESHOLD) {
int middle_x = Math.min(start1bp, end1bp) + Math.round(Math.abs((end1bp - start1bp) / 2));
int middle_y = Math.min(start2bp, end2bp) + Math.round(Math.abs((end2bp - start2bp) / 2));
Point mid = basePairToPixel(new Point(middle_x, middle_y));
g.fillOval(mid.x - 5, mid.y - 5, 10, 10);
setPickableArea(middle_x - (int)(5.0f / scale_x), middle_y - (int)(5.0f / scale_y), (int)(10.0f / scale_x), (int)(10.0f / scale_y), alignment);
continue;
}
start1bp = alignment.getStart(seq1);
start2bp = alignment.getStart(seq2);
end1bp = alignment.getEnd(seq1);
end2bp = alignment.getEnd(seq2);
int aln_width = Math.abs(end1bp - start1bp) + 1;
int aln_height = Math.abs(end2bp - start2bp) + 1;
setPickableArea(start1bp, start2bp, aln_width, aln_height, alignment);
drawThickLine(g, start_x, start_y, end_x, end_y, 4);
}
}
}
g.setFont(old_font);
}
protected void plotDiagonal(Graphics g, Point start_corner, Point end_corner) {
Point diag_start = basePairToPixel(start_corner);
Point diag_end = basePairToPixel(end_corner);
g.setColor(Color.LIGHT_GRAY);
int seq1 = ((Integer)axis_sequence[XAXIS].get(0)).intValue();
int seq2 = ((Integer)axis_sequence[YAXIS].get(0)).intValue();
boolean flip_diagonal = cur_align.fromNegativeSourceStrand(seq1) ^ cur_align.fromNegativeSourceStrand(seq2);
int off_x = Math.round(scale_x) / 2;
int off_y = Math.round(scale_y) / 2 * (invert_yaxis ? -1 : 1);
if (flip_diagonal) {
g.drawLine(diag_start.x + off_x, diag_end.y - off_y, diag_end.x + off_x, diag_start.y - off_y);
} else {
g.drawLine(diag_start.x + off_x, diag_start.y - off_y, diag_end.x + off_x, diag_end.y - off_y);
}
}
protected void pickArea(Object obj) {
final Alignment picked_aln = (Alignment)obj;
int[] seqs = {
((Integer)axis_sequence[XAXIS].get(0)).intValue(),
((Integer)axis_sequence[YAXIS].get(0)).intValue()};
float c_avg = picked_aln.getAverageConservation(seqs[0], seqs[1]);
JPopupMenu popup = new JPopupMenu("Sub-alignment " + picked_aln.getID());
popup.setBackground(Configuration.gui_blue);
JLabel title = new JLabel("Subalignment " + picked_aln.getID());
popup.add(title);
popup.add(new JSeparator());
int start = picked_aln.getStart(seqs[0]);
int end = picked_aln.getEnd(seqs[0]);
int length = Math.abs(end - start) + 1;
String invert_str = (picked_aln.isInverted(seqs[0]) ? " Inversion" : "");
String conservation = "NA";
if (c_avg >= 0) conservation = Math.round(c_avg * 100) + "%";
popup.add(new JLabel(" Average conservation: " + conservation));
popup.add(new JLabel(" x axis: " + start + ".." + end + " (" + length + ")" + invert_str));
start = picked_aln.getStart(seqs[1]);
end = picked_aln.getEnd(seqs[1]);
length = Math.abs(end - start) + 1;
invert_str = (picked_aln.isInverted(seqs[1]) ? " Inversion" : "");
popup.add(new JLabel(" y axis: " + start + ".." + end + " (" + length + ")" + invert_str));
popup.add(new JSeparator());
JMenuItem view_single = new JMenuItem("Gapped sub-alignment view...");
view_single.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
SingleAlignmentDialog alignment_panel =
new SingleAlignmentDialog(Sockeye.__frame, picked_aln, anchors, picked_aln.getParentOperation().getReferenceTrack());
singleAlignmentDialogOpened(alignment_panel);
}
});
popup.add(view_single);
JMenuItem to_3d = new JMenuItem("View in 3D");
to_3d.addActionListener( new ActionListener() {
public void actionPerformed(ActionEvent e) {
Rectangle[][] rect_arr = captureAlignmentAreas(picked_aln);
addHighlightArea("Select3D", rect_arr, aln3D_highlight_colour);
AlignOperation a_op = picked_aln.getParentOperation();
a_op.set3DSubalignment(picked_aln.getID() - 1);
}
});
popup.add(to_3d);
popup.show(this, mouse_pos.x, mouse_pos.y);
}
private void singleAlignmentDialogOpened(SingleAlignmentDialog sad) {
final Alignment picked_aln = sad.getAlignment();
Rectangle[][] rect_arr = captureAlignmentAreas(picked_aln);
addHighlightArea(picked_aln, rect_arr, aln_highlight_colour);
sad.addWindowListener(new WindowAdapter() {
public void windowClosing(WindowEvent e) {
removeHighlightArea(picked_aln);
}
});
}
public static void notifySingleAlignmentDialogOpened(SingleAlignmentDialog sad) {
AlignOperation a_op = sad.getAlignment().getParentOperation();
MultiAlignmentGraph mag = (MultiAlignmentGraph)opened_graphs.get(a_op);
if (mag != null) {
mag.singleAlignmentDialogOpened(sad);
}
}
}
package ca.bcgsc.sockeye.gui.alignment;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.FocusEvent;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.text.NumberFormat;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.EventObject;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import javax.swing.AbstractCellEditor;
import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JColorChooser;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JFormattedTextField;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JSlider;
import javax.swing.JTabbedPane;
import javax.swing.JTable;
import javax.swing.ListCellRenderer;
import javax.swing.border.Border;
import javax.swing.event.CellEditorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.TableModelEvent;
import javax.swing.event.TableModelListener;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.JTableHeader;
import javax.swing.table.TableCellEditor;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumn;
import javax.swing.table.TableColumnModel;
import javax.swing.table.TableModel;
import ca.bcgsc.sockeye.analysis.Alignment;
import ca.bcgsc.sockeye.analysis.scprofile.SCProfile;
import ca.bcgsc.sockeye.analysis.scprofile.SCProfileException;
import ca.bcgsc.sockeye.analysis.scprofile.SCProfileList;
import ca.bcgsc.sockeye.analysis.scprofile.SubsetGenerator;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.dataretrieval.DataSourceManager;
import ca.bcgsc.sockeye.dataretrieval.SCProfileDataSource;
import ca.bcgsc.sockeye.datastorage.DataStorageManager;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.datastorage.SockeyeTrackList;
import ca.bcgsc.sockeye.gui.Sockeye;
import ca.bcgsc.sockeye.gui.util.PercentileDistributionGraph;
import ca.bcgsc.sockeye.trackmanager.AlignOperation;
import ca.bcgsc.sockeye.trackmanager.TrackRelationshipException;
import ca.bcgsc.sockeye.trackmanager.TrackRelationshipOrderInterface;
import ca.bcgsc.sockeye.util.Log;
public class SCProfileDialog extends JDialog {
private final static int _MARGIN = 10;
private JTabbedPane tabbed_pane = new JTabbedPane();
private SettingsTab settings_tab = null;
private ProfilesTab profiles_tab = null;
private AdvancedTab advanced_tab = null;
private static int current_tab = 0;
private DataStorageManager track_manager = null;
private DataSourceManager source_manager = null;
private Alignment alignment;
private AlignOperation align_op = null;
private SCProfileList profileList = null;
private List relationships = null;
private TrackRelationshipOrderInterface current_relation = null;
JButton b_cancel = new JButton("Cancel");
JButton b_finish = new JButton("Finish");
JButton b_apply = new JButton("Apply");
private int ref_track;
private boolean fresh = true;
private static Map open_windows = new Hashtable();
private static boolean _do_warning = true;
public SCProfileDialog(Alignment alignment) {
super(Sockeye.__frame, "Sequence Conservation Profiles", false);
this.alignment = alignment;
align_op = alignment.getParentOperation();
List aln_open = (List)open_windows.get(align_op);
if (aln_open == null) {
aln_open = new ArrayList();
open_windows.put(align_op, aln_open);
}
for (int i = 0; i < aln_open.size(); i++) {
SCProfileDialog scd = (SCProfileDialog)aln_open.get(i);
if (scd.alignment == alignment) {
scd.requestFocus();
dispose();
return;
}
}
aln_open.add(this);
track_manager = DataStoreUser.getInstance().getSockeyeTrackList();
source_manager = DataStoreUser.getInstance().getDataSourceManager();
ref_track = align_op.getReferenceTrack();
try {
relationships = align_op.getAllRelationships();
SCProfileList original = alignment.getSCProfileList();
if (original == null) {
profileList =
new SCProfileList(alignment,
ref_track,
align_op.getTrackRelationship(),
SCProfileList.__DEFAULT_WINDOW_SIZE, SubsetGenerator.__SET_DISTANCE, null);
alignment.setSCProfileList(profileList);
} else {
profileList = new SCProfileList(original);
}
current_relation = profileList.getTrackRelationship();
setTitle("Conservation profiles for " + alignment.getIdentityTag());
jbInit();
show();
} catch (Exception e) {
Log.printStackTrace(e);
}
}
public void dispose() {
List d_list = (List)open_windows.get(align_op);
if (d_list != null) {
d_list.remove(this);
}
super.dispose();
}
private void jbInit() throws Exception {
setLocationRelativeTo(null);
Container contentPane = this.getContentPane();
contentPane.setLayout(new BorderLayout());
JPanel main_panel = new JPanel(new BorderLayout());
contentPane.add(main_panel);
this.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);
b_cancel.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
b_cancel_actionPerformed(e);
}
});
b_apply.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
b_apply_actionPerformed (e);
}
});
b_finish.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
b_finish_actionPerformed(e);
}
});
getRootPane().setDefaultButton(b_finish);
settings_tab = new SettingsTab();
profiles_tab = new ProfilesTab();
advanced_tab = new AdvancedTab();
tabbed_pane.addTab("Profiles", profiles_tab);
tabbed_pane.addTab("Settings", settings_tab);
tabbed_pane.addTab("Advanced", advanced_tab);
tabbed_pane.setPreferredSize(new Dimension(555, 250));
tabbed_pane.setMinimumSize(new Dimension(555, 250));
tabbed_pane.addChangeListener(new ChangeListener() {
public void stateChanged(ChangeEvent e) {
tab_panel_changed(e);
}
});
tabbed_pane.setSelectedIndex(current_tab);
JPanel opt_panel = new JPanel(new GridBagLayout());
GridBagConstraints opt_gbc = new GridBagConstraints();
Object[] relation_choices = relationships.toArray();
final JComboBox rel_chooser = new JComboBox(relation_choices);
rel_chooser.setSelectedItem(current_relation);
rel_chooser.setToolTipText("Changes the alignment relationship used for defining profiles");
rel_chooser.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
if (!confirmProfileChange()) {
rel_chooser.setSelectedItem(current_relation);
return;
}
current_relation =
(TrackRelationshipOrderInterface)rel_chooser.getSelectedItem();
profileList.setTrackRelationship(current_relation);
redefineProfiles();
}
});
JLabel rel_label = new JLabel("Sequence relationship");
rel_label.setLabelFor(rel_chooser);
opt_gbc.gridx = 0;
opt_gbc.gridy = 0;
opt_gbc.weightx = 10;
opt_gbc.insets = new Insets(5, _MARGIN, 0, 0);
opt_gbc.fill = GridBagConstraints.NONE;
opt_gbc.anchor = GridBagConstraints.EAST;
opt_panel.add(rel_label, opt_gbc);
opt_gbc.gridx = 1;
opt_gbc.gridy = 0;
opt_gbc.weightx = 10;
opt_gbc.anchor = GridBagConstraints.WEST;
opt_panel.add(rel_chooser, opt_gbc);
Object[] def_choices = SubsetGenerator.getMethods().toArray();
final JComboBox def_chooser = new JComboBox(def_choices);
def_chooser.setSelectedItem(profileList.getSetDefinitionMethod());
def_chooser.setToolTipText("Re-defines the set of profiles according to the chosen strategy");
def_chooser.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
if (!confirmProfileChange()) {
def_chooser.setSelectedItem(profileList.getSetDefinitionMethod());
return;
}
profileList.setSetDefinitionMethod((String)def_chooser.getSelectedItem());
redefineProfiles();
}
});
JLabel def_label = new JLabel("Define profiles by");
def_label.setLabelFor(def_chooser);
opt_gbc.gridx = 0;
opt_gbc.gridy = 1;
opt_gbc.weightx = 10;
opt_gbc.anchor = GridBagConstraints.EAST;
opt_panel.add(def_label, opt_gbc);
opt_gbc.gridx = 1;
opt_gbc.gridy = 1;
opt_gbc.weightx = 10;
opt_gbc.anchor = GridBagConstraints.WEST;
opt_panel.add(def_chooser, opt_gbc);
JCheckBox warn_check = new JCheckBox("Warn on reset", _do_warning);
warn_check.setToolTipText("Turns on warnings for operations that reset profile settings");
warn_check.setBackground(Configuration.gui_blue);
warn_check.addItemListener(new ItemListener() {
public void itemStateChanged(ItemEvent e) {
if (e.getStateChange() == ItemEvent.DESELECTED) {
_do_warning = false;
} else _do_warning = true;
}
});
opt_gbc.gridx = 2;
opt_gbc.gridy = 1;
opt_gbc.fill = GridBagConstraints.REMAINDER;
opt_gbc.weightx = 80;
opt_panel.add(warn_check, opt_gbc);
main_panel.add(opt_panel, BorderLayout.NORTH);
tabbed_pane.setBorder(BorderFactory.createEmptyBorder(_MARGIN, _MARGIN, 0, _MARGIN));
main_panel.add(tabbed_pane, BorderLayout.CENTER);
JPanel button_pane = new JPanel(new FlowLayout(FlowLayout.RIGHT, 10,10));
button_pane.add(b_finish);
button_pane.add(b_apply);
button_pane.add(b_cancel);
main_panel.add(button_pane, BorderLayout.SOUTH);
main_panel.setBackground(Configuration.gui_blue);
button_pane.setBackground(Configuration.gui_blue);
opt_panel.setBackground(Configuration.gui_blue);
setFresh(fresh);
this.pack();
}
public void redefineProfiles() {
try {
profileList.redefineProfiles();
setFresh(false);
profiles_tab.updateData();
tabbed_pane.setSelectedIndex(0);
} catch (SCProfileException e) {
Log.printStackTrace(e);
}
}
void tab_panel_changed(ChangeEvent e) {
int index = tabbed_pane.getSelectedIndex();
current_tab = index;
if (index == 1) {
settings_tab.updateData();
}
else if (index == 2) {
advanced_tab.updateData();
}
}
private boolean confirmProfileChange() {
if (!_do_warning) return true;
String message = "This action may reset this alignment's current profiles and all of their settings.\nWould you like to continue?";
int result = JOptionPane.showConfirmDialog(this, message, "Confirm Reset", JOptionPane.YES_NO_OPTION);
if (result == JOptionPane.OK_OPTION) return true;
return false;
}
void b_cancel_actionPerformed(ActionEvent e) {
dispose();
}
void b_apply_actionPerformed(ActionEvent e) {
if (!fresh) {
alignment.setSCProfileList(profileList);
List dialogs = SingleAlignmentDialog.getOpenWindows(align_op);
if (dialogs != null) {
for (int i = 0; i < dialogs.size(); i++) {
SingleAlignmentDialog sad = (SingleAlignmentDialog)dialogs.get(i);
if (sad.getAlignment() == alignment) {
sad.onProfileListChanged();
}
}
}
SCProfileDataSource d_src = null;
List dsources =
track_manager.getDataSources(ref_track);
for (int i = 0; i < dsources.size(); i++) {
try {
d_src = (SCProfileDataSource)dsources.get(i);
break;
} catch (ClassCastException no) {
}
}
if (d_src == null) {
d_src = new SCProfileDataSource(ref_track, align_op);
source_manager.addDataSource(d_src);
track_manager.addDataSourceId(ref_track, d_src.getId());
((SockeyeTrackList)track_manager).addStorageListener(d_src);
}
d_src.reset();
setFresh(true);
}
}
void b_finish_actionPerformed(ActionEvent e) {
b_apply_actionPerformed(e);
dispose();
}
void setFresh(boolean is_fresh) {
fresh = is_fresh;
b_apply.setEnabled(!fresh);
}
public static void close(AlignOperation align_op) {
List to_dispose = (List)open_windows.remove(align_op);
if (to_dispose != null && align_op != null) {
for (int i = 0; i < to_dispose.size(); i++) {
((SCProfileDialog)to_dispose.get(i)).dispose();
}
}
}
private class SettingsTab extends JPanel implements ChangeListener {
protected AbstractTableModel t_model = null;
List profiles;
List threshold_controls;
JTable profile_table;
TableCellEditor editor;
private static final String _PERCENTILE_TOOLTIP = "Percentile of column scores below threshold.";
private static final String _THRESHOLD_TOOLTIP = "Profile score threshold to indicate conserved regions.";
public SettingsTab() {
super(new BorderLayout(0, 0));
jbinit();
}
void jbinit() {
updateData();
JPanel master_p = new JPanel(new FlowLayout(FlowLayout.RIGHT, 0, 0));
master_p.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 87));
JLabel thresh_control_label = new JLabel("Master conservation threshold");
thresh_control_label.setToolTipText("Sets the conservation threshold of all profiles");
SliderValuePanel master = new SliderValuePanel(
null,
null,
0,
100,
profileList.getGroupThresholdByPercentile());
master.setToolTipText("Sets the conservation threshold of all profiles", null);
master.addChangeListener(this);
master_p.add(thresh_control_label);
master_p.add(master);
master_p.add(new JLabel("%"));
add(master_p, BorderLayout.NORTH);
t_model = new AbstractTableModel() {
public Object getValueAt(int row, int col) {
SCProfile p = (SCProfile)profiles.get(row);
if (col == 0) {
return profileList.getProfileOrderTag(row);
} else if (col == 1) {
return new Boolean(p.isVisible());
} else if (col == 2) {
return new Boolean(p.getCRDisplay(true));
} else if (col == 3) {
return new Boolean(p.getCRDisplay(false));
} else {
return new Float(p.getThreshold());
}
}
public void setValueAt(Object aValue, int row, int col) {
SCProfile p = (SCProfile)profiles.get(row);
if (col == 0) {
return;
} else if (col == 1) {
p.setVisible(((Boolean)aValue).booleanValue());
} else if (col == 2) {
p.setCRDisplay(((Boolean)aValue).booleanValue(), true);
} else if (col == 3) {
p.setCRDisplay(((Boolean)aValue).booleanValue(), false);
} else return;
setFresh(false);
}
public int getRowCount() {
return profileList.size();
}
public int getColumnCount() {
return 5;
}
public Class getColumnClass(int columnIndex) {
if (columnIndex == 0)
return String.class;
else if (columnIndex > 3)
return Float.class;
else
return Boolean.class;
}
public String getColumnName(int column) {
switch (column) {
case 0 :
return "Profile";
case 1 :
return "Show";
case 2 :
return "GCR";
case 3 :
return "OCR";
case 4 :
return "Conserved Region Threshold";
default :
return "?";
}
}
public boolean isCellEditable(int rowIndex, int columnIndex) {
return columnIndex > 0;
}
};
TableCellRenderer float_renderer = new TableCellRenderer() {
public Component getTableCellRendererComponent(
JTable table,
Object value,
boolean isSelected,
boolean hasFocus,
int row,
int column) {
SliderValuePanel comp = (SliderValuePanel)threshold_controls.get(row);
comp.setToolTipText(_PERCENTILE_TOOLTIP, _THRESHOLD_TOOLTIP);
return comp;
}
};
editor = new TableCellEditor() {
SliderValuePanel t_panel = null;
AbstractCellEditor abs = new AbstractCellEditor() {
public Object getCellEditorValue() {
return t_panel == null
? null
: new Float(t_panel.getValue());
}};
public Component getTableCellEditorComponent(
JTable table,
Object value,
boolean isSelected,
int row,
int column) {
t_panel = (SliderValuePanel)threshold_controls.get(row);
return t_panel;
}
public boolean isCellEditable(EventObject anEvent) {
return abs.isCellEditable(anEvent);
}
public boolean shouldSelectCell(EventObject anEvent) {
return abs.shouldSelectCell(anEvent);
}
public boolean stopCellEditing() {
return abs.stopCellEditing();
}
public void cancelCellEditing() {
abs.cancelCellEditing();
}
public void addCellEditorListener(CellEditorListener l) {
abs.addCellEditorListener(l);
}
public void removeCellEditorListener(CellEditorListener l) {
abs.removeCellEditorListener(l);
}
public Object getCellEditorValue() {
return abs.getCellEditorValue();
}
};
profile_table = new JTable(t_model);
profile_table.setDoubleBuffered(true);
profile_table.setDefaultEditor(Float.class, editor);
profile_table.setDefaultRenderer(Float.class, float_renderer);
profile_table.setRowHeight(30);
profile_table.setDragEnabled(false);
profile_table.setRowSelectionAllowed(false);
profile_table.setColumnSelectionAllowed(false);
TableColumn column = profile_table.getColumnModel().getColumn(4);
int col_width = 290;
column.setPreferredWidth(col_width);
column.setMinWidth(col_width);
column.setMaxWidth(col_width);
TableCellRenderer col_renderer = new TableCellRenderer() {
JPanel panel = new JPanel();
public Component getTableCellRendererComponent(
JTable table,
Object value,
boolean isSelected,
boolean hasFocus,
int row,
int col) {
JLabel label = new JLabel((String)value);
label.setHorizontalAlignment(JLabel.CENTER);
panel.removeAll();
panel.add(label);
SCProfile this_p = (SCProfile)profiles.get(row);
panel.setBackground(this_p.getColour());
return panel;
}
};
TableColumn col0 = profile_table.getColumnModel().getColumn(0);
col0.setCellRenderer(col_renderer);
initColumnSizes(profile_table);
JScrollPane scroll_pane =
new JScrollPane(
profile_table,
JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,
JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
scroll_pane.setBorder(BorderFactory.createEmptyBorder(0, _MARGIN, _MARGIN, _MARGIN));
add(scroll_pane, BorderLayout.CENTER);
pack();
}
public void stateChanged(ChangeEvent e) {
SliderValuePanel control = (SliderValuePanel)e.getSource();
int index = threshold_controls.indexOf(control);
if (index > -1) {
SCProfile p = (SCProfile) profiles.get(index);
if (control.isValueForSlider()) {
p.setThresholdByPercentile(control.getValue());
} else p.setThreshold(control.getValue());
setFresh(false);
} else {
profileList.setGroupThresholdByPercentile(control.getValue());
for (Iterator itr = threshold_controls.iterator(); itr.hasNext();) {
SliderValuePanel ctrl = (SliderValuePanel)itr.next();
ctrl.setValue(control.getValue());
}
t_model.fireTableDataChanged();
}
}
public void updateData() {
profiles = new ArrayList();
if (threshold_controls == null) threshold_controls = new ArrayList();
else threshold_controls.clear();
for (int i = 0; i < profileList.size(); i++) {
final SCProfile profile = profileList.getProfile(i);
profiles.add(profile);
Map thresh_map = profile.getThresholdPercentileMap();
SliderValuePanel control =
new SliderValuePanel(
null,
thresh_map,
0,
100,
profile.getThresholdPercentile());
control.setToolTipText(_PERCENTILE_TOOLTIP, _THRESHOLD_TOOLTIP);
control.addChangeListener(this);
threshold_controls.add(control);
}
if (t_model != null) {
initColumnSizes(profile_table);
t_model.fireTableDataChanged();
editor.cancelCellEditing();
}
}
}
private class ProfilesTab extends JPanel {
private AbstractTableModel t_model;
private JTable profile_table;
private TableCellRenderer h_renderer = null;
private List tracks = null;
private int pushedColumn = -1;
public ProfilesTab() {
super(new BorderLayout(0, 0));
jbinit();
}
public void updateData() {
try {
tracks = current_relation.getTrackOrder(ref_track);
t_model.fireTableStructureChanged();
t_model.fireTableDataChanged();
} catch (TrackRelationshipException e) {
Log.printStackTrace(e);
tracks = new ArrayList();
}
}
public boolean singleSequenceColumnExists() {
for (int i = 0; i < SCProfileList.__NUM_CUSTOM_PROFILES; i++) {
SCProfile profile = profileList.getCustomProfile(i);
List seqs = profile.getSequences();
if (seqs != null && seqs.size() == 1) return true;
}
return false;
}
public void setPressedColumn(int col) {
pushedColumn = col;
}
void jbinit() {
try {
tracks = current_relation.getTrackOrder(ref_track);
} catch (TrackRelationshipException e) {
Log.printStackTrace(e);
b_cancel_actionPerformed(null);
return;
}
t_model = new AbstractTableModel() {
public Object getValueAt(int row, int col) {
int trk_id = ((Integer)tracks.get(row)).intValue();
if (col == 0) {
try {
return current_relation.getRelatedName(trk_id);
} catch (TrackRelationshipException e) {
Log.printStackTrace(e);
return "Error Unkown";
}
} else {
SCProfile profile;
if (col <= SCProfileList.__NUM_CUSTOM_PROFILES)
profile = profileList.getCustomProfile(col - 1);
else
profile =
profileList.getPredefinedProfile(
col - 1 - SCProfileList.__NUM_CUSTOM_PROFILES);
if (profile != null)
return new Boolean(
profile.getSequences().contains(new Integer(trk_id)));
else
return new Boolean(false);
}
}
public void setValueAt(Object aValue, int row, int col) {
int trk_id = ((Integer)tracks.get(row)).intValue();
if (col == 0) {
return;
} else
profileList.setCustomProfile(
col - 1,
trk_id,
((Boolean)aValue).booleanValue());
setFresh(false);
fireTableChanged(new TableModelEvent(this, row));
}
public int getRowCount() {
return tracks.size();
}
public int getColumnCount() {
int num_cols = profileList.size() + profileList.numInactive() + 1;
return num_cols;
}
public Class getColumnClass(int columnIndex) {
if (columnIndex == 0)
return String.class;
else
return Boolean.class;
}
public String getColumnName(int column) {
if (column == 0)
return "Sequence";
if (column <= SCProfileList.__NUM_CUSTOM_PROFILES) {
return "C" + column;
}
return "P" + (column - SCProfileList.__NUM_CUSTOM_PROFILES);
}
public boolean isCellEditable(int rowIndex, int columnIndex) {
return columnIndex > 0
&& columnIndex <= SCProfileList.__NUM_CUSTOM_PROFILES;
}
};
h_renderer = new TableCellRenderer() {
JButton button = new JButton();
public Component getTableCellRendererComponent(JTable table, Object value,
boolean isSelected, boolean hasFocus, int row, int col) {
SCProfile profile;
if (col <= SCProfileList.__NUM_CUSTOM_PROFILES)
profile = profileList.getCustomProfile(col - 1);
else
profile =
profileList.getPredefinedProfile(
col - 1 - SCProfileList.__NUM_CUSTOM_PROFILES);
button.setText((value ==null) ? "" : value.toString());
button.setMargin(new Insets(0,0,0,0));
try {
button.setBackground(profile.getColour());
} catch (NullPointerException e) {
button.setBackground(SCProfileDialog.this.getBackground());
}
boolean isPressed = (col == pushedColumn);
button.getModel().setPressed(isPressed);
button.getModel().setArmed(isPressed);
return button;
}
};
profile_table = new JTable(t_model) {
return false;
}*/
public void createDefaultColumnsFromModel() {
final JTableHeader header = getTableHeader();
if (header != null) {
MouseListener[] listeners = header.getMouseListeners();
for (int i = 0; i < listeners.length; i++) header.removeMouseListener(listeners[i]);
}
super.createDefaultColumnsFromModel();
TableColumnModel cm = getColumnModel();
for (int i=1; i < cm.getColumnCount(); i++) {
TableColumn col = cm.getColumn(i);
if (col != null) try {
assert(h_renderer != null);
col.setHeaderRenderer(h_renderer);
col.setMinWidth(20);
col.setMaxWidth(40);
} catch (NullPointerException e) {
}
}
TableColumn column = cm.getColumn(0);
column.setPreferredWidth(200);
column.setMinWidth(200);
if (header != null) {
MouseAdapter m_adapter = new MouseAdapter() {
public void mousePressed(MouseEvent e) {
int col = header.columnAtPoint(e.getPoint());
if (col == 0) return;
setPressedColumn(col);
header.repaint();
SCProfile profile = profileList.getCustomProfile(col - 1);
if (col > SCProfileList.__NUM_CUSTOM_PROFILES) {
profile = profileList.getPredefinedProfile(col - SCProfileList.__NUM_CUSTOM_PROFILES - 1);
}
if (profile == null) return;
Color currentColour = profile.getColour();
Color newColour = JColorChooser.showDialog(
ProfilesTab.this,
"Choose a Profile Colour",
currentColour);
if (newColour != null && !Arrays.equals(currentColour.getColorComponents(null),
newColour.getColorComponents(null))) {
profile.setColour(newColour);
setFresh(false);
}
mouseReleased(e);
}
public void mouseReleased(MouseEvent e) {
setPressedColumn(-1);
header.repaint();
}
};
header.addMouseListener(m_adapter);
}
}
};
TableCellRenderer bool_renderer = new TableCellRenderer() {
JCheckBox box = new JCheckBox();
public Component getTableCellRendererComponent(
JTable table,
Object value,
boolean isSelected,
boolean hasFocus,
int row,
int column) {
box.setHorizontalAlignment(JLabel.CENTER);
if (column > SCProfileList.__NUM_CUSTOM_PROFILES) {
box.setForeground(table.getForeground());
box.setBackground(new Color(255, 255, 204));
} else {
box.setForeground(table.getForeground());
box.setBackground(table.getBackground());
}
box.setSelected((value != null && ((Boolean)value).booleanValue()));
return box;
}
};
profile_table.setDefaultRenderer(
Boolean.class,
bool_renderer);
JScrollPane scroll_pane =
new JScrollPane(
profile_table,
JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,
JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
scroll_pane.setBorder(BorderFactory.createEmptyBorder(0, _MARGIN, _MARGIN, _MARGIN));
scroll_pane.setColumnHeaderView(new JLabel("Profiles"));
add(scroll_pane, BorderLayout.CENTER);
final JLabel warning_label = new JLabel("WARNING: Profiles with single sequences will be ignored.");
warning_label.setForeground(Color.RED);
warning_label.setVisible(false);
warning_label.setBorder(BorderFactory.createEmptyBorder(0, _MARGIN, 0, 0));
add(warning_label, BorderLayout.SOUTH);
t_model.addTableModelListener(new TableModelListener() {
public void tableChanged(TableModelEvent e) {
warning_label.setVisible(singleSequenceColumnExists());
}
});
t_model.fireTableStructureChanged();
pack();
}
}
private class AdvancedTab extends JPanel implements ChangeListener {
private GridBagConstraints gbc = new GridBagConstraints();
private SCProfile selected_profile = null;
private int selected_profile_index;
private JComboBox p_chooser;
private JComboBox cs_chooser;
private JLabel island_label;
private PercentileDistributionGraph pd_graph;
public AdvancedTab() {
super(new BorderLayout(0,0));
jbinit();
}
public void updateData() {
if (p_chooser != null) {
p_chooser.removeAllItems();
int list_size = profileList.size();
int selected = -1;
ActionListener[] listeners = p_chooser.getActionListeners();
for (int i = 0; i < listeners.length; i++) p_chooser.removeActionListener(listeners[i]);
for (int i = 0; i < list_size; i++) {
SCProfile profile = profileList.getProfile(i);
if (selected == -1 && profile.isVisible())
selected = i;
p_chooser.addItem(profile);
}
for (int i = 0; i < listeners.length; i++) p_chooser.addActionListener(listeners[i]);
p_chooser.setSelectedIndex(Math.max(selected, 0));
}
}
private void jbinit() {
JPanel global_control_panel = new JPanel(new GridBagLayout());
JPanel profile_control_panel = new JPanel(new GridBagLayout());
Border border = BorderFactory.createEtchedBorder();
global_control_panel.setBorder(BorderFactory.createTitledBorder(border, "Profile Calculation Options"));
profile_control_panel.setBorder(BorderFactory.createTitledBorder(border, "Percentile Distributions"));
ListCellRenderer renderer = new ListCellRenderer() {
JPanel panel = new JPanel();
public Component getListCellRendererComponent(
JList list,
Object value,
int index,
boolean isSelected,
boolean cellHasFocus) {
SCProfile profile = (SCProfile)value;
if (profile == null) {
panel.setBackground(list.getBackground());
panel.removeAll();
panel.add(new JLabel("NA"));
return panel;
}
int num_profiles = profileList.size();
for (index = 0; index < num_profiles; index++)
if (profile == profileList.getProfile(index))
break;
Color color = profile.getColour();
if (color == null)
color = Color.WHITE;
if (!isSelected) {
color =
new Color(
Math.max(color.getRed() - 50, 0),
Math.max(color.getGreen() - 50, 0),
Math.max(color.getBlue() - 50, 0));
}
panel.setBackground(color);
panel.removeAll();
panel.add(new JLabel(profileList.getProfileOrderTag(index)));
return panel;
}
};
JPanel p_panel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 0));
p_chooser = new JComboBox();
p_chooser.setToolTipText("Select a profile to view its distribution graph");
p_chooser.setRenderer(renderer);
p_chooser.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
setSelectedProfile(p_chooser.getSelectedIndex());
}
});
JLabel p_label = new JLabel("Selected profile");
p_label.setLabelFor(p_chooser);
p_panel.add(p_label);
p_panel.add(p_chooser);
gbc.gridx = 0;
gbc.gridy = 0;
gbc.anchor = GridBagConstraints.NORTHWEST;
profile_control_panel.add(p_panel, gbc);
JPanel isl_panel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 0));
isl_panel.setToolTipText("Average run of un-smoothed column scores greater than selected threshold");
gbc.gridy = 1;
gbc.insets = new Insets(0, 0, 0, 0);
JLabel isl_label = new JLabel("Average island");
island_label = new JLabel(" ");
isl_panel.add(isl_label);
isl_panel.add(island_label);
profile_control_panel.add(isl_panel, gbc);
pd_graph = new PercentileDistributionGraph("Threshold");
pd_graph.addChangeListener(this);
gbc.gridx = 0;
gbc.gridwidth = GridBagConstraints.REMAINDER;
gbc.gridy = 2;
gbc.fill = GridBagConstraints.BOTH;
gbc.weightx = 100;
gbc.weighty = 100;
profile_control_panel.add(pd_graph, gbc);
gbc = new GridBagConstraints();
Object[] cs_choices = SCProfileList.__COLUMN_SCORING_METHODS;
cs_chooser = new JComboBox(cs_choices);
cs_chooser.setSelectedItem(profileList.getColScoreMethod());
cs_chooser.setToolTipText("Select an algorithm for profile column scoring");
cs_chooser.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
String method = (String)cs_chooser.getSelectedItem();
int index = Arrays.binarySearch(SCProfileList.__COLUMN_PHYLO_SCORING_METHODS, method);
if (index >= 0) {
String rel_type = profileList.getTrackRelationship().getType();
if (!rel_type.equals(TrackRelationshipOrderInterface.TYPE_PHYLODISTANCE) &&
!rel_type.equals(TrackRelationshipOrderInterface.TYPE_HOMOLOGOUS)) {
JOptionPane.showMessageDialog(((JComboBox)e.getSource()).getParent(), "Warning: The " + method + " column scoring method is"
+ " for use with phylogenetic sequence relationships.\nThe currently selected relationship, " +
rel_type + ", may give undefined results.");
}
}
profileList.setColumnScoreMethod(method);
setFresh(false);
setSelectedProfile(selected_profile_index);
}
});
gbc.gridx = 0;
gbc.gridy = 0;
gbc.anchor = GridBagConstraints.EAST;
gbc.insets = new Insets(0, 0, _MARGIN, 0);
JLabel cs_label = new JLabel("Column scoring");
cs_label.setLabelFor(cs_chooser);
global_control_panel.add(cs_label, gbc);
gbc.gridx = 1;
gbc.gridy = 0;
gbc.anchor = GridBagConstraints.WEST;
gbc.insets = new Insets(0,10,_MARGIN,0);
global_control_panel.add(cs_chooser, gbc);
global_control_panel.setAlignmentY(JComponent.TOP_ALIGNMENT);
Object[] ws_choices = SCProfileList.__WINDOW_SMOOTHING_METHODS;
final JComboBox ws_chooser = new JComboBox(ws_choices);
ws_chooser.setSelectedItem(profileList.getSmoothingMethod());
ws_chooser.setToolTipText("Select a window averaging algorithm for smoothing column scores");
ws_chooser.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
profileList.setWindowSmoothMethod(
(String)ws_chooser.getSelectedItem());
setFresh(false);
setSelectedProfile(selected_profile_index);
}
});
gbc.gridx = 0;
gbc.gridy = 1;
gbc.anchor = GridBagConstraints.EAST;
JLabel ws_label = new JLabel("Smoothing");
ws_label.setLabelFor(ws_chooser);
global_control_panel.add(ws_label, gbc);
gbc.gridx = 1;
gbc.gridy = 1;
gbc.anchor = GridBagConstraints.WEST;
global_control_panel .add(ws_chooser, gbc);
SliderValuePanel ws_slider =
new SliderValuePanel(
null,
null,
1,
200,
profileList.getWindowSize());
ws_slider.addChangeListener(this);
ws_slider.setToolTipText("Select a window size for smoothing column scores", null);
gbc.gridx = 0;
gbc.gridy = 2;
gbc.insets = new Insets(0,0,0,0);
gbc.anchor = GridBagConstraints.EAST;
JLabel wss_label = new JLabel("Window size");
wss_label.setLabelFor(ws_slider);
global_control_panel.add(wss_label, gbc);
gbc.gridx = 1;
gbc.gridy = 2;
gbc.anchor = GridBagConstraints.WEST;
global_control_panel .add(ws_slider, gbc);
SliderValuePanel step_slider =
new SliderValuePanel(
null,
null,
1,
100,
profileList.getStepSize()) {
void valueChanged(float value, boolean ignore) {
profileList.setStepSize((int)value);
setSelectedProfile(selected_profile_index);
}
};
gbc.gridx = 0;
gbc.gridy = 3;
gbc.anchor = GridBagConstraints.EAST;
JLabel step_label = new JLabel("Step Size:");
step_label.setLabelFor(step_slider);
global_control_panel.add(step_label, gbc);
gbc.gridx = 1;
gbc.gridy = 3;
gbc.anchor = GridBagConstraints.WEST;
global_control_panel .add(step_slider, gbc);*/
val_button.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
ValueMapDialog vmd = new ValueMapDialog(selected_profile);
}
});
gbc.gridx = 1;
gbc.gridy = 6;
gbc.anchor = GridBagConstraints.CENTER;
global_control_panel.add(val_button, gbc);*/
add(global_control_panel, BorderLayout.WEST);
add(profile_control_panel, BorderLayout.CENTER);
}
protected void setSelectedProfile(int p_index) {
SCProfile selected = profileList.getProfile(p_index);
if (selected == null) return;
selected_profile = selected;
selected_profile_index = p_index;
Map distrib_map = selected_profile.getThresholdPercentileMap();
if (distrib_map == null) distrib_map = new HashMap();
float[] values = new float[distrib_map.size()];
float[] percentiles = new float[distrib_map.size()];
int index = 0;
for (Iterator itr = distrib_map.keySet().iterator(); itr.hasNext();) {
Float key = (Float)itr.next();
Float value = (Float)distrib_map.get(key);
values[index] = value.floatValue();
percentiles[index++] = key.floatValue();
}
island_label.setText(selected_profile.getAverageIsland() + "");
pd_graph.removeChangeListener(this);
pd_graph.setDistributionValues(
values,
percentiles,
selected_profile.getThreshold());
pd_graph.addChangeListener(this);
pd_graph.setVisible(false);
pd_graph.setVisible(true);
}
public void stateChanged(ChangeEvent arg0) {
if (arg0.getSource() instanceof PercentileDistributionGraph) {
try {
float threshold = pd_graph.getXValue();
selected_profile.setThreshold(threshold);
setFresh(false);
island_label.setText(selected_profile.getAverageIsland() + "");
} catch (NullPointerException e) {
Log.printStackTrace(e);
e.printStackTrace();
}
} else {
SliderValuePanel p = (SliderValuePanel)arg0.getSource();
profileList.setWindowSize((int)p.getValue());
setFresh(false);
setSelectedProfile(selected_profile_index);
}
}
}
protected class SliderValuePanel extends JPanel {
JLabel label = null;
JSlider slider;
JFormattedTextField edit_box = null;
JFormattedTextField edit_box2 = null;
NumberFormat edit_format = NumberFormat.getNumberInstance();
NumberFormat edit2_format = NumberFormat.getNumberInstance();
Map floatValueMap;
List change_listeners = new ArrayList();
float value = 0;
boolean value_of_slider = true;
public SliderValuePanel(
String new_label,
Map fvalueMap,
int min,
int max,
float start) {
super(new FlowLayout(FlowLayout.LEFT));
this.floatValueMap = fvalueMap;
slider = new JSlider(min, max, max);
if (floatValueMap != null) {
slider.setMinimum(0);
slider.setMaximum(floatValueMap.size() - 1);
}
slider.setPreferredSize(new Dimension(150, 15));
setSliderFloatValue(start);
if (new_label != null) {
this.label = new JLabel(new_label);
label.setLabelFor(slider);
}
edit_format.setMaximumFractionDigits(floatValueMap == null ? 0 : 2);
edit_format.setMinimumIntegerDigits(1);
edit_box = new JFormattedTextField(edit_format);
edit_box.setColumns(floatValueMap == null ? 3 : 4);
edit_box.setValue(new Float(start));
try {
edit_box.setValue(new Float(start));
} catch (Exception e) {
e.printStackTrace();
}
if (floatValueMap != null) {
edit2_format.setMaximumFractionDigits(2);
edit2_format.setMinimumIntegerDigits(1);
edit_box2 = new JFormattedTextField(edit2_format);
edit_box2.setColumns(4);
edit_box2.setValue(new Float(box1Tobox2Value(start)));
}
slider.addMouseListener(new MouseAdapter() {
public void mouseReleased(MouseEvent e) {
synchValuesFrom(slider);
}
});
slider.addKeyListener(new KeyListener() {
public void keyTyped(KeyEvent e) {}
public void keyPressed(KeyEvent e) {}
public void keyReleased(KeyEvent e) {
int key = e.getKeyCode();
if (key == KeyEvent.VK_DOWN
|| key == KeyEvent.VK_UP
|| key == KeyEvent.VK_LEFT
|| key == KeyEvent.VK_RIGHT)
synchValuesFrom(slider);
}
});
edit_box.addFocusListener(new java.awt.event.FocusAdapter() {
public void focusLost(FocusEvent e) {
try {
edit_box.commitEdit();
} catch (ParseException p) {
}
synchValuesFrom(edit_box);
}
});
edit_box.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
synchValuesFrom(edit_box);
}
});
edit_box.addKeyListener(new KeyAdapter() {
public void keyPressed(KeyEvent e) {
setFresh(false);
}
});
if (edit_box2 != null) {
edit_box2.addFocusListener(new java.awt.event.FocusAdapter() {
public void focusLost(FocusEvent e) {
try {
edit_box2.commitEdit();
} catch (ParseException p) {
}
synchValuesFrom(edit_box2);
}
});
edit_box2.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
synchValuesFrom(edit_box2);
}
});
}
if (label != null)
this.add(label);
this.add(slider);
this.add(edit_box);
if (edit_box2 != null){
this.add(new JLabel("% "));
this.add(edit_box2);
this.add(new JLabel("Score"));
}
}
protected void setValue(float value) {
setSliderFloatValue(value);
synchValuesFrom(slider);
}
protected void setToolTipText(String text, String text2) {
slider.setToolTipText(text);
edit_box.setToolTipText(text);
if (edit_box2 != null && text2 != null) edit_box2.setToolTipText(text2);
}
protected float getValue() {
return value;
}
protected boolean isValueForSlider() {
return value_of_slider;
}
protected void synchValuesFrom(JComponent c) {
try {
boolean from_second_value = false;
float out_value = 0;
if (c == edit_box) {
out_value = Float.parseFloat(edit_box.getValue().toString());
if (out_value > slider.getMaximum()) {
out_value = slider.getMaximum();
if (floatValueMap != null) out_value = 100;
edit_box.setValue(new Float(out_value));
}
setSliderFloatValue(out_value);
if (edit_box2 != null) {
edit_box2.setText(edit2_format.format(box1Tobox2Value(out_value)));
edit_box2.commitEdit();
}
} else if (c == edit_box2 && edit_box2 != null) {
from_second_value = true;
out_value = Float.parseFloat(edit_box2.getValue().toString());
float box1_value = box2Tobox1Value(out_value);
setSliderFloatValue(box1_value);
edit_box.setText(edit_format.format(box1_value));
edit_box.commitEdit();
} else if (c == slider) {
out_value = getSliderFloatValue();
edit_box.setText(edit_format.format(out_value));
edit_box.commitEdit();
if (edit_box2 != null) {
edit_box2.setText(edit2_format.format(box1Tobox2Value(out_value)));
edit_box2.commitEdit();
}
} else
return;
value = out_value;
value_of_slider = !from_second_value;
fireChange();
} catch (ParseException e) {
e.printStackTrace();
}
}
protected float box1Tobox2Value(float value) {
Float box2_val = (Float)floatValueMap.get(new Float(value));
if (box2_val != null) return box2_val.floatValue();
List floatValues = new ArrayList(floatValueMap.values());
List floatKeys = new ArrayList(floatValueMap.keySet());
int index = 0;
float lastVal = 0;
for (index = 0; index < floatKeys.size(); index++) {
float key = ((Float)floatKeys.get(index)).floatValue();
if (key >= value) {
if (value - lastVal < key - value && index > 0) {
index--;
}
break;
}
lastVal = key;
}
if (index >= floatValues.size())
index = floatValues.size() - 1;
Float slider_value = (Float)floatValues.get(index);
return slider_value.floatValue();
}
protected float box2Tobox1Value(float value) {
List floatValues = new ArrayList(floatValueMap.values());
List floatKeys = new ArrayList(floatValueMap.keySet());
int index = 0;
float lastVal = 0;
for (index = 0; index < floatValues.size(); index++) {
float val = ((Float)floatValues.get(index)).floatValue();
if (val >= value) {
if (value - lastVal < val - value && index > 0) {
index--;
}
break;
}
lastVal = val;
}
if (index >= floatValues.size())
index = floatValues.size() - 1;
Float slider_value = (Float)floatKeys.get(index);
return slider_value.floatValue();
}
private void setSliderFloatValue(float value) {
int index = (int) (value + 0.5f);
if (floatValueMap != null) {
float lastVal = 0;
List floatValues = new ArrayList(floatValueMap.keySet());
index = floatValues.indexOf(new Float(value));
if (index == -1) {
for (index = 0; index < floatValues.size(); index++) {
float val = ((Float)floatValues.get(index)).floatValue();
if (val >= value) {
if (value - lastVal < val - value && index > 0) {
index--;
}
break;
}
lastVal = val;
}
if (index >= floatValues.size())
index = floatValues.size() - 1;
}
}
slider.setValue(index);
}
private float getSliderFloatValue() {
int index = slider.getValue();
if (floatValueMap == null)
return index;
List vals = new ArrayList(floatValueMap.keySet());
return ((Float)vals.get(index)).floatValue();
}
protected void addChangeListener(ChangeListener cl) {
if (!change_listeners.contains(cl)) change_listeners.add(cl);
}
protected void fireChange() {
ChangeEvent e = new ChangeEvent(this);
for (int i = 0; i < change_listeners.size(); i++) {
ChangeListener cl = (ChangeListener)change_listeners.get(i);
cl.stateChanged(e);
}
}
}
private static void initColumnSizes(JTable table) {
TableModel model = table.getModel();
TableColumn column = null;
Component comp = null;
int headerWidth = 0;
int cellWidth = 0;
TableCellRenderer headerRenderer =
table.getTableHeader().getDefaultRenderer();
for (int i = 0; i < 5; i++) {
column = table.getColumnModel().getColumn(i);
column.setResizable(false);
comp =
headerRenderer.getTableCellRendererComponent(
null,
column.getHeaderValue(),
false,
false,
0,
0);
headerWidth = comp.getPreferredSize().width;
comp =
table.getDefaultRenderer(
model.getColumnClass(i)).getTableCellRendererComponent(
table,
null,
false,
false,
0,
i);
cellWidth = comp.getPreferredSize().width;
column.setPreferredWidth(Math.max(headerWidth, cellWidth));
}
}
}
package ca.bcgsc.sockeye.gui.alignment;
import java.awt.BasicStroke;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Frame;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.LayoutManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Stroke;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.AdjustmentEvent;
import java.awt.event.AdjustmentListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.WindowListener;
import java.io.File;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import javax.swing.AbstractAction;
import javax.swing.BorderFactory;
import javax.swing.ButtonGroup;
import javax.swing.JComboBox;
import javax.swing.JDialog;
import javax.swing.JFileChooser;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JScrollPane;
import javax.swing.JSplitPane;
import javax.swing.JTable;
import javax.swing.SwingUtilities;
import javax.swing.table.JTableHeader;
import javax.swing.table.TableCellRenderer;
import ca.bcgsc.sockeye.analysis.Alignment;
import ca.bcgsc.sockeye.analysis.scprofile.SCProfile;
import ca.bcgsc.sockeye.analysis.scprofile.SCProfileList;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.datastorage.StorageException;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.gui.MainFrame;
import ca.bcgsc.sockeye.gui.Sockeye;
import ca.bcgsc.sockeye.io.ALNExporter;
import ca.bcgsc.sockeye.io.FASTAExporter;
import ca.bcgsc.sockeye.io.SCProfileExporter;
import ca.bcgsc.sockeye.trackmanager.AlignOperation;
import ca.bcgsc.sockeye.util.Log;
import ca.bcgsc.sockeye.util.StringUtils;
import ca.bcgsc.util.CoordinateUtils;
import ca.bcgsc.util.gui.SequenceColor;
import ca.bcgsc.util.gui.scomponents.RestrictedFormatFileChooser;
public class SingleAlignmentDialog implements AlignmentHighlightListener {
private JDialog mainFrame;
private SingleAlignmentGraph align_graph;
private JScrollPane textScrollPane = new JScrollPane();
private JScrollPane rowLabelScrollPane = new JScrollPane();
private RowTable name_table;
private JSplitPane view_split_pane = new JSplitPane();
private JSplitPane label_split_pane = new JSplitPane();
private ColumnHeader columnHeader;
private AlignmentSequencePanel seq_panel;
private Frame parent;
including the start, length, and whether the track is reversed.*/
protected TrackFeature[] highlight3Dfeatures;
protected int[] trackStartLocations;
protected int[] trackLengths;
protected boolean[] reverseFlag;
private boolean mouseEvent = false;
private static final Font _DEFAULT_TEXTAREA_FONT =
new Font("Monospaced", Font.PLAIN, 12);
private static Font _DEFAULT_LABEL_FONT = new Font("Dialog", Font.PLAIN, 12);
private static int _FONT_WIDTH = 7;
private static int _ROW_HEIGHT = 17;
private static final Color _BACKGROUND_COLOR = Color.WHITE;
private static final char gapChar = '-';
private static final char matchChar = '|';
private static final LayoutManager _PANEL_LAYOUT =
new BorderLayout();
private AlignOperation align_op = null;
private int[] align_seqs;
private Alignment alignment;
private List anchors;
private SCProfileList scprofileList;
private SCProfile scprofile = null;
private List alnHighlightListeners = new ArrayList();
private static Map open_windows = new Hashtable();
public SingleAlignmentDialog(
Frame parent,
Alignment alignment, List anchors,
int ref_track) {
this.alignment = alignment;
this.anchors = anchors;
this.scprofileList = alignment.getSCProfileList();
this.parent = parent;
this.align_op = alignment.getParentOperation();
registerWindow(align_op, this);
if (align_op.getSubalignments().size() > 1)
sub_string = " (Sub-alignment " + alignment.getID() + ")";
String dialogTitle =
align_op.getAlignApplication()
+ " Alignment "
+ align_op.getAlignID()
+ sub_string;*/
String dialogTitle = alignment.getIdentityTag();
align_seqs = alignment.getSequenceIDs();
mainFrame = new JDialog(parent, dialogTitle, false) {
public void dispose() {
unregisterWindow(align_op, SingleAlignmentDialog.this);
removeHighlight();
super.dispose();
}
};
mainFrame.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);
MultiAlignmentGraph.notifySingleAlignmentDialogOpened(this);
if (java.lang.System.getProperty("os.name").startsWith(("Windows"))) {
_ROW_HEIGHT = 17;
}
else {
_ROW_HEIGHT = 15;
_DEFAULT_LABEL_FONT = new Font("Dialog", Font.PLAIN, 10);
}
int start = alignment.getStart(ref_track);
int end = alignment.getGappedEnd(ref_track);
int strand = alignment.onNegativeStrand(ref_track) ? -1 : 1;
TrackFeature alignmentRegion =
new TrackFeature("vertical region", getClass().getName(), "vertical alignment sequence highlight", start, start + 100, 0, strand, 0 );
alignmentRegion.setTrackId(ref_track);
alignmentRegion.setAttribute(
"display_string",
"Alignment window scroll region");
addAlignmentSequenceHighlight(alignmentRegion, start, end);
init();
}
private void init() {
mainFrame.getContentPane().setLayout(new BorderLayout());
mainFrame.setLocation(200, 200);
textScrollPane.setViewportView(new JPanel());
textScrollPane.setColumnHeaderView(new JPanel());
textScrollPane.setVerticalScrollBarPolicy(
JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
textScrollPane.setHorizontalScrollBarPolicy(
JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);
rowLabelScrollPane.setVerticalScrollBarPolicy(
JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
rowLabelScrollPane.setHorizontalScrollBarPolicy(
JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
label_split_pane.setLeftComponent(rowLabelScrollPane);
label_split_pane.setRightComponent(textScrollPane);
JPanel blankPanel = new JPanel();
blankPanel.setBackground(Configuration.gui_blue);
textScrollPane.setCorner(JScrollPane.UPPER_RIGHT_CORNER, blankPanel);
textScrollPane.getHorizontalScrollBar().setUnitIncrement(_FONT_WIDTH);
rowLabelScrollPane.setVerticalScrollBar(
textScrollPane.getVerticalScrollBar());
textScrollPane.setVerticalScrollBar(
rowLabelScrollPane.getVerticalScrollBar());
textScrollPane
.getHorizontalScrollBar()
.addMouseListener(new MouseAdapter() {
public void mousePressed(MouseEvent e) {
mouseEvent = true;
}
public void mouseReleased(MouseEvent e) {
updateFeatureLocation(
highlight3Dfeatures,
trackStartLocations,
trackLengths,
reverseFlag);
updateSequenceHighlight(highlight3Dfeatures);
mouseEvent = false;
}
});
final SingleAlignmentDialog source = this;
textScrollPane
.getHorizontalScrollBar()
.addAdjustmentListener(new AdjustmentListener() {
public void adjustmentValueChanged(AdjustmentEvent e) {
updateRangeLabel();
int half_font = Math.round(_FONT_WIDTH / 2);
int current_pos = Math.round((textScrollPane.getViewport().getViewPosition().x + half_font) / _FONT_WIDTH);
int vis_length = Math.round((textScrollPane.getViewport().getWidth() + half_font) / _FONT_WIDTH);
int scroll_length = trackLengths[0];
AlignmentHighlightEvent event = new AlignmentHighlightEvent(source, alignment);
for (int index = 1; index < trackStartLocations.length; index++) {
int seq_id = highlight3Dfeatures[index].getTrackId();
int start = trackStartLocations[index] + current_pos;
int end = start + vis_length - 1;
if (reverseFlag[index]) {
end = trackStartLocations[index] + scroll_length - current_pos - 1;
start = end - vis_length + 1;
}
event.addRegion(seq_id, start, end);
}
for (int i = 0; i < alnHighlightListeners.size(); i++) {
((AlignmentHighlightListener)alnHighlightListeners.get(i)).handleAlignmentHighlight(event);
}
if (highlight3Dfeatures != null
&& reverseFlag != null
&& !mouseEvent) {
updateFeatureLocation(
highlight3Dfeatures,
trackStartLocations,
trackLengths,
reverseFlag);
updateSequenceHighlight(highlight3Dfeatures);
}
}
});
columnHeader = new ColumnHeader();
List alignments = new ArrayList();
alignments.add(alignment);
align_graph = new SingleAlignmentGraph(alignments, anchors);
mainFrame.addWindowListener(align_graph);
addAlignmentHighlightListener(align_graph);
align_graph.addAlignmentHighlightListener(this);
align_graph.setMinimumSize(new Dimension(200,200));
align_graph.setPreferredSize(new Dimension(500,500));
JPanel seq_view_panel = new JPanel();
seq_view_panel.setLayout(new BorderLayout());
seq_view_panel.add(columnHeader, BorderLayout.NORTH);
seq_view_panel.add(label_split_pane, BorderLayout.CENTER);
seq_view_panel.setMinimumSize(new Dimension(1,1));
seq_view_panel.setPreferredSize(new Dimension(600,130 + (50 * alignment.getSequenceIDs().length)));
view_split_pane = new JSplitPane(JSplitPane.VERTICAL_SPLIT,
align_graph, seq_view_panel);
view_split_pane.setBorder(Configuration.gui_blue_border);
view_split_pane.setOneTouchExpandable(true);
mainFrame.getContentPane().add(view_split_pane);
mainFrame.setSize(600,600);
this.show();
view_split_pane.setDividerLocation(0.6f);
}
public void show() {
mainFrame.show();
reloadTextArea(convertSequence(align_seqs));
}
public void addAlignmentHighlightListener(AlignmentHighlightListener listener) {
if (!alnHighlightListeners.contains(listener))
alnHighlightListeners.add(listener);
}
public void addAlignmentSequenceHighlight(TrackFeature feature, int start, int end) {
if (alignment != null) {
int size = align_seqs.length + 1;
trackStartLocations = new int[size];
trackLengths = new int[size];
reverseFlag = new boolean[size];
highlight3Dfeatures = new TrackFeature[size];
trackStartLocations[0] = start;
trackLengths[0] = end - start + 1;
highlight3Dfeatures[0] = feature;
for (int index = 1; index < size; index++) {
try {
int trackID = align_seqs[index - 1];
int startLocation = alignment.getStart(trackID);
trackStartLocations[index] = startLocation;
trackLengths[index] = alignment.getGappedEnd(trackID) - startLocation + 1;
reverseFlag[index] = alignment.onNegativeStrand(trackID);
if (index == 1) {
reverseFlag[0] = reverseFlag[1];
}
int strand = reverseFlag[index] ? -1 : 1;
TrackFeature alignmentRegion =
new TrackFeature("alignment sequence highlight", getClass().getName(), "alignment sequence highlight", startLocation, feature.getStart() + 100, 0, strand, 0 );
alignmentRegion.setAttribute(
"display_string",
"Alignment window scroll region");
alignmentRegion.setTrackId(trackID);
highlight3Dfeatures[index] = alignmentRegion;
}
catch (StorageException e) {
highlight3Dfeatures[index] = null;
}
}
}
}
private void reloadScore(boolean barType) {
ColumnScoresPanel scoresPanel = new ColumnScoresPanel(barType);
this.textScrollPane.setColumnHeaderView(scoresPanel);
textScrollPane.getColumnHeader().setViewPosition(
new Point(
(int) textScrollPane.getViewport().getViewPosition().getX(),
0));
}
private void updateFeatureLocation(
TrackFeature[] features,
int[] theTrackStartLocations,
int[] theTrackLengths,
boolean[] reverse) {
if (features == null || features.length == 0) return;
for (int index = 0; index < reverse.length; index++) {
features[index].setStart(
getRegionStartLocation(
theTrackStartLocations[index],
theTrackLengths[index],
reverse[index]));
features[index].setEnd(
getRegionEndLocation(
theTrackStartLocations[index],
theTrackLengths[index],
reverse[index]));
}
}
private int getRegionStartLocation(
int theTrackStartLocation,
int theTrackLength,
boolean reverse) {
double width = trackLengths[0] * _FONT_WIDTH;
if (reverse) {
double current_pos =
this.textScrollPane.getViewport().getViewPosition().getX()
+ this.textScrollPane.getViewport().getWidth();
int relative_end_location =
((int) Math.round((current_pos / width) * theTrackLength));
if (width != 0) {
return (theTrackLength - relative_end_location) + theTrackStartLocation;
}
else {
return theTrackStartLocation;
}
}
else {
double current_pos =
this.textScrollPane.getViewport().getViewPosition().getX();
int relative_start_location =
((int) Math.round((current_pos / width) * theTrackLength));
if (width != 0) {
return relative_start_location + theTrackStartLocation;
}
else {
return theTrackStartLocation;
}
}
}
private int getRegionEndLocation(
int theTrackStartLocation,
int theTrackLength,
boolean reverse) {
double width = trackLengths[0] * _FONT_WIDTH;
if (reverse) {
double current_pos =
this.textScrollPane.getViewport().getViewPosition().getX();
int relative_start_location =
((int) Math.round((current_pos / width) * theTrackLength));
if (width != 0) {
return (theTrackLength - relative_start_location - 1)
+ theTrackStartLocation;
}
else {
return theTrackStartLocation;
}
}
else {
double current_pos =
this.textScrollPane.getViewport().getViewPosition().getX()
+ this.textScrollPane.getViewport().getWidth();
int relative_end_location =
(int)( Math.round((current_pos / width) * theTrackLength)) ;
if (width != 0) {
return relative_end_location + theTrackStartLocation - 1;
}
else {
return theTrackStartLocation;
}
}
}
private void reloadTextArea(String[] sequences) {
boolean scores[][] = new boolean[sequences.length - 1][0];
for (int counter = 0;
counter < sequences.length - 1;
counter++) {
char[] firstSeq = sequences[counter].toCharArray();
char[] secondSeq = sequences[counter + 1].toCharArray();
scores[counter] = compareSeq(firstSeq, secondSeq, true);
}
seq_panel = new AlignmentSequencePanel(sequences, scores);
textScrollPane.setViewportView(seq_panel);
}
private boolean[] compareSeq(
char[] seq1,
char[] seq2,
boolean ignoreGap) {
int length = Math.min(seq1.length, seq2.length);
boolean[] scores = new boolean[length];
if (ignoreGap) {
for (int index = 0; index < length; index++) {
if (seq1[index] != gapChar && seq1[index] == seq2[index]) {
scores[index] = true;
}
else {
scores[index] = false;
}
}
}
else {
for (int index = 0; index < length; index++) {
if (seq1[index] == seq2[index]) {
scores[index] = true;
}
else scores[index] = false;
}
}
return scores;
}
private void setRowLabel(String[] reversed, String[] trackNames) {
int numOfTracks = trackNames.length;
name_table = new RowTable(numOfTracks * (2) + 7, 1);
int max_seq_length = 0;
int length = alignment.getGappedEnd(align_seqs[0]) - alignment.getStart(align_seqs[0]) + 1;
name_table.setValueAt(" Alignment length: " + CoordinateUtils.getAsUnitString(length, null, 3), 1, 0);
name_table.setValueAt(" Visible range:", 3, 0);
for (int index = 0; index < numOfTracks; index++) {
String seq_title = reversed[index] + " " + trackNames[index];
if (seq_title.length() > max_seq_length) max_seq_length = seq_title.length();
name_table.setValueAt(seq_title, (index * 2) + 6, 0);
}
updateRangeLabel();
label_split_pane.setDividerLocation(Math.min(300, max_seq_length * _FONT_WIDTH));
JTableHeader tableHeader = new JTableHeader();
tableHeader.setReorderingAllowed(false);
tableHeader.setResizingAllowed(false);
name_table.setTableHeader(tableHeader);
rowLabelScrollPane.getViewport().setBackground(_BACKGROUND_COLOR);
rowLabelScrollPane.setViewportView(name_table);
}
private String[] convertSequence(int[] alignment_seq_ids) {
int size = alignment_seq_ids.length;
String[] sequences = new String[size];
String[] sequenceNames = new String[size];
String[] reversed = new String[size];
for (int index = 0; index < size; index++) {
int trackID = alignment_seq_ids[index];
String sequence = alignment.getStrandSequence(trackID, true);
boolean negative_strand = alignment.onNegativeStrand(trackID);
if (negative_strand) {
if (java.lang.System.getProperty("os.name").startsWith(("Windows"))) {
reversed[index] = " (\u2013)";
}
else {
reversed[index] = " (-)";
}
}
else {
reversed[index] = " (+)";
}
sequences[index] = sequence;
String sequenceName = StringUtils.getShortNameForTrackID(trackID);
int i = sequenceName.indexOf("]");
if (i > - 1) {
sequenceName = sequenceName.substring(i + 1);
}
sequenceNames[index] = sequenceName;
}
setRowLabel(reversed, sequenceNames);
return sequences;
}
private void updateSequenceHighlight(TrackFeature[] features) {
if (features == null || features.length == 0) return;
MainFrame.getVis3D().updateAlignmentSequenceHighlights(features);
}
private void updateRangeLabel() {
if (name_table == null) return;
int half_font = Math.round(_FONT_WIDTH / 2);
int current_pos = Math.round((textScrollPane.getViewport().getViewPosition().x + half_font) / _FONT_WIDTH) + 1;
int vis_length = textScrollPane == null ? 100 : Math.round((textScrollPane.getViewport().getWidth() + half_font) / _FONT_WIDTH);
name_table.setValueAt(" " + current_pos + " - " + (current_pos + vis_length - 1) +
" (" + vis_length + "b)", 4, 0);
}
private void removeHighlight() {
if (highlight3Dfeatures != null) {
for (int index = 0; index < highlight3Dfeatures.length; index++) {
if (highlight3Dfeatures[index] != null) {
MainFrame.getVis3D().removeAlignmentSequenceHighlight(
highlight3Dfeatures[index]);
highlight3Dfeatures[index] = null;
}
}
highlight3Dfeatures = null;
trackStartLocations = null;
trackLengths = null;
}
}
class RowTable extends JTable {
Dimension preferredRowHeaderDimension =
this.getPreferredScrollableViewportSize();
int num_of_rows;
public RowTable(int num_of_rows, int num_of_cols) {
super(num_of_rows, num_of_cols);
this.num_of_rows = num_of_rows;
this.preferredRowHeaderDimension.width = 180;
this.getColumnModel().getColumn(0).setMinWidth(180);
if (num_of_cols > 1)this.getColumnModel().getColumn(1).setMinWidth(180);
this.setPreferredScrollableViewportSize(this.preferredRowHeaderDimension);
this.setCellSelectionEnabled(false);
this.setGridColor(Color.white);
this.setDefaultRenderer(Object.class, new TableCellRenderer() {
public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
JLabel label = new JLabel((value == null) ? "" : value.toString());
label.setBorder(BorderFactory.createLineBorder(Color.WHITE));
label.setFont(table.getFont());
label.setAlignmentY(JLabel.RIGHT_ALIGNMENT);
return label;
}
});
this.setRowHeight(SingleAlignmentDialog._ROW_HEIGHT);
this.setFont(SingleAlignmentDialog._DEFAULT_LABEL_FONT);
}
public boolean isCellSelected(int row, int col) {
return false;
}
public boolean isCellEditable(int row, int col) {
return false;
}
public Dimension getPreferredSize() {
return new Dimension(230, num_of_rows * SingleAlignmentDialog._ROW_HEIGHT);
}
}
class ColumnHeader extends JMenuBar implements ActionListener {
new SockeyeButton(
Configuration.export_icon,
"Export conservation profile column scores");
SockeyeButton b_save =
new SockeyeButton(
Configuration.save_icon,
"Save alignment to file");
JComboBox scoreDisplayType = new JComboBox(new String[] { "Bar", "Line" });
JMenu profile_menu = new JMenu("Profile...");
public ColumnHeader() {
super();
this.setBorder(BorderFactory.createRaisedBevelBorder());
menu_bar.setBorder(BorderFactory.createRaisedBevelBorder());
add(menu_bar, BorderLayout.WEST);*/
JMenu export_menu = new JMenu("Options");
add(export_menu);
JMenuItem export_aln = new JMenuItem("Export alignment...");
export_menu.add(export_aln);
export_aln.setActionCommand("ExportAln");
export_aln.addActionListener(this);
JMenuItem export_scp = new JMenuItem("Export profile score...");
export_menu.add(export_scp);
export_scp.setActionCommand("ExportProfile");
export_scp.addActionListener(this);
JMenuItem scp_edit = new JMenuItem("Edit profiles...");
export_menu.add(scp_edit);
scp_edit.setActionCommand("EditProfiles");
scp_edit.addActionListener(this);
b_save.addActionListener(this);
b_save.setActionCommand("Save");
b_export.addActionListener(this);
b_export.setActionCommand("Export");
scoreDisplayType.addActionListener(this);
scoreDisplayType.setActionCommand("ChangeType");
b_panel.add(b_save);
b_panel.add(b_export);*/
JMenu view_menu = new JMenu("View");
add(view_menu);
view_menu.add(profile_menu);
resetProfileMenu();
}
void resetProfileMenu() {
profile_menu.removeAll();
scprofile = null;
ButtonGroup p_group = new ButtonGroup();
AbstractAction p_action = new AbstractAction("All profiles") {
public void actionPerformed(ActionEvent e) {
scprofile = null;
reloadScore(true);
}
};
JRadioButtonMenuItem all_button = new JRadioButtonMenuItem(p_action);
profile_menu.add(all_button);
p_group.add(all_button);
for (int i = 0; i < scprofileList.size(); i++) {
SCProfile profile = scprofileList.getProfile(i);
if (profile.isVisible()) {
p_action = new AbstractAction(profile.getName()) {
public void actionPerformed(ActionEvent e) {
scprofile = (SCProfile)getValue("SCProfile");
reloadScore(true);
}
};
p_action.putValue("SCProfile", profile);
JRadioButtonMenuItem p_button = new JRadioButtonMenuItem(p_action);
p_group.add(p_button);
profile_menu.add(p_button);
}
}
all_button.doClick();
}
protected void disableAll() {
this.b_export.setEnabled(false);
this.b_save.setEnabled(false);
}
protected void enableAll() {
this.b_export.setEnabled(true);
this.b_save.setEnabled(true);
}*/
public void actionPerformed(ActionEvent evt) {
if (evt.getActionCommand().equals("ExportAln")) {
int[] trackIDs = new int[align_seqs.length];
for (int index = 0; index < align_seqs.length; index++) {
int trackID = align_seqs[index];
trackIDs[index] = trackID;
}
save_action(trackIDs);
}
else if (evt.getActionCommand().equals("ExportProfile")) {
List p_list = new ArrayList();
if (scprofile != null) {
int i = 0;
for (i = 0; i < scprofileList.size() && scprofileList.getProfile(i) != scprofile; i++);
if (i < scprofileList.size()) p_list.add(new Integer(i));
}
else for (int i = 0; i < scprofileList.size(); i++){
SCProfile profile = scprofileList.getProfile(i);
if (profile.isVisible()) p_list.add(new Integer(i));
}
SCProfileExporter.exportSCProfileList(parent, p_list, scprofileList);
}
else if (evt.getActionCommand().equals("ChangeType")) {
reloadScore(scoreDisplayType.getSelectedIndex() == 0);
}
else if (evt.getActionCommand().equals("EditProfiles")) {
try {
SCProfileDialog sc_dialog = new SCProfileDialog(alignment);
} catch (Exception ex) {
Log.printStackTrace(ex);
}
}
}
private void save_action(int[] trackIDs) {
try {
String file_name = "alignment";
file_name = file_name.replaceAll("\\W", "_");
file_name = file_name.replaceAll("__", "_");
file_name = Configuration.getUserPath() + file_name;
RestrictedFormatFileChooser save_dialog =
RestrictedFormatFileChooser.getRestrictedFormatFileChooser("SingleAlignmentDialog");
save_dialog.setDialogTitle("Save Alignment As...");
int result =
save_dialog.showSaveDialog(
Sockeye.__frame,
"fasta,aln",
new File(file_name));
if (result == JFileChooser.APPROVE_OPTION) {
file_name = save_dialog.getSelectedFile().getCanonicalPath();
if (file_name.indexOf(".aln") > -1){
ALNExporter.exportToClustalw(trackIDs, file_name);
return;
} else if (file_name.indexOf(".fasta") > -1){
FASTAExporter.exportToMultiFASTA(trackIDs, file_name);
return;
} else {
Log.println("AlignmentPanel: Invalid file filter specified. Can't save alignment to unknown format.");
}
}
} catch (Exception e) {
Log.printStackTrace(e);
JOptionPane.showMessageDialog(SingleAlignmentDialog.this.mainFrame, "Could not save alignment file.", "Error", JOptionPane.ERROR_MESSAGE);
}
}
}
class AlignmentSequencePanel extends JPanel {
private String[] sequences;
private boolean[][] scores;
private int width, height;
private Rectangle highLightRegion;
private int rowHeight = SingleAlignmentDialog._ROW_HEIGHT;
private Color colorA = SequenceColor.getAColor();
private Color colorC = SequenceColor.getCColor();
private Color colorG = SequenceColor.getGColor();
private Color colorT = SequenceColor.getTColor();
private Color colorGap = SequenceColor.getGapColor();
private Color colorMatch = SequenceColor.getMatchColor();
private Color colorMatchRegion = SequenceColor.getMatchRegionColor();
private Color panelBGColor = _BACKGROUND_COLOR;
public AlignmentSequencePanel(
String[] sequences,
boolean[][] scores) {
super(true);
this.sequences = sequences;
this.scores = scores;
this.width = sequences[0].length() * _FONT_WIDTH;
this.height = sequences.length * rowHeight * 2 + rowHeight;
highLightRegion = new Rectangle();
}
public Dimension getPreferredSize() {
return new Dimension(width, height);
}
protected void paintComponent(Graphics g) {
Rectangle r = getBounds();
int profile_length = sequences[0].length();
g.setColor(panelBGColor);
g.fillRect(0, 0, r.width, r.height);
g.setColor(colorMatchRegion);
g.fillRect(
highLightRegion.x,
highLightRegion.y,
highLightRegion.width,
highLightRegion.height);
int half_font = Math.round(_FONT_WIDTH / 2);
int current_pos = Math.round((textScrollPane.getViewport().getViewPosition().x + half_font) / _FONT_WIDTH);
int vis_length = Math.round((textScrollPane.getViewport().getWidth() + half_font) / _FONT_WIDTH);
int start = current_pos;
int end = current_pos + vis_length - 1;
int margin = 2;
start = Math.max(0, start - margin);
end = Math.min(profile_length - 1, end + margin);
for (int index = start; index < end; index++) {
char ch = sequences[0].charAt(index);
boolean match = true;
for (int p = 1; p < sequences.length; p++) {
if (ch != sequences[p].charAt(index)) {
match = false;
break;
}
}
if (match) g.fillRect(index * _FONT_WIDTH, 0, _FONT_WIDTH, height);
}
g.setFont(SingleAlignmentDialog._DEFAULT_TEXTAREA_FONT);
for (int index = 0; index < sequences.length; index++) {
char[] sequence = sequences[index].toCharArray();
for (int index2 = start; index2 <= end; index2++) {
if (sequence[index2] == 'G') {
g.setColor(colorG);
}
else if (sequence[index2] == 'A') {
g.setColor(colorA);
}
else if (sequence[index2] == 'T') {
g.setColor(colorT);
}
else if (sequence[index2] == 'C') {
g.setColor(colorC);
}
else if (sequence[index2] == gapChar) {
g.setColor(colorGap);
}
g.drawString(
"" + sequence[index2],
index2 * _FONT_WIDTH,
index * rowHeight * 2 + rowHeight * 2 - 5);
if (index != sequences.length - 1 && scores[index][index2]) {
g.setColor(colorMatch);
g.drawString(matchChar + "",
index2 * _FONT_WIDTH,
index * rowHeight * 2 + rowHeight * 3 - 5);
}
}
}
}
public void setRegion(int x, int numChar) {
highLightRegion =
new Rectangle(x * _FONT_WIDTH, 0, (numChar + x) * _FONT_WIDTH, height);
}
}
class ColumnScoresPanel extends JPanel {
private int width;
private final int panelHeight = SingleAlignmentDialog._ROW_HEIGHT * 4;
private final int top_margin = 1;
private final int y_offset = SingleAlignmentDialog._ROW_HEIGHT;
private final int font_width = SingleAlignmentDialog._FONT_WIDTH;
private boolean barType = true;
public ColumnScoresPanel(boolean barType) {
super();
this.barType = barType;
width = scprofileList.getProfile(0).getSmoothedScores().length * font_width;
}
public Dimension getPreferredSize() {
return new Dimension(width, y_offset + panelHeight);
}
protected void paintComponent(Graphics g) {
Rectangle r = getBounds();
g.setFont(SingleAlignmentDialog._DEFAULT_TEXTAREA_FONT);
g.setColor(SingleAlignmentDialog._BACKGROUND_COLOR);
g.fillRect(0, 0, r.width, r.height);
List col_scores = new ArrayList();
List thresholds = new ArrayList();
List colours = new ArrayList();
int num_profiles = 1;
if (scprofile != null) {
col_scores.add(scprofile.getSmoothedScores());
thresholds.add(new Float(scprofile.getThreshold()));
colours.add(scprofile.getColour());
} else {
num_profiles = scprofileList.size();
for (int i = 0; i < num_profiles; i++) {
SCProfile profile = scprofileList.getProfile(i);
if (profile.isVisible()) {
col_scores.add(profile.getSmoothedScores());
thresholds.add(new Float(profile.getThreshold()));
colours.add(profile.getColour());
}
}
}
if (col_scores.size() == 0) {
return;
}
int half_font = Math.round(_FONT_WIDTH / 2);
int start = Math.round((textScrollPane.getViewport().getViewPosition().x + half_font) / _FONT_WIDTH);
int vis_length = textScrollPane == null ? 100 : Math.round((textScrollPane.getViewport().getWidth() + half_font) / _FONT_WIDTH);
int end = start + vis_length;
int margin = 2;
start = Math.max(0, start - margin);
end = Math.min(((float[])col_scores.get(0)).length - 1, end + margin);
int pixel_start = start * _FONT_WIDTH;
int pixel_end = end * _FONT_WIDTH;
g.setColor(Color.BLACK);
g.drawLine(pixel_start, panelHeight, pixel_end, panelHeight);
if (barType) {
for (int index = start; index <= end; index++) {
for (int p = 0; p < col_scores.size(); p++) {
float score = ((float[])col_scores.get(p))[index];
if (score == Float.NEGATIVE_INFINITY) continue;
int height = Math.round(score * (panelHeight - top_margin));
Float thresh_F = (Float)thresholds.get(p);
int thresh = (int) (thresh_F.floatValue() * panelHeight + 0.5f);
int y_location = panelHeight - height;
g.setColor((Color)colours.get(p));
int cr_diff = height - thresh;
if (thresh_F.floatValue() > 0 && cr_diff > 0) g.drawRect(index * font_width, y_location, font_width, cr_diff);
else g.drawLine(index * font_width, y_location, (index + 1) * font_width, y_location);
}
int x_pos = 0, txt_offset;
String label;
if (index == 0) {
g.setColor(Color.BLACK);
x_pos = font_width / 2;
label = "1";
txt_offset = SwingUtilities.computeStringWidth(g.getFontMetrics(), label);
g.drawString(label, Math.max(0, x_pos - txt_offset / 2), panelHeight + 13);
g.drawLine(x_pos, panelHeight - 5, x_pos, panelHeight);
} else if (index % 10 == 0) {
g.setColor(Color.BLACK);
x_pos = (index - 1) * font_width + font_width / 2;
label = index + "";
txt_offset = SwingUtilities.computeStringWidth(g.getFontMetrics(), label);
g.drawString(label, Math.max(0, x_pos - txt_offset / 2), panelHeight + 13);
g.drawLine(x_pos, panelHeight - 5, x_pos, panelHeight);
}
}
for (int index = 0; index < colScores.length; index++) {
int height = (int) (colScores[index] * panelHeight);
int y_location = panelHeight - height;
int x_location = index * font_width + 3;
g.drawRect(index * font_width, y_location, font_width, height);
if (index % 10 == 0) {
g.setColor(Color.BLACK);
g.drawString("" + index, index * font_width, panelHeight + 13);
g.setColor(scprofile.getColour());
}
} */
}
else {
for (int index = 0; index < colScores.length; index++) {
if (colScores[index] != 0) {
int height = (int) (colScores[index] * panelHeight);
int x_location = index * font_width + 3;
g.drawLine(
x_location,
panelHeight,
x_location,
panelHeight - height);
}
if (index % 10 == 0) {
g.drawString("" + index, index * font_width, panelHeight + 13);
}
}*/
}
if (scprofile != null) {
float threshold = scprofile.getThreshold();
if (threshold > 0) {
g.setColor(scprofile.getColour());
int y_coord = Math.round((1.0f - threshold) * panelHeight);
if (y_coord != 0) drawDottedLine(g, 0, y_coord, r.width, y_coord);
}
} else {
num_profiles = scprofileList.size();
for (int i = 0; i < num_profiles; i++) {
SCProfile profile = scprofileList.getProfile(i);
if (profile.isVisible()) {
float threshold = profile.getThreshold();
if (threshold > 0) {
g.setColor(profile.getColour());
int y_coord = Math.round((1.0f - profile.getThreshold()) * panelHeight);
if (y_coord != 0) drawDottedLine(g, pixel_start + (i % 2) * 5, y_coord, pixel_end, y_coord);
}
}
}
}
}
}
public void drawDottedLine(Graphics g, int x, int y, int x2, int y2) {
Graphics2D g2d = (Graphics2D) g;
Stroke old_stroke = g2d.getStroke();
g2d.setStroke (new BasicStroke(
1f,
BasicStroke.CAP_ROUND,
BasicStroke.JOIN_ROUND,
1f,
new float[] {3f, 5f},
0f));
g2d.drawLine(x, y, x2, y2);
g2d.setStroke(old_stroke);
}
public void addWindowListener(WindowListener listener) {
mainFrame.addWindowListener(listener);
}
public void handleAlignmentHighlight(AlignmentHighlightEvent e) {
int[] seqs = e.getSequences();
Rectangle visibleRect =
textScrollPane.getViewport().getViewRect();
int start = e.getHighlightStart(seqs[0]);
visibleRect.setBounds(start - alignment.getStart(seqs[0]), visibleRect.y, visibleRect.width, visibleRect.height);
textScrollPane.getViewport().setViewPosition(new Point(visibleRect.x * _FONT_WIDTH, visibleRect.y));
}
public Alignment getAlignment() {
return alignment;
}
public static void registerWindow(AlignOperation a_op, SingleAlignmentDialog to_reg) {
List windows_of_op = (List)open_windows.get(a_op);
if (windows_of_op == null) {
windows_of_op = new ArrayList();
open_windows.put(a_op, windows_of_op);
}
if (!windows_of_op.contains(to_reg)) windows_of_op.add(to_reg);
}
public static void unregisterWindow(AlignOperation a_op, SingleAlignmentDialog to_unreg) {
List windows_of_op = (List)open_windows.get(a_op);
if (windows_of_op != null) {
windows_of_op.remove(to_unreg);
}
}
public static List getOpenWindows(AlignOperation a_op) {
return (List)open_windows.get(a_op);
}
public static void close(AlignOperation a_op) {
List windows_of_op = (List)open_windows.get(a_op);
if (windows_of_op != null) {
List dispose_list = new ArrayList(windows_of_op);
for (Iterator itr = dispose_list.iterator(); itr.hasNext();) {
((SingleAlignmentDialog)itr.next()).mainFrame.dispose();
}
}
}
public void onProfileListChanged() {
scprofileList = alignment.getSCProfileList();
columnHeader.resetProfileMenu();
align_graph.requestPaint();
}
}
package ca.bcgsc.sockeye.gui.alignment;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Stroke;
import java.awt.event.MouseEvent;
import java.awt.geom.AffineTransform;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.SwingUtilities;
import ca.bcgsc.sockeye.analysis.scprofile.SCProfile;
import ca.bcgsc.sockeye.analysis.scprofile.columnscore.ColumnScoreAlgorithm;
import ca.bcgsc.sockeye.util.Log;
public class SingleAlignmentGraph extends AlignmentGraph {
static final int MAX_PROFILE_THICKNESS = 40;
List highlight_listeners = new ArrayList();
public SingleAlignmentGraph(List alignments, List anchors) {
super(alignments.subList(0,1), null, true, true);
}
protected void plotAlignments(Graphics g) {
float[] scores;
int seqx, seqy;
for (int x_seq = 0; x_seq < axis_sequence[XAXIS].size(); x_seq++) {
for (int y_seq = 0; y_seq < axis_sequence[YAXIS].size(); y_seq++) {
seqx = ((Integer)axis_sequence[XAXIS].get(x_seq)).intValue();
seqy = ((Integer)axis_sequence[YAXIS].get(y_seq)).intValue();
boolean invert_x = cur_align.onNegativeStrand(seqx);
boolean invert_y = cur_align.onNegativeStrand(seqy);
ArrayList seq_ids = new ArrayList();
seq_ids.add(new Integer(seqx));
seq_ids.add(new Integer(seqy));
SCProfile profile = cur_align.getSCProfileList().getProfile(seq_ids);
if (profile == null) {
Log.println("Unable to obtain an SCProfile for sequences " + seq_ids);
continue;
}
scores = profile.getSmoothedScores();
float threshold = profile.getThreshold();
Point diag_start = basePairToPixel(new Point(seq_start_x, seq_start_y));
Point diag_end = basePairToPixel(new Point(seq_end_x + 1, seq_end_y + 1));
float slope = Math.abs((float)(diag_end.y - diag_start.y)/(diag_end.x - diag_start.x));
float angle = (float)((Math.PI / 2) - Math.atan(slope));
if ((invert_y ^ invert_x) ^ invert_yaxis) {
angle = -angle;
}
double bp_per_pixel = 1.0f / scale_x;
boolean zoomed_out = bp_per_pixel > 1f;
int bp_counter = 0;
float score_sum = 0;
int gaps = 0;
float alpha;
boolean thresh_exceed = false;
int bin_size = 1;
int scores_per_bin = (int)bp_per_pixel * bin_size;
int max_score = Math.min(scores.length, offset_x + Math.round((plot_width + 20) / scale_x));
int start_score = Math.max(0, offset_x - 20);
if (invert_x) {
start_score = scores.length - max_score;
max_score = scores.length - offset_x;
}
int bin_length = 2;
if (zoomed_out) {
bin_length += (int)Math.ceil((float)Math.sqrt( (bin_size * bin_size) + (bin_size * bin_size)));
} else {
bin_length += (int)Math.ceil((float)Math.sqrt( (scale_x * scale_x) + (scale_y * scale_y)));
}
for (int score_pos = start_score; score_pos < max_score; score_pos++) {
alpha = 0;
if (zoomed_out ) {
if (bp_counter++ < scores_per_bin) {
if (scores[score_pos] == ColumnScoreAlgorithm._UNDEFINED) {
gaps++;
} else {
score_sum += scores[score_pos];
if (scores[score_pos] >= threshold) thresh_exceed = true;
}
continue;
} else {
int count = bp_counter - gaps - 1;
if (count == 0) alpha = 0;
else alpha = score_sum / count;
bp_counter = 0;
score_sum = 0;
gaps = 0;
if (count == 0) continue;
}
} else {
if (scores[score_pos] != ColumnScoreAlgorithm._UNDEFINED) {
alpha = scores[score_pos];
if (alpha >= threshold) thresh_exceed = true;
}
else {
continue;
}
}
int line_thickness = Math.round(alpha * MAX_PROFILE_THICKNESS);
if (line_thickness == 0) continue;
if (thresh_exceed) {
g.setColor(profile.getColour());
} else {
g.setColor(profile.getColour().darker());
}
thresh_exceed = false;
int loc_x = invert_x ? seq_end_x - score_pos : seq_start_x + score_pos;
int loc_y = invert_y ? seq_end_y - score_pos : seq_start_y + score_pos;
Point dot = basePairToPixel(new Point(loc_x, loc_y));
dot.x += Math.round(scale_x / 2);
dot.y += Math.round(scale_y / 2) * (invert_yaxis ? 1 : -1);
drawRotatedRect(g, dot.x, dot.y, line_thickness, bin_length, angle);
if (scale_x > 5) {
g.setColor(Color.white);
g.fillOval(dot.x - 2, dot.y - 2,4,4);
}
}
}
}
}
protected void pickArea(Object obj) {
}
protected void updateRange() {
int seq_id = ((Integer)axis_sequence[XAXIS].get(0)).intValue();
range_x_min = cur_align.getStart(seq_id);
range_x_max = cur_align.getGappedEnd(seq_id);
seq_id = ((Integer)axis_sequence[YAXIS].get(0)).intValue();
range_y_min = cur_align.getStart(seq_id);
range_y_max = cur_align.getGappedEnd(seq_id);
}
protected void plotHighlights(Graphics g) {
int x_index = 0, y_index = 0;
int cur_seq_x = ((Integer)axis_sequence[XAXIS].get(0)).intValue();
int cur_seq_y = ((Integer)axis_sequence[YAXIS].get(0)).intValue();
int[] seqs = cur_align.getSequenceIDs();
for (int i = 0; i < seqs.length; i++) {
if (cur_seq_x == seqs[i]) x_index = i;
if (cur_seq_y == seqs[i]) y_index = i;
}
for (Iterator itr = highlight_rectangles.values().iterator(); itr.hasNext();) {
Rectangle rect_arr[][] = (Rectangle[][])itr.next();
Rectangle rect = rect_arr[x_index][y_index];
g.setColor((Color)highlight_colours.get(rect_arr));
Point corner = basePairToPixel(rect.getLocation());
Rectangle relative_rect = new Rectangle(rect.x - seq_start_x + 1, rect.y - seq_start_y + 1, rect.width, rect.height);
int h_width = (int)(rect.width * scale_x);
int h_height = (int)(rect.height * scale_y);
int adjusted_y = corner.y;
if (!invert_yaxis) {
adjusted_y = corner.y - h_height;
}
g.drawLine(margin_x, adjusted_y + h_height / 2, corner.x, adjusted_y + h_height / 2);
g.drawLine(corner.x + h_width / 2, adjusted_y + h_height, corner.x + h_width / 2, height - margin_y);
g.drawLine(corner.x + h_width, adjusted_y + h_height / 2, margin_x + plot_width, adjusted_y + h_height / 2);
g.drawLine(corner.x + h_width / 2, margin_y, corner.x + h_width / 2, adjusted_y);
Graphics2D g2d = (Graphics2D) g;
Stroke old_stroke = g2d.getStroke();
g2d.setStroke (new BasicStroke(
1f,
BasicStroke.CAP_ROUND,
BasicStroke.JOIN_ROUND,
1f,
new float[] {3f, 5f},
0f));
g2d.drawLine(corner.x, adjusted_y + h_height / 2, corner.x + h_width, adjusted_y + h_height / 2);
g2d.drawLine(corner.x + h_width / 2, adjusted_y, corner.x + h_width / 2, adjusted_y + h_height);
g2d.setStroke(old_stroke);
String label = "";
boolean reverse = cur_align.onNegativeStrand(cur_seq_x);
int ceiling = seq_end_x - seq_start_x + 2;
int test_val = (int)relative_rect.getMaxX();
if (reverse) test_val = ceiling - test_val;
int txt_offset = SwingUtilities.computeStringWidth(g.getFontMetrics(), test_val + " ");
boolean numbers_fit = h_width > (txt_offset * relative_rect.width / 10);
if (scale_x > 1) {
for (int index = relative_rect.x; index < relative_rect.x + relative_rect.width; index++) {
int rev_index = (reverse ? ceiling - index : index);
if (rev_index % 10 == 0) {
label = rev_index + "";
Point coord = basePairToPixel(new Point(seq_start_x + index - 1, 0));
coord.y = adjusted_y + h_height / 2;
coord.x += Math.round(scale_x / 2);
txt_offset = SwingUtilities.computeStringWidth(g.getFontMetrics(), label);
g.drawLine(coord.x, coord.y + 5, coord.x, coord.y - 5);
if (numbers_fit) g.drawString(label, Math.min(Math.max(corner.x, coord.x - txt_offset / 2),
corner.x + h_width - txt_offset), coord.y - 15);
}
}
}
if (corner.x < margin_x) {
h_width -= margin_x - corner.x;
corner.x = margin_x;
}
if (corner.x + h_width >= margin_x + plot_width) {
h_width = plot_width + margin_x - corner.x - 1;
}
if (adjusted_y < margin_y) {
h_height -= margin_y - adjusted_y;
adjusted_y = margin_y;
}
if (adjusted_y + h_height >= margin_y + plot_height) {
h_height = plot_height + margin_y - adjusted_y - 1;
}
g.drawRect(corner.x, adjusted_y, h_width, h_height);
}
}
public void mouseClicked(MouseEvent e) {
super.mouseClicked(e);
Point anchor = e.getPoint();
int clicks = e.getClickCount();
if (drag_mode == -1 && clicks == 1 && SwingUtilities.isLeftMouseButton(e)) {
int cur_seq_x = ((Integer)axis_sequence[XAXIS].get(0)).intValue();
int cur_seq_y = ((Integer)axis_sequence[YAXIS].get(0)).intValue();
int length = 100;
Object[] keys = highlight_rectangles.keySet().toArray();
if (keys != null && keys.length > 0) {
Rectangle[][] old_highlight = (Rectangle[][])highlight_rectangles.remove(keys[0]);
length = old_highlight[0][0].width;
}
AlignmentHighlightEvent new_event = new AlignmentHighlightEvent(this, cur_align);
Point cur_loc = pixelToBasePair(anchor);
Point ends = basePairToPixel(new Point(seq_end_x, seq_end_y));
if ( (anchor.x < margin_x || anchor.x > Math.min(ends.x, margin_x + plot_width)) &&
anchor.y < height - margin_y && anchor.y > margin_y) {
if (cur_align.onNegativeStrand(cur_seq_y)) {
cur_loc.y = cur_align.getGappedEnd(cur_seq_y) - cur_loc.y + cur_align.getStart(cur_seq_y);
}
new_event.addRegion(cur_seq_y, cur_loc.y - length / 2, cur_loc.y + length / 2);
} else if (anchor.x > margin_x && anchor.x < Math.min(ends.x, margin_x + plot_width) && anchor.y > margin_y){
if (cur_align.onNegativeStrand(cur_seq_x)) {
cur_loc.x = cur_align.getGappedEnd(cur_seq_x) - cur_loc.x + cur_align.getStart(cur_seq_x);
}
new_event.addRegion(cur_seq_x, cur_loc.x - length / 2, cur_loc.x + length / 2);
}
if (new_event.getSequences().length > 0) fireAlignmentHighlightEvent(new_event);
}
}
private void drawRotatedRect(Graphics g, int x, int y, int width, int height, float angle) {
Graphics2D g2d = (Graphics2D)g;
AffineTransform saveAT = g2d.getTransform();
AffineTransform at = new AffineTransform();
at.translate(x, y);
at.rotate(angle);
g2d.transform(at);
g.fillRect(Math.round(-width / 2.0f), Math.round(-height / 2.0f), width, height);
g2d.setTransform(saveAT);
}
public void addAlignmentHighlightListener(AlignmentHighlightListener listener) {
if (!highlight_listeners.contains(listener)) highlight_listeners.add(listener);
}
public void removeAlignmentHighlightListener(AlignmentHighlightListener listener) {
highlight_listeners.remove(listener);
}
protected void fireAlignmentHighlightEvent(AlignmentHighlightEvent e) {
for (Iterator itr = highlight_listeners.iterator(); itr.hasNext();) {
try {
AlignmentHighlightListener listener = (AlignmentHighlightListener)itr.next();
listener.handleAlignmentHighlight(e);
} catch (Exception err) {
Log.printStackTrace(err);
}
}
}
}
package ca.bcgsc.sockeye.gui.exportimagedialog;
import java.io.File;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import ca.bcgsc.sockeye.gui.ExtensionFilter;
public class ExportImageDialog
extends JFileChooser {
public static int __1024x768 = 0;
public static int __current_canvas = 1;
static String last_path = null;
private JPanel jpanel_image_info = new JPanel();
private BoxLayout bl = new BoxLayout(jpanel_image_info, BoxLayout.Y_AXIS);
private JLabel jlabel_image_info = new JLabel("Image Size:");
private JList jlist_image_info = new JList(image_sizes);*/
public ExportImageDialog(String path) {
super(last_path == null ? path : last_path);
this.setDialogTitle("Export Canvas As...");
this.setSelectedFile(new File("3Dcapture.jpg"));
javax.swing.filechooser.FileFilter[] filters = new javax.swing.filechooser.
FileFilter[] {
new ExtensionFilter("JPEG images (*.jpg, *.jpeg)", new String[] {".jpg",
".jpeg"}),
new FolderFilter(),
new FilesOnlyFilter(),
};
for (int i = 0; i < filters.length; i++) {
this.addChoosableFileFilter(filters[i]);
}
this.setFileFilter(filters[0]);
jpanel_image_info.setAlignmentX(JPanel.CENTER_ALIGNMENT);
jlabel_image_info.setVerticalTextPosition(JLabel.CENTER);
jlabel_image_info.setHorizontalTextPosition(JLabel.LEFT);
jlabel_image_info.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
jlabel_image_info.setBackground(Color.red);
jpanel_image_info.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createEmptyBorder(0,0,0,10), BorderFactory.createEtchedBorder()));
jpanel_image_info.add(jlabel_image_info);
jpanel_image_info.add(jlist_image_info);
jlist_image_info.setSelectedIndex(0);
this.add(jpanel_image_info, BorderLayout.WEST);*/
}
public void approveSelection() {
File selectedFile = this.getSelectedFile();
String filename = selectedFile.getName();
if (!(filename.toLowerCase().endsWith(".jpg")) && !(filename.toLowerCase().endsWith(".jpeg"))) {
JOptionPane.showMessageDialog(getParent(),
"Filename must end in .jpg or .jpeg",
"Invalid Filename",
JOptionPane.ERROR_MESSAGE);
this.setSelectedFile(new File(filename + ".jpg"));
return;
}
if (selectedFile.exists()) {
String message = "Overwrite " + filename + "?";
int response = JOptionPane.showConfirmDialog(null, message,
"File Already Exists", JOptionPane.YES_NO_CANCEL_OPTION,
JOptionPane.ERROR_MESSAGE);
if (response == JOptionPane.CANCEL_OPTION) {
cancelSelection();
}
else if (response == JOptionPane.YES_OPTION) {
if (!selectedFile.canWrite() || !selectedFile.isFile()) {
JOptionPane.showMessageDialog(getParent(),
"You do not have permission to write to that file",
"File not Writable",
JOptionPane.ERROR_MESSAGE);
}
else {
last_path = selectedFile.getParent();
super.approveSelection();
}
}
else {
return;
}
}
else if (!selectedFile.getParentFile().canWrite()) {
JOptionPane.showMessageDialog(getParent(),
"You do not have permission to write to that directory",
"Directory not Writable",
JOptionPane.ERROR_MESSAGE);
}
else {
last_path = selectedFile.getParent();
super.approveSelection();
}
}
public int getSelectedSize() {
return ExportImageDialog.__current_canvas;
}
}
package ca.bcgsc.sockeye.gui.exportimagedialog;
import java.io.File;
class FilesOnlyFilter
extends javax.swing.filechooser.FileFilter {
public boolean accept(File f) {
return f != null && f.isFile();
}
public String getDescription() {
return "Files Only";
}
}
package ca.bcgsc.sockeye.gui.exportimagedialog;
import java.io.File;
class FolderFilter
extends javax.swing.filechooser.FileFilter {
public boolean accept(File f) {
return f != null && f.isDirectory();
}
public String getDescription() {
return "Folders Only";
}
}
package ca.bcgsc.sockeye.gui.navigation;
import javax.swing.JPanel;
import javax.swing.*;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.plaf.basic.BasicLabelUI;
import java.awt.Graphics2D;
import java.awt.Graphics;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.Rectangle;
import java.awt.FontMetrics;
import java.awt.geom.AffineTransform;
import java.awt.Component;
public class ExtendedRotNavWheel extends JPanel implements ChangeListener {
JLabel _text_label;
JLabel _unit_label;
SpringLoadedSlider _wheel;
SpinnerModel _spinner_model =
new SpinnerNumberModel(5, 1, 180, 5);
JSpinner _spinner = new JSpinner(_spinner_model);
int factor = Integer.parseInt(_spinner_model.getValue().toString());
public ExtendedRotNavWheel(boolean horizontal, boolean use_spinner, String label, String units) {
init(horizontal, use_spinner, label, units);
}
public void wheelSpin(int ticks){
}
public void stateChanged(ChangeEvent e) {
factor = Integer.parseInt(_spinner_model.getValue().toString());
}
private void init(boolean h, boolean us, String l, String u){
GridBagLayout gbl = new GridBagLayout();
GridBagConstraints gbc = new GridBagConstraints();
gbc.gridy = 0;
gbc.gridx = 0;
gbc.fill = GridBagConstraints.BOTH;
gbc.anchor = GridBagConstraints.WEST;
this.setLayout(gbl);
Component[] comp = new Component[5];
java.util.Arrays.fill(comp, null);
int counter = 0;
if (l != null){
_text_label = new JLabel(l);
if (!h)
_text_label.setUI(new VerticalLabelUI(false));
comp[counter++] = _text_label;
}
_wheel = new SpringLoadedSlider(h) {
public void action(int ticks) {
wheelSpin(ticks * factor);
}
};
comp[counter++] = _wheel;
if (us){
_spinner.addChangeListener(this);
comp[counter++] = _spinner;
}
if (u != null){
_unit_label = new JLabel(u);
if (!h)
_unit_label.setUI(new VerticalLabelUI(false));
comp[counter++] = _unit_label;
}
if (h){
for (int i=0; i<comp.length; i++)
if (comp[i] != null){
gbc.gridx++;
this.add(comp[i], gbc);
gbc.gridx++;
this.add(Box.createHorizontalStrut(5), gbc);
}
}
else
for (int i=comp.length-1; i>=0; i--)
if (comp[i] != null){
gbc.gridy++;
this.add(comp[i], gbc);
gbc.gridy++;
this.add(Box.createVerticalStrut(5), gbc);
}
}
}
class VerticalLabelUI
extends BasicLabelUI {
static {
labelUI = new VerticalLabelUI(false);
}
protected boolean clockwise;
VerticalLabelUI(boolean clockwise) {
super();
this.clockwise = clockwise;
}
public Dimension getPreferredSize(JComponent c) {
Dimension dim = super.getPreferredSize(c);
return new Dimension(c.getFontMetrics(c.getFont()).getAscent(), dim.width);
}
private static Rectangle paintIconR = new Rectangle();
private static Rectangle paintTextR = new Rectangle();
private static Rectangle paintViewR = new Rectangle();
private static Insets paintViewInsets = new Insets(0, 0, 0, 0);
public void paint(Graphics g, JComponent c) {
JLabel label = (JLabel) c;
String text = label.getText();
FontMetrics fm = g.getFontMetrics();
paintViewInsets = c.getInsets(paintViewInsets);
paintViewR.x = paintViewInsets.left;
paintViewR.y = paintViewInsets.top;
paintViewR.height = c.getWidth() -
(paintViewInsets.left + paintViewInsets.right);
paintViewR.width = c.getHeight() -
(paintViewInsets.top + paintViewInsets.bottom);
paintIconR.x = paintIconR.y = paintIconR.width = paintIconR.height = 0;
paintTextR.x = paintTextR.y = paintTextR.width = paintTextR.height = 0;
String clippedText =
layoutCL(label, fm, text, null, paintViewR, paintIconR, paintTextR);
Graphics2D g2 = (Graphics2D) g;
AffineTransform tr = g2.getTransform();
if (clockwise) {
g2.rotate(Math.PI / 2);
g2.translate(0, -c.getWidth());
}
else {
g2.setClip((-c.getWidth()+fm.getAscent())/2-1, 0, c.getWidth(), c.getHeight());
g2.rotate( -Math.PI / 2);
g2.translate( -c.getHeight(), (-c.getWidth()+fm.getAscent())/2);
}
if (text != null) {
int textX = paintTextR.x;
int textY = paintTextR.y + fm.getAscent();
if (label.isEnabled()) {
paintEnabledText(label, g, clippedText, textX, textY);
}
else {
paintDisabledText(label, g, clippedText, textX, textY);
}
}
g2.setTransform(tr);
}
}
package ca.bcgsc.sockeye.gui.navigation;
import java.awt.BorderLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.List;
import java.util.Random;
import java.util.Arrays;
import javax.help.CSH;
import javax.swing.SwingUtilities;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTree;
import javax.swing.Timer;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeNode;
import javax.swing.tree.TreePath;
import javax.swing.tree.TreeSelectionModel;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.config.Feature;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.datastorage.events.StorageEvent;
import ca.bcgsc.sockeye.datastorage.events.StorageEventListener;
import ca.bcgsc.sockeye.gui.scomponents.CheckboxTreeRenderer;
import ca.bcgsc.sockeye.gui.sevents.SockeyeNodeSelectionListener;
import ca.bcgsc.util.gui.scomponents.CheckboxTreeNode;
import ca.bcgsc.sockeye.gui.*;
import ca.bcgsc.sockeye.popup.FeatureTreePopup;
public class FeaturePanel extends JPanel implements StorageEventListener {
JScrollPane scrollPane = new JScrollPane();
private final static String _ALL_FEATURES = "All selected features";
private final static String _ALL = "All";
private static JTree __tree;
private static final String _user_defined_node_name =
"User defined feature sets";
private static final CheckboxTreeNode _user_def_goup_node =
new CheckboxTreeNode(_user_defined_node_name);
private static CheckboxTreeNode root = new CheckboxTreeNode(_ALL_FEATURES);
private static JLabel l_sel_features_count = new JLabel();
private static List update_features = new ArrayList();
private static List _user_defined_feature_names = new ArrayList();
private static final List _config_known_feature_names =
Arrays.asList(Configuration.getFeatureNames());
public FeaturePanel() {
jbInit();
initHelp();
timer.start();
}
public static JTree getTree() {
return __tree;
}
public static void setTree(JTree tree) {
__tree = tree;
__tree.updateUI();
}
private void jbInit() {
List features = Configuration.getFeatures();
List parents = new ArrayList();
List remove = new ArrayList();
List selected_nodes = new ArrayList();
List selected_features = Configuration.getSelectedFeatures();
Feature f;
for (int i = 0; i < features.size(); i++) {
f = (Feature) features.get(i);
String parent_name;
if (f.getName().equals("") || f.getName().matches("[\\s]+")) {
Random r = new Random(System.currentTimeMillis());
String nameless = "noname" + r.nextInt(5);
JOptionPane.showMessageDialog(
null,
"An XML-specified feature, "
+ f.getName()
+ ", has been found with an empty name \n\""
+ f.getName()
+ "\" invalid, setting name to "
+ nameless,
"Warning",
JOptionPane.WARNING_MESSAGE);
f.setName(nameless);
}
if (f.getParentName() != null) {
if (f.getParentName().equals(f.getName())) {
JOptionPane.showMessageDialog(
null,
"An XML-specified feature, "
+ f.getName()
+ ", has been found with a parent_name matching its own name\n\""
+ f.getParentName()
+ "\" invalid, setting parent name to \"Misc\"",
"Warning",
JOptionPane.WARNING_MESSAGE);
f.setParentName("Misc");
}
}
if ((!Configuration.isParentFeatureDefined(f.getParentName()))
&& f.getParentName() != null) {
JOptionPane.showMessageDialog(
null,
"An XML-specified feature, "
+ f.getName()
+ ", has been found without a valid parent_name\n\""
+ f.getParentName()
+ "\" undefined, setting parent name to \"Misc\"",
"Warning",
JOptionPane.WARNING_MESSAGE);
f.setParentName("Misc");
}
parent_name = f.getParentName();
if (parent_name == null) {
CheckboxTreeNode child = new CheckboxTreeNode(f.getName());
if (!child.getUserObject().toString().equals("default")
&& !child.getUserObject().toString().equals("select")
&& !child.getUserObject().toString().equals("region")
&& !child.getUserObject().toString().equals("search_region")
&& !child.getUserObject().toString().equals("alignment highlight")
&& !child.getUserObject().toString().equals(
"alignment sequence highlight")
&& !child.getUserObject().toString().equals(
"vertical alignment sequence highlight")
&& !child.getUserObject().toString().equals("gap")
&& !child.getUserObject().toString().equals("track")) {
root.add(child);
if (selected_features.contains(child.toString())) {
selected_nodes.add(child);
}
remove.add(f);
parents.add(child);
} else {
remove.add(f);
}
}
}
features.removeAll(remove);
remove.clear();
List new_parents;
while (!features.isEmpty()) {
new_parents = new ArrayList(parents);
parents = new ArrayList();
for (int k = 0; k < new_parents.size(); k++) {
CheckboxTreeNode parent = (CheckboxTreeNode) new_parents.get(k);
parent.setSelected(false);
boolean some_leaf_selected = false;
for (int i = 0; i < features.size(); i++) {
f = (Feature) features.get(i);
String parent_name = f.getParentName();
if (parent.getUserObject().toString().equals(parent_name)) {
CheckboxTreeNode child = new CheckboxTreeNode(f.getName());
if (selected_features.contains(child.toString())) {
selected_nodes.add(child);
some_leaf_selected = true;
}
parent.add(child);
remove.add(f);
parents.add(child);
}
}
parents.remove(parent);
if (parent.getChildCount() == 1) {
((CheckboxTreeNode) parent.getChildAt(0)).setSelected(true);
} else if (parent.getChildCount() > 1) {
parent.addNodeAt(new CheckboxTreeNode(_ALL, !some_leaf_selected), 0);
}
}
features.removeAll(remove);
remove.clear();
root.add(_user_def_goup_node);
_user_def_goup_node.setChecked(true);
}
Enumeration l = root.depthFirstEnumeration();
while (l.hasMoreElements()) {
CheckboxTreeNode t = (CheckboxTreeNode) l.nextElement();
if (t.getLevel() > 1)
t.setEnabled(false);
}
List dummy = new ArrayList();
dummy.add("gene");
showOnly(dummy);
for (int i = 0; i < selected_nodes.size(); i++) {
CheckboxTreeNode node = (CheckboxTreeNode) selected_nodes.get(i);
node.setChecked(true);
action(node, false);
}
__tree = new JTree(root);
__tree.setCellRenderer(new CheckboxTreeRenderer());
__tree.getSelectionModel().setSelectionMode(
TreeSelectionModel.SINGLE_TREE_SELECTION);
__tree.putClientProperty("JTree.lineStyle", "Angled");
__tree.addMouseListener(new FeatureNodeSelectionListener(__tree));
__tree.setShowsRootHandles(false);
scrollPane.getViewport().add(__tree);
scrollPane.createVerticalScrollBar();
this.setLayout(new BorderLayout());
this.add(scrollPane, BorderLayout.CENTER);
this.add(l_sel_features_count, BorderLayout.SOUTH);
}
synchronized public void storageEventReceived(StorageEvent e) {
List e_attrib = (List) e.getAttribute();
switch (e.getEventType()) {
case StorageEvent.STORAGE_EVENT_FEATURE_VISIBILITY_CHANGED :
if (e_attrib == null || e_attrib.isEmpty())
return;
boolean check = e_attrib.get(0).toString().equals("true");
for (int i = 1; i < e_attrib.size(); i++) {
if (e_attrib.get(i) == null)
continue;
String feature_name = e_attrib.get(i).toString();
CheckboxTreeNode node =
(CheckboxTreeNode) findNode(root, feature_name);
if (node != null) {
if ((node.getEnabled() && check == false)
|| (check == true && !node.getAlwaysOn())) {
node.setChecked(check);
}
while (check && node.getParent() != null) {
node = (CheckboxTreeNode) node.getParent();
if (node != null) {
node.setChecked(check);
action(node, true);
}
}
}
}
break;
case StorageEvent.STORAGE_EVENT_TRACK_ADD_FEATURES :
String new_feature_name = e_attrib.get(1).toString();
if (!(_config_known_feature_names.contains(new_feature_name)
|| _user_defined_feature_names.contains(new_feature_name)
|| new_feature_name.equals("sequence"))) {
_user_def_goup_node.add(new CheckboxTreeNode(new_feature_name));
((DefaultTreeModel) __tree.getModel()).reload();
TreePath p = new TreePath(_user_def_goup_node.getPath());
try {
__tree.expandPath(p);
} catch (Exception ex) {
}
_user_defined_feature_names.add(new_feature_name);
}
break;
case StorageEvent.STORAGE_EVENT_TRACK_REMOVE :
Collection all_feature_names =
DataStoreUser.getInstance().getSockeyeTrackList().getFeatureNames();
for (Iterator i = _user_defined_feature_names.iterator();
i.hasNext();
) {
String feat = i.next().toString();
if (!all_feature_names.contains(feat)) {
for (int child = 0;
child < _user_def_goup_node.getChildCount();
child++)
if (_user_def_goup_node
.getChildAt(child)
.toString()
.equals(feat)) {
_user_def_goup_node.remove(child);
((DefaultTreeModel) __tree.getModel()).reload();
break;
}
_user_defined_feature_names.remove(feat);
}
}
break;
}
}
public static boolean areParentsSelected(CheckboxTreeNode node) {
CheckboxTreeNode parent = (CheckboxTreeNode) node.getParent();
if (parent == null) {
return false;
}
if (parent.isChecked() || root.isChecked()) {
return true;
} else {
while (!parent.isRoot()) {
CheckboxTreeNode child = parent;
parent = (CheckboxTreeNode) child.getParent();
if (parent.isChecked()) {
return true;
}
}
return false;
}
}
public static List getAllSelectedFeatures() {
List all_selected_features = new ArrayList();
Enumeration c = root.postorderEnumeration();
while (c.hasMoreElements()) {
CheckboxTreeNode tn = (CheckboxTreeNode) c.nextElement();
if (tn.getEnabled()
&& tn.isLeaf()
&& (tn.isChecked() || tn.getAlwaysOn()))
all_selected_features.add(tn.toString());
}
while (all_selected_features.remove(_ALL));
return all_selected_features;
}
public static List selectedFeatures(CheckboxTreeNode node) {
List f = new ArrayList();
if (node.isLeaf()) {
CheckboxTreeNode parent = (CheckboxTreeNode) node.getParent();
int siblings_count = parent.getChildCount();
if (!areParentsSelected(node)) {
return f;
} else if (node.toString().equals(_ALL)) {
for (int i = 1; i < siblings_count; i++) {
CheckboxTreeNode sibling = (CheckboxTreeNode) parent.getChildAt(i);
if (!sibling.isChecked()) {
if (sibling.getChildCount() != 0) {
f.addAll(selectedFeatures(sibling));
} else {
f.add(sibling.toString());
}
}
}
} else if (siblings_count != 1) {
if ((CheckboxTreeNode) node.getParent() == _user_def_goup_node
|| !((CheckboxTreeNode) parent.getChildAt(0)).isChecked())
f.add(node.toString());
} else {
f.add(node.toString());
}
} else if (node.toString().equals(_ALL_FEATURES)) {
for (int i = 0; i < node.getChildCount(); i++) {
CheckboxTreeNode child = (CheckboxTreeNode) node.getChildAt(i);
if (!child.isChecked()) {
f.addAll(selectedFeatures(child));
}
}
} else {
int child_count = node.getChildCount();
CheckboxTreeNode first_child = (CheckboxTreeNode) node.getChildAt(0);
if (first_child.isLeaf()) {
if (child_count == 1) {
if (first_child.isChecked()) {
f.add(first_child.toString());
}
} else {
for (int i = 1; i < child_count; i++) {
CheckboxTreeNode child = (CheckboxTreeNode) node.getChildAt(i);
if (child.isChecked() || first_child.isChecked()) {
if (child.getChildCount() != 0) {
f.addAll(selectedFeatures(child));
} else {
f.add(child.toString());
}
}
}
}
} else {
f.addAll(selectedFeatures(first_child));
}
}
return f;
}
public static void resetPanel() {
for (int i = 0; i < root.getChildCount(); i++) {
CheckboxTreeNode child = (CheckboxTreeNode) root.getChildAt(i);
if (child.toString().equals(_user_defined_node_name))
child.removeAllChildren();
}
((DefaultTreeModel) __tree.getModel()).reload();
}
public static void resetTree(List checked_feature) {
clearTree(root);
resetTree(root, checked_feature);
}
private static void resetTree(CheckboxTreeNode node, List _checked_feature) {
for (int i = 0; i < node.getChildCount(); i++) {
CheckboxTreeNode child = (CheckboxTreeNode) node.getChildAt(i);
CheckboxTreeNode parent = (CheckboxTreeNode) child.getParent();
if (!parent.equals(root))
child.setEnabled(parent.isChecked());
if (_checked_feature.size() == 0)
return;
for (int j = 0; j < _checked_feature.size(); j++) {
String[] feature = (String[]) _checked_feature.get(j);
if (child.toString().equals(feature[0])
&& parent.toString().equals(feature[1])) {
child.setChecked(true);
action(child, true);
((DefaultTreeModel) __tree.getModel()).reload();
_checked_feature.remove(j);
break;
}
}
if (!child.isLeaf()) {
List cf = _checked_feature;
resetTree(child, cf);
}
}
}
static private void clearTree(CheckboxTreeNode node) {
for (int i = 0; i < node.getChildCount(); i++) {
CheckboxTreeNode child = (CheckboxTreeNode) node.getChildAt(i);
child.setChecked(false);
if (!child.isLeaf()) {
clearTree(child);
}
}
}
static public void clearWholeTree() {
clearTree(root);
}
public static void setSelectedFeature(String feature_name) {
Enumeration c = root.postorderEnumeration();
while (c.hasMoreElements()) {
CheckboxTreeNode node = (CheckboxTreeNode) c.nextElement();
if (node.getUserObject().equals(feature_name)) {
TreePath p = new TreePath(node.getPath());
__tree.setSelectionPath(p);
__tree.scrollPathToVisible(p);
}
}
}
private static CheckboxTreeNode findNode(
CheckboxTreeNode node,
String search_node_name) {
Enumeration nodes = node.depthFirstEnumeration();
while (nodes.hasMoreElements()) {
CheckboxTreeNode n = (CheckboxTreeNode) nodes.nextElement();
if (n.toString().equals(search_node_name)) {
return n;
}
}
return null;
}
private void showOnly(Collection features) {
Iterator it = features.iterator();
while (it.hasNext()) {
CheckboxTreeNode n = findNode(root, it.next().toString());
if (n != null) {
TreeNode[] tn_list = n.getPath();
for (int i = 0; i < tn_list.length; i++)
((CheckboxTreeNode) tn_list[i]).setVisible(true);
}
}
}
private void initHelp() {
CSH.setHelpIDString(this, "vis_working_with_3D_feature_tree");
}
synchronized public static void action(
CheckboxTreeNode node,
boolean blind) {
boolean visibility = node.isChecked();
if (!node.isLeaf() && node != root && node.getEnabled()) {
List children_to_enable = new ArrayList();
children_to_enable.addAll(java.util.Collections.list(node.children()));
while (!children_to_enable.isEmpty()) {
CheckboxTreeNode n = (CheckboxTreeNode) children_to_enable.remove(0);
if (!n.isLeaf() && n.isChecked())
children_to_enable.addAll(java.util.Collections.list(n.children()));
n.setEnabled(visibility);
}
}
if (node.isLeaf()
&& node == ((CheckboxTreeNode) node.getParent()).getFirstChild()
&& (CheckboxTreeNode) node.getParent() != _user_def_goup_node) {
Enumeration c = ((CheckboxTreeNode) node.getParent()).children();
c.nextElement();
while (c.hasMoreElements()) {
CheckboxTreeNode childnode = (CheckboxTreeNode) c.nextElement();
if (childnode.isLeaf())
childnode.setAlwaysOn(node.isChecked());
}
}
if (!blind && node.getEnabled())
DataStoreUser.getInstance().getSockeyeTrackList().setFeatureVisibility(
selectedFeatures(node),
visibility);
}
private Timer timer = new Timer(900, new ActionListener() {
int count = 0;
int max_vis = 0;
public void actionPerformed(ActionEvent evt) {
if (MainFrame.getVis3D() != null
&& DataStoreUser.getInstance().getSockeyeTrackList() != null) {
count = MainFrame.getVis3D().getFeatureCount();
max_vis =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getVisibleFeatureCount();
l_sel_features_count.setText("Features: " + count + " / " + max_vis);
}
}
});
class FeatureNodeSelectionListener extends SockeyeNodeSelectionListener {
FeatureNodeSelectionListener(JTree tree) {
super(tree);
}
public void mouseClicked(MouseEvent e) {
if (e.getClickCount() > 2) {
return;
}
super.mouseClicked(e);
super.action(e);
CheckboxTreeNode node = this.getSelectedNode();
if (node == null)
return;
if (SwingUtilities.isRightMouseButton(e)
&& (node.getParent() == _user_def_goup_node)) {
FeatureTreePopup p = new FeatureTreePopup(node.toString());
p.show(FeaturePanel.this, e.getX(), e.getY());
return;
}
if (this.check_event) {
FeaturePanel.action(node, false);
}
}
}
}
package ca.bcgsc.sockeye.gui.navigation;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import javax.help.CSH;
import javax.swing.Box;
import javax.swing.JPanel;
import javax.swing.JTextField;
import ca.bcgsc.sockeye.gui.MainFrame;
public class HorizontalNavigationBar
extends JPanel {
int slowdown = 2;
GridBagLayout gridbag = new GridBagLayout();
GridBagConstraints gbc = new GridBagConstraints();
static JPanel p_memory = new JPanel();
public static JTextField memory = new JTextField(10);
ExtendedRotNavWheel rotz = new ExtendedRotNavWheel(true, false, "Z-Rot", null) {
public void wheelSpin(int ticks) {
MainFrame.getVis3D().platformRelRotateZ(ticks/(15f*slowdown));
}
};
ExtendedRotNavWheel movh = new ExtendedRotNavWheel(true, false, "H-Move", null) {
public void wheelSpin(int ticks) {
MainFrame.getVis3D().platformRelMove(ticks/(100f*slowdown), 0);
}
};
public HorizontalNavigationBar() {
this.setLayout(gridbag);
java.awt.Component spc1 = Box.createHorizontalGlue();
java.awt.Component spc2 = Box.createHorizontalGlue();
java.awt.Component spc3 = Box.createHorizontalGlue();
gbc.fill = GridBagConstraints.HORIZONTAL;
gbc.gridy = 0;
gbc.gridx = 1;
gridbag.setConstraints(rotz, gbc);
gbc.gridx = 3;
gridbag.setConstraints(movh, gbc);
gbc.gridx = 5;
gridbag.setConstraints(memory, gbc);
gbc.weightx = 1.0;
gbc.gridx = 4;
gridbag.setConstraints(spc1, gbc);
gbc.weightx = 0.1;
gbc.gridx = 2;
gridbag.setConstraints(spc2, gbc);
gbc.gridx = 0;
gridbag.setConstraints(spc3, gbc);
this.add(rotz);
this.add(movh);
this.add(spc1);
this.add(spc2);
this.add(spc3);
this.add(memory);
memory.setEditable(false);
initHelp();
}
protected void initHelp() {
CSH.setHelpIDString(this, "vis_working_with_3D_overview");
}
}
package ca.bcgsc.sockeye.gui.navigation;
import java.text.DateFormat;
import java.util.Collection;
import java.util.Date;
import java.util.Iterator;
import java.util.Stack;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.datastorage.StorageException;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
public class MoveActionAdaptor {
public static Stack __undo_stack = new Stack();
public synchronized static void move(
int track_id,
double c,
boolean add_offset) {
int length =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackDataWindowLength(
track_id)
- 1;
int shift = (int) (c * (length + 1));
move(track_id, shift, add_offset);
DataStoreUser.getInstance().getSockeyeTrackList().refreshTrackOffsets();
}
public synchronized static void move(
int track_id,
int a_shift,
boolean add_offset) {
if (track_id < 0)
return;
int old_offset =
DataStoreUser.getInstance().getSockeyeTrackList().getTrackOffset(
track_id);
if (add_offset) {
DataStoreUser.getInstance().getSockeyeTrackList().setTrackOffset(
track_id,
0);
}
int length =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackDataWindowLength(
track_id);
int start =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackDataWindowStart(
track_id);
int end =
DataStoreUser.getInstance().getSockeyeTrackList().getTrackDataWindowEnd(
track_id);
int offset =
DataStoreUser.getInstance().getSockeyeTrackList().getTrackOffset(
track_id);
int shift2 = a_shift + (add_offset ? offset : 0);
int new_start = start - shift2;
int new_end = new_start + length - 1;
if (new_start < 1) {
new_start = 1;
DataStoreUser.getInstance().getSockeyeTrackList().setTrackOffset(
track_id,
1 - new_start);
}
DataStoreUser.getInstance().getSockeyeTrackList().setTrackDataWindow(
track_id,
new_start,
new_end);
int new_offset =
DataStoreUser.getInstance().getSockeyeTrackList().getTrackOffset(
track_id);
if (add_offset) {
__undo_stack.push(new TrackInfo(start, end, old_offset,
-a_shift, 0, track_id, false));
} else {
__undo_stack.push(new TrackInfo(start, end, old_offset,
0, 0, track_id, false));
}
}
public synchronized static void updateViewport(
int track_id,
int start,
int end) {
if (track_id < 0)
return;
int old_offset =
DataStoreUser.getInstance().getSockeyeTrackList().getTrackOffset(
track_id);
int old_start =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackDataWindowStart(
track_id);
int old_end =
DataStoreUser.getInstance().getSockeyeTrackList().getTrackDataWindowEnd(
track_id);
updateTrackName(track_id, start, end);
DataStoreUser.getInstance().getSockeyeTrackList().setTrackDataWindow(
track_id,
start,
end);
DataStoreUser.getInstance().getSockeyeTrackList().setTrackOffset(
track_id,
old_offset + start - old_start);
int new_offset =
DataStoreUser.getInstance().getSockeyeTrackList().getTrackOffset(
track_id);
int shift = start - old_start;
__undo_stack.push(new TrackInfo(old_start, old_end, old_offset,
shift, 0, track_id, false));
DataStoreUser.getInstance().getSockeyeTrackList().refreshTrackOffsets();
}
public synchronized static void moveViewportAndDataByPercent(
int track_id,
double c) {
int length =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackDataWindowLength(
track_id)
- 1;
int shift = (int) (c * (length + 1));
moveViewportAndData(track_id, shift);
DataStoreUser.getInstance().getSockeyeTrackList().refreshTrackOffsets();
}
public synchronized static void moveViewportAndData(
int track_id,
int shift) {
if (track_id < 0) {
return;
}
int old_offset =
DataStoreUser.getInstance().getSockeyeTrackList().getTrackOffset(
track_id);
int offset = old_offset + shift;
DataStoreUser.getInstance().getSockeyeTrackList().setTrackOffset(
track_id,
offset);
int start =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackDataWindowStart(
track_id);
int end =
DataStoreUser.getInstance().getSockeyeTrackList().getTrackDataWindowEnd(
track_id);
int new_offset =
DataStoreUser.getInstance().getSockeyeTrackList().getTrackOffset(
track_id);
__undo_stack.push(new TrackInfo(start, end, old_offset,
shift, 0, track_id, false));
}
public synchronized static void zoom(int track_id, double c) {
DataStoreUser.getInstance().getSockeyeTrackList().refreshTrackOffsets();
if (track_id < 0)
return;
int old_offset =
DataStoreUser.getInstance().getSockeyeTrackList().getTrackOffset(
track_id);
int start =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackDataWindowStart(
track_id);
int end =
DataStoreUser.getInstance().getSockeyeTrackList().getTrackDataWindowEnd(
track_id);
int offset =
DataStoreUser.getInstance().getSockeyeTrackList().getTrackOffset(
track_id);
int actual_start = (start == 1 ? start - offset : start);
int length = end - actual_start + 1;
int median = (int) (end + actual_start) / 2;
int new_start = Math.max(1, median - (int) (length / 2f * c));
Object tml =
DataStoreUser.getInstance().getSockeyeTrackList().getTrackAttribute(
track_id,
"track_max_length");
int track_max_length =
(tml == null ? Integer.MAX_VALUE : Integer.parseInt(tml.toString()));
offset = offset + new_start - start;
int platform_correction = 0;
if( c > 1) {
platform_correction = old_offset - offset;
}
DataStoreUser.getInstance().getSockeyeTrackList().setTrackOffset(
track_id,
offset);
if (new_start < 1) {
DataStoreUser.getInstance().getSockeyeTrackList().setTrackOffset(
track_id,
offset - new_start + 1);
new_start = 1;
}
int new_end = Math.min(median + (int) (length / 2f * c), track_max_length);
if (new_end < new_start)
new_end = new_start;
updateTrackName(track_id, new_start, new_end);
DataStoreUser.getInstance().getSockeyeTrackList().setTrackDataWindow(
track_id,
new_start,
new_end);
__undo_stack.push(new TrackInfo(start, end, old_offset,
0, platform_correction, track_id, false));
Collection regions =
DataStoreUser.getInstance().getSockeyeTrackList().getFeatures(
track_id,
"region");
if (regions != null) {
for (Iterator i = regions.iterator(); i.hasNext();) {
TrackFeature region = (TrackFeature) i.next();
DataStoreUser.getInstance().getSockeyeTrackList().setFeatureVisibility(
track_id,
"region",
region.getAccessionID(),
TrackPanel.isVisible(region.getAccessionID()));
}
}
DataStoreUser.getInstance().getSockeyeTrackList().refreshTrackOffsets();
}
public synchronized static void undo() {
if (!__undo_stack.empty()) {
TrackInfo track_info = (TrackInfo) __undo_stack.pop();
if (__undo_stack.empty()) {
NZControlPanel.setUndoEnable(false);
}
int start = track_info.getStart();
int end = track_info.getEnd();
int old_offset = track_info.getOldOffset();
int shift = track_info.getShift();
int track_id = track_info.getTrackID();
int current_offset = 0, current_start = 0, current_data_window_start = 0;
try {
current_offset =
DataStoreUser.getInstance().getSockeyeTrackList().getTrackOffset(
track_id);
current_start =
DataStoreUser.getInstance().getSockeyeTrackList().getTrackDataStart(
track_id);
current_data_window_start =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackDataWindowStart(
track_id);
} catch (StorageException e) {
return;
}
DataStoreUser.getInstance().getSockeyeTrackList().setTrackDataWindow(
track_id,
start,
end);
if (shift < 0 && start == current_data_window_start) {
DataStoreUser.getInstance().getSockeyeTrackList().setTrackOffset(
track_id,
current_offset - shift);
} else {
DataStoreUser.getInstance().getSockeyeTrackList().setTrackOffset(
track_id,
old_offset);
}
int platform_correction = track_info.getPlatformCorrection();
if( platform_correction != 0 ) {
DataStoreUser.getInstance().getSockeyeTrackList().setTrackOffset(
track_id,
platform_correction);
DataStoreUser.getInstance().getSockeyeTrackList().refreshTrackOffsets();
}
updateTrackName(track_id, start, end);
}
DataStoreUser.getInstance().getSockeyeTrackList().refreshTrackOffsets();
}
private static void updateTrackName(int track_id, int start, int end) {
String old_track_name =
(String) DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackAttribute(
track_id,
"track_name");
String track_name = old_track_name.split(":")[0];
track_name
+= new String(
":"
+ start
+ ".."
+ end
+ "="
+ DateFormat.getDateTimeInstance(
DateFormat.SHORT,
DateFormat.SHORT).format(
new Date()));
DataStoreUser.getInstance().getSockeyeTrackList().setTrackAttribute(
track_id,
"track_name",
track_name);
}
}
class TrackInfo {
int start, end, track_id, old_offset, shift, platform_correction;
boolean undo_next;
public TrackInfo(int start, int end, int old_offset,
int shift,
int platform_correction, int track_id, boolean undo_next) {
this.start = start;
this.end = end;
this.old_offset = old_offset;
this.shift = shift;
this.track_id = track_id;
this.undo_next = false;
this.platform_correction = platform_correction;
System.out.println(this);
}
public int getPlatformCorrection() {
return platform_correction;
}
public int getStart() {
return start;
}
public int getEnd() {
return end;
}
public int getOldOffset() {
return old_offset;
}
public int getTrackID() {
return track_id;
}
public int getShift() {
return shift;
}
public boolean getUndoNext() {
return undo_next;
}
public String toString() {
return new String(
"track_id="
+ track_id
+ " old_start="
+ start
+ " old_end="
+ end
+ " shift="
+ shift
+ " old_offset="
+ old_offset
);
}
}
package ca.bcgsc.sockeye.gui.navigation;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.event.ActionEvent;
import java.util.regex.Pattern;
import javax.help.CSH;
import javax.swing.JComboBox;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JToolBar;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.datastorage.StorageException;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.gui.MainFrame;
import ca.bcgsc.sockeye.j3d.events.EventListener3D;
import ca.bcgsc.sockeye.j3d.events.Feature3DSelectedEvent;
import ca.bcgsc.sockeye.j3d.events.Track3DMouseDragged;
import ca.bcgsc.sockeye.j3d.events.Track3DSelectedEvent;
import ca.bcgsc.sockeye.j3d.events.UnselectAll3DEvent;
import ca.bcgsc.sockeye.j3d.events.UnselectAll3DTracks;
import ca.bcgsc.util.gui.models.SockeyeComboBoxModel;
import ca.bcgsc.util.gui.scomponents.SockeyeButton;
import ca.bcgsc.util.gui.scomponents.SockeyeComboBox;
import ca.bcgsc.util.gui.scomponents.SockeyeTextField;
public class NZControlPanel extends JPanel implements EventListener3D {
final String[] MOVE_BY = { "10%", "25%", "50%", "75%", "90%" };
final String[] MOVE_WHAT = { "Window & data", "Data only", "Window only" };
final String[] RANGE = { "1000", "10000", "100000", "1000000" };
final String[] ZOOM = { "2", "5", "10" };
SockeyeButton b_move_left =
new SockeyeButton(Configuration.reverse_icon, "Move left");
SockeyeButton b_move_right =
new SockeyeButton(Configuration.forward_icon, "Move right");
SockeyeButton b_remove_offset =
new SockeyeButton(Configuration.clear_icon, "Remove offset");
JComboBox cb_move_what = new JComboBox(MOVE_WHAT);
SockeyeTextField tf_start_coord = new SockeyeTextField(0, 10);
SockeyeTextField tf_end_coord = new SockeyeTextField(0, 10);
SockeyeComboBox cb_range = new SockeyeComboBox(RANGE);
JComboBox cb_move_by = new JComboBox(MOVE_BY);
SockeyeButton b_execute =
new SockeyeButton(Configuration.crop_track_icon, "Execute operation");
SockeyeButton b_zoom_in =
new SockeyeButton(Configuration.zoom_in_icon, "Zoom in");
SockeyeButton b_zoom_out =
new SockeyeButton(Configuration.zoom_out_icon, "Zoom out");
SockeyeComboBoxModel cb_zoom_model = new SockeyeComboBoxModel();
SockeyeComboBox cb_zoom = new SockeyeComboBox(cb_zoom_model);
static SockeyeButton b_undo =
new SockeyeButton(Configuration.undo_icon, "Undo");
int height = 20;
int top_margin = 5;
int old_start, old_end;
int active_track = 0;
int active_track_max_length = Integer.MAX_VALUE;
MoveActionAdaptor moveActionAdaptor;
TrackFeature _currently_selected_feature;
public NZControlPanel() {
jbInit();
initHelp();
}
void jbInit() {
this.setLayout(new FlowLayout(FlowLayout.LEFT));
setMovePanel();
setUpdatePanel();
setZoomPanel();
b_undo.setMnemonic('0');
b_undo.setEnabled(false);
add(b_undo);
b_undo.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
MoveActionAdaptor.undo();
}
});
enableControls(false);
}
public void feature3DSelectedEventReceived(Feature3DSelectedEvent e) {
_currently_selected_feature = e.getTrackFeature();
active_track = _currently_selected_feature.getTrackId();
int start = e.getTrackFeature().getStart();
int end = e.getTrackFeature().getEnd();
updatePanel(start, end);
enableControls(true);
}
public void unselectAll3DEventReceived(UnselectAll3DEvent e) {
try {
int start =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackDataWindowStart(
active_track);
int end =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackDataWindowEnd(
active_track);
Object tml =
DataStoreUser.getInstance().getSockeyeTrackList().getTrackAttribute(
active_track,
"track_max_length");
active_track_max_length =
(tml == null ? Integer.MAX_VALUE : Integer.parseInt(tml.toString()));
updatePanel(start, end);
} catch (StorageException se) {
active_track = -1;
updatePanel(0, 0);
enableControls(false);
}
}
public void track3DSelectedEventReceived(Track3DSelectedEvent e) {
if (e.isSelected()) {
active_track = e.getTrackId();
int start =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackDataWindowStart(
active_track);
int end =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackDataWindowEnd(
active_track);
Object tml =
DataStoreUser.getInstance().getSockeyeTrackList().getTrackAttribute(
active_track,
"track_max_length");
active_track_max_length =
(tml == null ? Integer.MAX_VALUE : Integer.parseInt(tml.toString()));
updatePanel(start, end);
enableControls(true);
} else {
active_track = -1;
updatePanel(0, 0);
enableControls(false);
}
}
public void unselectAllTracks3DEventReceived(UnselectAll3DTracks e) {
active_track = -1;
active_track_max_length = Integer.MAX_VALUE;
updatePanel(0, 0);
enableControls(false);
}
public void Track3DMouseDraggedEventReceived(Track3DMouseDragged e) {
int start = e.getStart();
int end = e.getEnd();
updatePanel(start, end);
}
private void setMovePanel() {
b_move_left.setEnabled(false);
b_move_left.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
b_undo.setEnabled(true);
b_move_actionPerformed(-1);
}
});
cb_move_what.setToolTipText("Select what to move");
cb_move_what.setPreferredSize(
new Dimension((int) cb_move_what.getPreferredSize().getWidth(), 22));
cb_move_what.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
if ( !((String) cb_move_what.getSelectedItem()).equals("Window & data") ) {
b_move_left.setEnabled(true);
b_move_right.setEnabled(true);
} else if ( DataStoreUser.getInstance().getSockeyeTrackList().getVisibleTrackCount() < 2){
b_move_left.setEnabled(false);
b_move_right.setEnabled(false);
}
}
});
cb_move_by.setEditable(true);
cb_move_by.setToolTipText("Move by");
cb_move_by.setPrototypeDisplayValue("10000");
cb_move_by.setPreferredSize(new Dimension((int)cb_move_by.getPreferredSize().getWidth(), 22));
b_move_right.setEnabled(false);
b_move_right.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
b_undo.setEnabled(true);
b_move_actionPerformed(1);
}
});
b_remove_offset.setEnabled(false);
b_remove_offset.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
b_undo.setEnabled(true);
DataStoreUser.getInstance().getSockeyeTrackList().setTrackOffset(
active_track,
0);
}
});
this.add(b_move_left, null);
this.add(cb_move_what);
this.add(cb_move_by);
this.add(b_move_right, null);
this.add(b_remove_offset, null);
add(new JToolBar.Separator());
}
private void setUpdatePanel() {
tf_start_coord.setToolTipText("Start coordinate");
tf_end_coord.setToolTipText("End coordinate");
Dimension tdf = tf_start_coord.getPreferredSize();
tdf.setSize((int)tdf.getHeight(), 22);
tf_start_coord.setPreferredSize(tdf);
tf_end_coord.setPreferredSize(tdf);
tf_start_coord.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
updateSelectedRegion();
};
});
tf_end_coord.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
updateSelectedRegion();
};
});
cb_range.setToolTipText("Range");
cb_range.setEditable(true);
cb_range.setPrototypeDisplayValue("999 999 999");
cb_range.setPreferredSize(new Dimension((int)cb_range.getPreferredSize().getWidth(), 22));
cb_range.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
try {
String item = cb_range.getValue();
int range = 1;
if (!item.equals("")) {
range = Integer.parseInt(item);
} else {
range = 1;
cb_range.setSelectedItem("1");
}
int old_start = Integer.valueOf(tf_start_coord.getValue()).intValue();
int old_end = Integer.valueOf(tf_end_coord.getValue()).intValue();
int median = (old_start + old_end) / 2;
int start = median - range / 2;
if (start < 1) {
start = 1;
}
int end = median + range / 2;
if (end > active_track_max_length) {
end = active_track_max_length;
}
tf_start_coord.setValue(start);
tf_end_coord.setValue(end);
} catch (Throwable t) {
t.printStackTrace();
}
}
});
b_execute.setEnabled(false);
b_execute.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
b_undo.setEnabled(true);
int start = Integer.valueOf(tf_start_coord.getValue()).intValue();
int end = Integer.valueOf(tf_end_coord.getValue()).intValue();
if (start > end) {
JOptionPane.showMessageDialog(
null,
" Wrong entry: start > end. No action.",
"Warning",
JOptionPane.YES_NO_OPTION);
tf_start_coord.setValue(old_start);
tf_end_coord.setValue(old_end);
return;
} else {
old_start = start;
old_end = end;
MoveActionAdaptor.updateViewport(active_track, start, end);
}
}
});
add(tf_start_coord);
add(tf_end_coord);
add(cb_range);
add(b_execute);
add(new JToolBar.Separator());
}
private void setZoomPanel() {
for (int i = 0; i < ZOOM.length; i++) {
cb_zoom_model.addItem(i, ZOOM[i]);
}
cb_zoom.setSelectedIndex(0);
cb_zoom.updateUI();
cb_zoom.setToolTipText("Zoom level");
cb_zoom.setPrototypeDisplayValue("999%");
cb_zoom.setPreferredSize(new Dimension((int)cb_zoom.getPreferredSize().getWidth(), 22));
b_zoom_in.setEnabled(false);
b_zoom_in.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
b_undo.setEnabled(true);
String zoom_level = (String) cb_zoom_model.getSelectedItem();
MoveActionAdaptor.zoom(
active_track,
1.0 / Double.valueOf(zoom_level).doubleValue());
}
});
b_zoom_out.setEnabled(false);
b_zoom_out.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
b_undo.setEnabled(true);
String zoom_level = (String) cb_zoom_model.getSelectedItem();
MoveActionAdaptor.zoom(
active_track,
Double.valueOf(zoom_level).doubleValue());
}
});
add(b_zoom_in);
add(cb_zoom);
add(b_zoom_out);
add(new JToolBar.Separator());
}
void b_move_actionPerformed(int left_or_right) {
if (active_track < 0) {
return;
}
if (cb_move_what.getSelectedItem().equals("Window only")) {
left_or_right = -left_or_right;
}
String move_value = (String) cb_move_by.getEditor().getItem();
Pattern percent = Pattern.compile("([0-9]+)%");
Pattern bases = Pattern.compile("([0-9]+)");
if (percent.matcher(move_value).matches()) {
double move_by_percent =
Double.valueOf(move_value.split("%")[0]).doubleValue();
if (cb_move_what.getSelectedItem().equals("Window only")) {
MoveActionAdaptor.move(
active_track,
left_or_right * move_by_percent / 100,
true);
} else if (cb_move_what.getSelectedItem().equals("Data only")) {
MoveActionAdaptor.move(
active_track,
left_or_right * move_by_percent / 100,
false);
} else if (cb_move_what.getSelectedItem().equals("Window & data")) {
MoveActionAdaptor.moveViewportAndDataByPercent(
active_track,
left_or_right * move_by_percent / 100);
}
} else if (bases.matcher(move_value).matches()) {
int move_by_bases = Integer.valueOf(move_value).intValue();
if (cb_move_what.getSelectedItem().equals("Window only")) {
MoveActionAdaptor.move(
active_track,
left_or_right * move_by_bases,
true);
} else if (cb_move_what.getSelectedItem().equals("Data only")) {
MoveActionAdaptor.move(
active_track,
left_or_right * move_by_bases,
false);
} else if (cb_move_what.getSelectedItem().equals("Window & data")) {
MoveActionAdaptor.moveViewportAndData(
active_track,
left_or_right * move_by_bases);
}
} else {
JOptionPane.showMessageDialog(
null,
"Please enter correct value, either in percent (%) or in bases.",
"Warning",
JOptionPane.ERROR_MESSAGE);
cb_move_by.getEditor().setItem(MOVE_BY[0]);
}
}
private void enableControls(boolean e) {
if ( DataStoreUser.getInstance().getSockeyeTrackList().getTrackCount() < 2
&& ((String) cb_move_what.getSelectedItem()).equals("Window & data")) {
b_move_left.setEnabled(false);
b_move_right.setEnabled(false);
} else {
b_move_left.setEnabled(e);
b_move_right.setEnabled(e);
}
b_execute.setEnabled(e);
b_zoom_in.setEnabled(e);
b_zoom_out.setEnabled(e);
cb_move_what.setEnabled(e);
cb_move_by.setEnabled(e);
cb_range.setEnabled(e);
cb_zoom.setEnabled(e);
tf_start_coord.setEnabled(e);
tf_end_coord.setEnabled(e);
b_remove_offset.setEnabled(e);
}
static void setUndoEnable(boolean state) {
b_undo.setEnabled(state);
}
protected void initHelp() {
CSH.setHelpIDString(this, "vis_working_with_3D_overview");
}
void updatePanel(int start, int end) {
old_start = start;
old_end = end;
cb_range.setSelectedItem(String.valueOf(end - start + 1));
tf_start_coord.setValue(start);
tf_end_coord.setValue(end);
}
protected void updateSelectedRegion() {
int start =
Math.max(
Integer.parseInt(tf_start_coord.getValue()),
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackDataWindowStart(
active_track));
int end =
Math.min(
Integer.parseInt(tf_end_coord.getValue()),
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackDataWindowEnd(
active_track));
if (_currently_selected_feature!=null &&
_currently_selected_feature.getFeature().equals("region")){
System.out.println("NZ CONTROL BAR DEBUG: CHANGING STORED REGION");
_currently_selected_feature.setStart((int)Math.min(start,end));
_currently_selected_feature.setEnd((int)Math.max(start,end));
cb_range.setSelectedItem(String.valueOf(end - start + 1));
MainFrame.getVis3D().resetAllFeatures();
return;
}
if (start < end)
MainFrame.getVis3D().updateRegionSelect(start, end);
else
MainFrame.getVis3D().updateRegionSelect(end, start);
}
}
package ca.bcgsc.sockeye.gui.navigation;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import javax.swing.JPanel;
import ca.bcgsc.sockeye.gui.util.ImageLoader;
public class RotWheelSlider extends JPanel {
private Image icon_deactive = ImageLoader.loadIcon("slider_horiz.gif").getImage();
private Image icon_active = ImageLoader.loadIcon("slider_horiz_sharp.gif").getImage();
private Image icon_background = icon_deactive;
private boolean _drag = false;
private int _drag_width;
private boolean _is_horizontal = true;
int _last_mouse_pos;
public RotWheelSlider(){
init();
}
public void sliderDragged(int ticks){
}
public void setSliderHorizontal(boolean h){
_is_horizontal = h;
if (h){
icon_deactive = ImageLoader.loadIcon("slider_horiz.gif").getImage();
icon_active = ImageLoader.loadIcon("slider_horiz_sharp.gif").getImage();
}
else{
icon_deactive = ImageLoader.loadIcon("slider_vert.gif").getImage();
icon_active = ImageLoader.loadIcon("slider_vert_sharp.gif").getImage();
}
icon_background = icon_deactive;
this.setPreferredSize(new Dimension(icon_background.getWidth(this), icon_background.getHeight(this)));
}
protected void paintChildren (Graphics g){
super.paintChildren(g);
if (_is_horizontal)
g.translate(0,(getHeight()-icon_background.getHeight(this))/2);
else
g.translate((getWidth()-icon_background.getWidth(this))/2, 0);
g.drawImage(icon_background, 0, 0, this);
if (_drag){
if (_is_horizontal) {
for (int i = 0; i < _drag_width; i++)
g.drawLine(2 + (6 * i + _drag_width) % 60, 2,
2 + (6 * i + _drag_width) % 60, 8);
}
else {
for (int i = 0; i < _drag_width; i++)
g.drawLine (3, 2 + (6*i+_drag_width) % 60,
8, 2 + (6*i+_drag_width) % 60);
}
}
}
public boolean isOpaque() {
return false;
}
private void init() {
this.setPreferredSize(new Dimension(icon_background.getWidth(this), icon_background.getHeight(this)));
this.addMouseListener(new MouseAdapter() {
public void mouseEntered(MouseEvent e) {
icon_background = icon_active;
repaint();
}
public void mouseExited(MouseEvent e) {
icon_background = icon_deactive;
_drag = false;
_drag_width = 0;
repaint();
}
public void mouseReleased(MouseEvent e) {
if (_drag) {
_drag = false;
_drag_width = 0;
repaint();
}
}
});
this.addMouseMotionListener(new MouseMotionAdapter() {
public void mouseDragged(MouseEvent e) {
int pos = _is_horizontal ? e.getX() : e.getY();
int max = _is_horizontal ? icon_background.getWidth(RotWheelSlider.this): icon_background.getHeight(RotWheelSlider.this);
if (pos > max || pos < 0){
_drag = false;
_drag_width = 0;
return;
}
if (!_drag) {
_last_mouse_pos = _is_horizontal ? e.getX() : e.getY();
}
_drag = true;
_drag_width += 2;
sliderDragged( (_is_horizontal ? e.getX() : e.getY()) - _last_mouse_pos);
_last_mouse_pos = _is_horizontal ? e.getX() : e.getY();
repaint();
}
});
}
}
package ca.bcgsc.sockeye.gui.navigation;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import javax.swing.JPanel;
import javax.swing.Timer;
import ca.bcgsc.sockeye.gui.util.ImageLoader;
public class SpringLoadedSlider extends JPanel {
private Image icon_background = ImageLoader.loadIcon("slider_horiz_sharp.gif").getImage();
private Image icon_knob_active = ImageLoader.loadIcon("circle_blue_16.gif").getImage();
private Image icon_knob_deactive = ImageLoader.loadIcon("circle_gray_16.gif").getImage();
private Image icon_knob = icon_knob_deactive;
private int knob_middle_x;
private int knob_middle_y;
private int knob_dim_x;
private int knob_dim_y;
private int _drag_offset;
private int _max_extend;
private boolean _is_horizontal = true;
int _last_mouse_pos;
public SpringLoadedSlider(){
init(false);
}
public SpringLoadedSlider(boolean horiz){
init(horiz);
}
public void action(int ticks){
}
protected void paintChildren (Graphics g){
super.paintChildren(g);
if (_is_horizontal){
g.translate(0, (getHeight() - icon_background.getHeight(this)) / 2);
knob_middle_x = getWidth()/2 - icon_knob.getWidth(this)/2;
}
else{
g.translate( (getWidth() - icon_background.getWidth(this)) / 2, 0);
knob_middle_y = getHeight()/2 - icon_knob.getHeight(this)/2;
}
g.drawImage(icon_background, 0, 0, this);
if (_is_horizontal) {
for (int i = 0; i < _max_extend; i++)
g.drawLine(2 + (20 * i + _drag_offset) % 65, 2,
2 + (20 * i + _drag_offset) % 65, 8);
g.drawImage(icon_knob, knob_middle_x+_drag_offset, knob_middle_y, this);
}
else {
for (int i = 0; i < _max_extend; i++)
g.drawLine (3, 2 + (20 * i+_drag_offset) % 65,
8, 2 + (20 * i+_drag_offset) % 65);
g.drawImage(icon_knob, knob_middle_x, knob_middle_y+_drag_offset, this);
}
}
public boolean isOpaque() {
return false;
}
private void init(boolean horizontal) {
_is_horizontal = horizontal;
if (horizontal){
icon_background = ImageLoader.loadIcon(
"slider_horiz_sharp.gif").
getImage();
_max_extend = icon_background.getWidth(this)/2;
}
else{
icon_background = ImageLoader.loadIcon(
"slider_vert_sharp.gif").
getImage();
_max_extend = icon_background.getHeight(this)/2;
}
setPreferredSize(new Dimension(icon_background.getWidth(this), icon_background.getHeight(this)));
setMinimumSize(new Dimension(icon_background.getWidth(this), icon_background.getHeight(this)));
knob_dim_x = icon_knob.getWidth(this)/2;
knob_dim_y = icon_knob.getHeight(this)/2;
knob_middle_x = -icon_knob.getWidth(this)/2 + icon_background.getWidth(this)/2;
knob_middle_y = -icon_knob.getHeight(this)/2 + icon_background.getHeight(this)/2;
this.addMouseListener(new MouseAdapter() {
public void mouseEntered(MouseEvent e) {
icon_knob = icon_knob_active;
repaint();
}
public void mouseExited(MouseEvent e) {
if (!javax.swing.SwingUtilities.isLeftMouseButton(e)){
icon_knob = icon_knob_deactive;
repaint();
}
}
public void mouseReleased(MouseEvent e) {
if (!javax.swing.SwingUtilities.getLocalBounds(SpringLoadedSlider.this).contains(e.getPoint()))
icon_knob = icon_knob_deactive;
_drag_offset = 0;
timer.stop();
repaint();
}
});
this.addMouseMotionListener(new MouseMotionAdapter() {
public void mouseDragged(MouseEvent e) {
if (!timer.isRunning())
timer.start();
if (_is_horizontal)
_drag_offset = e.getX()-knob_dim_x - knob_middle_x;
else
_drag_offset = e.getY()-knob_dim_y - knob_middle_y;
_drag_offset = Math.max(-_max_extend,_drag_offset);
_drag_offset = Math.min(_max_extend, _drag_offset);
repaint();
}
});
}
private Timer timer = new Timer(10, new ActionListener() {
private double maxExpFactor = 10/Math.exp(_max_extend/10);
public void actionPerformed(ActionEvent evt) {
int drag = Math.abs(_drag_offset/10);
int actionvalue = (int)(Math.exp(drag)*maxExpFactor);
action (_drag_offset<0?-actionvalue:actionvalue);
}
});
}
package ca.bcgsc.sockeye.gui.navigation;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.List;
import javax.help.CSH;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTree;
import javax.swing.SwingUtilities;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreePath;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.datastorage.Track;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.datastorage.events.StorageEvent;
import ca.bcgsc.sockeye.datastorage.events.StorageEventListener;
import ca.bcgsc.sockeye.gui.MainFrame;
import ca.bcgsc.sockeye.gui.scomponents.CheckboxTreeRenderer;
import ca.bcgsc.sockeye.gui.sevents.SockeyeNodeSelectionListener;
import ca.bcgsc.sockeye.gui.sevents.SockeyeTreeTransferHandler;
import ca.bcgsc.sockeye.j3d.events.EventListener3D;
import ca.bcgsc.sockeye.j3d.events.Feature3DSelectedEvent;
import ca.bcgsc.sockeye.j3d.events.Track3DMouseDragged;
import ca.bcgsc.sockeye.j3d.events.Track3DSelectedEvent;
import ca.bcgsc.sockeye.j3d.events.UnselectAll3DEvent;
import ca.bcgsc.sockeye.j3d.events.UnselectAll3DTracks;
import ca.bcgsc.sockeye.popup.FeatureRightPopup;
import ca.bcgsc.sockeye.popup.TrackRightPopupNZ;
import ca.bcgsc.sockeye.trackmanager.AlignOperation;
import ca.bcgsc.util.gui.scomponents.CheckboxTreeNode;
public class TrackPanel
extends JPanel
implements StorageEventListener, EventListener3D {
final static String _ALL_TRACKS_TITLE = "Data Tracks";
final static String _REGIONS_TITLE = "Regions";
final static String _DATA_TITLE = "Data";
final static String _ALIGN_TITLE = "Align Highlight";
final static String _REV_PREFIX = "[R] ";
final static int _DATA_TITLE_INDEX = 0;
final static int _REGIONS_TITLE_INDEX = 1;
final static int _ALIGN_TITLE_INDEX = 2;
final static int _DEFAULT_TYPE = 0;
final static int _TRACK_TYPE = 1;
final static int _DATA_TITLE_TYPE = 2;
final static int _DATA_TYPE = 3;
final static int _REGION_TITLE_TYPE = 4;
final static int _REGION_TYPE = 5;
final static int _ALIGN_TITLE_TYPE = 6;
final static int _ALIGN_TYPE = 7;
JScrollPane scroll_pane = new JScrollPane();
public static JTree __track_tree;
public static int __sel_track_id = -1;
static List _visible_features;
static CheckboxTreeNode _root = new CheckboxTreeNode(_ALL_TRACKS_TITLE);
static boolean _select_all_tracks_action = false;
static public ArrayList __sel_tracks = new ArrayList();
public TrackPanel() {
jbInit();
initHelp();
}
private void jbInit() {
CheckboxTreeRenderer treeRenderer = new CheckboxTreeRenderer();
treeRenderer.setTrackTreeStyle();
_root.setChecked(true);
__track_tree = new JTree(_root);
_visible_features = new ArrayList();
__track_tree.setCellRenderer(treeRenderer);
__track_tree.putClientProperty("JTree.lineStyle", "Angled");
__track_tree.addMouseListener(new TrackNodeSelectionListener(__track_tree));
new SockeyeTreeTransferHandler(__track_tree);
scroll_pane.getViewport().add(__track_tree);
scroll_pane.createVerticalScrollBar();
this.setLayout(new BorderLayout());
this.add(scroll_pane, BorderLayout.CENTER);
this.setPreferredSize(new Dimension(300, 300));
}
public void feature3DSelectedEventReceived(Feature3DSelectedEvent e) {
TrackFeature region = e.getTrackFeature();
selectRegionPaths(region.getTrackId(), region.getSeqName(), e.isSelected());
}
public void unselectAll3DEventReceived(UnselectAll3DEvent e) {
__track_tree.clearSelection();
}
public void track3DSelectedEventReceived(Track3DSelectedEvent e) {
__track_tree.clearSelection();
selectTrackPaths(e.getTrackId());
}
public void unselectAllTracks3DEventReceived(UnselectAll3DTracks e) {
__track_tree.clearSelection();
}
public void Track3DMouseDraggedEventReceived(Track3DMouseDragged e) {
}
public void storageEventReceived(StorageEvent e) {
List attr = (List) e.getAttribute();
if (e.getEventType() == StorageEvent.STORAGE_EVENT_TRACK_ADD) {
for (int i = 0; i < attr.size(); i++)
addTrack(Integer.parseInt(attr.get(i).toString()));
}
if (e.getEventType() == StorageEvent.STORAGE_EVENT_TRACK_ADD_DS) {
addData(
Integer.parseInt(attr.get(0).toString()),
Integer.parseInt(attr.get(1).toString()));
}
if (e.getEventType() == StorageEvent.STORAGE_EVENT_TRACK_REMOVE_DS) {
deleteData(
Integer.parseInt(attr.get(0).toString()),
Integer.parseInt(attr.get(1).toString()));
}
if (e.getEventType() == StorageEvent.STORAGE_EVENT_TRACK_REMOVE) {
for (int i = 0; i < attr.size(); i++) {
deleteTrack(Integer.parseInt(attr.get(i).toString()));
}
}
if (e.getEventType() == StorageEvent.STORAGE_EVENT_TRACK_ADD_FEATURES) {
if (attr.get(1).equals("region")) {
int track_id = Integer.parseInt(attr.get(0).toString());
for (int i = 2; i < attr.size(); i++) {
TrackFeature region = (TrackFeature) attr.get(i);
addRegion(track_id, region);
}
}
if (attr.get(1).equals(AlignOperation.ALN_HIGHLIGHT_FEATURE)) {
int track_id = Integer.parseInt(attr.get(0).toString());
for (int i = 2; i < attr.size(); i++) {
TrackFeature region = (TrackFeature) attr.get(i);
addAlignmentRegion(track_id, region);
}
}
}
if (e.getEventType()
== StorageEvent.STORAGE_EVENT_TRACK_ATTRIBUTE_CHANGED) {
int track_id = Integer.parseInt(attr.get(0).toString());
String attr_name = attr.get(1).toString();
String attr_value = attr.get(2).toString();
if (attr_name.equals("track_name")) {
setTrackNodeUserObject(track_id, attr_value);
}
}
if (e.getEventType()
== StorageEvent.STORAGE_EVENT_TRACK_VISIBILITY_CHANGED) {
int track_id = Integer.parseInt(attr.get(0).toString());
boolean vis = Boolean.toString(true).equals(attr.get(1).toString());
CheckboxTreeNode n = getTrackNode(track_id);
if (n != null && n.isChecked() != vis) {
CheckboxTreeNode track_node = getTrackNode(track_id);
if (track_node != null)
track_node.setChecked(vis);
showTrack(track_id, vis);
}
}
if (e.getEventType() == StorageEvent.STORAGE_EVENT_TRACK_REMOVE_FEATURES) {
int track_id = Integer.parseInt(attr.get(0).toString());
if (attr.contains("region")) {
CheckboxTreeNode regionnode =
getTrackChildNode(getTrackNode(track_id), _REGIONS_TITLE, true);
if (regionnode == null)
return;
List to_delete = new ArrayList();
for (Enumeration r = regionnode.children(); r.hasMoreElements();) {
String acc_id = r.nextElement().toString();
if (DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getFeature(track_id, "region", acc_id)
== null)
to_delete.add(acc_id);
}
for (Iterator it = to_delete.iterator(); it.hasNext();)
deleteRegion(track_id, it.next().toString(), _REGIONS_TITLE);
}
if (attr.contains(AlignOperation.ALN_HIGHLIGHT_FEATURE)) {
CheckboxTreeNode regionnode =
getTrackChildNode(getTrackNode(track_id), _ALIGN_TITLE, true);
if (regionnode == null)
return;
List to_delete = new ArrayList();
for (Enumeration r = regionnode.children(); r.hasMoreElements();) {
String acc_id = r.nextElement().toString();
if (DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getFeature(track_id, AlignOperation.ALN_HIGHLIGHT_FEATURE, acc_id)
== null)
to_delete.add(acc_id);
}
for (Iterator it = to_delete.iterator(); it.hasNext();)
deleteRegion(track_id, it.next().toString(), _ALIGN_TITLE);
}
}
if (e.getEventType()
== StorageEvent.STORAGE_EVENT_TRACK_REVERSED_STATE_CHANGED) {
int track_id = Integer.parseInt(attr.get(0).toString());
CheckboxTreeNode track_node = getTrackNode(track_id);
if (track_node == null)
return;
String track_name = track_node.getUserObject().toString();
setTrackNodeUserObject(track_id, track_name);
}
}
private void setTrackNodeUserObject(int t_id, Object o) {
CheckboxTreeNode track_node = getTrackNode(t_id);
if (track_node == null)
return;
TreePath path = new TreePath(track_node.getPath());
String name = o.toString();
if (DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackReverse(t_id)) {
if (!name.startsWith(_REV_PREFIX))
name = _REV_PREFIX + name;
} else if (name.startsWith(_REV_PREFIX))
name = name.substring(4);
__track_tree.getModel().valueForPathChanged(path, name);
}
static public void selectTrackPaths(int track_id) {
ArrayList sel_tracks = getSelectedPaths();
if (sel_tracks == null)
sel_tracks = new ArrayList();
CheckboxTreeNode track_node = getTrackNode(track_id);
if (track_node != null) {
Object[] path = new Object[2];
path[0] = _root;
path[1] = track_node;
sel_tracks.add(new TreePath(path));
TreePath[] new_paths = new TreePath[sel_tracks.size()];
for (int i = 0; i < sel_tracks.size(); i++) {
new_paths[i] = (TreePath) sel_tracks.get(i);
}
try{
__track_tree.scrollPathToVisible(new_paths[new_paths.length - 1]);
}catch(Exception e){
}
__track_tree.getSelectionModel().setSelectionPaths(new_paths);
}
}
private void selectRegionPaths(
int track_id,
String region_name,
boolean selected) {
ArrayList sel_regions = getSelectedPaths();
if (sel_regions == null)
sel_regions = new ArrayList();
CheckboxTreeNode region_node = getRegionNode(track_id, region_name);
CheckboxTreeNode track_node = getTrackNode(track_id);
if (region_node != null && track_node != null) {
Object[] path = new Object[4];
path[0] = _root;
path[1] = track_node;
path[2] = getTrackChildNode(track_node, _REGIONS_TITLE, true);
path[3] = region_node;
TreePath cur_path = new TreePath(path);
if (selected)
sel_regions.add(cur_path);
else
sel_regions.remove(cur_path);
TreePath[] new_paths = new TreePath[sel_regions.size()];
for (int i = 0; i < sel_regions.size(); i++) {
if (__track_tree.isVisible((TreePath) sel_regions.get(i)))
new_paths[i] = (TreePath) sel_regions.get(i);
}
if (new_paths.length > 0)
__track_tree.scrollPathToVisible(new_paths[new_paths.length - 1]);
__track_tree.getSelectionModel().setSelectionPaths(new_paths);
}
}
static private CheckboxTreeNode getTrackNode(int track_id) {
for (int i = 0; i < _root.getChildCount(); i++) {
CheckboxTreeNode child = (CheckboxTreeNode) _root.getChildAt(i);
if (child.getId().equals(String.valueOf(track_id))) {
return child;
}
}
return null;
}
private CheckboxTreeNode getRegionNode(int track_id, String region_id) {
CheckboxTreeNode track_node = getTrackNode(track_id);
CheckboxTreeNode regions =
getTrackChildNode(track_node, _REGIONS_TITLE, true);
for (int i = 0; i < regions.getChildCount(); i++) {
CheckboxTreeNode region = (CheckboxTreeNode) regions.getChildAt(i);
if (region.toString().equals(region_id)) {
return region;
}
}
return null;
}
private void deleteRegion(int track_id, String region_id, String title) {
CheckboxTreeNode track_node = getTrackNode(track_id);
CheckboxTreeNode regions = getTrackChildNode(track_node, title, true);
for (int i = 0; i < regions.getChildCount(); i++) {
CheckboxTreeNode region = (CheckboxTreeNode) regions.getChildAt(i);
if (region.toString().equals(region_id)) {
regions.remove(region);
break;
}
}
if (regions.getChildCount() == 0) {
track_node.remove(regions);
}
((DefaultTreeModel) __track_tree.getModel()).reload();
if (regions.getChildCount() != 0) {
expendTrackChildNode(track_node, regions);
}
if (!_visible_features.contains(region_id))
_visible_features.remove(region_id);
}
private void addAllRegions(int track_id) {
Collection regions =
DataStoreUser.getInstance().getSockeyeTrackList().getFeatures(
track_id,
"region");
if (regions != null) {
for (Iterator i = regions.iterator(); i.hasNext();) {
TrackFeature region = (TrackFeature) i.next();
addRegion(track_id, region);
}
}
}
private void addAllAlignmentRegions(int track_id) {
Collection regions =
DataStoreUser.getInstance().getSockeyeTrackList().getFeatures(
track_id,
AlignOperation.ALN_HIGHLIGHT_FEATURE);
if (regions != null) {
for (Iterator i = regions.iterator(); i.hasNext();) {
TrackFeature region = (TrackFeature) i.next();
addAlignmentRegion(track_id, region);
}
}
}
private void addTrack(int track_id) {
Object tno =
DataStoreUser.getInstance().getSockeyeTrackList().getTrackAttribute(
track_id,
"track_name");
String track_name = new String("Unknown Track");
if (tno != null)
track_name = tno.toString();
if (DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackReverse(track_id)) {
track_name = _REV_PREFIX + track_name;
}
CheckboxTreeNode track_node =
new CheckboxTreeNode(
track_name,
String.valueOf(track_id),
TrackPanel._TRACK_TYPE);
track_node.setSelected(true);
track_node.setChecked(
DataStoreUser.getInstance().getSockeyeTrackList().getTrackVisibility(
track_id));
_root.add(track_node);
__track_tree.revalidate();
((DefaultTreeModel) __track_tree.getModel()).reload();
}
private static CheckboxTreeNode getTrackChildNode(
CheckboxTreeNode track_node,
String child_name,
boolean add) {
int count = track_node.getChildCount();
CheckboxTreeNode title = null;
for (int i = 0; i < count; i++) {
CheckboxTreeNode child = (CheckboxTreeNode) track_node.getChildAt(i);
if (child.toString().equals(child_name))
return child;
}
if (add) {
int index = 0;
if (child_name.equals(_DATA_TITLE)) {
title = new CheckboxTreeNode(child_name, _DATA_TITLE_TYPE);
index = _DATA_TITLE_INDEX;
} else if (child_name.equals(_REGIONS_TITLE)) {
title = new CheckboxTreeNode(child_name, _REGION_TITLE_TYPE);
index = _REGIONS_TITLE_INDEX;
} else if (child_name.equals(_ALIGN_TITLE)) {
title = new CheckboxTreeNode(child_name, _ALIGN_TITLE_TYPE);
index = _ALIGN_TITLE_INDEX;
}
if (title != null) {
if (count < index)
index = count;
track_node.addNodeAt(title, index);
title.setChecked(true);
}
}
return title;
}
private void addRegion(int track_id, TrackFeature region) {
int region_index = 0;
String region_id = region.getSeqName();
if (!_visible_features.contains(region_id))
_visible_features.add(region_id);
CheckboxTreeNode track_node = getTrackNode(track_id);
CheckboxTreeNode regions_node =
getTrackChildNode(track_node, _REGIONS_TITLE, true);
if (regions_node == null)
return;
if (isNodeExist(regions_node, region_id))
return;
region_index = regions_node.getChildCount();
for (int j = 0; j < regions_node.getChildCount(); j++) {
String old_region_id = regions_node.getChildAt(j).toString();
TrackFeature old_region =
DataStoreUser.getInstance().getSockeyeTrackList().getFeature(
track_id,
"region",
old_region_id);
if (old_region != null)
if (old_region.getStart() > region.getStart()) {
region_index = j;
break;
}
}
CheckboxTreeNode region_node =
new CheckboxTreeNode(region_id, TrackPanel._REGION_TYPE);
regions_node.addNodeAt(region_node, region_index);
region_node.setChecked(true);
region_node.setSelected(true);
region_node.setId(region.getAccessionID());
((DefaultTreeModel) __track_tree.getModel()).reload();
__track_tree.clearSelection();
selectRegionPaths(track_id, region_id, true);
}
private void addAlignmentRegion(int track_id, TrackFeature region) {
int region_index = 0;
String region_id = region.getSeqName();
if (!_visible_features.contains(region_id))
_visible_features.add(region_id);
CheckboxTreeNode track_node = getTrackNode(track_id);
CheckboxTreeNode regions_node =
getTrackChildNode(track_node, _ALIGN_TITLE, true);
if (regions_node == null)
return;
if (isNodeExist(regions_node, region_id))
return;
region_index = regions_node.getChildCount();
for (int j = 0; j < regions_node.getChildCount(); j++) {
String old_region_id = regions_node.getChildAt(j).toString();
TrackFeature old_region =
DataStoreUser.getInstance().getSockeyeTrackList().getFeature(
track_id,
AlignOperation.ALN_HIGHLIGHT_FEATURE,
old_region_id);
if (old_region != null)
if (old_region.getStart() > region.getStart()) {
region_index = j;
break;
}
}
CheckboxTreeNode region_node =
new CheckboxTreeNode(region_id, _ALIGN_TYPE);
regions_node.addNodeAt(region_node, region_index);
region_node.setChecked(true);
region_node.setSelected(true);
region_node.setId(region.getAccessionID());
((DefaultTreeModel) __track_tree.getModel()).reload();
__track_tree.clearSelection();
selectRegionPaths(track_id, region_id, true);
}
private void addData(int track_id, int ds_id) {
String ds_name =
DataStoreUser
.getInstance()
.getDataSourceManager()
.getDataSource(ds_id)
.getDisplayString();
Track t =
DataStoreUser.getInstance().getSockeyeTrackList().getTrackReference(
track_id);
CheckboxTreeNode track_node = getTrackNode(track_id);
CheckboxTreeNode data_node =
getTrackChildNode(track_node, _DATA_TITLE, true);
CheckboxTreeNode data_source_node =
new CheckboxTreeNode(ds_name, TrackPanel._DATA_TYPE);
data_node.add(data_source_node);
data_source_node.setChecked(true);
data_source_node.setSelected(true);
((DefaultTreeModel) __track_tree.getModel()).reload();
}
private void deleteData(int track_id, int ds_id) {
}
private boolean expendTrackChildNode(
CheckboxTreeNode track_node,
CheckboxTreeNode track_child_node) {
Object[] path = new Object[3];
path[0] = _root;
path[1] = track_node;
path[2] = track_child_node;
try {
__track_tree.expandPath(new TreePath(path));
return true;
} catch (Exception e) {
return false;
}
}
protected void initHelp() {
CSH.setHelpIDString(this, "vis_working_with_3D_data_tracks");
}
static protected void action(CheckboxTreeNode track_node, boolean checked) {
int track_id = Integer.valueOf(track_node.getId()).intValue();
DataStoreUser.getInstance().getSockeyeTrackList().setTrackVisibility(
track_id,
checked);
if (checked) {
CheckboxTreeNode regions =
getTrackChildNode(track_node, _REGIONS_TITLE, false);
if (regions == null)
return;
for (int i = 0; i < regions.getChildCount(); i++) {
CheckboxTreeNode region_node = (CheckboxTreeNode) regions.getChildAt(i);
TrackFeature region =
DataStoreUser.getInstance().getSockeyeTrackList().getFeature(
track_id,
"region",
region_node.getId());
action(track_id, region, "region", region_node.isChecked());
}
}
}
static protected void action(
int track_id,
TrackFeature region,
String feature,
boolean checked) {
if (region == null)
return;
String acc_id = region.getAccessionID();
if (!checked && _visible_features.contains(acc_id))
_visible_features.remove(acc_id);
if (checked && !_visible_features.contains(acc_id))
_visible_features.add(acc_id);
DataStoreUser.getInstance().getSockeyeTrackList().setFeatureVisibility(
track_id,
feature,
acc_id,
checked);
}
private void deleteTrack(int track_id) {
for (int i = 0; i < _root.getChildCount(); i++) {
CheckboxTreeNode child = (CheckboxTreeNode) _root.getChildAt(i);
int id = Integer.valueOf(child.getId()).intValue();
if (id == track_id) {
((DefaultTreeModel) __track_tree.getModel()).removeNodeFromParent(
child);
break;
}
}
updateSelectAllTracks();
}
private void showTrack(int track_id, boolean vis) {
CheckboxTreeNode track_node = getTrackNode(track_id);
if (track_node == null || !vis)
return;
CheckboxTreeNode regions =
getTrackChildNode(track_node, _REGIONS_TITLE, true);
if (regions == null)
return;
for (Enumeration enum = regions.children(); enum.hasMoreElements();) {
CheckboxTreeNode region = (CheckboxTreeNode) enum.nextElement();
if (region.isChecked()) {
DataStoreUser.getInstance().getSockeyeTrackList().setFeatureVisibility(
track_id,
"region",
region.toString(),
true);
}
}
}
static boolean isVisible(String id) {
return _visible_features.contains(id);
}
protected static synchronized void updateSelectAllTracks() {
boolean checked = true;
for (int i = 0; i < _root.getChildCount(); i++) {
if (!((CheckboxTreeNode) _root.getChildAt(i)).isChecked()) {
checked = false;
break;
}
}
_root.setChecked(checked);
}
public static ArrayList getSelectedTrackIds() {
TreePath[] paths = TrackPanel.__track_tree.getSelectionPaths();
ArrayList track_ids = new ArrayList();
if (paths != null) {
for (int i = 0; i < paths.length; i++) {
track_ids.add(
i,
String.valueOf(
((CheckboxTreeNode) paths[i].getLastPathComponent()).getId()));
}
}
return track_ids;
}
private static ArrayList getSelectedPaths() {
TreePath[] paths = TrackPanel.__track_tree.getSelectionPaths();
ArrayList sel_paths = new ArrayList();
if (paths != null) {
for (int i = 0; i < paths.length; i++) {
sel_paths.add(paths[i]);
}
}
return sel_paths;
}
protected static ArrayList getSelectedRegions() {
ArrayList sel_reg_f = new ArrayList();
TreePath[] paths = __track_tree.getSelectionPaths();
if (paths != null) {
for (int i = 0; i < paths.length; i++) {
CheckboxTreeNode region_node =
(CheckboxTreeNode) paths[i].getLastPathComponent();
CheckboxTreeNode track_node =
(CheckboxTreeNode) region_node.getParent().getParent();
sel_reg_f.add(
DataStoreUser.getInstance().getSockeyeTrackList().getFeature(
Integer.valueOf(track_node.getId()).intValue(),
"region",
region_node.toString()));
}
}
return sel_reg_f;
}
boolean isNodeExist(CheckboxTreeNode parent, String node_name) {
for (int i = 0; i < parent.getChildCount(); i++) {
CheckboxTreeNode node = (CheckboxTreeNode) parent.getChildAt(i);
if (node.toString().equals(node_name)) {
return true;
}
}
return false;
}
static public void unselectAll() {
__track_tree.clearSelection();
MainFrame.getVis3D().unHighlightTrack();
MainFrame.getVis3D().unSelectAllFeatures();
}
static public void selectTrack(String track) {
try {
String[] tmpTrack = track.split(":");
int trackid = new Integer(tmpTrack[0]).intValue();
MainFrame.getVis3D().highlightTrack(trackid);
} catch (Throwable t) {
t.printStackTrace();
}
}
}
class TrackNodeSelectionListener extends SockeyeNodeSelectionListener {
TrackRightPopupNZ trp;
FeatureRightPopup frp;
int prev_sel_type = -1;
int cur_sel_type = -1;
ArrayList sel_nodes = new ArrayList();
TrackNodeSelectionListener(JTree tree) {
super(tree);
}
public void mousePressed(MouseEvent e) {
if (SwingUtilities.isLeftMouseButton(e)) {
if (e.isControlDown()) {
super.mousePressed(e);
CheckboxTreeNode node = super.getSelectedNode(e);
if (node != null) {
cur_sel_type = node.getType();
if (prev_sel_type != cur_sel_type) {
TrackPanel.unselectAll();
prev_sel_type = cur_sel_type;
}
if (cur_sel_type == TrackPanel._TRACK_TYPE) {
sel_nodes = TrackPanel.getSelectedTrackIds();
MainFrame.getVis3D().highlightTracks(sel_nodes);
}
else if (
cur_sel_type == TrackPanel._DATA_TITLE_TYPE
|| cur_sel_type == TrackPanel._REGION_TITLE_TYPE
|| cur_sel_type == TrackPanel._ALIGN_TITLE_TYPE
|| cur_sel_type == TrackPanel._DATA_TYPE) {
TrackPanel.unselectAll();
prev_sel_type = cur_sel_type;
}
else if (cur_sel_type == TrackPanel._REGION_TYPE) {
sel_nodes = TrackPanel.getSelectedRegions();
CheckboxTreeNode parent_node = (CheckboxTreeNode) node.getParent();
CheckboxTreeNode parent_track_node =
(CheckboxTreeNode) parent_node.getParent();
TrackFeature region =
DataStoreUser.getInstance().getSockeyeTrackList().getFeature(
Integer.valueOf(parent_track_node.getId()).intValue(),
"region",
node.toString());
MainFrame.getVis3D().controlLeftClickFeature(region);
}
else if (cur_sel_type == TrackPanel._ALIGN_TYPE) {
sel_nodes = TrackPanel.getSelectedRegions();
CheckboxTreeNode parent_node = (CheckboxTreeNode) node.getParent();
CheckboxTreeNode parent_track_node =
(CheckboxTreeNode) parent_node.getParent();
TrackFeature region =
DataStoreUser.getInstance().getSockeyeTrackList().getFeature(
Integer.valueOf(parent_track_node.getId()).intValue(),
AlignOperation.ALN_HIGHLIGHT_FEATURE,
node.toString());
MainFrame.getVis3D().controlLeftClickFeature(region);
}
}
} else {
TrackPanel.unselectAll();
action(e);
}
} else {
displayPopup(e);
}
}
public boolean action(MouseEvent e) {
if (super.action(e)) {
CheckboxTreeNode node = getSelectedNode();
cur_sel_type = node.getType();
if (node != null) {
prev_sel_type = cur_sel_type;
if (cur_sel_type == TrackPanel._DEFAULT_TYPE) {
TrackPanel._select_all_tracks_action = true;
for (int i = 0; i < node.getChildCount(); i++) {
CheckboxTreeNode child = ((CheckboxTreeNode) node.getChildAt(i));
if (node.isChecked() && !child.isChecked()) {
child.setChecked(true);
TrackPanel.action(child, child.isChecked());
} else if (!node.isChecked() && child.isChecked()) {
child.setChecked(false);
TrackPanel.action(child, node.isChecked());
}
}
TrackPanel._select_all_tracks_action = false;
TrackPanel.updateSelectAllTracks();
}
else if (cur_sel_type == TrackPanel._TRACK_TYPE) {
if (this.check_event) {
TrackPanel.action(node, node.isChecked());
} else
MainFrame.getVis3D().highlightTrack(
Integer.valueOf(node.getId()).intValue());
TrackPanel.updateSelectAllTracks();
}
else if (
cur_sel_type == TrackPanel._DATA_TITLE_TYPE
|| cur_sel_type == TrackPanel._REGION_TITLE_TYPE
|| cur_sel_type == TrackPanel._ALIGN_TITLE_TYPE
|| cur_sel_type == TrackPanel._DATA_TYPE
|| cur_sel_type == TrackPanel._ALIGN_TITLE_TYPE) {
node.setChecked(true);
return false;
}
else if (cur_sel_type == TrackPanel._REGION_TYPE) {
CheckboxTreeNode parent_node = (CheckboxTreeNode) node.getParent();
CheckboxTreeNode parent_track_node =
(CheckboxTreeNode) parent_node.getParent();
int parent_track_id =
Integer.valueOf(parent_track_node.getId()).intValue();
TrackFeature region =
DataStoreUser.getInstance().getSockeyeTrackList().getFeature(
parent_track_id,
"region",
node.getId());
if (region != null) {
TrackPanel.action(
parent_track_id,
region,
"region",
node.isChecked());
MainFrame.getVis3D().leftClickFeature(region);
}
}
else if (cur_sel_type == TrackPanel._ALIGN_TYPE) {
CheckboxTreeNode parent_node = (CheckboxTreeNode) node.getParent();
CheckboxTreeNode parent_track_node =
(CheckboxTreeNode) parent_node.getParent();
int parent_track_id =
Integer.valueOf(parent_track_node.getId()).intValue();
TrackFeature region =
DataStoreUser.getInstance().getSockeyeTrackList().getFeature(
parent_track_id,
AlignOperation.ALN_HIGHLIGHT_FEATURE,
node.getId());
if (region != null) {
TrackPanel.action(
parent_track_id,
region,
AlignOperation.ALN_HIGHLIGHT_FEATURE,
node.isChecked());
MainFrame.getVis3D().leftClickFeature(region);
}
}
}
return true;
} else {
TrackPanel.unselectAll();
return false;
}
}
public void displayPopup(MouseEvent e) {
TreePath prev_path = TrackPanel.__track_tree.getSelectionPath();
if (prev_path != null)
prev_sel_type =
((CheckboxTreeNode) prev_path.getLastPathComponent()).getType();
else
sel_nodes.clear();
boolean selected = false;
if (super.action(e)) {
CheckboxTreeNode node = this.getSelectedNode();
cur_sel_type = node.getType();
if (prev_sel_type != cur_sel_type) {
TrackPanel.unselectAll();
sel_nodes.clear();
}
if (sel_nodes.size() > 0) {
for (int i = 0; i < sel_nodes.size(); i++) {
Object obj = sel_nodes.get(i);
String acc_id = obj.toString();
if (obj instanceof TrackFeature) {
acc_id = ((TrackFeature) obj).getAccessionID();
}
if (acc_id.equals(String.valueOf(node.getId()))) {
selected = true;
}
}
}
if (!selected) {
sel_nodes.clear();
TrackPanel.unselectAll();
}
if (cur_sel_type == TrackPanel._TRACK_TYPE) {
if (!selected)
sel_nodes.add(String.valueOf(node.getId()));
MainFrame.getVis3D().highlightTracks(sel_nodes);
if (sel_nodes.size() != 0) {
trp = new TrackRightPopupNZ(sel_nodes);
trp.show(e.getComponent(), e.getX(), e.getY());
}
} else if (
cur_sel_type == TrackPanel._DATA_TITLE_TYPE
|| cur_sel_type == TrackPanel._REGION_TITLE_TYPE) {
} else if (cur_sel_type == TrackPanel._REGION_TYPE) {
if (!selected) {
CheckboxTreeNode parent_node = (CheckboxTreeNode) node.getParent();
CheckboxTreeNode parent_track_node =
(CheckboxTreeNode) parent_node.getParent();
TrackFeature region =
DataStoreUser.getInstance().getSockeyeTrackList().getFeature(
Integer.valueOf(parent_track_node.getId()).intValue(),
"region",
node.getId());
MainFrame.getVis3D().controlLeftClickFeature(region);
sel_nodes.add(region);
}
frp = new FeatureRightPopup(sel_nodes);
frp.show(e.getComponent(), e.getX(), e.getY());
}
}
}
}
package ca.bcgsc.sockeye.gui.navigation;
import java.awt.Color;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.FlowLayout;
import java.awt.Frame;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Image;
import java.awt.Insets;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.Iterator;
import java.util.List;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.SwingUtilities;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.gui.CreateViewDialog;
import ca.bcgsc.sockeye.gui.MainFrame;
import ca.bcgsc.sockeye.gui.Sockeye;
import ca.bcgsc.sockeye.gui.SockeyeMenubar;
import ca.bcgsc.sockeye.gui.UserView;
import ca.bcgsc.sockeye.gui.util.ImageLoader;
import ca.bcgsc.util.gui.scomponents.SockeyeButton;
public class VerticalNavigationBar
extends JPanel
implements ActionListener{
int slowdown = 2;
ExtendedRotNavWheel rotx = new ExtendedRotNavWheel(false, false, "X-Rot", null) {
public void wheelSpin(int ticks) {
MainFrame.getVis3D().platformRelRotateX(ticks/(80f*slowdown));
}
};
ExtendedRotNavWheel movv = new ExtendedRotNavWheel(false, false, "V-Move", null) {
public void wheelSpin(int ticks) {
MainFrame.getVis3D().platformRelMove(0, ticks/(80f*slowdown));
}
};
ExtendedRotNavWheel zoom = new ExtendedRotNavWheel(false, false, "Zoom", null) {
public void wheelSpin(int ticks) {
MainFrame.getVis3D().platformRelZoom(-ticks/(slowdown*slowdown*1000f));
}
};
SockeyeButton top_view_button = new SockeyeButton(ImageLoader.loadIcon("top_view.gif"));
SockeyeButton ff_deg_back_button = new SockeyeButton(ImageLoader.loadIcon("45back_view.gif"));
SockeyeButton ff_deg_button = new SockeyeButton(ImageLoader.loadIcon("45deg_view.gif"));
SockeyeButton store_button = new SockeyeButton(ImageLoader.loadIcon("pin.gif"));
SockeyeButton recall_button = new SockeyeButton(ImageLoader.loadIcon("posrecall.gif"));
public VerticalNavigationBar() {
GridBagLayout gridbag = new GridBagLayout();
GridBagConstraints gbc = new GridBagConstraints();
Box buttons = Box.createVerticalBox();
store_button.addActionListener(this);
recall_button.addActionListener(this);
ff_deg_button.addActionListener(this);
top_view_button.addActionListener(this);
ff_deg_back_button.addActionListener(this);
store_button.setActionCommand("store");
recall_button.setActionCommand("recall");
ff_deg_button.setActionCommand("45");
ff_deg_back_button.setActionCommand("45back");
top_view_button.setActionCommand("top");
store_button.setToolTipText("Store current viewport");
recall_button.setToolTipText("Goto stored viewport");
ff_deg_button.setToolTipText("Set 45 degree angle view");
top_view_button.setToolTipText("Set top view");
ff_deg_back_button.setToolTipText("Set 45 degree back view");
this.setLayout(gridbag);
java.awt.Component spc1 = Box.createVerticalGlue();
gbc.gridx = 0; gbc.ipady = 2;
gbc.gridy = 0;
gbc.insets=new Insets(10,0,0,0);
gridbag.setConstraints(top_view_button, gbc);
gbc.insets=new Insets(0,0,0,0);
gbc.gridy = 1;
gridbag.setConstraints(ff_deg_button, gbc);
gbc.gridy = 2;
gridbag.setConstraints(ff_deg_back_button, gbc);
gbc.gridy = 3;
gridbag.setConstraints(store_button, gbc);
gbc.gridy = 4;
gridbag.setConstraints(recall_button, gbc);
gbc.gridy = 6;
gridbag.setConstraints(zoom, gbc);
gbc.gridy = 7;
gridbag.setConstraints(movv, gbc);
gbc.gridy = 8;
gridbag.setConstraints(rotx, gbc);
gbc.weighty = 1;
gbc.gridy = 5;
gridbag.setConstraints(spc1, gbc);
this.add(top_view_button);
this.add(ff_deg_button);
this.add(ff_deg_back_button);
this.add(store_button);
this.add(recall_button);
rotx.setMinimumSize(rotx.getPreferredSize());
movv.setMinimumSize(movv.getPreferredSize());
zoom.setMinimumSize(zoom.getPreferredSize());
this.add(buttons);
this.add(rotx);
this.add(movv);
this.add(zoom);
this.add(spc1);
}
public void actionPerformed(ActionEvent e) {
if (e.getActionCommand().equals("top"))
MainFrame.getVis3D().setViewValues(0f, 0f, 0f, 0f, 7f);
else
if (e.getActionCommand().equals("45"))
MainFrame.getVis3D().setViewValues(45f, 0f, 0f, 0f, 7f);
else
if (e.getActionCommand().equals("45back"))
MainFrame.getVis3D().setViewValues(45f, 180f, 0f, 0f, 7f);
else
if (e.getActionCommand().equals("store")) {
new CreateViewDialog(Sockeye.__frame);
}
else
if (e.getActionCommand().equals("recall")) {
List views = SockeyeMenubar.getUserViews();
if (views == null || views.size() == 0) return;
new RestoreViewDialog(Sockeye.__frame, this);
}
}
}
class RestoreViewDialog extends JDialog{
JScrollPane scroll_pane = new JScrollPane(null, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
public RestoreViewDialog(Frame owner, Component c) {
super(owner, "Select a previously stored viewport", true);
update();
this.setLocationRelativeTo(c);
this.getContentPane().add(scroll_pane);
this.setDefaultCloseOperation(JDialog.HIDE_ON_CLOSE);
this.pack();
this.setSize(300, 300);
this.show();
}
private void update() {
List views = SockeyeMenubar.getUserViews();
JPanel panel = new JPanel();
BoxLayout layout = new BoxLayout(panel, BoxLayout.Y_AXIS);
panel.setLayout(layout);
int index = 0;
Color[] color = {Configuration.gui_blue, new Color(240, 240, 200)};
for (Iterator i = views.iterator(); i.hasNext();){
UserView view = (UserView)i.next();
final String name = view.getViewName();
Image image = view.getViewThumbnail();
ImageIcon icon = new ImageIcon(image);
JLabel label = new JLabel(icon);
label.setText(name);
label.setName(name);
JPanel v_panel = new JPanel(new FlowLayout(FlowLayout.LEFT));
v_panel.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
v_panel.addMouseListener(new MouseAdapter(){
public void mouseClicked(MouseEvent e) {
if (SwingUtilities.isLeftMouseButton(e)) {
SockeyeMenubar.setToUserView(name);
RestoreViewDialog.this.hide();
} else if (SwingUtilities.isRightMouseButton(e)) {
String message = "Delete View \"" + name + "\"?";
int response =
JOptionPane.showConfirmDialog(
Sockeye.__frame,
message,
"Delete View",
JOptionPane.YES_NO_OPTION,
JOptionPane.QUESTION_MESSAGE);
if (response == JOptionPane.YES_OPTION) {
SockeyeMenubar.removeUserView(name);
RestoreViewDialog.this.update();
}
}
}
});
v_panel.add(label);
v_panel.setBackground(color[index++ % 2]);
panel.add(v_panel);
}
panel.doLayout();
scroll_pane.setViewportView(panel);
}
}
package ca.bcgsc.sockeye.gui.optionsdialog;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Insets;
import java.awt.Rectangle;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Hashtable;
import javax.help.CSH;
import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JTree;
import javax.swing.SwingConstants;
import javax.swing.border.TitledBorder;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreePath;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.config.Connection;
import ca.bcgsc.sockeye.gui.util.ConnectionGUIUtil;
import ca.bcgsc.sockeye.service.featureloader.common.ConnectionManager;
import ca.bcgsc.util.gui.scomponents.SockeyeButton;
public class DataSourceOptionPanel extends JSplitPane {
static JButton b_update = new JButton();
JLabel l_user = new JLabel();
JButton b_remove = new JButton();
JLabel l_pwd = new JLabel();
static JButton b_test = new JButton();
JPanel pDSConfig = new JPanel();
SockeyeButton b_help = new SockeyeButton(Configuration.help_icon);
JLabel l_server = new JLabel();
JButton b_add = new JButton();
JLabel l_display = new JLabel();
JScrollPane spDSTree = new JScrollPane();
DSTree ds_tree;
DefaultMutableTreeNode root = new DefaultMutableTreeNode("Connections");
JButton b_reset = new JButton();
JLabel l_port = new JLabel();
static JTextField tf_port = new JTextField();
static JTextField tf_display = new JTextField();
static JTextField tf_server = new JTextField();
static JTextField tf_user = new JTextField();
static JTextField tf_pwd = new JTextField();
public DataSourceOptionPanel() {
jbInit();
initHelp();
}
private void jbInit() {
this.setLeftComponent(spDSTree);
this.setRightComponent(pDSConfig);
this.setTopComponent(null);
pDSConfig.setLayout(null);
pDSConfig.setBorder(
new TitledBorder(
BorderFactory.createEtchedBorder(Color.white, new Color(148, 145, 140)),
"DataSource configuration"));
pDSConfig.setPreferredSize(new Dimension(300, 220));
b_help.setBounds(
new Rectangle(257, 186, b_help.getWidth(), b_help.getHeight()));
b_help.setEnabled(false);
b_add.setText("Add");
b_add.setBounds(new Rectangle(19, 186, 63, 26));
b_add.setEnabled(true);
b_add.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
Connection conn =
new Connection(
DataSourceOptionPanel.tf_display.getText(),
DataSourceOptionPanel.tf_server.getText(),
DataSourceOptionPanel.tf_port.getText(),
DataSourceOptionPanel.tf_user.getText(),
DataSourceOptionPanel.tf_pwd.getText(),
"Ensembl");
boolean is_added = ConnectionManager.addConnection(conn);
if (is_added) {
ds_tree.setModel(
ConnectionGUIUtil.getCurrentDataStructureTreeModel(root));
}
}
});
b_test.setText("Test");
b_test.setBounds(new Rectangle(19, 219, 63, 26));
b_test.setEnabled(false);
b_test.setMargin(new Insets(2, 5, 2, 5));
b_test.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
Connection conn =
new Connection(
DataSourceOptionPanel.tf_display.getText(),
DataSourceOptionPanel.tf_server.getText(),
DataSourceOptionPanel.tf_port.getText(),
DataSourceOptionPanel.tf_user.getText(),
DataSourceOptionPanel.tf_pwd.getText(),
"Ensembl");
try {
boolean isGood = ConnectionManager.testEnsemblForConnection(conn);
if (isGood) {
JOptionPane.showMessageDialog(
null,
"Connection is valid EnsEMBL server",
"Connection status",
JOptionPane.INFORMATION_MESSAGE);
} else {
throw new Exception();
}
} catch (Exception exception) {
JOptionPane.showMessageDialog(
null,
"Connection failed test - Can't create EnsEMBL driver",
"Warning",
JOptionPane.ERROR_MESSAGE);
}
}
});
b_update.setText("Update");
b_update.setBounds(new Rectangle(87, 186, 78, 26));
b_update.setEnabled(false);
b_update.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
Connection conn =
new Connection(
DataSourceOptionPanel.tf_display.getText(),
DataSourceOptionPanel.tf_server.getText(),
DataSourceOptionPanel.tf_port.getText(),
DataSourceOptionPanel.tf_user.getText(),
DataSourceOptionPanel.tf_pwd.getText(),
"Ensembl");
boolean is_added = ConnectionManager.addConnection(conn);
if (is_added) {
ds_tree.setModel(
ConnectionGUIUtil.getCurrentDataStructureTreeModel(root));
}
}
});
b_remove.setText("Remove");
b_remove.setBounds(new Rectangle(169, 186, 83, 26));
b_remove.setEnabled(true);
b_remove.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
if (JOptionPane
.showConfirmDialog(
null,
"Do you want to remove datasource "
+ DataSourceOptionPanel.tf_display.getText()
+ "?")
== 0) {
Connection conn =
new Connection(
DataSourceOptionPanel.tf_display.getText(),
DataSourceOptionPanel.tf_server.getText(),
DataSourceOptionPanel.tf_port.getText(),
DataSourceOptionPanel.tf_user.getText(),
DataSourceOptionPanel.tf_pwd.getText(),
"Ensembl");
boolean removed = ConnectionManager.removeConnection(conn);
if (removed) {
ds_tree.setModel(
ConnectionGUIUtil.getCurrentDataStructureTreeModel(root));
} else {
JOptionPane.showMessageDialog(
null,
"Connection doesn't exist for removal",
"Warning",
JOptionPane.ERROR_MESSAGE);
}
}
}
});
l_display.setHorizontalAlignment(SwingConstants.RIGHT);
l_display.setText("Display");
l_display.setBounds(new Rectangle(8, 22, 65, 20));
l_server.setHorizontalAlignment(SwingConstants.RIGHT);
l_server.setText("Server");
l_server.setBounds(new Rectangle(22, 52, 51, 20));
l_user.setHorizontalAlignment(SwingConstants.RIGHT);
l_user.setText("User");
l_user.setBounds(new Rectangle(43, 114, 30, 20));
l_pwd.setHorizontalAlignment(SwingConstants.RIGHT);
l_pwd.setText("Pwd");
l_pwd.setBounds(new Rectangle(43, 145, 30, 20));
tf_display.setText("");
tf_display.setBounds(new Rectangle(83, 22, 213, 20));
tf_server.setText("");
tf_server.setBounds(new Rectangle(83, 52, 213, 20));
tf_user.setText("");
tf_user.setBounds(new Rectangle(83, 114, 213, 20));
tf_pwd.setText("");
tf_pwd.setBounds(new Rectangle(83, 145, 213, 20));
b_reset.setBounds(new Rectangle(87, 219, 110, 26));
b_reset.setEnabled(false);
b_reset.setMargin(new Insets(2, 5, 2, 5));
b_reset.setText("Reset defaults");
l_port.setEnabled(false);
l_port.setHorizontalAlignment(SwingConstants.RIGHT);
l_port.setText("Port");
l_port.setBounds(new Rectangle(31, 83, 42, 21));
tf_port.setEditable(false);
tf_port.setText("");
tf_port.setBounds(new Rectangle(83, 83, 213, 20));
this.add(pDSConfig, JSplitPane.RIGHT);
pDSConfig.add(tf_display, null);
pDSConfig.add(tf_server, null);
pDSConfig.add(tf_user, null);
pDSConfig.add(l_pwd, null);
pDSConfig.add(tf_pwd, null);
pDSConfig.add(l_user, null);
pDSConfig.add(l_port, null);
this.add(spDSTree, JSplitPane.LEFT);
ds_tree =
new DSTree(ConnectionGUIUtil.getCurrentDataStructureTreeModel(root));
ds_tree.setPreferredSize(new Dimension(300, 64));
ds_tree.addTreeSelectionListener(ds_tree);
spDSTree.getViewport().add(ds_tree, null);
pDSConfig.add(tf_port, null);
pDSConfig.add(b_reset, null);
pDSConfig.add(b_add, null);
pDSConfig.add(b_test, null);
pDSConfig.add(b_update, null);
pDSConfig.add(b_remove, null);
pDSConfig.add(l_display, null);
pDSConfig.add(l_server, null);
pDSConfig.add(b_help, null);
this.doLayout();
}
class DSTree extends JTree implements TreeSelectionListener {
DSTree(Hashtable source) {
super(source);
}
DSTree(DefaultTreeModel tm) {
super(tm);
}
public void valueChanged(TreeSelectionEvent event) {
TreePath path = event.getPath();
int cnt = path.getPathCount();
String[] path_value = new String[cnt];
for (int i = 0; i < cnt; i++) {
path_value[i] = path.getPathComponent(i).toString();
}
try {
if (cnt >= 3) {
DataSourceOptionPanel.tf_display.setText(path_value[2]);
Connection selected_conn =
ConnectionManager.getConnectionForName(path_value[2]);
DataSourceOptionPanel.tf_server.setText(selected_conn.getHost());
DataSourceOptionPanel.tf_port.setText(selected_conn.getPort());
DataSourceOptionPanel.tf_user.setText(selected_conn.getUser());
DataSourceOptionPanel.tf_pwd.setText(selected_conn.getPass());
DataSourceOptionPanel.b_test.setEnabled(true);
DataSourceOptionPanel.b_update.setEnabled(true);
} else {
DataSourceOptionPanel.b_test.setEnabled(false);
DataSourceOptionPanel.b_update.setEnabled(false);
DataSourceOptionPanel.tf_display.setText("");
DataSourceOptionPanel.tf_server.setText("");
DataSourceOptionPanel.tf_port.setText("");
DataSourceOptionPanel.tf_user.setText("");
DataSourceOptionPanel.tf_pwd.setText("");
}
} catch (Exception e) {
DataSourceOptionPanel.tf_display.setText("");
DataSourceOptionPanel.tf_server.setText("");
DataSourceOptionPanel.tf_port.setText("");
DataSourceOptionPanel.tf_user.setText("");
DataSourceOptionPanel.tf_pwd.setText("");
}
}
}
protected void initHelp() {
CSH.setHelpIDString(b_help, "options_overview");
<mapID target="options_overview" url="content/work_env/options/options_overview.html" />
<mapID target="options_data_sources" url="content/work_env/options/options_data_sources.html" />
<mapID target="options_graphics_settings" url="content/work_env/options/options_graphics_settings.html" />
}
}
package ca.bcgsc.sockeye.gui.optionsdialog;
import javax.swing.JPanel;
import java.awt.LayoutManager;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import ca.bcgsc.sockeye.j3d.*;
public class DistributionOptionPanel
extends JPanel
implements ItemListener {
private JLabel md_label_stacking = new JLabel("Place multiple distributions:");
private JLabel md_label_width = new JLabel(
"Width of distribution (% of feature width):");
private JLabel md_label_color = new JLabel("Distribution colours:");
private JLabel md_threshold_label = new JLabel("Show threshold values: ");
private JCheckBox md_threshold_cb = new JCheckBox();
private JComboBox md_stack_combo = new JComboBox(new String[] {
"Over top of each other", "Stack (same height)", "Stack (shrink fit)"});
private SpinnerModel md_width_sm = new SpinnerNumberModel(new Integer(50),
new Integer(1), new Integer(100), new Integer(1));
private JSpinner md_width_spinner = new JSpinner(md_width_sm);
private JComboBox md_color_combo = new JComboBox();
private JButton md_color_add_button = new JButton("Add");
private JButton md_color_edit_button = new JButton("Edit");
private JButton md_color_delete_button = new JButton("Delete");
private JLabel md_label_reverse_order = new JLabel ("Reverse order");
private JCheckBox md_reverse_order_cb = new JCheckBox();
private JCheckBox show_text_anno_cb = new JCheckBox();
private JLabel show_text_anno_label = new JLabel("Show text annotations: ");
private JCheckBox show_coord_system_cb = new JCheckBox();
private JCheckBox show_z_axis_cb = new JCheckBox();
private JSlider coord_system_transp_sl = new JSlider(JSlider.HORIZONTAL, 0, 100,
(int) (DistributionFeature3D.
getCoordTransparency() * 100));
private SpinnerModel coord_tick_width_sm = new SpinnerNumberModel(new Float(
DistributionFeature3D.getCoordSystemTickWidth()), new Float(0.01), null,
new Float(1));
private JSpinner coord_ticks_sm = new JSpinner(coord_tick_width_sm);
private JComboBox stack_distribution_combo = new JComboBox(new String[] {
"Behind each other", "On top of each other"});
private JComboBox dist_color_model_combo = new JComboBox(new String[] {
"Colour of original feature", "Colour gradient"});
private JComboBox normalisation_ref_combo = new JComboBox(new String[] {
"To global maximum", "To local maximum"});
private JSlider feature_transparency_slider = new JSlider(JSlider.HORIZONTAL, 0, 100,
(int) (DistributionFeature3D.getDefaultTransparency() * 100));
private JSlider distrib_height_slider = new JSlider(JSlider.HORIZONTAL, 0, 50,
(int) (DistributionFeature3D.
getScale() * 10));
private JLabel label_a = new JLabel("Stack multiple distributions: ");
private JLabel label_b = new JLabel("Transparency of distribution features: ");
private JLabel label_c = new JLabel("Height of distribution (3D units): ");
private JLabel label_d = new JLabel("Colour model used for distributions: ");
private JLabel label_e = new JLabel("3D height normalisation reference: ");
private JLabel label_f = new JLabel("Transparency of coordinate system: ");
private JLabel label_g = new JLabel("Tick width: ");
private JLabel label_h = new JLabel("Visual coordinate system: ");
public DistributionOptionPanel() {
initMainPanel();
}
public DistributionOptionPanel(LayoutManager layout, boolean isDoubleBuffered) {
super(layout, isDoubleBuffered);
initMainPanel();
}
public DistributionOptionPanel(LayoutManager layout) {
super(layout);
initMainPanel();
}
public DistributionOptionPanel(boolean isDoubleBuffered) {
super(isDoubleBuffered);
initMainPanel();
}
public void setWidthOfMultiDistFeature(int w) {
if (w > 0 && w <= 100)
md_width_sm.setValue(new Integer(w));
else
System.out.println("DOP Error: Illegal multi dist. width value: " + w);
}
public int getWidthOfMultiDistFeature() {
return Integer.parseInt(md_width_sm.getValue().toString());
}
public void setMultiDistributionPlotStyleIndex(int i) {
md_stack_combo.setSelectedIndex(i);
if (i==0){
md_label_reverse_order.setEnabled(false);
md_reverse_order_cb.setEnabled(false);
}
}
public int getMultiDistributionPlotStyleIndex() {
return md_stack_combo.getSelectedIndex();
}
public boolean stackHorizontaly() {
return (stack_distribution_combo.getSelectedIndex() == 0 ? true : false);
}
public float getTransparencyValue() {
return ( (float) feature_transparency_slider.getValue() / 100f);
}
public int get3DHeightValue() {
return distrib_height_slider.getValue();
}
public boolean getDistributionsUseStaticColor() {
return (dist_color_model_combo.getSelectedIndex() == 0 ? true : false);
}
public boolean get3dHeightReferenceIsGlobal() {
return (normalisation_ref_combo.getSelectedIndex() == 0 ? true : false);
}
public boolean getShowCoordSystem() {
return show_coord_system_cb.isSelected();
}
public boolean getShowZAxis() {
return show_z_axis_cb.isSelected();
}
public float getTicks() {
return Float.parseFloat(coord_tick_width_sm.getValue().toString());
}
public float getCoordSystemTransparencyValue() {
return ( (float) coord_system_transp_sl.getValue() / 100f);
}
public boolean getMDReverseOrder(){
return md_reverse_order_cb.isSelected();
}
public void setMDReverseOrder(boolean s){
md_reverse_order_cb.setSelected(s);
}
public boolean getMDShowThresholds(){
return md_threshold_cb.isSelected();
}
public void setMDShowThresholds(boolean b){
md_threshold_cb.setSelected(b);
}
public boolean getShowTextAnnotation(){
return show_text_anno_cb.isSelected();
}
public void setShowTextAnnotation(boolean b){
show_text_anno_cb.setSelected(b);
}
public void setGeneralOptionValues(boolean do_stackHorizontaly,
int val_transparency,
int val_distheight,
boolean do_useStaticDistColor,
boolean val_heightRefGlobal,
boolean do_showCoordSystem,
boolean do_showZAxis,
float val_ticks,
int val_coordTrans){
stack_distribution_combo.setSelectedIndex(do_stackHorizontaly?0:1);
feature_transparency_slider.setValue(val_transparency);
distrib_height_slider.setValue(val_distheight);
dist_color_model_combo.setSelectedIndex(do_useStaticDistColor?0:1);
normalisation_ref_combo.setSelectedIndex(val_heightRefGlobal?0:1);
show_coord_system_cb.setSelected(do_showCoordSystem);
show_z_axis_cb.setSelected(do_showZAxis);
coord_tick_width_sm.setValue(new Float(val_ticks));
coord_system_transp_sl.setValue(val_coordTrans);
}
protected void initMainPanel() {
JPanel generalPanel = createGeneralOptionsPanel();
JPanel histogramPanel = createHistogramPanel();
JPanel multiDistPanel = createMultiDistPanel();
GridBagLayout gridbag = new GridBagLayout();
GridBagConstraints gbc = new GridBagConstraints();
this.setLayout(gridbag);
gbc.fill = GridBagConstraints.HORIZONTAL;
gbc.gridx = 0;
gbc.gridy = 0;
gridbag.setConstraints(generalPanel, gbc);
gbc.gridx = 0;
gbc.gridy = 1;
gridbag.setConstraints(histogramPanel, gbc);
gbc.gridx = 0;
gbc.gridy = 2;
gridbag.setConstraints(multiDistPanel, gbc);
generalPanel.setBorder(BorderFactory.createTitledBorder(BorderFactory.
createEtchedBorder(), "General Options"));
histogramPanel.setBorder(BorderFactory.createTitledBorder(BorderFactory.
createEtchedBorder(), "Histogram-Feature Options"));
multiDistPanel.setBorder(BorderFactory.createTitledBorder(BorderFactory.
createEtchedBorder(), "Multi-Distribution-Feature Options"));
generalPanel.doLayout();
histogramPanel.doLayout();
multiDistPanel.doLayout();
this.add(generalPanel);
this.add(histogramPanel);
this.add(multiDistPanel);
this.doLayout();
}
private JPanel createHistogramPanel() {
JPanel rightPanel = new JPanel();
GridBagLayout gridbag = new GridBagLayout();
GridBagConstraints gbc = new GridBagConstraints();
gbc.ipadx = 10;
gbc.fill = GridBagConstraints.HORIZONTAL;
rightPanel.setLayout(gridbag);
dist_color_model_combo.setToolTipText(
"Here you can choose how to pick the colour for a distribution");
rightPanel.add(label_d);
rightPanel.add(dist_color_model_combo);
dist_color_model_combo.setSelectedIndex(DistributionFeature3D.
getUseStaticFeatureColor() ? 0 : 1);
return rightPanel;
}
private JPanel createMultiDistPanel() {
JPanel panel = new JPanel();
GridBagLayout gridbag = new GridBagLayout();
GridBagConstraints gbc = new GridBagConstraints();
Box helpContainer = Box.createHorizontalBox();
md_reverse_order_cb.setToolTipText("Draw all distributions in reverse order");
md_label_reverse_order.setToolTipText("Draw all distributions in reverse order");
md_width_spinner.setToolTipText("Set the width of a distribution \"ribbon\" in % of featurewidth");
md_color_combo.setToolTipText("Select a colour for distributioon \"ribbons\" for further action");
md_color_edit_button.setToolTipText("Change the color for a particular distribution");
md_color_add_button.setToolTipText("Add a colour to the list distribution");
md_color_delete_button.setToolTipText("Delete the selected colour");
md_threshold_label.setToolTipText("To show threshold values, please check this box...");
md_threshold_cb.setToolTipText("To show threshold values, please check this box...");
gbc.ipadx = 10;
panel.setLayout(gridbag);
gbc.anchor = GridBagConstraints.LINE_END;
gbc.gridx = 0; gbc.gridy = 0;
gridbag.setConstraints(md_label_stacking, gbc);
gbc.gridx = 0; gbc.gridy = 1;
gridbag.setConstraints(md_threshold_label, gbc);
gbc.gridx = 0;
gbc.gridy = 2;
gridbag.setConstraints(md_label_width, gbc);
gbc.gridx = 0;
gbc.gridy = 3;
gridbag.setConstraints(md_label_color, gbc);
md_stack_combo.addItemListener(this);
gbc.anchor = GridBagConstraints.LINE_START;
helpContainer.add(md_stack_combo);
helpContainer.add(Box.createHorizontalStrut(10));
helpContainer.add(md_label_reverse_order);
helpContainer.add(md_reverse_order_cb);
gbc.gridwidth = 4;
gbc.gridx = 1; gbc.gridy = 0;
gridbag.setConstraints(helpContainer, gbc);
gbc.gridx = 1; gbc.gridy = 1;
gridbag.setConstraints(md_threshold_cb, gbc);
gbc.gridx = 1; gbc.gridy = 2;
gridbag.setConstraints(md_width_spinner, gbc);
gbc.gridwidth = 1;
gbc.gridx = 1; gbc.gridy = 3;
gridbag.setConstraints(md_color_combo, gbc);
gbc.gridx = 2; gbc.gridy = 3;
gridbag.setConstraints(md_color_edit_button, gbc);
gbc.gridx = 3; gbc.gridy = 3;
gridbag.setConstraints(md_color_add_button, gbc);
gbc.gridx = 4; gbc.gridy = 3;
gridbag.setConstraints(md_color_delete_button, gbc);
panel.add(md_label_stacking);
panel.add(md_label_width);
panel.add(md_label_color);
panel.add(md_threshold_label);
panel.add(md_threshold_cb);
panel.add(helpContainer);
panel.add(md_width_spinner);
panel.add(md_color_combo);
panel.add(md_color_edit_button);
panel.add(md_color_add_button);
panel.add(md_color_delete_button);
md_color_delete_button.setEnabled(false);
md_color_add_button.setEnabled(false);
md_color_edit_button.setEnabled(false);
md_color_combo.setEnabled(false);
return panel;
}
private JPanel createGeneralOptionsPanel() {
JPanel panel = new JPanel();
GridBagLayout gridbag = new GridBagLayout();
GridBagConstraints gbc = new GridBagConstraints();
panel.setLayout(gridbag);
gbc.anchor = GridBagConstraints.LINE_END;
gbc.ipadx = 10;
gbc.gridx = 0;
gbc.gridy = 0;
gridbag.setConstraints(label_a, gbc);
gbc.gridx = 0;
gbc.gridy = 1;
gridbag.setConstraints(label_e, gbc);
gbc.gridx = 0;
gbc.gridy = 2;
gridbag.setConstraints(label_b, gbc);
gbc.gridx = 0;
gbc.gridy = 3;
gridbag.setConstraints(label_c, gbc);
gbc.gridx = 0;
gbc.gridy = 4;
gridbag.setConstraints(show_text_anno_label, gbc);
gbc.gridx = 0;
gbc.gridy = 5;
gridbag.setConstraints(label_h, gbc);
gbc.gridx = 0; gbc.gridy = 8;
gridbag.setConstraints(label_f, gbc);
gbc.gridx = 1; gbc.gridy = 7;
gridbag.setConstraints(label_g, gbc);
gbc.fill = GridBagConstraints.HORIZONTAL;
gbc.anchor = GridBagConstraints.LINE_START;
gbc.gridx = 2; gbc.gridy = 7;
gridbag.setConstraints(coord_ticks_sm, gbc);
gbc.gridx = 1; gbc.gridy = 4;
gridbag.setConstraints(show_text_anno_cb, gbc);
gbc.gridwidth = 2;
gbc.gridx = 1; gbc.gridy = 5;
gridbag.setConstraints(show_coord_system_cb, gbc);
gbc.gridx = 1; gbc.gridy = 0;
gridbag.setConstraints(stack_distribution_combo, gbc);
gbc.gridx = 1; gbc.gridy = 2;
gridbag.setConstraints(feature_transparency_slider, gbc);
gbc.gridx = 1; gbc.gridy = 3;
gridbag.setConstraints(distrib_height_slider, gbc);
gbc.gridx = 1; gbc.gridy = 1;
gridbag.setConstraints(normalisation_ref_combo, gbc);
gbc.gridx = 1; gbc.gridy = 6;
gridbag.setConstraints(show_z_axis_cb, gbc);
gbc.gridx = 1; gbc.gridy = 8;
gridbag.setConstraints(coord_system_transp_sl, gbc);
panel.add(label_h);
panel.add(label_g);
panel.add(show_text_anno_label);
panel.add(show_text_anno_cb);
coord_ticks_sm.setToolTipText(
"Distance beween two \"ticks\" of the coordinate system");
panel.add(coord_ticks_sm);
coord_system_transp_sl.setToolTipText("Transparency of the \"tick\" surfaces");
panel.add(label_f);
panel.add(coord_system_transp_sl);
show_z_axis_cb.setText("Show Z axis");
show_z_axis_cb.setToolTipText(
"Select if you want the z axis of this distribution to be drawn or not");
show_z_axis_cb.setSelected(DistributionFeature3D.getShowCoordZAxis());
panel.add(show_z_axis_cb);
show_coord_system_cb.setText("Show coordinate system");
show_coord_system_cb.setToolTipText(
"Should a coordinate system to be drawn or not");
show_coord_system_cb.addItemListener(this);
show_coord_system_cb.setSelected(!DistributionFeature3D.getShowCoordSystem());
show_coord_system_cb.doClick();
panel.add(show_coord_system_cb);
normalisation_ref_combo.setToolTipText("The 3D height of the distribution containers can be normalized either to the platform wide maximum or to the local feature maximum");
normalisation_ref_combo.setSelectedIndex(DistributionFeature3D.
get3DNormalizeToGlobalMax() ? 0 : 1);
panel.add(label_e);
panel.add(normalisation_ref_combo);
stack_distribution_combo.setToolTipText("If we have more than one distribution on a track, we can stack them behind or on top of each other...");
panel.add(label_a);
panel.add(stack_distribution_combo);
stack_distribution_combo.setMaximumSize(stack_distribution_combo.getMinimumSize());
stack_distribution_combo.setSelectedIndex(DistributionFeature3D.
getStackInYDirection() ? 0 : 1);
feature_transparency_slider.setToolTipText(
"A value of 0 makes the distribution solid, 100 makes it fully transparent");
panel.add(label_b);
panel.add(feature_transparency_slider);
distrib_height_slider.setToolTipText(
"The maximum height a distribution can have in 3D...");
panel.add(label_c);
panel.add(distrib_height_slider);
return panel;
}
public void itemStateChanged(ItemEvent e) {
if (e.getSource() == md_stack_combo){
if (md_stack_combo.getSelectedIndex() == 0) {
md_label_reverse_order.setEnabled(false);
md_reverse_order_cb.setEnabled(false);
}
else {
md_label_reverse_order.setEnabled(true);
md_reverse_order_cb.setEnabled(true);
}
return;
}
if (e.getSource() == show_coord_system_cb) {
if (e.getStateChange() == ItemEvent.SELECTED) {
show_z_axis_cb.setEnabled(true);
coord_system_transp_sl.setEnabled(true);
coord_ticks_sm.setEnabled(true);
label_g.setEnabled(true);
label_f.setEnabled(true);
}
else {
show_z_axis_cb.setEnabled(false);
coord_system_transp_sl.setEnabled(false);
coord_ticks_sm.setEnabled(false);
label_g.setEnabled(false);
label_f.setEnabled(false);
}
}
}
}
package ca.bcgsc.sockeye.gui.optionsdialog;
import java.awt.Color;
import java.awt.Component;
import java.awt.Rectangle;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JColorChooser;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JDialog;
public class GraphicOptionPanel extends JPanel {
private JCheckBox antiAlias = new JCheckBox();
private JCheckBox mouseOverPopups = new JCheckBox();
private JCheckBox showCenterLine = new JCheckBox();
private JCheckBox billboard = new JCheckBox();
private JCheckBox truncate_text = new JCheckBox();
private JCheckBox enable_region_select = new JCheckBox();
private JCheckBox show_popup_icons = new JCheckBox();
private JButton b_bgColor = new JButton(" ");
private JButton b_txtColor = new JButton(" ");
private Color bgColor = Color.BLACK;
private Color txtColor = Color.WHITE;
private JDialog _parent_dialog;
public GraphicOptionPanel(JDialog d) {
_parent_dialog = d;
jbInit();
}
private void jbInit() {
JPanel leftPanel = new JPanel();
leftPanel.setLayout(new BoxLayout(leftPanel, BoxLayout.Y_AXIS));
this.setLayout(new BoxLayout(this, BoxLayout.X_AXIS));
Component glueTop = Box.createHorizontalGlue();
Component glueBottom = Box.createHorizontalGlue();
leftPanel.add(Box.createVerticalGlue());
b_bgColor.setBackground(bgColor);
b_bgColor.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
b_bgColorActionPerformed(e);
}
});
JLabel bgLabel = new JLabel("Background colour: ");
leftPanel.add(bgLabel);
leftPanel.add(b_bgColor);
b_txtColor.setBackground(txtColor);
b_txtColor.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
b_txtColorActionPerformed(e);
}
});
JLabel txtLabel = new JLabel("Track label colour: ");
leftPanel.add(txtLabel);
leftPanel.add(b_txtColor);
antiAlias.setText("Smooth feature edges (Antialias)");
antiAlias.setBounds(new Rectangle(59, 34, 282, 24));
leftPanel.add(antiAlias);
mouseOverPopups.setText("Show mouseover popups on features");
mouseOverPopups.setBounds(new Rectangle(59, 34, 282, 24));
mouseOverPopups.setSelected(OptionsDialog.__setMouseOverPopups);
leftPanel.add(mouseOverPopups);
showCenterLine.setText("Show center line for each track");
showCenterLine.setBounds(new Rectangle(59, 34, 282, 24));
leftPanel.add(showCenterLine);
billboard.setText("Text labels rotate");
billboard.setBounds(new Rectangle(59, 34, 282, 24));
leftPanel.add(billboard);
truncate_text.setText("Truncate text labels");
truncate_text.setBounds(new Rectangle(59, 34, 282, 24));
leftPanel.add(truncate_text);
enable_region_select.setText("Enable region select");
enable_region_select.setBounds(new Rectangle(59, 34, 282, 24));
enable_region_select.setSelected(OptionsDialog.__setEnableRegionSelect);
leftPanel.add(enable_region_select);
show_popup_icons.setText("Show icons in popup menus");
show_popup_icons.setBounds(new Rectangle(59, 34, 282, 24));
show_popup_icons.setSelected(OptionsDialog.__showPopupIcons);
leftPanel.add(show_popup_icons);
leftPanel.add(Box.createVerticalGlue());
leftPanel.setBorder(
BorderFactory.createTitledBorder(
BorderFactory.createEtchedBorder(),
"Misc graphical options"));
this.add(leftPanel);
}
private void b_bgColorActionPerformed(ActionEvent e) {
int dco = _parent_dialog.getDefaultCloseOperation();
_parent_dialog.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE);
Color color =
JColorChooser.showDialog(
this,
"Colour Chooser",
Color.black);
_parent_dialog.setDefaultCloseOperation(dco);
if (color == null)
return;
bgColor = color;
b_bgColor.setBackground(color);
}
private void b_txtColorActionPerformed(ActionEvent e) {
int dco = _parent_dialog.getDefaultCloseOperation();
_parent_dialog.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE);
Color color =
JColorChooser.showDialog(
_parent_dialog.getParent(),
"Colour Chooser",
Color.WHITE);
_parent_dialog.setDefaultCloseOperation(dco);
if (color == null)
return;
txtColor = color;
b_txtColor.setBackground(color);
}
public void setBackgroundButton(Color background, Color text) {
bgColor = background;
b_bgColor.setBackground(bgColor);
txtColor = text;
b_txtColor.setBackground(txtColor);
}
public void setCheckBoxes(
boolean text,
boolean billb,
boolean trunc,
boolean center,
boolean antialias) {
showCenterLine.setSelected(center);
billboard.setSelected(billb);
truncate_text.setSelected(trunc);
antiAlias.setSelected(antialias);
}
public boolean isAntialiasSelected() {
return antiAlias.isSelected();
}
public boolean isMouseOverPopupsSelected() {
return mouseOverPopups.isSelected();
}
public boolean isShowCenterLineSelected() {
return showCenterLine.isSelected();
}
public boolean isBillboardSelected() {
return billboard.isSelected();
}
public boolean isTruncateTextSelected() {
return truncate_text.isSelected();
}
public boolean isShowPopupIcons() {
return show_popup_icons.isSelected();
}
public boolean isEnableRegionSelectSelected() {
return enable_region_select.isSelected();
}
public Color getBgColor() {
return bgColor;
}
public Color getTextColor() {
return txtColor;
}
public void reset(
boolean do_antialias,
boolean do_mouseover,
boolean do_showcenterline,
boolean do_text2d,
boolean do_billboard,
boolean do_truncatetext,
boolean do_regionselect,
boolean do_showPopupIcons) {
antiAlias.setSelected(do_antialias);
mouseOverPopups.setSelected(do_mouseover);
showCenterLine.setSelected(do_showcenterline);
billboard.setSelected(do_billboard);
truncate_text.setSelected(do_truncatetext);
enable_region_select.setSelected(do_regionselect);
show_popup_icons.setSelected(do_showPopupIcons);
bgColor = Color.BLACK;
b_bgColor.setBackground(bgColor);
txtColor = Color.WHITE;
b_txtColor.setBackground(txtColor);
}
}
package ca.bcgsc.sockeye.gui.optionsdialog;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.ButtonGroup;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JRadioButton;
import ca.bcgsc.sockeye.datastorage.SockeyeTrackList;
public class NormalizationOptionPanel extends JPanel {
JRadioButton b1 = new JRadioButton("Per feature type on individual tracks");
JRadioButton b2 = new JRadioButton(
"Per feature type on all tracks in platform");
JRadioButton b3 = new JRadioButton("All feature types on individual tracks");
JRadioButton b4 = new JRadioButton(
"All feature types on all tracks in platform");
public NormalizationOptionPanel() {
jbInit();
}
private void jbInit() {
JPanel cPanel = new JPanel();
this.setLayout(new BoxLayout(this, BoxLayout.X_AXIS));
cPanel.setLayout(new BoxLayout(cPanel, BoxLayout.Y_AXIS));
ButtonGroup group = new ButtonGroup();
group.add(b1);
group.add(b2);
group.add(b3);
group.add(b4);
cPanel.add(Box.createVerticalStrut(20));
cPanel.add(b1);
JLabel j1 = new JLabel(
"<HTML>Best for comparing same feature type on same track."
+ "<BR>Each feature type on each track has an unique normalization value</HTML>");
cPanel.add(j1);
cPanel.add(Box.createVerticalStrut(10));
cPanel.add(b2);
JLabel j2 = new JLabel(
"<HTML>Best for comparing same feature type on different tracks."
+ "<BR>Each feature type across the platform has an unique normalization value</HTML>");
cPanel.add(j2);
cPanel.add(Box.createVerticalStrut(10));
cPanel.add(b3);
JLabel j3 = new JLabel(
"<HTML>Best for comparing different feature types on same track."
+ "<BR>All feature types on each track has an unique normalization value</HTML>");
cPanel.add(j3);
cPanel.add(Box.createVerticalStrut(10));
cPanel.add(b4);
JLabel j4 = new JLabel(
"<HTML>Best for comparing different feature types on different tracks."
+ "<BR>All feature types across the platform has an unique normalization value</HTML>");
cPanel.add(j4);
cPanel.add(Box.createVerticalGlue());
this.setBorder(BorderFactory.createTitledBorder(BorderFactory
.createEtchedBorder(), "Perform score normalization based on:"));
this.add(Box.createHorizontalStrut(30));
this.add(cPanel);
this.add(Box.createHorizontalGlue());
}
public void setNormalizationMethod(int method) {
if (method == SockeyeTrackList.NORMALIZE_PERFEATURE_PERTRACK) {
b1.setSelected(true);
}
else if (method == SockeyeTrackList.NORMALIZE_PERFEATURE_ALLTRACK) {
b2.setSelected(true);
}
else if (method == SockeyeTrackList.NORMALIZE_ALLFEATURE_PERTRACK) {
b3.setSelected(true);
}
else if (method == SockeyeTrackList.NORMALIZE_ALLFEATURE_ALLTRACK) {
b4.setSelected(true);
}
}
public int getNormalizationMethod() {
if (b1.isSelected())
return SockeyeTrackList.NORMALIZE_PERFEATURE_PERTRACK;
else if (b2.isSelected())
return SockeyeTrackList.NORMALIZE_PERFEATURE_ALLTRACK;
else if (b3.isSelected())
return SockeyeTrackList.NORMALIZE_ALLFEATURE_PERTRACK;
else
return SockeyeTrackList.NORMALIZE_ALLFEATURE_ALLTRACK;
}
}
package ca.bcgsc.sockeye.gui.optionsdialog;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Insets;
import java.awt.event.ActionEvent;
import javax.help.CSH;
import javax.swing.JButton;
import javax.swing.JDialog;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JTabbedPane;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.dataretrieval.SemanticZoomManager;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.gui.MainFrame;
import ca.bcgsc.sockeye.j3d.DistributionFeature3D;
import ca.bcgsc.sockeye.j3d.MultiDimDistributionFeature3D;
import ca.bcgsc.sockeye.util.Log;
import ca.bcgsc.util.gui.scomponents.SockeyeButton;
public class OptionsDialog extends JDialog {
JTabbedPane tp_options = new JTabbedPane();
JPanel p_buttons = new JPanel();
private final static boolean _setmouseoverpopups_default = true;
private final static boolean _setshowcenterline_default = true;
private final static boolean _setenable_region_select_default = true;
private final static boolean _setenable_popup_icons_show_default = true;
public boolean __setAntiAliasing = MainFrame.getVis3D().getAntiAliasing();
public static boolean __setMouseOverPopups = _setmouseoverpopups_default;
public static boolean __setShowCenterLine = _setshowcenterline_default;
public boolean __setText2D = MainFrame.getVis3D().getShowtext2D();
public boolean __setBillboard = MainFrame.getVis3D().getBillboard();
public boolean __setTruncateText = MainFrame.getVis3D().getTruncated();
public Color __setBackgroundColor = MainFrame.getVis3D().getBackgroundColor();
public Color __setTextColor = MainFrame.getVis3D().getTrackTextColor();
public static boolean __setEnableRegionSelect = _setenable_region_select_default;
public static boolean __showPopupIcons = _setenable_popup_icons_show_default;
public static int __setNormalizationMethod = DataStoreUser.getInstance()
.getSockeyeTrackList().getNormalizeMethod();
GraphicOptionPanel GOP = new GraphicOptionPanel(this);
SZOptionPanel szOpt = new SZOptionPanel();
DistributionOptionPanel DOP = new DistributionOptionPanel();
NormalizationOptionPanel NOP = new NormalizationOptionPanel();
JPanel p_buttons_center = new JPanel();
JButton b_OK = new JButton();
JButton b_reset = new JButton();
JButton b_cancel = new JButton();
JPanel p_buttons_right = new JPanel();
SockeyeButton b_help = new SockeyeButton(Configuration.help_icon);
BorderLayout borderLayout1 = new BorderLayout();
public OptionsDialog(JFrame parent) {
super(parent, "Options", true);
try {
initHelp();
jbInit();
this.show();
} catch (Exception e) {
Log.printStackTrace(e);
}
}
public OptionsDialog(JFrame parent, int tab) {
super(parent, "Options", true);
initHelp();
jbInit();
tp_options.setSelectedIndex(tab);
this.show();
}
private void jbInit() {
this.setSize(660, 360);
this.setLocationRelativeTo(null);
this.getContentPane().setLayout(new BorderLayout());
b_OK.setText("OK");
b_reset.setMargin(new Insets(2, 5, 2, 5));
b_reset.setText("Reset all defaults");
b_cancel.setText("Cancel");
p_buttons.setLayout(borderLayout1);
this.getContentPane().add(tp_options, BorderLayout.CENTER);
this.getContentPane().add(p_buttons, BorderLayout.SOUTH);
p_buttons.add(p_buttons_right, BorderLayout.EAST);
p_buttons.add(p_buttons_center, BorderLayout.CENTER);
p_buttons_center.add(b_OK, null);
p_buttons_center.add(b_cancel, null);
tp_options.add(new DataSourceOptionPanel(), "DataSources");
tp_options.doLayout();
tp_options.add(GOP, "Graphic Settings");
tp_options.add(DOP, "Distribution Feature Settings");
initSemZoomDialogData();
initDistribOptionPanelData();
GOP.setCheckBoxes(__setText2D, __setBillboard, __setTruncateText,
__setShowCenterLine, __setAntiAliasing);
GOP.setBackgroundButton(__setBackgroundColor, __setTextColor);
szOpt.createControls();
tp_options.add(szOpt, "Semantic Zooming");
tp_options.add(NOP, "Score Normalization Settings");
NOP.setNormalizationMethod(DataStoreUser.getInstance()
.getSockeyeTrackList().getNormalizeMethod());
tp_options.doLayout();
this.pack();
b_OK.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
b_OK_actionPerformed(e);
}
});
b_cancel.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
b_cancel_actionPerformed(e);
}
});
b_reset.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
b_reset_actionPerformed(e);
}
});
}
void b_cancel_actionPerformed(ActionEvent e) {
dispose();
}
void b_OK_actionPerformed(ActionEvent e) {
MainFrame.getVis3D().setBackgroundColor(GOP.getBgColor());
MainFrame.getVis3D().setTrackTextColor(GOP.getTextColor());
__setAntiAliasing = GOP.isAntialiasSelected();
MainFrame.getVis3D().setAntiAliasing(__setAntiAliasing);
__setMouseOverPopups = GOP.isMouseOverPopupsSelected();
__setShowCenterLine = GOP.isShowCenterLineSelected();
MainFrame.getVis3D().setShowCenterLine(__setShowCenterLine);
if (__setBillboard != GOP.isBillboardSelected()
|| __setTruncateText != GOP.isTruncateTextSelected()) {
MainFrame.getVis3D().setBillboard(GOP.isBillboardSelected());
MainFrame.getVis3D().setTruncated(GOP.isTruncateTextSelected());
if (DataStoreUser.getInstance().getSockeyeTrackList()
.getFeatureVisibility("gene")) {
DataStoreUser.getInstance().getSockeyeTrackList().setFeatureVisibility(
"gene", false);
DataStoreUser.getInstance().getSockeyeTrackList().setFeatureVisibility(
"gene", true);
}
}
__setEnableRegionSelect = GOP.isEnableRegionSelectSelected();
__showPopupIcons = GOP.isShowPopupIcons();
int oldNormalize = DataStoreUser.getInstance().getSockeyeTrackList()
.getNormalizeMethod();
int newNormalize = NOP.getNormalizationMethod();
if (oldNormalize != newNormalize) {
DataStoreUser.getInstance().getSockeyeTrackList().setNormalizeMethod(
newNormalize);
MainFrame.getVis3D().redrawAllFeatures();
}
boolean redrawDistributionFeatures = !(DistributionFeature3D
.getStackInYDirection() == DOP.stackHorizontaly()
&& DistributionFeature3D.getUseStaticFeatureColor() == DOP
.getDistributionsUseStaticColor()
&& DistributionFeature3D.getDefaultTransparency() == DOP
.getTransparencyValue()
&& (int) (DistributionFeature3D.getScale() * 10) == DOP
.get3DHeightValue()
&& DistributionFeature3D.get3DNormalizeToGlobalMax() == DOP
.get3dHeightReferenceIsGlobal()
&& DistributionFeature3D.getCoordSystemTickWidth() == DOP.getTicks()
&& DistributionFeature3D.getCoordTransparency() == DOP
.getCoordSystemTransparencyValue()
&& DistributionFeature3D.getShowCoordSystem() == DOP
.getShowCoordSystem()
&& DistributionFeature3D.getShowCoordZAxis() == DOP.getShowZAxis()
&& MultiDimDistributionFeature3D.getPlotWidth3D() == DOP
.getWidthOfMultiDistFeature()
&& MultiDimDistributionFeature3D.getPlotStyle() == DOP
.getMultiDistributionPlotStyleIndex()
&& MultiDimDistributionFeature3D.getReverse3D() == DOP
.getMDReverseOrder()
&& DistributionFeature3D.getShowTextAnnotation() == DOP
.getShowTextAnnotation() && MultiDimDistributionFeature3D
.getShowThresholds() == DOP.getMDShowThresholds());
DistributionFeature3D.setStackInYDirection(DOP.stackHorizontaly());
DistributionFeature3D.setDefaultTransparency(DOP.getTransparencyValue());
DistributionFeature3D.setScale((float) DOP.get3DHeightValue() / 10f);
DistributionFeature3D.setUseStaticFeatureColor(DOP
.getDistributionsUseStaticColor());
DistributionFeature3D.set3DNormalizeToGlobalMax(DOP
.get3dHeightReferenceIsGlobal());
DistributionFeature3D.setCoordSystemTickWidth(DOP.getTicks());
DistributionFeature3D.setShowCoordSystem(DOP.getShowCoordSystem());
DistributionFeature3D.setShowCoordZAxis(DOP.getShowZAxis());
DistributionFeature3D.setCoordTransparency(DOP
.getCoordSystemTransparencyValue());
DistributionFeature3D.setShowTextAnnotation(DOP.getShowTextAnnotation());
MultiDimDistributionFeature3D.setShowThresholds(DOP.getMDShowThresholds());
MultiDimDistributionFeature3D.setPlotStyle(DOP
.getMultiDistributionPlotStyleIndex());
MultiDimDistributionFeature3D.setPlotWidth3D(DOP
.getWidthOfMultiDistFeature());
MultiDimDistributionFeature3D.setReverse3D(DOP.getMDReverseOrder());
if (redrawDistributionFeatures)
MainFrame.getVis3D().redrawDistributions();
else
System.out.println("No need to redraw distribution!");
applySemZoomDialogData();
dispose();
}
void b_reset_actionPerformed(ActionEvent e) {
GOP.reset(MainFrame.getVis3D().getAntiAliasing(),
_setmouseoverpopups_default, _setshowcenterline_default, MainFrame
.getVis3D().getShowtext2D(), MainFrame.getVis3D().getBillboard(),
MainFrame.getVis3D().getTruncated(), _setenable_region_select_default,
_setenable_popup_icons_show_default);
DOP.setGeneralOptionValues(DistributionFeature3D.getStackInYDirection(),
(int) (DistributionFeature3D.getDefaultTransparency() * 100),
(int) (DistributionFeature3D.getScale() * 10), DistributionFeature3D
.getUseStaticFeatureColor(), DistributionFeature3D
.get3DNormalizeToGlobalMax(), DistributionFeature3D
.getShowCoordSystem(), DistributionFeature3D.getShowCoordZAxis(),
DistributionFeature3D.getCoordSystemTickWidth(),
(int) (DistributionFeature3D.getCoordTransparency() * 100));
DOP.setShowTextAnnotation(DistributionFeature3D.getShowTextAnnotation());
DOP.setMDShowThresholds(MultiDimDistributionFeature3D.getShowThresholds());
DOP.setWidthOfMultiDistFeature(MultiDimDistributionFeature3D
.getPlotWidth3D());
DOP.setMultiDistributionPlotStyleIndex(MultiDimDistributionFeature3D
.getPlotStyle());
DOP.setMDReverseOrder(MultiDimDistributionFeature3D.getReverse3D());
}
protected void initHelp() {
CSH.setHelpIDString(b_help, "options_overview");
}
private void initDistribOptionPanelData() {
DOP.setWidthOfMultiDistFeature(MultiDimDistributionFeature3D
.getPlotWidth3D());
DOP.setMultiDistributionPlotStyleIndex(MultiDimDistributionFeature3D
.getPlotStyle());
DOP.setShowTextAnnotation(DistributionFeature3D.getShowTextAnnotation());
DOP.setMDShowThresholds(MultiDimDistributionFeature3D.getShowThresholds());
DOP.setMDReverseOrder(MultiDimDistributionFeature3D.getReverse3D());
}
private void initSemZoomDialogData() {
for (int track = 0; track < 2; track++) {
szOpt.setBinSizeCustomValue(track, SemanticZoomManager
.getBinSizeCustomValues(track), SemanticZoomManager
.getBinSizeSelectedCustomMetric(track));
szOpt.setBinSizeOptionList(track, SemanticZoomManager
.getBinSizeOptionList(track));
szOpt.setBinSizeSelectedRule(track, SemanticZoomManager
.getBinSizeSelectedOption(track));
}
szOpt.setBinSizeMetricNames(SemanticZoomManager.getBinSizeMetricNames());
szOpt.setSupportedFeatureParameter(SemanticZoomManager
.getSupportedFeatureParameterMatrix(), SemanticZoomManager
.getAvailableSZStateStrings());
}
private void applySemZoomDialogData() {
for (int track = 0; track < 2; track++) {
SemanticZoomManager.setBinSizeCustomValue(track, szOpt
.getBinSizeCustomValues(track), szOpt
.getBinSizeSelectedCustomMetric(track));
SemanticZoomManager.setBinSizeSelectedRule(track, szOpt
.getBinSizeSelectedRule(track));
}
SemanticZoomManager.setSupportedFeatureParameterMatrix(szOpt
.getSupportedFeatureParameter());
DataStoreUser.getInstance().getDataSourceManager().resetAllDataSources();
}
}/*------
package ca.bcgsc.sockeye.gui.optionsdialog;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Vector;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.ButtonGroup;
import javax.swing.DefaultCellEditor;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JRadioButton;
import javax.swing.JScrollPane;
import javax.swing.JSpinner;
import javax.swing.JTable;
import javax.swing.SpinnerNumberModel;
import javax.swing.table.DefaultTableModel;
public class SZOptionPanel extends JPanel implements ActionListener{
private JScrollPane featureSettingsPanel;
private JPanel binSizeSettingsPanel;
private String[] binMetrics;
private String[] binReferencesFirst;
private String[] binReferencesSucc;
private int[][] binSizeValue = new int[2][2];
private int[] binSizeMetric = new int[2];
private int[] binSizeOption = new int[2];
private Vector szFeatureOptions;
private JTable szOptionsTable;
private String[] szStateOptions;
private JSpinner succCustomTrackSize;
private JComboBox succCustomTrackMetric;
SpinnerNumberModel[] spinModels= new SpinnerNumberModel[2];
private final String comboCommand[] = new String[]{"ftMetricChange", "succMetricChange"};
public SZOptionPanel() {
}
public void createControls(){
featureSettingsPanel = createFeatureSettingsPanel();
binSizeSettingsPanel = createBinSizeSettingsPanel();
this.setLayout (new BoxLayout(this, BoxLayout.Y_AXIS));
this.add (Box.createVerticalStrut(10));
this.add (featureSettingsPanel);
this.add (Box.createVerticalStrut(20));
this.add (binSizeSettingsPanel);
this.doLayout();
}
public void setBinSizeOptionList (int trackNo, String[] options){
if (trackNo == 0)
binReferencesFirst = options;
else
binReferencesSucc = options;
}
public void setBinSizeMetricNames (String[] metr){
binMetrics = metr;
}
public void setBinSizeCustomValue (int track, int[] sizes, int metric){
binSizeValue [(track==0)?0:1] = sizes;
binSizeMetric[(track==0)?0:1] = metric;
}
public int[] getBinSizeCustomValues (int track){
track = (track==0)?0:1;
binSizeValue[track][binSizeMetric[track]]=spinModels[track].getNumber().intValue();
return binSizeValue[track];
}
public int getBinSizeSelectedCustomMetric (int track){
return binSizeMetric[(track==0)?0:1];
}
public int getBinSizeSelectedRule (int track){
return binSizeOption[(track==0)?0:1];
}
public void setBinSizeSelectedRule (int track, int option){
binSizeOption[(track==0)?0:1] = option;
}
public void setSupportedFeatureParameter (Vector featureParam, String[] szState){
szFeatureOptions = featureParam;
szStateOptions = szState;
}
public Vector getSupportedFeatureParameter(){
if (szOptionsTable.isEditing()){
int row = szOptionsTable.getEditingRow();
int col = szOptionsTable.getEditingColumn();
szOptionsTable.getCellEditor(row, col).stopCellEditing();
}
return ( ((DefaultTableModel)szOptionsTable.getModel()).getDataVector() );
}
public void actionPerformed(ActionEvent e){
String cmd = e.getActionCommand();
for (int c=0; c<2; c++)
if (cmd.equals(comboCommand[c]))
{
binSizeValue[c][binSizeMetric[c]]=spinModels[c].getNumber().intValue();
binSizeMetric[c] = ((JComboBox)e.getSource()).getSelectedIndex();
spinModels[c].setValue(new Integer(binSizeValue[c][binSizeMetric[c]]));
return;
}
for (int counter=0; counter < binReferencesSucc.length; counter++)
if (cmd.equals(binReferencesSucc[counter])){
binSizeOption[1] = counter;
if (counter==binReferencesSucc.length-1){
succCustomTrackSize.setEnabled(true);
succCustomTrackMetric.setEnabled(true);
}
else {
succCustomTrackSize.setEnabled(false);
succCustomTrackMetric.setEnabled(false);
}
}
}
private JScrollPane createFeatureSettingsPanel(){
Vector tableHeader = new Vector();
tableHeader.add("Feature");
tableHeader.add("Behaviour");
tableHeader.add("Threshold");
JComboBox behaviorChoice = new JComboBox(szStateOptions);
behaviorChoice.setSelectedIndex(1);
szOptionsTable = new JTable (new DefaultTableModel(szFeatureOptions, tableHeader){public boolean isCellEditable(int row, int column){return !(column==0);};});
szOptionsTable.setToolTipText("Set the threshold value and desired semantic zooming behaviour by double-clicking on a table cell");
szOptionsTable.getColumnModel().getColumn(1).setCellEditor(new DefaultCellEditor(behaviorChoice));
szOptionsTable.getColumnModel().getColumn(2).setCellEditor(szOptionsTable.getDefaultEditor(Integer.class));
JScrollPane scrollPane = new JScrollPane(szOptionsTable);
szOptionsTable.setPreferredScrollableViewportSize(new Dimension(szOptionsTable.getPreferredSize().width, 100));
scrollPane.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(),
"Semantic Zooming Behaviour"));
return scrollPane;
}
private JPanel createBinSizeSettingsPanel(){
GridBagLayout gridbag = new GridBagLayout();
GridBagConstraints gbc = new GridBagConstraints();
JPanel panel = new JPanel();
JLabel firstTrackLabel = new JLabel("First added track: ");
JLabel successiveTrackLabel = new JLabel("Successive tracks: ");
JComboBox firstTrackMetric = new JComboBox (binMetrics);
succCustomTrackMetric = new JComboBox (binMetrics);
ButtonGroup binSizeReference = new ButtonGroup();
spinModels[0] = new SpinnerNumberModel(new Integer(binSizeValue[0][binSizeMetric[0]]), new Integer(0), null, new Integer (10));
spinModels[1] = new SpinnerNumberModel(new Integer(binSizeValue[1][binSizeMetric[1]]), new Integer(0), null, new Integer (10));
JSpinner firstTrackSize = new JSpinner(spinModels[0]);
succCustomTrackSize = new JSpinner(spinModels[1]);
Dimension size;
Box customSizeContainer = Box.createHorizontalBox();
firstTrackLabel.setToolTipText("The desired histogram bin size for the very first track");
firstTrackMetric.setToolTipText("The desired histogram bin size for the very first track");
successiveTrackLabel.setToolTipText("The desired histogram bin size for every successive track");
succCustomTrackMetric.setToolTipText("Metric for the histogram bin size entered");
firstTrackMetric.setToolTipText("Metric for the histogram bin size entered");
firstTrackMetric.setSelectedIndex(binSizeMetric[0]);
succCustomTrackMetric.setSelectedIndex(binSizeMetric[1]);
firstTrackMetric.setActionCommand(comboCommand[0]);
succCustomTrackMetric.setActionCommand(comboCommand[1]);
firstTrackMetric.addActionListener(this);
succCustomTrackMetric.addActionListener(this);
gbc.fill = GridBagConstraints.HORIZONTAL;
panel.setLayout(gridbag);
panel.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(),"Initial Histogram Bin Size"));
gbc.gridx=0; gbc.gridy=0;
gridbag.setConstraints (firstTrackLabel, gbc);
gbc.gridx=0; gbc.gridy=1;
gridbag.setConstraints (successiveTrackLabel, gbc);
gbc.gridx=1; gbc.gridy=0;
gridbag.setConstraints (firstTrackSize, gbc);
size = firstTrackSize.getPreferredSize();
size.width *= 4;
firstTrackSize.setPreferredSize(size);
succCustomTrackSize.setPreferredSize(size);
gbc.gridx=2; gbc.gridy=0;
gridbag.setConstraints (firstTrackMetric, gbc);
for (int button = 0; button < binReferencesSucc.length; button++){
JRadioButton rbutton = new JRadioButton(binReferencesSucc[button]);
if (button==binSizeOption[1])
rbutton.setSelected(true);
rbutton.setToolTipText("Select bin size reference for the second of following track");
rbutton.setActionCommand(binReferencesSucc[button]);
rbutton.addActionListener(this);
gbc.gridx=1; gbc.gridy=1+button; gbc.gridwidth=2;
binSizeReference.add(rbutton);
if (binReferencesSucc[button].equalsIgnoreCase("custom"))
customSizeContainer.add(rbutton);
else{
gridbag.setConstraints (rbutton, gbc);
panel.add(rbutton);
}
}
if (!binReferencesSucc[binSizeOption[1]].equalsIgnoreCase("custom"))
{
succCustomTrackSize.setEnabled(false);
succCustomTrackMetric.setEnabled(false);
}
gbc.gridx=1; gbc.gridy=0 + binReferencesSucc.length;
gridbag.setConstraints (customSizeContainer, gbc);
customSizeContainer.add(succCustomTrackSize);
customSizeContainer.add(succCustomTrackMetric);
panel.add(firstTrackLabel);
panel.add(successiveTrackLabel);
panel.add(firstTrackSize);
panel.add(firstTrackMetric);
panel.add(customSizeContainer);
return panel;
}
}
package ca.bcgsc.sockeye.gui.retrievaldialog;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;
import javax.swing.JButton;
import javax.swing.JFileChooser;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import ca.bcgsc.sockeye.dataretrieval.FileDRU;
import ca.bcgsc.sockeye.parser.ParserManager;
public class AdvanceGFFPanel extends JPanel {
private JButton openButton;
private RetrievalWizard _parent;
public AdvanceGFFPanel(RetrievalWizard parent) {
super(new BorderLayout());
this._parent = parent;
jbInit();
}
private void jbInit() {
_parent.getFileChooser().setAccessory(_parent.getFilePreviewPanel());
_parent.getFileChooser().setApproveButtonText("Open");
JPanel p = new JPanel(new GridBagLayout());
GridBagConstraints inner_c = new GridBagConstraints();
inner_c.gridx = 0;
inner_c.gridy = 0;
inner_c.insets = new Insets(10, 0, 0, 0);
inner_c.anchor = GridBagConstraints.NORTHWEST;
JLabel fileLabel = new JLabel("File");
p.add(fileLabel, inner_c);
inner_c.gridx = 1;
inner_c.gridy = 0;
inner_c.weightx = 1.0;
inner_c.insets = new Insets(10, 10, 0, 0);
inner_c.fill = GridBagConstraints.HORIZONTAL;
_parent.getGFFFileField().setEditable(false);
p.add(_parent.getGFFFileField(), inner_c);
inner_c.gridx = 2;
inner_c.gridy = 0;
inner_c.gridwidth = 1;
inner_c.weightx = 0.0;
inner_c.insets = new Insets(10, 10, 0, 0);
inner_c.anchor = GridBagConstraints.EAST;
inner_c.fill = GridBagConstraints.NONE;
openButton = new JButton("...");
openButton.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
try {
int returnVal = _parent.getFileChooser().showOpenDialog(
AdvanceGFFPanel.this);
if (returnVal == JFileChooser.APPROVE_OPTION) {
_parent.setGFFFile(_parent.getFileChooser()
.getSelectedFile());
File gffFile = _parent.getGFFFile();
if (ParserManager
.getClassNameForAnnotationExtension((gffFile
.getName().substring(gffFile.getName()
.length() - 3))) != null) {
_parent.setParser(FileDRU.getParser(gffFile));
_parent.getParser().validate();
_parent.getFilePreviewPanel().setFilePreviewTable(
_parent.getParser());
_parent.getGFFFileField()
.setText(gffFile.getName());
_parent.set_gff_text_field(gffFile.getName());
_parent.set_enabled_finish_button(true);
return;
} else {
throw new Exception("File Does Not Exist");
}
}
_parent.setGFFFile(null);
_parent.getGFFFileField().setText("");
_parent.set_gff_text_field("");
_parent.getFilePreviewPanel().clearTable();
_parent.set_enabled_finish_button(false);
} catch (Throwable t) {
JOptionPane.showMessageDialog(null, "Could not load file: "
+ _parent.getGFFFile().getName(), "Warning",
JOptionPane.ERROR_MESSAGE);
_parent.setGFFFile(null);
_parent.getGFFFileField().setText("");
_parent.set_gff_text_field("");
_parent.getFilePreviewPanel().clearTable();
_parent.set_enabled_finish_button(false);
}
}
});
p.add(openButton, inner_c);
inner_c.gridx = 0;
inner_c.gridy = 1;
inner_c.fill = GridBagConstraints.HORIZONTAL;
inner_c.insets = new Insets(10, 0, 0, 0);
inner_c.gridwidth = 3;
_parent.getFilePreviewPanel().setPreferredSize(new Dimension(500, 200));
p.add(_parent.getFilePreviewPanel(), inner_c);
add(p, BorderLayout.NORTH);
}
Component getDefaultComponent() {
return _parent.getGFFFileField();
}
Component getBeforeComponent(Component current) {
return null;
}
Component getNextComponent(Component current) {
if (current != _parent.getGFFFileField() && current != openButton)
return _parent.getGFFFileField();
else if (current == _parent.getGFFFileField())
return openButton;
else
return null;
}
Component getLastDefaultComponent() {
return openButton;
}
}package ca.bcgsc.sockeye.gui.retrievaldialog;
import java.awt.CardLayout;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.util.Vector;
import javax.swing.BorderFactory;
import javax.swing.DefaultListModel;
import javax.swing.JCheckBox;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ListSelectionModel;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
public class DatasourcePane extends JPanel {
private DefaultListModel listModel = new DefaultListModel();
private GridBagConstraints c = new GridBagConstraints();
private JLabel txtLabel1;
private JList list;
private JScrollPane listScrollPane;
private JLabel txtLabel2;
private JComboBox verCombo;
private JCheckBox finishBox = new JCheckBox("Close dialog after Finish");
private int index = -1;
private JPanel rightPanel;
private CardLayout cards = new CardLayout();
EnsemblConnectionPane ensPane;
ImportGFFPane gffPane;
RetrievalWizard _parent;
public DatasourcePane(RetrievalWizard parent) {
super(new GridBagLayout());
_parent = parent;
jbinit();
}
void jbinit() {
c.gridheight = 1;
c.gridwidth = 1;
c.insets = new Insets(0, 0, 0, 0);
c.gridx = 0;
c.gridy = 0;
c.anchor = GridBagConstraints.WEST;
txtLabel1 = new JLabel(
"<HTML>1. Please select a data source<br></HTML>");
add(txtLabel1, c);
listModel.addElement("EnsEMBL server");
listModel.addElement("GFF annotation file");
list = new JList(listModel);
list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
list.setSelectedIndex(0);
list.setVisibleRowCount(5);
list.addListSelectionListener(new ListSelectionListener() {
public void valueChanged(ListSelectionEvent e) {
list_valueChanged();
}
});
JScrollPane listScrollPane = new JScrollPane(list,
JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,
JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
listScrollPane.setPreferredSize(new Dimension(200, 70));
c.gridx = 0;
c.gridy = 1;
c.anchor = GridBagConstraints.WEST;
c.insets = new Insets(10, 0, 0, 0);
add(listScrollPane, c);
rightPanel = new JPanel(cards);
ensPane = new EnsemblConnectionPane(_parent);
rightPanel.add(ensPane, "connection");
gffPane = new ImportGFFPane(_parent);
rightPanel.add(gffPane, "gff");
c.gridx = 1;
c.gridy = 0;
c.gridheight = 3;
c.gridwidth = 2;
c.insets = new Insets(0, 20, 0, 0);
c.fill = GridBagConstraints.BOTH;
c.anchor = GridBagConstraints.NORTHWEST;
add(rightPanel, c);
setBorder(BorderFactory.createEmptyBorder(20, 20, 20, 20));
}
public int getSelectedIndex() {
return list.getSelectedIndex();
}
public Vector get_version_list() {
return ensPane.get_version_list();
}
void setGFFText(String input) {
gffPane.setGffText(input);
}
public void list_valueChanged() {
index = list.getSelectedIndex();
if (index == 0) {
if (_parent.getRenewConnection()) {
_parent.set_enabled_next_button(false);
_parent.set_enabled_finish_button(false);
_parent.set_enabled_pane(0, true);
_parent.set_enabled_pane(1, false);
_parent.set_enabled_pane(2, false);
} else {
_parent.set_enabled_pane(0, true);
_parent.set_enabled_pane(1, true);
_parent.set_enabled_pane(2, true);
_parent.set_enabled_next_button(true);
_parent.set_enabled_finish_button(false);
}
_parent.change_tab_title(1, "Data and species");
cards.show(rightPanel, "connection");
_parent.showSecondPane("species pane");
} else if (index == 1) {
_parent.change_tab_title(1, "Preview and Import");
_parent.set_enabled_pane(0, true);
if (_parent.getGFFFile() == null) {
_parent.set_enabled_pane(1, false);
_parent.set_enabled_pane(2, false);
_parent.set_enabled_finish_button(false);
_parent.set_enabled_next_button(false);
} else {
_parent.set_enabled_pane(1, true);
_parent.set_enabled_pane(2, true);
_parent.set_enabled_finish_button(true);
_parent.set_enabled_next_button(true);
}
cards.show(rightPanel, "gff");
_parent.showSecondPane("gff pane");
_parent.set_viewer_status(0, true, true);
_parent.set_viewer_status(1, false, false);
_parent.set_viewer_status(2, false, false);
_parent.set_viewer_status(3, false, false);
_parent.set_viewer_status(4, false, false);
} else if (index == 2) {
_parent.set_enabled_finish_button(false);
_parent.set_enabled_next_button(false);
_parent.set_enabled_pane(0, true);
_parent.set_enabled_pane(1, false);
_parent.set_enabled_pane(2, false);
cards.show(rightPanel, "annotation");
} else
System.out.println("Selection Error");
}
Component getDefaultComponent() {
return list;
}
Component getLastDefaultComponent() {
if (index == 0)
return ensPane.getLastComponent();
else if (index == 1)
return gffPane.getLastComponent();
else
return null;
}
Component getBeforeComponent(Component current) {
if (index == 0)
return ensPane.getBeforeComponent(current);
else if (index == 1)
return gffPane.getBeforeComponent(current);
else
return null;
}
Component getNextComponent(Component current) {
if (index == 0)
return ensPane.getNextComponent(current);
else if (index == 1)
return gffPane.getNextComponent(current);
else
return null;
}
}package ca.bcgsc.sockeye.gui.retrievaldialog;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.Vector;
import javax.swing.DefaultListModel;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ListSelectionModel;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.config.Service;
import ca.bcgsc.sockeye.service.featureloader.common.ConnectionManager;
import ca.bcgsc.sockeye.service.featureloader.common.FeatureLoaderService;
import ca.bcgsc.sockeye.service.featureloader.common.FeatureLoaderServiceFactory;
import ca.bcgsc.sockeye.util.Log;
public class EnsemblConnectionPane extends JPanel {
private JLabel txtLabel2;
private JComboBox specieCombo;
private JButton conButton;
private DefaultListModel serverModel = new DefaultListModel();
private JList serverList;
private JScrollPane serverScrollPane;
private int index = -1;
private int server_index = 0;
private String selected_server = "";
private Object[] species, db_core;
private static ArrayList _all_database_names = new ArrayList();
private RetrievalWizard _parent;
public EnsemblConnectionPane(RetrievalWizard parent) {
super(new GridBagLayout());
this._parent = parent;
jbinit();
}
protected void jbinit() {
GridBagConstraints inner_c = new GridBagConstraints();
inner_c.gridx = 0;
inner_c.gridy = 0;
inner_c.anchor = GridBagConstraints.NORTHWEST;
inner_c.insets = new Insets(0, 0, 0, 0);
JLabel txtLabel4 = new JLabel(
"<HTML>2. Please choose an EnsEMBL server<br>and press the Connect button</HTML>");
add(txtLabel4, inner_c);
inner_c.gridheight = 1;
inner_c.gridwidth = 1;
inner_c.gridx = 0;
inner_c.gridy = 1;
inner_c.insets = new Insets(10, 0, 0, 0);
inner_c.fill = GridBagConstraints.NONE;
inner_c.anchor = GridBagConstraints.WEST;
serverList = new JList(ConnectionManager.getConnectionNames("Ensembl")
.toArray());
serverList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
serverList.setSelectedIndex(0);
serverList.setVisibleRowCount(3);
serverList.addListSelectionListener(new ListSelectionListener() {
public void valueChanged(ListSelectionEvent e) {
serverList_valueChanged();
}
});
serverScrollPane = new JScrollPane(serverList,
JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,
JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
serverScrollPane.setPreferredSize(new Dimension(280, 70));
add(serverScrollPane, inner_c);
inner_c.gridx = 0;
inner_c.gridy = 2;
inner_c.anchor = GridBagConstraints.WEST;
inner_c.insets = new Insets(5, 0, 0, 0);
conButton = new JButton("Connect");
conButton.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
conButton_actionPerformed();
}
});
add(conButton, inner_c);
inner_c.gridx = 0;
inner_c.gridy = 3;
inner_c.fill = GridBagConstraints.NONE;
inner_c.anchor = GridBagConstraints.WEST;
inner_c.insets = new Insets(15, 0, 0, 0);
txtLabel2 = new JLabel("3. Please choose species");
add(txtLabel2, inner_c);
inner_c.gridx = 0;
inner_c.gridy = 4;
inner_c.fill = GridBagConstraints.NONE;
inner_c.anchor = GridBagConstraints.WEST;
inner_c.insets = new Insets(5, 0, 0, 0);
specieCombo = new JComboBox();
specieCombo.setEnabled(false);
specieCombo.setPreferredSize(new Dimension(280, 25));
specieCombo.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
if (!_parent.getSelectedSpecies().equals(
specieCombo.getSelectedItem())) {
_parent.set_enabled_finish_button(false);
_parent.setRenewSpecies(true);
}
}
});
add(specieCombo, inner_c);
}
public void conButton_actionPerformed() {
ArrayList speciesList = new ArrayList();
selected_server = (String) serverList.getSelectedValue();
ConnectionManager.setCurrentConnectionByName(selected_server);
specieCombo.setEnabled(true);
_parent.set_enabled_next_button(true);
specieCombo.removeAllItems();
_parent.getEnsemblVersion().clear();
_parent.clearServerDatabaseMap();
try {
FeatureLoaderServiceFactory fac = FeatureLoaderServiceFactory
.getInstance();
Service service = Configuration
.getService(FeatureLoaderServiceFactory.FEATURELOADER_SERVICES);
String mode = null;
String remotehost = null;
if (service != null) {
mode = service.getMode();
remotehost = service.getRemotehost();
} else {
throw new RuntimeException(
"Feature loader service not set up properly.");
}
FeatureLoaderService ser = fac.getService(mode, remotehost);
Object[] db_core = ser.getDatabaseList(
ConnectionManager.getCurrentConnection("Ensembl"), "CORE")
.toArray();
if (_parent.getDatabaseFromServer(selected_server) == null)
_parent.putServerDatabase(selected_server, db_core);
for (int j = 0; j < db_core.length; j++) {
try {
String db_name = (String) db_core[j];
String[] db_name1 = db_name.split("_");
String db_name2 = db_name1[0] + "_" + db_name1[1];
String db_name3 = (String) SpeciesNameContainer
.getCommonSpeciesName(db_name2);
if (db_name3 == null) {
db_name3 = db_name2.replaceAll("_", " ");
db_name3 = db_name3.substring(0, 1).toUpperCase()
+ db_name3.substring(1);
}
if (!speciesList.contains(db_name3))
speciesList.add(db_name3);
db_name3 = db_name3.concat(new String("_" + db_name1[3]
+ "." + db_name1[4]));
_parent.putSpeciesDatabase(db_name3, db_name);
_all_database_names.add(db_name);
_parent.addEnsemblVersion(db_name1[3]);
} catch (Throwable t) {
Log.printStackTrace(t);
}
}
_parent.setRenewConnection(false);
_parent.setRenewVersion(true);
_parent.setRenewSpecies(true);
} catch (Exception ex) {
Log.printStackTrace(ex);
JOptionPane.showMessageDialog(null,
"Connection to " + selected_server
+ " failed.\n Please try another server.",
"Warning", JOptionPane.ERROR_MESSAGE);
return;
}
Collections.sort(speciesList);
for (Iterator i = speciesList.iterator(); i.hasNext();) {
specieCombo.addItem((String) i.next());
}
_parent.setSelectedSpecies((String) (specieCombo.getItemAt(0)));
_parent.set_enabled_pane(1, true);
_parent.set_enabled_pane(2, true);
}
public Vector get_version_list() {
Vector tmpVector = new Vector();
_parent.setSelectedSpecies((String) specieCombo.getSelectedItem());
species = _parent.getAllSpeciesInDatabase();
String selectedSpecies = _parent.getSelectedSpecies();
for (int j = 0; j < species.length; j++) {
String[] tmpSpecies = ((String) species[j]).split("_");
String specie = tmpSpecies[0];
if (selectedSpecies.equals(specie)) {
tmpVector.add(tmpSpecies[1]);
} else {
continue;
}
}
Collections.sort(tmpVector);
Collections.reverse(tmpVector);
System.out.println();
return tmpVector;
}
public void add_geneid_database() {
}
public void serverList_valueChanged() {
String newServer = (String) serverList.getSelectedValue();
if (selected_server == newServer) {
return;
} else {
_parent.setRenewConnection(true);
_parent.setRenewVersion(true);
_parent.setRenewSpecies(true);
if (_parent.getDatabaseFromServer(newServer) == null) {
specieCombo.removeAllItems();
specieCombo.setEnabled(false);
_parent.set_enabled_next_button(false);
_parent.set_enabled_pane(1, false);
_parent.set_enabled_pane(2, false);
_parent.set_enabled_finish_button(false);
} else {
conButton_actionPerformed();
_parent.set_enabled_next_button(true);
}
selected_server = newServer;
}
}
Component getBeforeComponent(Component current) {
if (current != serverList && current != conButton
&& current != specieCombo)
if (specieCombo.isEnabled())
return specieCombo;
else
return conButton;
if (current == specieCombo) {
return conButton;
}
if (current == conButton) {
return serverList;
}
return null;
}
Component getNextComponent(Component current) {
if (current != serverList && current != conButton
&& current != specieCombo)
return serverList;
if (current == serverList) {
return conButton;
}
if (current == conButton && specieCombo.isEnabled()) {
return specieCombo;
}
return null;
}
Component getLastComponent() {
if (specieCombo.isEnabled())
return specieCombo;
else
return conButton;
}
}/*------
package ca.bcgsc.sockeye.gui.retrievaldialog;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.Collections;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.DefaultListModel;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextField;
import javax.swing.ListSelectionModel;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import ca.bcgsc.sockeye.datastorage.ensembl.CachedGeneID;
import ca.bcgsc.sockeye.service.featureloader.common.ConnectionManager;
public class EnsemblGeneNameInputPanel extends JPanel implements
ListSelectionListener {
JLabel db_name_lab = new JLabel("Unknown gene naming scheme");
JLabel gene_count_lab = new JLabel();
JTextField gene_input_tf = new JTextField(10);
Pattern ensembl_pat = Pattern.compile("ENS(\\p{Alpha}{0,3})G\\d*",
Pattern.CASE_INSENSITIVE);
Pattern c_eleg_pat_1 = Pattern.compile("[B-FH-KMRTW]{1,1}\\d+",
Pattern.CASE_INSENSITIVE);
Pattern c_eleg_pat_2 = Pattern.compile("[AZ]{1,1}\\w+",
Pattern.CASE_INSENSITIVE);
Pattern s_cere_pat_1 = Pattern
.compile("[YT]\\w+", Pattern.CASE_INSENSITIVE);
Pattern s_cere_pat_2 = Pattern.compile("Q0\\w*", Pattern.CASE_INSENSITIVE);
Pattern drosoph_pat = Pattern.compile("CG\\d*", Pattern.CASE_INSENSITIVE);
Pattern fugu_pat = Pattern.compile("SI\\w*", Pattern.CASE_INSENSITIVE);
Pattern tetra_pat = Pattern.compile("GSTENG\\d*", Pattern.CASE_INSENSITIVE);
HashMap ensemb_map = new HashMap();
HashMap species_prefix = new HashMap();
DefaultListModel _list_model = new DefaultListModel();
GeneDBThread _db_thread = new GeneDBThread();
JList _gene_list = new JList();
ListSelectionModel _lsm;
Map _core_databases = new HashMap();
JScrollPane listScroller = new JScrollPane(_gene_list);
private String _db_host = null;
private String _db_user = null;
private String _db_pass = null;
private final int _list_row_count = 5;
public EnsemblGeneNameInputPanel() {
ensemb_map.put("ANG", "anopheles");
ensemb_map.put("APMG", "apis");
ensemb_map.put("CBR", "caenorhabditis_briggsae");
ensemb_map.put("CAFG", "canis");
ensemb_map.put("DAR", "danio");
ensemb_map.put("GAL", "gal");
ensemb_map.put("MUS", "mus");
ensemb_map.put("PTR", "pan");
ensemb_map.put("RNO", "rattus");
ensemb_map.put("XETG", "xenopus");
_db_thread.setDaemon(true);
_db_thread.start();
init();
}
public EnsemblGeneNameInputPanel(String host, String user, String pass) {
this();
setConnectionParameter(host, user, pass);
}
public void setConnectionParameter(String host, String user, String pass) {
_db_host = host;
_db_user = user;
_db_pass = pass;
try {
Class.forName("com.mysql.jdbc.Driver");
} catch (ClassNotFoundException e) {
System.out.println("gene panel - Driver not found: "
+ e.getMessage());
}
}
public void setCoreDatabases(Map db_map) {
_core_databases = db_map;
}
public String getActiveDB() {
return _db_thread.getActiveDB();
}
public String getGeneId() {
return gene_input_tf.getText();
}
public void setGeneId(String input) {
gene_input_tf.setText(input);
}
protected void calledWhenValid() {
System.out.println("Valid Input");
}
protected void calledWhenInvalid() {
System.out.println("Go away with that...");
}
private void init() {
this.setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
gene_input_tf.getDocument().addDocumentListener(
new ValidationListener());
_gene_list.setVisibleRowCount(_list_row_count);
Box b = Box.createHorizontalBox();
b.add(db_name_lab);
b.add(gene_count_lab);
this.add(b);
this.add(gene_input_tf);
this.add(listScroller);
}
private class GeneDBThread extends Thread {
private String _active_db = null;
private String _last_active_db;
private HashMap _gene_name_cache = new HashMap();
private HashMap _common_name_cache = new HashMap();
public synchronized void setDB(String db) {
_active_db = db;
_last_active_db = db;
notifyAll();
}
public GeneDBThread() {
}
public String getActiveDB() {
return _last_active_db;
}
public synchronized String getDB() {
while (_active_db == null) {
try {
wait();
} catch (InterruptedException e) {
}
}
String ret = _active_db;
_active_db = null;
return ret;
}
private synchronized void filterList(String database) {
if (database.length() == 0)
return;
List cached = (List) _gene_name_cache.get(database);
DefaultListModel dlm = new DefaultListModel();
if (cached == null) {
System.out
.println("In filter function: Check this out - this should never happen!");
return;
}
String txt = gene_input_tf.getText().toUpperCase();
for (Iterator gn_it = cached.iterator(); gn_it.hasNext();) {
String gene_name = (String) gn_it.next();
if (gene_name.startsWith(txt))
dlm.addElement(gene_name);
}
if (dlm.contains(txt))
calledWhenValid();
gene_count_lab.setText(" - " + dlm.size() + " matches");
JList l = new JList(dlm);
l.setVisibleRowCount(_list_row_count);
_lsm = l.getSelectionModel();
_lsm.addListSelectionListener(EnsemblGeneNameInputPanel.this);
listScroller.setViewportView(l);
_list_model = dlm;
}
public void run() {
String lastDB = new String();
String db;
while (true) {
db = getDB();
if (db.equals(lastDB)) {
filterList(db);
continue;
}
lastDB = db;
_list_model.clear();
if (db.length() == 0)
continue;
List cached = (List) _gene_name_cache.get(db);
if (cached == null) {
_gene_name_cache.put(db, getGenesFromDB(db));
filterList(db);
continue;
}
filterList(db);
String com = (String) _common_name_cache.get(db);
if (gene_input_tf.getText().length() < com.length()) {
String diff = com.substring(gene_input_tf.getText()
.length());
try {
gene_input_tf.getDocument().insertString(
gene_input_tf.getText().length(), diff, null);
} catch (javax.swing.text.BadLocationException e) {
}
;
}
}
}
private synchronized List getGenesFromDB(String source_db) {
ArrayList result_list = CachedGeneID.getGeneID(source_db);
if (result_list != null) {
addtoJList(source_db, result_list);
return result_list;
}
else {
String url = new String("jdbc:mysql:
+ source_db;
result_list = new ArrayList();
Connection conn;
Statement stmt;
ResultSet rset;
try {
conn = DriverManager.getConnection(url, _db_user, _db_pass);
} catch (SQLException e) {
System.out.println("gene panel: Can't connect to DB: "
+ e.getMessage());
return null;
}
try {
stmt = conn.createStatement();
} catch (SQLException e) {
System.out.println("gene panel: Can't create statement: "
+ e.toString());
try {
conn.close();
} catch (SQLException s) {
System.out.println("Can't close connection: "
+ e.toString());
}
return null;
}
try {
rset = stmt.executeQuery("SELECT * FROM gene_stable_id ");
} catch (SQLException e) {
System.out
.println("gene panel: Error while executing query: "
+ e.toString());
return null;
}
try {
while (rset.next()) {
result_list.add(rset.getString(2));
}
} catch (SQLException e) {
System.out
.println("gene panel Error while reading result set: "
+ e.toString());
return null;
}
addtoJList(source_db, result_list);
try {
stmt.close();
} catch (SQLException e) {
System.out.println("gene panel Can't close statement: "
+ e.toString());
}
try {
conn.close();
} catch (SQLException e) {
System.out.println("gene panel Can't close connection: "
+ e.toString());
}
return result_list;
}
}
private synchronized void addtoJList(String source_db, List result_list) {
DefaultListModel dlm = new DefaultListModel();
Collections.sort(result_list);
for (Iterator sit = result_list.iterator(); sit.hasNext();) {
dlm.addElement(sit.next());
}
JList l = new JList(dlm);
l.setVisibleRowCount(_list_row_count);
_lsm = l.getSelectionModel();
_lsm.addListSelectionListener(EnsemblGeneNameInputPanel.this);
listScroller.setViewportView(l);
_list_model = dlm;
String commonRegion = (String) result_list.get(0);
for (Iterator it = result_list.iterator(); it.hasNext();) {
String gene = it.next().toString();
for (int i = commonRegion.length(); i >= 0; i--) {
if (gene.regionMatches(0, commonRegion, 0, i)) {
commonRegion = commonRegion.substring(0, i);
break;
}
}
}
_common_name_cache.put(source_db, commonRegion);
if (gene_input_tf.getText().length() < commonRegion.length())
try {
gene_input_tf.getDocument().insertString(
gene_input_tf.getText().length(),
commonRegion.substring(gene_input_tf.getText()
.length()), null);
} catch (javax.swing.text.BadLocationException e) {
}
;
}
}
class ValidationListener implements DocumentListener {
private final String _nodb = new String();
private String _last_matched = null;
public void insertUpdate(DocumentEvent e) {
checkMatch();
}
public void removeUpdate(DocumentEvent e) {
checkMatch();
}
public void changedUpdate(DocumentEvent e) {
}
private void noMatch() {
if (_last_matched == null)
return;
calledWhenInvalid();
db_name_lab.setText("Unknown gene naming scheme");
_last_matched = null;
_db_thread.setDB(_nodb);
}
private void match(String s) {
String _database = new String();
String _display_string;
String currentConnection = ConnectionManager.getCurrentConnection(
"Ensembl").getName();
if (_last_matched != null) {
if (_list_model.contains(gene_input_tf.getText().toUpperCase()))
calledWhenValid();
else
calledWhenInvalid();
_db_thread.setDB(_last_matched);
return;
}
for (Iterator it = _core_databases.keySet().iterator(); it
.hasNext();) {
String db = (String) it.next();
if (db.startsWith(s)) {
_database = db;
break;
}
}
_last_matched = _database;
_display_string = (String) _core_databases.get(_database);
if (_display_string != null)
db_name_lab.setText(_display_string);
_db_thread.setDB(_database);
}
private void checkMatch() {
Matcher m = ensembl_pat.matcher(gene_input_tf.getText());
if (m.matches()) {
String spec = (String) ensemb_map.get(m.group(1).toUpperCase());
if (spec != null || m.group(1).length() == 0)
match(m.group(1).length() == 0 ? "homo" : spec);
else
noMatch();
return;
}
m = drosoph_pat.matcher(gene_input_tf.getText());
if (m.matches()) {
match("drosophila");
return;
}
m = fugu_pat.matcher(gene_input_tf.getText());
if (m.matches()) {
match("fugu");
return;
}
m = tetra_pat.matcher(gene_input_tf.getText());
if (m.matches()) {
match("tetraodon");
return;
}
if (s_cere_pat_1.matcher(gene_input_tf.getText()).matches()
|| s_cere_pat_2.matcher(gene_input_tf.getText()).matches()) {
match("saccharomyces");
return;
}
if (c_eleg_pat_1.matcher(gene_input_tf.getText()).matches()
|| c_eleg_pat_2.matcher(gene_input_tf.getText()).matches()) {
match("caenorhabditis_elegans");
return;
}
noMatch();
}
}
public void valueChanged(ListSelectionEvent e) {
if (_lsm.isSelectionEmpty())
return;
int firstIndex = _lsm.getMinSelectionIndex();
gene_input_tf.setText(_list_model.get(firstIndex).toString());
calledWhenValid();
}
public void resetGeneField() {
gene_input_tf.setText("");
db_name_lab.setText("");
gene_count_lab.setText("");
_list_model.clear();
}
}package ca.bcgsc.sockeye.gui.retrievaldialog;
import java.awt.Component;
import ca.bcgsc.sockeye.service.featureloader.common.ConnectionManager;
class GeneIdListenerPane extends EnsemblGeneNameInputPanel {
private RetrievalWizard _parent;
public GeneIdListenerPane(RetrievalWizard parent) {
this._parent = parent;
}
public GeneIdListenerPane(RetrievalWizard parent, String host, String user,
String pass) {
super(host, user, pass);
this._parent = parent;
}
public GeneIdListenerPane(RetrievalWizard parent,
ca.bcgsc.sockeye.config.Connection connection) {
super(connection.getHost(), connection.getUser(), connection.getPass());
this._parent = parent;
}
public void setDatabase() {
ConnectionManager.setCurrentDatabase("Ensembl", getActiveDB());
if (ConnectionManager.convertEnsemblDatabaseNameToSpeciesName(
ConnectionManager.getCurrentDatabaseByType("Ensembl")).equals(
"Caenorhabditis_elegans")) {
_parent.set_viewer_status(3, true, false);
} else
_parent.set_viewer_status(3, false, false);
}
protected void calledWhenValid() {
setDatabase();
_parent.set_gene_id(this.getGeneId());
_parent.set_enabled_finish_button(true);
_parent.set_enabled_next_button(true);
}
protected void calledWhenInvalid() {
_parent.set_gene_id(this.getGeneId());
_parent.set_enabled_finish_button(true);
_parent.set_enabled_next_button(true);
}
Component getDefaultComponent() {
return gene_input_tf;
}
}package ca.bcgsc.sockeye.gui.retrievaldialog;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;
import javax.swing.JButton;
import javax.swing.JFileChooser;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.filechooser.FileFilter;
import ca.bcgsc.sockeye.dataretrieval.FileDRU;
import ca.bcgsc.sockeye.gui.ExtensionFilter;
import ca.bcgsc.sockeye.parser.ParserManager;
public class ImportGFFPane extends JPanel {
private JButton openButton;
private JButton nextButton;
private JTextField gff_file_field = new JTextField(20);
private RetrievalWizard _parent = null;
public ImportGFFPane(RetrievalWizard parent) {
super(new BorderLayout());
this._parent = parent;
jbinit();
}
protected void jbinit() {
JPanel p = new JPanel(new GridBagLayout());
GridBagConstraints inner_c = new GridBagConstraints();
inner_c.gridx = 0;
inner_c.gridy = 0;
inner_c.gridwidth = 2;
inner_c.anchor = GridBagConstraints.NORTHWEST;
JLabel fileLabel = new JLabel(
"<HTML>2. Please enter a file name or browse.<br>To preview file contents before importing,<br>click Next.</HTML>");
p.add(fileLabel, inner_c);
inner_c.gridx = 0;
inner_c.gridy = 1;
inner_c.gridwidth = 1;
inner_c.fill = GridBagConstraints.HORIZONTAL;
inner_c.insets = new Insets(30, 0, 0, 0);
gff_file_field.setEditable(false);
p.add(gff_file_field, inner_c);
inner_c.gridx = 1;
inner_c.gridy = 1;
inner_c.insets = new Insets(30, 5, 0, 0);
inner_c.fill = GridBagConstraints.NONE;
inner_c.anchor = GridBagConstraints.EAST;
openButton = new JButton("...");
p.add(openButton, inner_c);
FileFilter[] filters = new FileFilter[] {
new ExtensionFilter("GFF File (*.gff)", new String[] { ".gff",
".GFF", ".Gff", ".gFF" }),
new ExtensionFilter("TFF File (*.tff)", new String[] { ".tff",
".TFF", ".Tff", ".tFF" }) };
for (int i = 0; i < filters.length; i++) {
_parent.getFileChooser().addChoosableFileFilter(filters[i]);
}
_parent.getFileChooser().setFileFilter(filters[0]);
openButton.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
try {
int returnVal = _parent.getFileChooser().showOpenDialog(
_parent);
if (returnVal == JFileChooser.APPROVE_OPTION) {
_parent.setGFFFile(_parent.getFileChooser()
.getSelectedFile());
File gffFile = _parent.getGFFFile();
if (ParserManager
.getClassNameForAnnotationExtension((gffFile
.getName().substring(gffFile.getName()
.length() - 3))) != null) {
_parent.setParser(FileDRU.getParser(_parent
.getGFFFile()));
_parent.getParser().validate();
_parent.getFilePreviewPanel().setFilePreviewTable(
_parent.getParser());
_parent.getGFFFileField()
.setText(gffFile.getName());
_parent.set_gff_text_field(gffFile.getName());
_parent.set_enabled_next_button(true);
_parent.set_enabled_finish_button(true);
_parent.set_enabled_pane(1, true);
_parent.set_enabled_pane(2, true);
return;
} else {
throw new Exception("File Does Not Exist");
}
}
_parent.setGFFFile(null);
_parent.getGFFFileField().setText("");
_parent.set_gff_text_field("");
_parent.getFilePreviewPanel().clearTable();
_parent.set_enabled_next_button(false);
_parent.set_enabled_finish_button(false);
_parent.set_enabled_pane(1, false);
_parent.set_enabled_pane(2, false);
} catch (Throwable t) {
JOptionPane.showMessageDialog(null, "Could not load file: "
+ _parent.getGFFFile().getName(), "Warning",
JOptionPane.ERROR_MESSAGE);
_parent.setGFFFile(null);
_parent.getGFFFileField().setText("");
_parent.set_gff_text_field("");
_parent.getFilePreviewPanel().clearTable();
_parent.set_enabled_finish_button(false);
}
}
});
add(p, BorderLayout.NORTH);
}
void setGffText(String input) {
gff_file_field.setText(input);
}
Component getBeforeComponent(Component current) {
if (current != openButton)
return openButton;
else
return null;
}
Component getNextComponent(Component current) {
if (current != openButton)
return openButton;
else
return null;
}
Component getLastComponent() {
return openButton;
}
}/*------
package ca.bcgsc.sockeye.gui.retrievaldialog;
import java.awt.BorderLayout;
import java.awt.CardLayout;
import java.awt.Component;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.FocusTraversalPolicy;
import java.awt.Frame;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.Reader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.DefaultListModel;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JDialog;
import javax.swing.JFileChooser;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTabbedPane;
import javax.swing.JTextField;
import javax.swing.ListSelectionModel;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.config.Connection;
import ca.bcgsc.sockeye.config.Service;
import ca.bcgsc.sockeye.dataretrieval.CisREDDataSource;
import ca.bcgsc.sockeye.dataretrieval.EnsemblDataSource;
import ca.bcgsc.sockeye.dataretrieval.FileDRU;
import ca.bcgsc.sockeye.dataretrieval.FileDataSource;
import ca.bcgsc.sockeye.datastorage.ChromosomeInfo;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.datastorage.SockeyeTrackList;
import ca.bcgsc.sockeye.datastorage.Track;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.datastorage.events.StorageEvent;
import ca.bcgsc.sockeye.gui.navigation.FeaturePanel;
import ca.bcgsc.sockeye.parser.Parser;
import ca.bcgsc.sockeye.parser.ParserManager;
import ca.bcgsc.sockeye.popup.BrowserLauncher;
import ca.bcgsc.sockeye.service.featureloader.common.ConnectionManager;
import ca.bcgsc.sockeye.service.featureloader.common.FeatureLoaderService;
import ca.bcgsc.sockeye.service.featureloader.common.FeatureLoaderServiceFactory;
import ca.bcgsc.sockeye.service.featureloader.common.GeneInfo;
import ca.bcgsc.sockeye.trackmanager.ImportGFFOperation;
import ca.bcgsc.sockeye.trackmanager.TrackManagerFactory;
import ca.bcgsc.sockeye.util.Log;
import ca.bcgsc.sockeye.util.ResourceLoader;
public class RetrievalWizard extends JDialog {
final static int _DEFAULT_START = 1;
final static int _DEFAULT_END = 100000;
final static int _DEFAULT_QUERY_ADDITION = 1000;
private JLabel __step1_label;
private JLabel __step2_0_label;
private JLabel __step2_1_label;
private JLabel __step3_label;
private JTabbedPane _tabbed_pane = new JTabbedPane();
private GridBagConstraints constraints = new GridBagConstraints();
private boolean _renew_connection = true;
private boolean _renew_version = true;
private boolean _renew_species = true;
private HashSet _ensembl_version = new HashSet();
private static Hashtable _species_db_core = new Hashtable();
private static Hashtable _server_db_core = new Hashtable();
private ButtonPane _button_pane;
private DatasourcePane _datasource_pane;
private SpeciesPane _species_pane;
private ViewerPane _viewer_pane;
private AdvanceGFFPanel _advance_gff_pane;
private int __start_pos = _DEFAULT_START;
private int __end_pos = _DEFAULT_END;
private String __selected_chromosome = "";
private String __selected_database = "";
private String __selected_specie = "";
private File _file = null;
private Parser _parser = null;
private CardLayout __cards = new CardLayout();
private JPanel __second_pane = new JPanel(__cards);
private JFileChooser _fc = new JFileChooser(Configuration.getGFFPath());
private SockeyeFilePreviewPanel _file_preview = new SockeyeFilePreviewPanel(
RetrievalWizard.this);
private JTextField _gff_file_field = new JTextField(30);
private Dimension _panel_size = new Dimension(280, 200);
static private long _last_click = 0L;
static private long _mouseDoubleClickThreshold = 700L;
public RetrievalWizard(Frame parent) {
super(parent, "Retrieve Data", true);
this.setResizable(false);
this.setDefaultCloseOperation(JDialog.HIDE_ON_CLOSE);
this.setSize(600, 400);
this.setLocationRelativeTo(null);
jbinit();
RetrievalWizard.this.getRootPane().setDefaultButton(
_button_pane.getFinishButton());
final CustomPolicy customPolicy = new CustomPolicy();
this.setFocusTraversalPolicy(customPolicy);
pack();
}
void jbinit() {
JPanel panel = new JPanel(new GridBagLayout());
panel.setBackground(Configuration.gui_blue);
__step1_label = new JLabel("Step 1 of 3: Select a data source");
__step2_0_label = new JLabel("Step 2 of 3: Select data set and species");
__step2_1_label = new JLabel("Step 2 of 3: Select a file");
__step3_label = new JLabel("Step 3 of 3: Select viewer");
__step2_0_label.setVisible(false);
__step2_1_label.setVisible(false);
__step3_label.setVisible(false);
constraints.gridx = 0;
constraints.gridy = 0;
constraints.gridheight = 1;
constraints.gridwidth = 1;
constraints.anchor = GridBagConstraints.NORTHWEST;
panel.add(__step1_label, constraints);
panel.add(__step2_0_label, constraints);
panel.add(__step2_1_label, constraints);
panel.add(__step3_label, constraints);
_button_pane = new ButtonPane();
_datasource_pane = new DatasourcePane(this);
_species_pane = new SpeciesPane(this);
_viewer_pane = new ViewerPane();
_advance_gff_pane = new AdvanceGFFPanel(this);
__second_pane.add(_species_pane, "species pane");
__second_pane.add(_advance_gff_pane, "gff pane");
_tabbed_pane.addTab("Data source", _datasource_pane);
_tabbed_pane.addTab("Data and species", __second_pane);
_tabbed_pane.addTab("Viewer", _viewer_pane);
_tabbed_pane.setSelectedIndex(0);
_tabbed_pane.setEnabledAt(1, false);
_tabbed_pane.setEnabledAt(2, false);
_tabbed_pane.addChangeListener(new ChangeListener() {
public void stateChanged(ChangeEvent e) {
tab_panel_changed(e);
}
});
constraints.gridx = 0;
constraints.gridy = 1;
constraints.anchor = GridBagConstraints.NORTHWEST;
constraints.fill = GridBagConstraints.BOTH;
panel.add(_tabbed_pane, constraints);
constraints.gridx = 0;
constraints.gridy = 2;
constraints.anchor = GridBagConstraints.SOUTH;
constraints.fill = GridBagConstraints.HORIZONTAL;
constraints.insets = new Insets(10, 0, 10, 0);
panel.add(_button_pane, constraints);
panel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
getContentPane().setBackground(Configuration.gui_blue);
getContentPane().setLayout(
new BoxLayout(this.getContentPane(), BoxLayout.X_AXIS));
getContentPane().add(panel);
}
void close() {
this.setVisible(false);
}
void update_species_pane() {
if (_datasource_pane.getSelectedIndex() == 0) {
_species_pane.setSpeciesPane(_datasource_pane.get_version_list());
_renew_version = false;
_renew_species = false;
}
}
void show_update() {
_file_preview.updateCombo();
}
int get_tabbed_index() {
return _tabbed_pane.getSelectedIndex();
}
void change_tab_title(int i, String text) {
_tabbed_pane.setTitleAt(i, text);
}
void set_gene_id(String gene_id) {
_species_pane.setGeneId(gene_id);
}
boolean finish_action() {
try {
if (_datasource_pane.getSelectedIndex() == 0) {
if (_species_pane.getCurrentSelection() == 2) {
if (_viewer_pane.getViewerSelected(4)) {
_species_pane.searchEnsemblWeb();
return true;
} else
return false;
} else if (_species_pane.getCurrentSelection() == 3) {
readListandQuery(_species_pane.getIdListFile());
return true;
} else if (_species_pane.updateVariables()) {
if (_viewer_pane.getViewerSelected(1))
startContigView(__start_pos, __end_pos,
__selected_chromosome);
if (_viewer_pane.getViewerSelected(2))
startMapView(__start_pos, __end_pos,
__selected_chromosome);
if (_viewer_pane.getViewerSelected(3))
startWormBase(__start_pos, __end_pos,
__selected_chromosome);
if (_viewer_pane.getViewerSelected(0))
start_query_track(__start_pos, __end_pos,
__selected_chromosome, __selected_database);
return true;
} else
return false;
} else if (_datasource_pane.getSelectedIndex() == 1) {
if (_viewer_pane.getViewerSelected(0))
return start_gff_import();
else
return true;
}
else
return false;
} catch (Throwable t) {
javax.swing.JOptionPane.showMessageDialog(RetrievalWizard.this,
"Query failed, please check data parameters", "Warning",
javax.swing.JOptionPane.WARNING_MESSAGE);
t.printStackTrace();
return false;
}
}
private void readListandQuery(File file) {
String filename = "";
ArrayList ensemblIDs = new ArrayList();
try {
Reader resourceReader = ResourceLoader.getReader(file
.getCanonicalPath());
if (resourceReader != null && resourceReader.ready()) {
BufferedReader reader = new BufferedReader(resourceReader);
String singleLine = reader.readLine();
while (singleLine != null) {
if (!(singleLine.equals(""))) {
String[] ids = singleLine.split("\\s+");
int length = ids.length;
for (int i = 0; i < ids.length; i++) {
ensemblIDs.add(ids[i]);
}
}
singleLine = reader.readLine();
}
}
} catch (IOException e) {
Log.printStackTrace(e);
}
DefaultListModel badIDListModel = new DefaultListModel();
for (Iterator it = ensemblIDs.iterator(); it.hasNext();) {
String ensemblID = (String) it.next();
String db = getDatabase(ensemblID);
if (db != null) {
ConnectionManager.setCurrentDatabase("Ensembl", db);
GeneInfo gInfo = getGeneInfo(ensemblID);
if (gInfo != null && gInfo.getChromosome() != null) {
start_query_track(gInfo.getStart(), gInfo.getEnd(), gInfo
.getChromosome(), ConnectionManager
.getCurrentDatabaseByType("Ensembl"));
} else {
badIDListModel.addElement(ensemblID);
}
} else {
badIDListModel.addElement(ensemblID);
}
}
if (badIDListModel.size() > 0) {
JList list = new JList(badIDListModel);
list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
list.setSelectedIndex(0);
list.setVisibleRowCount(5);
final JDialog dialog = new JDialog(this, "Bad Ensembl ID List",
true) {
public void dispose() {
super.dispose();
}
};
JLabel label = new JLabel(
"<HTML>These are the ensembl IDs <br>that did not queried:</HTML>");
JScrollPane listScrollPane = new JScrollPane(list,
JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,
JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
listScrollPane.setPreferredSize(new Dimension(200, 100));
JButton ok_button = new JButton("OK");
ok_button.addMouseListener(new java.awt.event.MouseAdapter() {
public void mouseClicked(java.awt.event.MouseEvent e) {
dialog.hide();
}
public void mouseEntered(java.awt.event.MouseEvent e) {
}
public void mouseExited(java.awt.event.MouseEvent e) {
}
});
JPanel panel = new JPanel(new FlowLayout(FlowLayout.CENTER, 20, 10));
panel.setBackground(Configuration.gui_blue);
panel.add(label);
panel.add(listScrollPane);
panel.add(ok_button);
dialog.getContentPane().add(panel);
dialog.setSize(250, 220);
dialog.setLocation(300, 300);
dialog.show();
}
}
private String getDatabase(String ensemblID) {
Hashtable ensemb_map = new Hashtable();
ensemb_map.put("MUS", "mus");
ensemb_map.put("RNO", "rattus");
ensemb_map.put("CBR", "caenorhabditis_briggsae");
ensemb_map.put("ANG", "anopheles");
ensemb_map.put("DAR", "danio");
ensemb_map.put("PTR", "pan");
ensemb_map.put("GAL", "gal");
Pattern ensembl_pat = Pattern.compile("ENS(\\p{Alpha}{0,3})G\\d*",
Pattern.CASE_INSENSITIVE);
Pattern c_eleg_pat = Pattern.compile("\\S{3,}\\S+",
Pattern.CASE_INSENSITIVE);
Pattern drosoph_pat = Pattern.compile("CG\\d*",
Pattern.CASE_INSENSITIVE);
Pattern fugu_pat = Pattern.compile("SI\\w*", Pattern.CASE_INSENSITIVE);
String species = null;
Matcher m = ensembl_pat.matcher(ensemblID);
if (m.matches()) {
String spec = (String) ensemb_map.get(m.group(1).toUpperCase());
if (spec != null || m.group(1).length() == 0)
species = m.group(1).length() == 0 ? "homo" : spec;
}
m = drosoph_pat.matcher(ensemblID);
if (m.matches()) {
species = "drosophila";
}
m = fugu_pat.matcher(ensemblID);
if (m.matches()) {
species = "fugu";
}
m = c_eleg_pat.matcher(ensemblID);
if (m.matches() && !ensemblID.toUpperCase().startsWith("ENS")) {
species = "caenorhabditis_elegans";
}
if (species == null) {
return null;
}
String database = null;
return database;
}
private GeneInfo getGeneInfo(String ensemblID) {
try {
Connection curr_conn = ConnectionManager
.getCurrentConnection("Ensembl");
FeatureLoaderServiceFactory fac = FeatureLoaderServiceFactory
.getInstance();
Service service = Configuration
.getService(FeatureLoaderServiceFactory.FEATURELOADER_SERVICES);
String mode = null;
String remotehost = null;
if (service != null) {
mode = service.getMode();
remotehost = service.getRemotehost();
} else {
throw new RuntimeException(
"Feature loader service not set up properly.");
}
FeatureLoaderService ser = fac.getService(mode, remotehost);
GeneInfo gInfo = ser.getGeneInfo(curr_conn, ConnectionManager
.getCurrentDatabaseByType("Ensembl"), ensemblID);
int offset_5_prime = _DEFAULT_QUERY_ADDITION;
try {
offset_5_prime = Integer.parseInt(_species_pane.getPlus5Text()
.getValue());
} catch (Exception nexp) {
JOptionPane.showMessageDialog(null,
"5 prime offset invalid \n set to Default: "
+ String.valueOf(_DEFAULT_QUERY_ADDITION)
+ "\n" + nexp.getMessage(), "Warning",
JOptionPane.WARNING_MESSAGE);
}
int offset_3_prime = _DEFAULT_QUERY_ADDITION;
try {
offset_3_prime = Integer.parseInt(_species_pane.getPlus3Text()
.getValue());
} catch (Exception nexp) {
JOptionPane.showMessageDialog(null,
"3 prime offset invalid \n set to Default: "
+ String.valueOf(_DEFAULT_QUERY_ADDITION)
+ "\n" + nexp.getMessage(), "Warning",
JOptionPane.WARNING_MESSAGE);
}
int start;
int end;
if (gInfo.getStrand() == -1) {
start = gInfo.getStart() - offset_3_prime;
if (start <= 0) {
start = 1;
} else {
gInfo.setStart(start);
}
gInfo.setEnd(gInfo.getEnd() + offset_5_prime);
} else {
start = gInfo.getStart() - offset_5_prime;
if (start <= 0) {
gInfo.setStart(1);
} else {
gInfo.setStart(start);
}
gInfo.setEnd(gInfo.getEnd() + offset_3_prime);
}
return gInfo;
} catch (Exception ex) {
JOptionPane.showMessageDialog(null, ex.getMessage(), "Warning",
JOptionPane.WARNING_MESSAGE);
return null;
}
}
public void start_query_track(int start, int end, String chromosome,
String database) {
Date date = new Date();
int max_track_length = ChromosomeInfo.getChromosomeLength(database,
chromosome);
String display_name = ConnectionManager
.convertEnsemblDatabaseToShortSpeciesName(database)
+ " v"
+ ConnectionManager.getEnsemblVersionForDatabase(database);
String track_name = Track.computeTrackName(start, end, chromosome,
date, display_name);
Track t = new Track(start, end);
t.setAttribute(Track.TRACK_NAME_ATTRIBUTE_KEY, track_name);
t.setAttribute("track_max_length", new Integer(max_track_length));
int t_id = DataStoreUser.getInstance().getSockeyeTrackList()
.addTrack(t);
TrackManagerFactory.getInstance().addTrackToRoot(t_id);
String databaseVersion = CisREDDataSource.getInfoFromDatabaseName(
database, "version");
String databaseSpecies = CisREDDataSource.getInfoFromDatabaseName(
database, "species");
List connectionList = ConnectionManager.getCisRedConnections();
if ((connectionList == null) || (connectionList.isEmpty())) {
System.err
.println("CisRED Connection is not set in user_config.xml or it's not supported for species "
+ databaseSpecies);
} else {
for (Iterator itr = connectionList.iterator(); itr.hasNext();) {
Connection cisREDconn = (Connection) itr.next();
String cisredVersion = CisREDDataSource
.getInfoFromDatabaseName(cisREDconn.getSubtype(),
"version");
if (cisredVersion.equals(databaseVersion)) {
CisREDDataSource cis_red_src = new CisREDDataSource(t_id,
chromosome, cisREDconn, databaseSpecies);
DataStoreUser.getInstance().getSockeyeTrackList()
.addStorageListener(cis_red_src);
int cis_red_ds_id = DataStoreUser.getInstance()
.getDataSourceManager().addDataSource(cis_red_src);
DataStoreUser.getInstance().getSockeyeTrackList()
.addDataSourceId(t_id, cis_red_ds_id);
}
}
}
EnsemblDataSource src = new EnsemblDataSource(t_id, database,
chromosome);
src.setConnection(ConnectionManager.getCurrentConnection("Ensembl"));
DataStoreUser.getInstance().getSockeyeTrackList().addStorageListener(
src);
int ds_id = DataStoreUser.getInstance().getDataSourceManager()
.addDataSource(src);
DataStoreUser.getInstance().getSockeyeTrackList().addDataSourceId(t_id,
ds_id);
DataStoreUser.getInstance().getSockeyeTrackList().setFeatureVisibility(
FeaturePanel.getAllSelectedFeatures(), true);
_file_preview.updateCombo();
}
boolean start_gff_import() {
try {
if (ParserManager.getClassNameForAnnotationExtension((_file
.getName().substring(_file.getName().length() - 3))) != null) {
_parser = FileDRU.getParser(_file);
try {
_parser.validate();
} catch (Exception fe) {
fe.printStackTrace();
}
Iterator seqit = _parser.getSequenceNames().iterator();
while (seqit.hasNext()) {
String seq_id = seqit.next().toString();
Object importObject = _file_preview.filePreviewTableValue(
seq_id, SockeyeFilePreviewPanel.IMPORT);
if (importObject != null && importObject instanceof Boolean
&& !((Boolean) importObject).booleanValue())
continue;
Object offsetObject = _file_preview.filePreviewTableValue(
seq_id, SockeyeFilePreviewPanel.OFFSET);
int offset = 0;
if (offsetObject != null) {
try {
offset = Integer.parseInt(offsetObject.toString());
} catch (RuntimeException e) {
e.printStackTrace();
}
}
String gff_track_name = _parser
.getDisplaySequenceName(seq_id);
int t_id = -1;
int start = 0;
Object track_startObject = _file_preview
.filePreviewTableValue(seq_id,
SockeyeFilePreviewPanel.TRACK_START);
if (track_startObject != null)
start = Integer.parseInt(track_startObject.toString());
int end = 0;
Object track_endObject = _file_preview
.filePreviewTableValue(seq_id,
SockeyeFilePreviewPanel.TRACK_END);
if (track_endObject != null)
end = Integer.parseInt(track_endObject.toString());
List tracks = _parser.getFeatures(seq_id, "track");
String track_name = "";
if (tracks != null && tracks.size() > 0) {
TrackFeature track = (TrackFeature) tracks.get(0);
start = track.getStart();
end = track.getEnd();
track_name = track.getSeqName();
}
if ((start + offset) < 1) {
JOptionPane.showMessageDialog(null,
"Start coordinates can not be less than one\n"
+ "Please modify your offset value");
return false;
}
String track_selected = FileDataSource.__NEW_TRACK;
Object track_selectedObject = _file_preview
.filePreviewTableValue(seq_id,
SockeyeFilePreviewPanel.TRACK);
if (track_selectedObject != null)
track_selected = track_selectedObject.toString();
if (track_selected.equals(FileDataSource.__NEW_TRACK)) {
start += offset;
end += offset;
Track t = new Track(start, end);
t.setAttribute(Track.TRACK_NAME_ATTRIBUTE_KEY,
(track_name.equals("")) ? _parser
.getDisplaySequenceName(seq_id)
: track_name);
t_id = DataStoreUser.getInstance()
.getSockeyeTrackList().addTrack(t);
}
else {
int targ_track = Integer.valueOf(
track_selected.split(":")[0]).intValue();
int trk_start = DataStoreUser.getInstance()
.getSockeyeTrackList().getTrackDataStart(
targ_track);
int trk_end = DataStoreUser.getInstance()
.getSockeyeTrackList().getTrackDataEnd(
targ_track);
if (trk_start > (start + offset)
|| trk_end < (end + offset)) {
int result = JOptionPane
.showOptionDialog(
getParent(),
"Some features to be imported from file are outside\n"
+ "the range of the target track.\n"
+ "Do you want to zoom out track to display all imported features?",
"Features out of range",
JOptionPane.YES_NO_CANCEL_OPTION,
JOptionPane.QUESTION_MESSAGE, null,
null, null);
switch (result) {
case JOptionPane.YES_OPTION:
t_id = targ_track;
int zoomStart = ((trk_start < (start + offset)) ? trk_start
: (start + offset));
int zoomEnd = ((trk_end > (end + offset)) ? trk_end
: (end + offset));
DataStoreUser.getInstance()
.getSockeyeTrackList()
.setTrackDataWindow(targ_track,
zoomStart, zoomEnd);
break;
case JOptionPane.NO_OPTION:
t_id = targ_track;
break;
case JOptionPane.CANCEL_OPTION:
return false;
}
} else
t_id = targ_track;
}
if (t_id == -1) {
throw new Exception("Unkown track id to import gff");
}
_parser.setFeatureNamesToImport(seq_id, _file_preview
.featureNamesToImport(seq_id));
FileDataSource src = new FileDataSource(t_id, _parser,
seq_id, offset);
boolean as_dist = false;
Object as_distObject = _file_preview.filePreviewTableValue(
seq_id, SockeyeFilePreviewPanel.AS_DIST);
if (as_distObject != null
&& as_distObject instanceof Boolean) {
as_dist = ((Boolean) as_distObject).booleanValue();
}
src.setLoadAsDistribution(as_dist);
DataStoreUser.getInstance().getSockeyeTrackList()
.addStorageListener(src);
int ds_id = DataStoreUser.getInstance()
.getDataSourceManager().addDataSource(src);
DataStoreUser.getInstance().getDataSourceManager()
.setSingleShotSource(ds_id, true);
DataStoreUser.getInstance().getSockeyeTrackList()
.addDataSourceId(t_id, ds_id);
ImportGFFOperation importGFFoper = new ImportGFFOperation(
gff_track_name);
TrackManagerFactory.getInstance().addOperation(
importGFFoper, null);
TrackManagerFactory.getInstance().addTrack(importGFFoper,
t_id);
List list = Arrays.asList(_parser.getFeatureNames(seq_id)
.toArray());
List event_attrib = new ArrayList();
event_attrib.add(new Integer(t_id));
event_attrib.add(new Integer(DataStoreUser.getInstance()
.getSockeyeTrackList().getTrackDataStart(t_id)));
event_attrib.add(new Integer(DataStoreUser.getInstance()
.getSockeyeTrackList().getTrackDataEnd(t_id)));
event_attrib.addAll(list);
((SockeyeTrackList) DataStoreUser.getInstance()
.getSockeyeTrackList()).triggerEvent(
StorageEvent.STORAGE_EVENT_TRACK_DATA_REQUEST,
event_attrib);
_file_preview.updateCombo();
}
return true;
} else {
JOptionPane.showMessageDialog(getParent(),
"Sockeye has no registered parser for "
+ (_file.getName().substring(_file.getName()
.length() - 4))
+ "\n Try another file extension (ie. gff)",
"Invalid Filename", JOptionPane.ERROR_MESSAGE);
return false;
}
} catch (Exception ex) {
Log.printStackTrace(ex);
ex.printStackTrace();
JOptionPane.showMessageDialog(getParent(), "Open GFF File Error");
return false;
}
}
void startContigView(int start, int end, String chromosome) {
String url = (String) Configuration.getPopupConfiguration().get(
"ContigView");
String species = ConnectionManager
.convertEnsemblDatabaseNameToSpeciesName(ConnectionManager
.getCurrentDatabaseByType("Ensembl"));
try {
url = url.replaceAll("CHR", chromosome).replaceAll("SPECIES",
species).replaceAll("START", String.valueOf(start))
.replaceAll("END", String.valueOf(end));
BrowserLauncher.openURL(url);
} catch (Exception ee) {
Log.printStackTrace(ee);
JOptionPane.showMessageDialog(null, "Cannot open Web browser.",
"Warning", JOptionPane.WARNING_MESSAGE);
}
}
void startMapView(int start, int end, String chromosome) {
String species = ConnectionManager
.convertEnsemblDatabaseNameToSpeciesName(ConnectionManager
.getCurrentDatabaseByType("Ensembl"));
String url = (String) Configuration.getPopupConfiguration().get(
new String(species + "_MapView"));
if (url == null) {
JOptionPane.showMessageDialog(null, species
+ " is not defined in MapView", "Warning",
JOptionPane.WARNING_MESSAGE);
return;
}
try {
url = url.replaceAll("chr", chromosome).replaceAll("start",
String.valueOf(start)).replaceAll("end",
String.valueOf(end));
BrowserLauncher.openURL(url);
} catch (Exception ee) {
ee.printStackTrace();
JOptionPane.showMessageDialog(null, "Cannot open Web Browser.",
"Warning", JOptionPane.WARNING_MESSAGE);
}
}
void startWormBase(int start, int end, String chromosome) {
String url = (String) Configuration.getPopupConfiguration().get(
"WormBaseDasView");
try {
url = url.replaceAll("CHR", chromosome).replaceAll("START",
String.valueOf(start)).replaceAll("END",
String.valueOf(end));
BrowserLauncher.openURL(url);
} catch (Exception ee) {
Log.printStackTrace(ee);
JOptionPane.showMessageDialog(null, "Cannot open Web Browser.",
"Warning", JOptionPane.WARNING_MESSAGE);
}
}
void set_viewer_status(int index, boolean enabled, boolean selected) {
_viewer_pane.setViewerStatus(index, enabled, selected);
}
void set_enabled_finish_button(boolean cond) {
_button_pane.setEnabledFinishButton(cond);
}
void set_enabled_next_button(boolean cond) {
_button_pane.setEnabledNextButton(cond);
}
void set_enabled_pane(int index, boolean cond) {
_tabbed_pane.setEnabledAt(index, cond);
}
void set_gff_text_field(String text) {
_datasource_pane.setGFFText(text);
}
void tab_panel_changed(ChangeEvent e) {
int index = _tabbed_pane.getSelectedIndex();
if (index == 0) {
__step1_label.setVisible(true);
__step2_0_label.setVisible(false);
__step2_1_label.setVisible(false);
__step3_label.setVisible(false);
if (_datasource_pane.getSelectedIndex() == 0) {
if (_renew_connection) {
set_enabled_next_button(false);
set_enabled_pane(1, false);
set_enabled_pane(2, false);
} else {
set_enabled_next_button(true);
set_enabled_pane(1, true);
set_enabled_pane(2, true);
}
} else if (_datasource_pane.getSelectedIndex() == 1) {
set_enabled_next_button(true);
if (_file == null)
set_enabled_finish_button(false);
else
set_enabled_finish_button(true);
} else if (_datasource_pane.getSelectedIndex() == 2) {
set_enabled_next_button(false);
set_enabled_finish_button(false);
set_enabled_pane(0, false);
set_enabled_pane(1, false);
set_enabled_pane(2, false);
} else {
set_enabled_next_button(false);
set_enabled_finish_button(false);
set_enabled_pane(1, false);
set_enabled_pane(2, false);
}
}
else if (index == 1) {
if (_datasource_pane.getSelectedIndex() == 0) {
set_enabled_finish_button(true);
if (_renew_connection || _renew_species)
update_species_pane();
}
set_enabled_pane(2, true);
set_enabled_next_button(true);
__step1_label.setVisible(false);
__step3_label.setVisible(false);
if (_datasource_pane.getSelectedIndex() == 0) {
__step2_0_label.setVisible(true);
} else
__step2_1_label.setVisible(true);
}
else if (index == 2) {
if (_datasource_pane.getSelectedIndex() == 0) {
set_enabled_finish_button(true);
}
set_enabled_next_button(false);
__step1_label.setVisible(false);
__step2_0_label.setVisible(false);
__step2_1_label.setVisible(false);
__step3_label.setVisible(true);
} else {
__step1_label.setVisible(false);
__step2_0_label.setVisible(false);
__step2_1_label.setVisible(false);
set_enabled_pane(0, false);
set_enabled_pane(1, false);
set_enabled_pane(2, false);
}
}
JFileChooser getFileChooser() {
return _fc;
}
SockeyeFilePreviewPanel getFilePreviewPanel() {
return _file_preview;
}
File getGFFFile() {
return _file;
}
void setGFFFile(File file) {
this._file = file;
}
boolean getRenewConnection() {
return _renew_connection;
}
void setRenewConnection(boolean renew) {
_renew_connection = renew;
}
boolean getRenewSpecies() {
return _renew_species;
}
void setRenewSpecies(boolean renew) {
_renew_species = renew;
}
boolean getRenewVersion() {
return _renew_version;
}
void setRenewVersion(boolean renew) {
_renew_version = renew;
}
void setSelectedDatabase(String selected) {
__selected_database = selected;
}
JTextField getGFFFileField() {
return _gff_file_field;
}
Parser getParser() {
return _parser;
}
void setParser(Parser parser) {
this._parser = parser;
}
void showSecondPane(String title) {
__cards.show(__second_pane, title);
}
String getDatabaseFromSpecies(String species) {
return (String) _species_db_core.get(species);
}
Object[] getAllSpeciesInDatabase() {
return _species_db_core.keySet().toArray();
}
void putServerDatabase(String server, Object[] database) {
_server_db_core.put(server, database);
}
void putSpeciesDatabase(String species, String database) {
_species_db_core.put(species, database);
}
Object[] getDatabaseFromServer(String server) {
return (Object[]) _server_db_core.get(server);
}
Object[] getServerMapKeys() {
return _server_db_core.keySet().toArray();
}
void clearServerDatabaseMap() {
_server_db_core.clear();
}
String getSelectedSpecies() {
return __selected_specie;
}
void setSelectedSpecies(String species) {
__selected_specie = species;
}
String getSelecteChromosome() {
return __selected_chromosome;
}
void setSelectedChromosome(String chromosome) {
__selected_chromosome = chromosome;
}
public HashSet getEnsemblVersion() {
return _ensembl_version;
}
public void addEnsemblVersion(String version) {
this._ensembl_version.add(version);
}
public int getEndPos() {
return __end_pos;
}
public void setEndPos(int __end_pos) {
this.__end_pos = __end_pos;
}
public int getStartPos() {
return __start_pos;
}
public void setStartPos(int __start_pos) {
this.__start_pos = __start_pos;
}
class CustomPolicy extends FocusTraversalPolicy {
public Component getDefaultComponent(Container focusCycleRoot) {
if (get_tabbed_index() == 0)
return _datasource_pane.getDefaultComponent();
else if (get_tabbed_index() == 1)
if (_datasource_pane.getSelectedIndex() == 0)
return _species_pane.getDefaultComponent();
else
return _advance_gff_pane.getDefaultComponent();
else if (get_tabbed_index() == 2)
return _viewer_pane.getDefaultComponent();
return null;
}
public Component getLastDefaultComponent(Container focussycleRoot) {
if (get_tabbed_index() == 0)
return _datasource_pane.getLastDefaultComponent();
else if (get_tabbed_index() == 1)
if (_datasource_pane.getSelectedIndex() == 0)
return _species_pane.getLastDefaultComponent();
else
return _advance_gff_pane.getLastDefaultComponent();
else if (get_tabbed_index() == 2)
return _viewer_pane.getLastDefaultComponent();
return null;
}
public Component getFirstComponent(Container focusCycleRoot) {
if (get_tabbed_index() == 0)
return _datasource_pane.getDefaultComponent();
else if (get_tabbed_index() == 1)
return _species_pane.getDefaultComponent();
else if (get_tabbed_index() == 2)
return _viewer_pane.getDefaultComponent();
return null;
}
public Component getLastComponent(Container focusCycleRoot) {
return null;
}
public Component getComponentBefore(Container focusCycleRoot,
Component aComponent) {
Component before = null;
if (_button_pane.isComponent(aComponent))
before = _button_pane.getBeforeComponent(aComponent);
if (before == null) {
if (get_tabbed_index() == 0)
before = _datasource_pane.getBeforeComponent(aComponent);
else if (get_tabbed_index() == 1)
if (_datasource_pane.getSelectedIndex() == 0)
before = _species_pane.getBeforeComponent(aComponent);
else
before = _advance_gff_pane
.getBeforeComponent(aComponent);
else if (get_tabbed_index() == 2)
before = _viewer_pane.getBeforeComponent(aComponent);
}
if (before == null)
before = getDefaultComponent(focusCycleRoot);
return before;
}
public Component getComponentAfter(Container focusCycleRoot,
Component aComponent) {
Component next = null;
if (aComponent == _tabbed_pane)
return getDefaultComponent(focusCycleRoot);
if (!_button_pane.isComponent(aComponent)) {
if (get_tabbed_index() == 0)
next = _datasource_pane.getNextComponent(aComponent);
else if (get_tabbed_index() == 1)
if (_datasource_pane.getSelectedIndex() == 0)
next = _species_pane.getNextComponent(aComponent);
else
next = _advance_gff_pane.getNextComponent(aComponent);
else if (get_tabbed_index() == 2)
next = _viewer_pane.getNextComponent(aComponent);
}
if (next == null)
next = _button_pane.getNextComponent(aComponent);
if (next == null)
next = getDefaultComponent(focusCycleRoot);
return next;
}
}
class ButtonPane extends JPanel {
private JButton nextButton;
private JButton cancelButton;
private JButton finishButton;
private JCheckBox finishBox = new JCheckBox("Close dialog after Finish");
public ButtonPane() {
super(new BorderLayout());
jbinit();
}
void jbinit() {
this.setBackground(Configuration.gui_blue);
finishBox.setBackground(Configuration.gui_blue);
finishBox.setSelected(true);
finishButton = new JButton("Finish");
finishButton.setEnabled(false);
finishButton.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
long click_time = e.getWhen();
if ((click_time - _last_click) < _mouseDoubleClickThreshold) {
return;
}
_last_click = click_time;
if (finish_action() && finishBox.isSelected()) {
close();
} else {
}
}
});
nextButton = new JButton("Next");
nextButton.setEnabled(false);
nextButton.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
if (get_tabbed_index() == 0) {
__step1_label.setVisible(false);
if (_datasource_pane.getSelectedIndex() == 0) {
if (_renew_connection || _renew_species)
update_species_pane();
_renew_connection = false;
_renew_species = false;
__step2_0_label.setVisible(true);
finishButton.setEnabled(true);
}
else if (_datasource_pane.getSelectedIndex() == 1) {
if (_file == null) {
finishButton.setEnabled(false);
nextButton.setEnabled(false);
}
_parser = FileDRU.getParser(_file);
try {
_parser.validate();
} catch (Exception e1) {
e1.printStackTrace();
}
_file_preview.setFilePreviewTable(_parser);
__step2_1_label.setVisible(true);
}
__step3_label.setVisible(false);
_tabbed_pane.setEnabledAt(1, true);
_tabbed_pane.setEnabledAt(2, true);
_tabbed_pane.setSelectedIndex(1);
} else if (get_tabbed_index() == 1) {
__step1_label.setVisible(false);
__step2_0_label.setVisible(false);
__step2_1_label.setVisible(false);
__step3_label.setVisible(true);
_tabbed_pane.setEnabledAt(2, true);
_tabbed_pane.setSelectedIndex(2);
nextButton.setEnabled(false);
}
}
});
cancelButton = new JButton("Cancel");
cancelButton.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
close();
}
});
Container buttonPanel = Box.createHorizontalBox();
buttonPanel.add(finishBox);
buttonPanel.add(Box.createHorizontalGlue());
buttonPanel.add(finishButton);
buttonPanel.add(Box.createHorizontalStrut(5));
buttonPanel.add(nextButton);
buttonPanel.add(Box.createHorizontalStrut(5));
buttonPanel.add(cancelButton);
add(buttonPanel);
}
void setEnabledNextButton(boolean cond) {
nextButton.setEnabled(cond);
}
void setEnabledFinishButton(boolean cond) {
finishButton.setEnabled(cond);
}
void setSelectedFinishBox(boolean cond) {
finishBox.setSelected(cond);
}
JButton getNextButton() {
return nextButton;
}
JButton getFinishButton() {
return finishButton;
}
Component getBeforeComponent(Component current) {
boolean closest = false;
if ((current != finishBox) && (current != finishButton)
&& (current != nextButton) && (current != cancelButton))
return cancelButton;
if ((current == cancelButton) || closest)
if (nextButton.isEnabled())
return nextButton;
else
closest = true;
if (current == nextButton || closest)
if (finishButton.isEnabled())
return finishButton;
else
closest = true;
if (current == finishButton || closest)
if (finishBox.isEnabled())
return finishBox;
else
closest = true;
if (current == finishBox || closest)
return null;
return null;
}
Component getNextComponent(Component current) {
boolean closest = false;
if ((current != finishBox) && (current != finishButton)
&& (current != nextButton) && (current != cancelButton))
return finishBox;
if ((current == finishBox) || closest)
if (finishButton.isEnabled())
return finishButton;
else
closest = true;
if (current == finishButton || closest)
if (nextButton.isEnabled())
return nextButton;
else
closest = true;
if (current == nextButton || closest)
if (cancelButton.isEnabled())
return cancelButton;
else
closest = true;
if (current == cancelButton || closest)
return null;
return null;
}
boolean isComponent(Component current) {
return ((current == finishBox) || (current == finishButton)
|| (current == nextButton) || (current == cancelButton));
}
}
}package ca.bcgsc.sockeye.gui.retrievaldialog;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;
import javax.swing.JButton;
import javax.swing.JFileChooser;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JTextField;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.util.gui.scomponents.SockeyeTextField;
public class SearchEnsemblIdListPane extends JPanel {
private JButton openButton;
private RetrievalWizard _parent;
private File _idList_file = null;
private JTextField _idList_file_field = new JTextField(20);
private SockeyeTextField _idList_plus5Text = new SockeyeTextField();
private SockeyeTextField _idList_plus3Text = new SockeyeTextField();
private static JFileChooser _ids_file_chooser = new JFileChooser(
Configuration.getSessionPath());
public SearchEnsemblIdListPane(RetrievalWizard parent) {
super(new BorderLayout());
_parent = parent;
jbinit();
}
protected void jbinit() {
Dimension gridSize = new Dimension(150, 25);
JPanel p = new JPanel(new GridBagLayout());
GridBagConstraints inner_c = new GridBagConstraints();
inner_c.gridx = 0;
inner_c.gridy = 0;
inner_c.gridwidth = 2;
inner_c.anchor = GridBagConstraints.NORTHWEST;
JLabel fileLabel = new JLabel(
"<HTML>2. Please enter a file name or browse.<br>The file should contain Ensembl IDs <br>(space/line separated).</HTML>");
p.add(fileLabel, inner_c);
inner_c.gridx = 0;
inner_c.gridy = 1;
inner_c.gridwidth = 2;
inner_c.fill = GridBagConstraints.HORIZONTAL;
inner_c.insets = new Insets(30, 0, 0, 0);
_idList_file_field.setEditable(false);
p.add(_idList_file_field, inner_c);
inner_c.gridx = 2;
inner_c.gridy = 1;
inner_c.insets = new Insets(30, 5, 0, 0);
inner_c.fill = GridBagConstraints.NONE;
inner_c.anchor = GridBagConstraints.EAST;
openButton = new JButton("...");
p.add(openButton, inner_c);
JLabel plus5Label = new JLabel("Plus 5'");
_idList_plus5Text.setPreferredSize(gridSize);
_idList_plus5Text.setText("1000");
inner_c.gridx = 0;
inner_c.gridy = 3;
inner_c.gridwidth = 1;
inner_c.gridheight = 1;
inner_c.insets = new Insets(10, 0, 0, 0);
inner_c.fill = GridBagConstraints.NONE;
inner_c.anchor = GridBagConstraints.WEST;
p.add(plus5Label, inner_c);
inner_c.gridx = 1;
inner_c.gridy = 3;
inner_c.gridwidth = 1;
inner_c.gridheight = 1;
inner_c.insets = new Insets(10, 5, 0, 0);
inner_c.fill = GridBagConstraints.NONE;
inner_c.anchor = GridBagConstraints.WEST;
p.add(_idList_plus5Text, inner_c);
JLabel plus3Label = new JLabel("Plus 3'");
_idList_plus3Text.setPreferredSize(gridSize);
_idList_plus3Text.setText("1000");
inner_c.gridx = 0;
inner_c.gridy = 4;
inner_c.gridwidth = 1;
inner_c.gridheight = 1;
inner_c.insets = new Insets(10, 0, 0, 0);
inner_c.fill = GridBagConstraints.NONE;
inner_c.anchor = GridBagConstraints.EAST;
p.add(plus3Label, inner_c);
inner_c.gridx = 1;
inner_c.gridy = 4;
inner_c.gridwidth = 1;
inner_c.gridheight = 1;
inner_c.insets = new Insets(10, 5, 0, 0);
inner_c.fill = GridBagConstraints.NONE;
inner_c.anchor = GridBagConstraints.WEST;
p.add(_idList_plus3Text, inner_c);
openButton.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
try {
int returnVal = _ids_file_chooser.showOpenDialog(_parent);
if (returnVal == JFileChooser.APPROVE_OPTION) {
_idList_file = _ids_file_chooser.getSelectedFile();
_idList_file_field.setText(_idList_file.getName());
_parent.set_enabled_next_button(true);
_parent.set_enabled_finish_button(true);
_parent.set_enabled_pane(1, true);
_parent.set_enabled_pane(2, true);
}
} catch (Throwable t) {
t.printStackTrace();
JOptionPane.showMessageDialog(null, "Could not load file: "
+ _idList_file.getName(), "Warning",
JOptionPane.ERROR_MESSAGE);
_idList_file = null;
_parent.set_enabled_finish_button(false);
}
}
});
add(p, BorderLayout.NORTH);
}
public File getIdListFile() {
return _idList_file;
}
public SockeyeTextField getPlus3Text() {
return _idList_plus3Text;
}
public SockeyeTextField getPlus5Text() {
return _idList_plus5Text;
}
}package ca.bcgsc.sockeye.gui.retrievaldialog;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.config.Connection;
import ca.bcgsc.sockeye.config.Service;
import ca.bcgsc.sockeye.service.featureloader.common.ConnectionManager;
import ca.bcgsc.sockeye.service.featureloader.common.FeatureLoaderService;
import ca.bcgsc.sockeye.service.featureloader.common.FeatureLoaderServiceFactory;
import ca.bcgsc.sockeye.service.featureloader.common.GeneInfo;
import ca.bcgsc.util.gui.scomponents.SockeyeTextField;
public class SearchEnsemblIdPane extends JPanel {
private SockeyeTextField plus5Text = new SockeyeTextField();
private SockeyeTextField plus3Text = new SockeyeTextField();
private JComboBox versionCombo = new JComboBox();
private String selected_version = "";
private String selected_specie = "";
private String selected_database = "";
private String gene_name = "";
private GeneIdListenerPane idListenerPane = null;
private RetrievalWizard _parent;
public SearchEnsemblIdPane(RetrievalWizard parent) {
super(new BorderLayout());
this._parent = parent;
idListenerPane = new GeneIdListenerPane(parent, ConnectionManager
.getCurrentConnection("Ensembl"));
jbinit();
}
void jbinit() {
JPanel p = new JPanel(new GridBagLayout());
GridBagConstraints c = new GridBagConstraints();
Dimension gridSize = new Dimension(150, 25);
JLabel title = new JLabel(
"2. Please enter stable gene id (eg, B0513.6)");
c.gridx = 0;
c.gridy = 0;
c.gridwidth = 2;
c.gridheight = 1;
c.insets = new Insets(0, 0, 0, 0);
c.anchor = GridBagConstraints.NORTHWEST;
p.add(title, c);
c.gridx = 0;
c.gridy = 1;
c.gridwidth = 2;
c.gridheight = 2;
c.insets = new Insets(7, 0, 0, 0);
c.fill = GridBagConstraints.BOTH;
c.anchor = GridBagConstraints.NORTHWEST;
idListenerPane.setPreferredSize(new Dimension(280, 100));
p.add(idListenerPane, c);
JLabel versionLabel = new JLabel("EnsEMBL Version");
versionCombo.setPreferredSize(gridSize);
versionCombo.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
versionComboActionPerformed();
}
});
c.gridx = 0;
c.gridy = 3;
c.gridwidth = 1;
c.gridheight = 1;
c.insets = new Insets(10, 0, 0, 0);
c.fill = GridBagConstraints.NONE;
c.anchor = GridBagConstraints.EAST;
p.add(versionLabel, c);
c.gridx = 1;
c.gridy = 3;
c.gridwidth = 1;
c.gridheight = 1;
c.insets = new Insets(10, 5, 0, 0);
c.fill = GridBagConstraints.NONE;
c.anchor = GridBagConstraints.WEST;
p.add(versionCombo, c);
JLabel plus5Label = new JLabel("Plus 5'");
plus5Text.setPreferredSize(gridSize);
plus5Text.setText("1000");
c.gridx = 0;
c.gridy = 4;
c.gridwidth = 1;
c.gridheight = 1;
c.insets = new Insets(10, 0, 0, 0);
c.fill = GridBagConstraints.NONE;
c.anchor = GridBagConstraints.EAST;
p.add(plus5Label, c);
c.gridx = 1;
c.gridy = 4;
c.gridwidth = 1;
c.gridheight = 1;
c.insets = new Insets(10, 5, 0, 0);
c.fill = GridBagConstraints.NONE;
c.anchor = GridBagConstraints.WEST;
p.add(plus5Text, c);
JLabel plus3Label = new JLabel("Plus 3'");
plus3Text.setPreferredSize(gridSize);
plus3Text.setText("1000");
c.gridx = 0;
c.gridy = 5;
c.gridwidth = 1;
c.gridheight = 1;
c.insets = new Insets(10, 0, 0, 0);
c.fill = GridBagConstraints.NONE;
c.anchor = GridBagConstraints.EAST;
p.add(plus3Label, c);
c.gridx = 1;
c.gridy = 5;
c.gridwidth = 1;
c.gridheight = 1;
c.insets = new Insets(10, 5, 0, 0);
c.fill = GridBagConstraints.NONE;
c.anchor = GridBagConstraints.WEST;
p.add(plus3Text, c);
add(p, BorderLayout.NORTH);
}
void versionComboActionPerformed() {
try {
selected_version = (String) versionCombo.getSelectedItem();
HashMap db_names = new HashMap();
Object[] species = _parent.getAllSpeciesInDatabase();
for (int j = 0; j < species.length; j++) {
String db_name = _parent
.getDatabaseFromSpecies((String) species[j]);
String[] db_name1 = db_name.split("_");
if (db_name1[3].equals(selected_version)) {
db_names.put(db_name, species[j]);
}
}
setDatabase(db_names);
} catch (Throwable t) {
t.printStackTrace();
}
}
void setVersionComboBox(HashSet versions) {
versionCombo.removeAllItems();
ActionListener[] all = versionCombo.getActionListeners();
for (int i = 0; i < all.length; i++) {
versionCombo.removeActionListener(all[i]);
}
ArrayList e_v = new ArrayList(versions);
while (!e_v.isEmpty()) {
Object maxVersion = Collections.max(e_v);
versionCombo.addItem((String) maxVersion);
e_v.remove(maxVersion);
}
versionCombo.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
versionComboActionPerformed();
}
});
versionComboActionPerformed();
}
void setDatabase(Map database) {
String geneId = idListenerPane.getGeneId();
idListenerPane.setCoreDatabases(database);
Connection c = ConnectionManager.getCurrentConnection("Ensembl");
idListenerPane.setConnectionParameter(c.getHost(), c.getUser(), c
.getPass());
idListenerPane.resetGeneField();
idListenerPane.setGeneId(geneId);
}
void setGeneId(String id) {
gene_name = id;
}
void setDefaultValue(String value) {
idListenerPane.setGeneId(value);
}
boolean updateVariables() {
gene_name = idListenerPane.getGeneId();
try {
Connection curr_conn = ConnectionManager
.getCurrentConnection("Ensembl");
FeatureLoaderServiceFactory fac = FeatureLoaderServiceFactory
.getInstance();
Service service = Configuration
.getService(FeatureLoaderServiceFactory.FEATURELOADER_SERVICES);
String mode = null;
String remotehost = null;
if (service != null) {
mode = service.getMode();
remotehost = service.getRemotehost();
} else {
throw new RuntimeException(
"Feature loader service not set up properly.");
}
FeatureLoaderService ser = fac.getService(mode, remotehost);
GeneInfo gInfo = ser.getGeneInfo(curr_conn, ConnectionManager
.getCurrentDatabaseByType("Ensembl"), gene_name);
int offset_5_prime = RetrievalWizard._DEFAULT_QUERY_ADDITION;
try {
offset_5_prime = Integer.parseInt(plus5Text.getValue());
} catch (Exception nexp) {
JOptionPane
.showMessageDialog(
null,
"5 prime offset invalid \n set to Default: "
+ String
.valueOf(RetrievalWizard._DEFAULT_QUERY_ADDITION)
+ "\n" + nexp.getMessage(), "Warning",
JOptionPane.WARNING_MESSAGE);
}
int offset_3_prime = RetrievalWizard._DEFAULT_QUERY_ADDITION;
try {
offset_3_prime = Integer.parseInt(plus3Text.getValue());
} catch (Exception nexp) {
JOptionPane
.showMessageDialog(
null,
"3 prime offset invalid \n set to Default: "
+ String
.valueOf(RetrievalWizard._DEFAULT_QUERY_ADDITION)
+ "\n" + nexp.getMessage(), "Warning",
JOptionPane.WARNING_MESSAGE);
}
int start;
int end;
if (gInfo.getStrand() == -1) {
start = gInfo.getStart() - offset_3_prime;
if (start <= 0) {
start = 1;
}
end = gInfo.getEnd() + offset_5_prime;
} else {
start = gInfo.getStart() - offset_5_prime;
if (start <= 0) {
start = 1;
}
end = gInfo.getEnd() + offset_3_prime;
}
_parent.setStartPos(start);
_parent.setEndPos(end);
_parent.setSelectedChromosome(gInfo.getChromosome());
_parent.setSelectedDatabase(ConnectionManager
.getCurrentDatabaseByType("Ensembl"));
return true;
} catch (Exception ex) {
JOptionPane.showMessageDialog(null, ex.getMessage(), "Warning",
JOptionPane.WARNING_MESSAGE);
return false;
}
}
Component getDefaultComponent() {
return idListenerPane.getDefaultComponent();
}
Component getNextComponent(Component current) {
if (current == idListenerPane.getDefaultComponent())
return plus5Text;
if (current == plus5Text)
return plus3Text;
return null;
}
Component getBeforeComponent(Component current) {
if (current != idListenerPane.getDefaultComponent()
&& current != plus5Text && current != plus3Text)
return plus3Text;
else if (current == plus3Text)
return plus5Text;
else if (current == plus5Text)
return idListenerPane.getDefaultComponent();
return null;
}
Component getLastComponent() {
return plus3Text;
}
}
package ca.bcgsc.sockeye.gui.retrievaldialog;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.util.Iterator;
import java.util.Set;
import javax.swing.Box;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JTextField;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.popup.BrowserLauncher;
import ca.bcgsc.sockeye.util.Log;
class SearchEnsemblPane extends JPanel {
private JComboBox findCombo;
private JTextField with = new JTextField();
private String selected_find_type;
private JComboBox speciesCombo;
private String selected_specie = "";
RetrievalWizard _parent;
public SearchEnsemblPane(RetrievalWizard parent) {
super(new BorderLayout());
this._parent = parent;
jbinit();
}
void jbinit() {
Dimension gridSize = new Dimension(150, 25);
JLabel title = new JLabel("<HTML>2. Full text search<br><HTML>");
JPanel p = new JPanel(new GridBagLayout());
GridBagConstraints c = new GridBagConstraints();
c.gridx = 0;
c.gridy = 0;
c.insets = new Insets(0, 0, 0, 0);
c.fill = GridBagConstraints.NONE;
c.anchor = GridBagConstraints.NORTHWEST;
p.add(title, c);
speciesCombo = new JComboBox();
speciesCombo.setPreferredSize(new Dimension(280, 27));
c.gridx = 0;
c.gridy = 1;
c.insets = new Insets(10, 0, 0, 0);
c.fill = GridBagConstraints.HORIZONTAL;
c.anchor = GridBagConstraints.NORTHWEST;
p.add(speciesCombo, c);
JLabel findLabel = new JLabel("Find");
String[] find_type = { "Anything", "Disease", "Domain", "EST",
"External", "Family", "Gene", "MRNA", "Marker", "Peptide",
"Protein", "SNP", "SangerProject", "Sequence", "Unigene" };
selected_find_type = find_type[0];
findCombo = new JComboBox(find_type);
findCombo.setPreferredSize(gridSize);
Container box1 = Box.createHorizontalBox();
box1.add(findLabel);
box1.add(Box.createHorizontalStrut(5));
box1.add(findCombo);
c.gridx = 0;
c.gridy = 2;
c.insets = new Insets(10, 0, 0, 0);
c.fill = GridBagConstraints.NONE;
c.anchor = GridBagConstraints.EAST;
p.add(box1, c);
JLabel knowLabel = new JLabel("With");
with.setPreferredSize(gridSize);
Container box2 = Box.createHorizontalBox();
box2.add(knowLabel);
box2.add(Box.createHorizontalStrut(5));
box2.add(with);
c.gridx = 0;
c.gridy = 3;
c.insets = new Insets(10, 0, 0, 0);
c.fill = GridBagConstraints.NONE;
c.anchor = GridBagConstraints.EAST;
p.add(box2, c);
add(p, BorderLayout.NORTH);
}
void setSpeciesList(Object species_list) {
speciesCombo.addItem("All Species");
for (Iterator i = ((Set) species_list).iterator(); i.hasNext();) {
speciesCombo.addItem(i.next());
}
selected_specie = (String) speciesCombo.getSelectedItem();
}
void removeSpeciesList() {
speciesCombo.removeAllItems();
}
void searchEnsemblWeb() {
String url = (String) Configuration.getPopupConfiguration().get(
"TextView");
String text = with.getText();
String species;
if (text == null) {
JOptionPane.showMessageDialog(null, "Please Insert Search Text",
"Warning", JOptionPane.WARNING_MESSAGE);
} else {
java.util.Hashtable search = new java.util.Hashtable();
selected_find_type = (String) findCombo.getSelectedItem();
if (selected_find_type.equals("Anything")) {
selected_find_type = "All";
}
String select_specie = (String) speciesCombo.getSelectedItem();
if (select_specie == "All Species") {
species = "ALL";
} else {
String[] parse_text = select_specie.split(" ");
species = (String) SpeciesNameContainer
.getScientificName(parse_text[0] + " " + parse_text[1]);
}
if (species == null) {
System.out.println("Invalid species name");
return;
}
else if (species.length() > 1) {
species = species.substring(0, 1).toUpperCase()
+ species.substring(1);
}
url = url.replaceAll("TYPE", selected_find_type).replaceAll(
"SPECIES", species).replaceAll("TEXT",
with.getText().replaceAll("[+]", "%2b"));
try {
BrowserLauncher.openURL(url);
} catch (Exception ee) {
Log.printStackTrace(ee);
JOptionPane.showMessageDialog(null, "Cannot open Web Browser.",
"Warning", JOptionPane.WARNING_MESSAGE);
}
}
}
Component getDefaultComponent() {
return speciesCombo;
}
Component getNextComponent(Component current) {
if (current == speciesCombo)
return findCombo;
if (current == findCombo)
return with;
return null;
}
Component getBeforeComponent(Component current) {
if (current != speciesCombo && current != findCombo && current != with)
return with;
if (current == with)
return findCombo;
else if (current == findCombo)
return speciesCombo;
return null;
}
Component getLastComponent() {
return with;
}
}package ca.bcgsc.sockeye.gui.retrievaldialog;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Vector;
import javax.swing.Box;
import javax.swing.DefaultComboBoxModel;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import ca.bcgsc.sockeye.datastorage.ChromosomeInfo;
import ca.bcgsc.sockeye.service.featureloader.common.ConnectionManager;
import ca.bcgsc.util.gui.models.SockeyeComboBoxModel;
import ca.bcgsc.util.gui.models.SockeyeTextFormat;
import ca.bcgsc.util.gui.scomponents.SockeyeComboBox;
import ca.bcgsc.util.gui.scomponents.SockeyeTextField;
public class SearchRangePane extends JPanel {
private GridBagConstraints c = new GridBagConstraints();
private JLabel txtLabel1;
private JComboBox speciesCombo;
private JComboBox charCombo;
private JComboBox betweenCombo;
private JComboBox versionCombo;
private SockeyeTextField startText = new SockeyeTextField(
RetrievalWizard._DEFAULT_START);
private SockeyeComboBoxModel endModel = new SockeyeComboBoxModel();
private SockeyeComboBox endCombo = new SockeyeComboBox(endModel);
private String selected_specie = "";
private String selected_version = "";
private String selected_database = "";
private String[] chrom_name_list;
private int[] chrom_length_list;
private int selected_chrom_length = 0;
private String selected_chrom = "";
private int start_pos = 0;
private int end_pos = 0;
private RetrievalWizard _parent;
public SearchRangePane(RetrievalWizard parent) {
super(new BorderLayout());
_parent = parent;
jbinit();
}
void jbinit() {
JPanel p = new JPanel(new GridBagLayout());
c.gridx = 0;
c.gridy = 0;
c.gridwidth = 1;
c.gridheight = 1;
c.insets = new Insets(0, 0, 0, 0);
c.anchor = GridBagConstraints.NORTHWEST;
txtLabel1 = new JLabel("<HTML>2. Selected species : "
+ _parent.getSelectedSpecies() + "<br></HTML>");
p.add(txtLabel1, c);
Dimension gridSize = new Dimension(150, 25);
JLabel versionLabel = new JLabel("Ensembl version");
versionCombo = new JComboBox();
versionCombo.setPreferredSize(gridSize);
Container box0 = Box.createHorizontalBox();
box0.add(versionLabel);
box0.add(Box.createHorizontalStrut(5));
box0.add(versionCombo);
c.gridx = 0;
c.gridy = 1;
c.insets = new Insets(10, 0, 0, 0);
c.fill = GridBagConstraints.NONE;
c.anchor = GridBagConstraints.EAST;
p.add(box0, c);
JLabel charLabel = new JLabel("Chrom/scaffold");
charCombo = new JComboBox();
charCombo.setPreferredSize(gridSize);
charCombo.setPrototypeDisplayValue("soooooooooooooooooo fast!");
Container box1 = Box.createHorizontalBox();
box1.add(charLabel);
box1.add(Box.createHorizontalStrut(5));
box1.add(charCombo);
c.gridx = 0;
c.gridy = 2;
c.insets = new Insets(10, 0, 0, 0);
c.fill = GridBagConstraints.NONE;
c.anchor = GridBagConstraints.EAST;
p.add(box1, c);
JLabel betweenLabel = new JLabel("Unit");
betweenCombo = new JComboBox();
betweenCombo.setPreferredSize(gridSize);
betweenCombo.addItem("b");
Container box2 = Box.createHorizontalBox();
box2.add(betweenLabel);
box2.add(Box.createHorizontalStrut(5));
box2.add(betweenCombo);
c.gridx = 0;
c.gridy = 3;
c.insets = new Insets(7, 0, 0, 0);
p.add(box2, c);
JLabel startLabel = new JLabel("Start");
startText.setPreferredSize(gridSize);
Container box3 = Box.createHorizontalBox();
box3.add(startLabel);
box3.add(Box.createHorizontalStrut(5));
box3.add(startText);
c.gridx = 0;
c.gridy = 5;
c.insets = new Insets(7, 0, 0, 0);
p.add(box3, c);
JLabel endLabel = new JLabel("End");
endCombo.setPreferredSize(gridSize);
Container box4 = Box.createHorizontalBox();
box4.add(endLabel);
box4.add(Box.createHorizontalStrut(5));
box4.add(endCombo);
c.gridx = 0;
c.gridy = 6;
c.insets = new Insets(7, 0, 0, 0);
p.add(box4, c);
add(p, BorderLayout.NORTH);
}
void versionsComboActionPerformed() {
selected_version = (String) versionCombo.getSelectedItem();
setCharList();
setEndCombo();
}
void charComboActionPerformed() {
selected_chrom = (String) charCombo.getSelectedItem();
setEndCombo();
}
void setVersionsList(Vector versions_list) {
txtLabel1.setText("<HTML>2. Selected species : "
+ _parent.getSelectedSpecies() + "<br></HTML>");
for (int i = 0; i < (versions_list.size()); i++) {
versionCombo.addItem(versions_list.get(i));
}
selected_version = (String) versionCombo.getSelectedItem();
}
void removeVersionsList() {
ActionListener[] all = versionCombo.getActionListeners();
for (int i = 0; i < all.length; i++) {
versionCombo.removeActionListener(all[i]);
}
versionCombo.removeAllItems();
}
void addVersionsComboListener() {
versionCombo.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
versionsComboActionPerformed();
}
});
charCombo.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
charComboActionPerformed();
}
});
}
void setCharList() {
selected_specie = _parent.getSelectedSpecies() + "_" + selected_version;
selected_database = _parent.getDatabaseFromSpecies(selected_specie);
ConnectionManager.setCurrentDatabase("Ensembl", selected_database);
chrom_name_list = ChromosomeInfo.getChromosomeName(selected_database);
chrom_length_list = ChromosomeInfo
.getChromosomeLength(selected_database);
charCombo.setModel(new DefaultComboBoxModel(chrom_name_list));
chrom_length_list = ChromosomeInfo
.getChromosomeLength(selected_database);
if (chrom_length_list != null) {
selected_chrom_length = chrom_length_list[0];
selected_chrom = chrom_name_list[0];
}
}
void setEndCombo() {
endModel.clear();
int sel_index = charCombo.getSelectedIndex();
if (sel_index > -1) {
selected_chrom_length = chrom_length_list[sel_index];
if (RetrievalWizard._DEFAULT_END < selected_chrom_length) {
endModel.addItem(0, String
.valueOf(RetrievalWizard._DEFAULT_END));
endModel.addItem(1, String.valueOf(selected_chrom_length));
} else {
endModel.addItem(0, String.valueOf(selected_chrom_length));
}
}
endCombo.update();
}
void removeAllChromosomes() {
charCombo.removeAllItems();
}
boolean updateVariables() {
try {
if (startText.getValue().equals("")) {
start_pos = 0;
} else {
start_pos = Integer.parseInt(startText.getValue());
}
if (endCombo.getSelectedItem().toString().equals("")) {
end_pos = 0;
} else {
SockeyeTextFormat.setUnit("b");
end_pos = SockeyeTextFormat
.toBases((endCombo.getSelectedItem()).toString());
if (end_pos > selected_chrom_length) {
end_pos = selected_chrom_length;
endCombo.setSelectedItem(String
.valueOf(selected_chrom_length));
JOptionPane
.showMessageDialog(
null,
"End > length of the chromosome.\nSet to the chromosome length.",
"Warning", JOptionPane.ERROR_MESSAGE);
}
}
if (start_pos >= end_pos || start_pos == 0 || end_pos == 0) {
JOptionPane.showMessageDialog(null, "START/END: invalid input",
"Warning", JOptionPane.ERROR_MESSAGE);
return false;
}
_parent.setStartPos(start_pos);
_parent.setEndPos(end_pos);
_parent.setSelectedChromosome(selected_chrom);
_parent.setSelectedDatabase(selected_database);
return true;
} catch (Throwable e) {
if (start_pos >= end_pos || start_pos == 0 || end_pos == 0) {
JOptionPane.showMessageDialog(null, "START/END: invalid input",
"Warning", JOptionPane.ERROR_MESSAGE);
}
return false;
}
}
String getSelectedSpecie() {
return selected_specie;
}
Component getDefaultComponent() {
return speciesCombo;
}
Component getNextComponent(Component current) {
if (current == speciesCombo)
return charCombo;
if (current == charCombo)
return startText;
if (current == startText)
return endCombo.getEditor().getEditorComponent();
return null;
}
Component getBeforeComponent(Component current) {
Component editor = endCombo.getEditor().getEditorComponent();
if (current != speciesCombo && current != charCombo
&& current != startText && current != editor)
return editor;
if (current == editor)
return startText;
if (current == startText)
return charCombo;
if (current == charCombo)
return speciesCombo;
return null;
}
Component getLastComponent() {
return endCombo;
}
}/*
package ca.bcgsc.sockeye.gui.retrievaldialog;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Iterator;
import java.util.Set;
import java.util.TreeSet;
import javax.swing.JDialog;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.table.DefaultTableModel;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.parser.Parser;
import ca.bcgsc.util.gui.scomponents.SockeyeButton;
public class SockeyeFeaturesPreviewDialog extends JDialog {
private DefaultTableModel _f_model = new DefaultTableModel();
private JTable _f_table = new JTable(_f_model) {
public Class getColumnClass(int column) {
if (column == SockeyeFeaturesPreviewDialog.IMPORT)
return Boolean.class;
else
return String.class;
}
public boolean isCellEditable(int row, int column) {
if (column == SockeyeFeaturesPreviewDialog.IMPORT)
return true;
else
return false;
}
};
private static final Object[] _headers =
{ "Import", "Feature", "Range", "Score", "Count" };
public final static int IMPORT = 0;
public final static int FEATURE = 1;
public final static int RANGE = 2;
public final static int SCORE = 3;
public final static int COUNT = 4;
public SockeyeFeaturesPreviewDialog(
JDialog rw,
Parser parser,
String seq_id) {
super(rw, "Features preview: " + seq_id, false);
int height =
_f_table.getRowHeight() * (setFeaturePreviewTable(parser, seq_id) + 1)
+ 3;
JPanel f_panel = new JPanel(new GridBagLayout());
JScrollPane scroll_pane = new JScrollPane(_f_table);
scroll_pane.setPreferredSize(new Dimension(600, height));
final SockeyeButton import_all =
new SockeyeButton(Configuration.check, "Import: ALL");
final SockeyeButton import_none =
new SockeyeButton(Configuration.uncheck, "Import: NONE");
f_panel.add(
scroll_pane,
new GridBagConstraints(
0,
0,
2,
1,
0.0,
0.0,
GridBagConstraints.NORTH,
GridBagConstraints.HORIZONTAL,
new Insets(0, 0, 0, 0),
0,
0));
f_panel.add(
import_all,
new GridBagConstraints(
0,
1,
1,
1,
0.0,
0.0,
GridBagConstraints.SOUTHWEST,
GridBagConstraints.NONE,
new Insets(2, 0, 0, 1),
0,
0));
f_panel.add(
import_none,
new GridBagConstraints(
1,
1,
1,
1,
0.0,
0.0,
GridBagConstraints.SOUTHWEST,
GridBagConstraints.NONE,
new Insets(2, 0, 0, 0),
0,
0));
aal(true, import_all, import_none);
aal(false, import_none, import_all);
Container content_pane = this.getContentPane();
content_pane.add(f_panel);
pack();
}
private void aal(
final boolean a,
final SockeyeButton import_all,
final SockeyeButton import_none) {
import_all.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
for (int i = 0; i < _f_table.getRowCount(); i++) {
_f_table.setValueAt(
new Boolean(a),
i,
SockeyeFeaturesPreviewDialog.IMPORT);
}
}
});
}
public int setFeaturePreviewTable(Parser parser, String seq_id) {
Set features = parser.getFeatureNames(seq_id);
Object[][] data = new Object[features.size()][_headers.length];
int i = 0;
for (Iterator fit = features.iterator(); fit.hasNext();) {
data[i][SockeyeFeaturesPreviewDialog.IMPORT] = new Boolean(true);
String feature = fit.next().toString();
data[i][SockeyeFeaturesPreviewDialog.FEATURE] = feature;
final String range =
parser.getMinPosition(seq_id, feature)
+ ".."
+ parser.getMaxPosition(seq_id, feature);
data[i][SockeyeFeaturesPreviewDialog.RANGE] = range;
String score = "unscored";
double max = parser.getMaxScore(seq_id, feature);
double min = parser.getMinScore(seq_id, feature);
if (max > 0.) {
score = (min == max) ? "" + min : min + ".." + max;
}
data[i][SockeyeFeaturesPreviewDialog.SCORE] = score;
data[i][SockeyeFeaturesPreviewDialog.COUNT] =
new Integer(parser.getFeatures(seq_id, feature).size());
_f_model.setDataVector(data, _headers);
i++;
}
return features.size();
}
public Set featureNamesToImport() {
Set ret = new TreeSet();
for (int i = 0; i < _f_table.getRowCount(); i++) {
if (((Boolean) _f_table
.getValueAt(i, SockeyeFeaturesPreviewDialog.IMPORT))
.booleanValue()) {
ret.add(_f_table.getValueAt(i, SockeyeFeaturesPreviewDialog.FEATURE));
}
}
return ret;
}
}
package ca.bcgsc.sockeye.gui.retrievaldialog;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.Vector;
import javax.swing.Box;
import javax.swing.DefaultCellEditor;
import javax.swing.JComboBox;
import javax.swing.JDialog;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.SwingUtilities;
import javax.swing.table.DefaultTableModel;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.dataretrieval.FileDataSource;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.parser.Parser;
import ca.bcgsc.util.gui.scomponents.SockeyeButton;
public class SockeyeFilePreviewPanel extends JPanel implements
PropertyChangeListener, ActionListener {
private static DefaultTableModel _fp_model = new DefaultTableModel();
private JTable _fp_table = new JTable(_fp_model) {
public Class getColumnClass(int column) {
if (column == SockeyeFilePreviewPanel.IMPORT
|| column == SockeyeFilePreviewPanel.AS_DIST)
return Boolean.class;
else
return String.class;
}
public boolean isCellEditable(int row, int column) {
if (column == SockeyeFilePreviewPanel.IMPORT
|| column == SockeyeFilePreviewPanel.TRACK
|| column == SockeyeFilePreviewPanel.OFFSET
|| column == SockeyeFilePreviewPanel.TRACK_START
|| column == SockeyeFilePreviewPanel.TRACK_END
|| column == SockeyeFilePreviewPanel.AS_DIST) {
return true;
} else
return false;
}
};
private Vector _tracks = new Vector();
private static final Object[] _headers = { "Import", "Sequence ID",
"Sequence region", "Feature count", "Offset", "Track",
"Track start", "Track end", "As distribution" };
public final static int IMPORT = 0;
public final static int SEQ_ID = 1;
public final static int SEQ_RANGE = 2;
public final static int FEATURE_COUNT = 3;
public final static int OFFSET = 4;
public final static int TRACK = 5;
public final static int TRACK_START = 6;
public final static int TRACK_END = 7;
public final static int AS_DIST = 8;
private static JComboBox _cb_tracks = new JComboBox();
private static Map _features_preview = new HashMap();
private JDialog _rw = null;
public SockeyeFilePreviewPanel(JDialog rw) {
super(new GridBagLayout());
_rw = rw;
JScrollPane scroll_pane = new JScrollPane(_fp_table);
final SockeyeButton import_all = new SockeyeButton(Configuration.check,
"Import: ALL");
final SockeyeButton import_none = new SockeyeButton(
Configuration.uncheck, "Import: NONE");
final SockeyeButton as_dist_all = new SockeyeButton(
Configuration.check, "As distribution: ALL");
final SockeyeButton as_dist_none = new SockeyeButton(
Configuration.uncheck, "As distribution: NONE");
add(scroll_pane, new GridBagConstraints(0, 0, 5, 1, 0.0, 0.0,
GridBagConstraints.NORTH, GridBagConstraints.HORIZONTAL,
new Insets(0, 0, 0, 0), 0, 145));
add(import_all, new GridBagConstraints(0, 1, 1, 1, 0.0, 0.0,
GridBagConstraints.SOUTHWEST, GridBagConstraints.NONE,
new Insets(2, 0, 0, 1), 0, 0));
add(import_none, new GridBagConstraints(1, 1, 1, 1, 0.0, 0.0,
GridBagConstraints.SOUTHWEST, GridBagConstraints.NONE,
new Insets(2, 0, 0, 0), 0, 0));
add(as_dist_all, new GridBagConstraints(3, 1, 1, 1, 0.0, 0.0,
GridBagConstraints.SOUTHEAST, GridBagConstraints.NONE,
new Insets(2, 0, 0, 0), 0, 0));
add(as_dist_none, new GridBagConstraints(4, 1, 1, 1, 0.0, 0.0,
GridBagConstraints.SOUTHEAST, GridBagConstraints.NONE,
new Insets(2, 1, 0, 0), 0, 0));
add(Box.createHorizontalStrut(300), new GridBagConstraints(2, 1, 1, 1,
2.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE,
new Insets(0, 0, 0, 0), 0, 0));
aal(true, SockeyeFilePreviewPanel.IMPORT, import_all, import_none);
aal(false, SockeyeFilePreviewPanel.IMPORT, import_none, import_all);
aal(true, SockeyeFilePreviewPanel.AS_DIST, as_dist_all, as_dist_none);
aal(false, SockeyeFilePreviewPanel.AS_DIST, as_dist_none, as_dist_all);
}
private void aal(final boolean a, final int column,
final SockeyeButton import_all, final SockeyeButton import_none) {
import_all.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
for (int i = 0; i < _fp_table.getRowCount(); i++) {
_fp_table.setValueAt(new Boolean(a), i, column);
}
}
});
}
public void setFilePreviewTable(final Parser parser) {
setTracks();
Set seq_ids = parser.getSequenceNames();
Object[][] data = new Object[seq_ids.size()][_headers.length];
int i = 0;
for (Iterator sit = seq_ids.iterator(); sit.hasNext();) {
data[i][SockeyeFilePreviewPanel.IMPORT] = new Boolean(true);
String seq_id = sit.next().toString();
data[i][SockeyeFilePreviewPanel.SEQ_ID] = seq_id;
final int track_start = parser.getMinPosition(seq_id);
final int track_end = parser.getMaxPosition(seq_id);
String range = track_start + ".." + track_end;
data[i][SockeyeFilePreviewPanel.SEQ_RANGE] = range;
int f = parser.getFeatures(seq_id).size();
data[i][SockeyeFilePreviewPanel.FEATURE_COUNT] = new Integer(f);
data[i][SockeyeFilePreviewPanel.OFFSET] = new Integer(0);
data[i][SockeyeFilePreviewPanel.TRACK] = _tracks.get(0);
data[i][SockeyeFilePreviewPanel.TRACK_START] = String
.valueOf(track_start);
data[i][SockeyeFilePreviewPanel.TRACK_END] = String
.valueOf(track_end);
Set features = parser.getFeatureNames();
if ((features != null) && (features.contains("distribution")))
data[i][SockeyeFilePreviewPanel.AS_DIST] = new Boolean(true);
else
data[i][SockeyeFilePreviewPanel.AS_DIST] = new Boolean(false);
_fp_model.setDataVector(data, _headers);
_cb_tracks = new JComboBox(_tracks);
_fp_table.getColumn(
_fp_table.getColumnName(SockeyeFilePreviewPanel.TRACK))
.setCellEditor(new DefaultCellEditor(_cb_tracks));
final int row = i;
_cb_tracks.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
String track_name = _cb_tracks.getSelectedItem().toString();
if (!track_name.equals(FileDataSource.__NEW_TRACK)) {
int t_id = Integer.parseInt(track_name.split(":")[0]);
_fp_model.setValueAt(String.valueOf(DataStoreUser
.getInstance().getSockeyeTrackList()
.getTrackDataWindowStart(t_id)), row,
SockeyeFilePreviewPanel.TRACK_START);
_fp_model.setValueAt(String.valueOf(DataStoreUser
.getInstance().getSockeyeTrackList()
.getTrackDataWindowStart(t_id)), row,
SockeyeFilePreviewPanel.TRACK_END);
} else {
_fp_model.setValueAt(String.valueOf(track_start), row,
SockeyeFilePreviewPanel.TRACK_START);
_fp_model.setValueAt(String.valueOf(track_end), row,
SockeyeFilePreviewPanel.TRACK_END);
}
}
});
i++;
}
_fp_table.addMouseListener(new MouseAdapter() {
public void mouseClicked(MouseEvent e) {
int row = _fp_table.rowAtPoint(e.getPoint());
if (SwingUtilities.isRightMouseButton(e)
&& e.getClickCount() == 1 && row != -1) {
String seq_id = (String) _fp_table.getValueAt(row,
SockeyeFilePreviewPanel.SEQ_ID);
SockeyeFeaturesPreviewDialog sfpd = new SockeyeFeaturesPreviewDialog(
_rw, parser, seq_id);
_features_preview.put(seq_id, sfpd);
sfpd.show();
}
}
});
}
private void setTracks() {
_tracks.clear();
_tracks.add(FileDataSource.__NEW_TRACK);
for (Iterator t_id_it = DataStoreUser.getInstance()
.getSockeyeTrackList().getAllOrderedTrackIds().iterator(); t_id_it
.hasNext();) {
int t_id = ((Integer) t_id_it.next()).intValue();
String track_name = (String) DataStoreUser.getInstance()
.getSockeyeTrackList()
.getTrackAttribute(t_id, "track_name");
_tracks.add(new String(t_id + ": " + track_name));
}
}
public Object filePreviewTableValue(String seq_id, int column) {
if (_fp_table.isEditing()) {
int row = _fp_table.getEditingRow();
int col = _fp_table.getEditingColumn();
_fp_table.getCellEditor(row, col).stopCellEditing();
}
Object ret = null;
int edited_row = 0;
for (int row = 0; row < _fp_model.getRowCount(); row++) {
if (_fp_model.getValueAt(row, SockeyeFilePreviewPanel.SEQ_ID)
.equals(seq_id)) {
ret = _fp_model.getValueAt(row, column);
edited_row = row;
break;
}
}
if (column == SockeyeFilePreviewPanel.OFFSET
&& _fp_model.getValueAt(edited_row,
SockeyeFilePreviewPanel.TRACK).equals(
FileDataSource.__NEW_TRACK)) {
int offset = 0;
try {
System.out.println(">>>>>>>>>>>>> ''' "
+ _fp_model.getValueAt(edited_row,
SockeyeFilePreviewPanel.TRACK_START));
offset = Integer.parseInt(ret.toString());
int track_start = (Integer.valueOf((String) _fp_model
.getValueAt(edited_row,
SockeyeFilePreviewPanel.TRACK_START)))
.intValue()
+ offset;
int track_end = (Integer.valueOf((String) _fp_model.getValueAt(
edited_row, SockeyeFilePreviewPanel.TRACK_END)))
.intValue()
+ offset;
_fp_model.setValueAt(String.valueOf(track_start), edited_row,
SockeyeFilePreviewPanel.TRACK_START);
_fp_model.setValueAt(String.valueOf(track_end), edited_row,
SockeyeFilePreviewPanel.TRACK_END);
} catch (NumberFormatException e) {
JOptionPane
.showMessageDialog(
SockeyeFilePreviewPanel.this,
"Wrong input format in 'offset' field: offset set to 0",
"Warning", JOptionPane.WARNING_MESSAGE);
e.printStackTrace();
_fp_model.setValueAt("0", edited_row,
SockeyeFilePreviewPanel.OFFSET);
}
}
return ret;
}
public Set featureNamesToImport(String seq_id) {
Object o = _features_preview.get(seq_id);
if (o != null)
return ((SockeyeFeaturesPreviewDialog) o).featureNamesToImport();
else
return null;
}
public void clearTable() {
for (int i = 0; i < _fp_model.getRowCount(); i++) {
_fp_model.removeRow(i);
}
}
public void updateCombo() {
setTracks();
_cb_tracks = new JComboBox(_tracks);
}
public void propertyChange(PropertyChangeEvent evt) {
}
public void actionPerformed(ActionEvent e) {
}
}package ca.bcgsc.sockeye.gui.retrievaldialog;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Set;
public class SpeciesNameContainer {
private static Hashtable _name_correspondence = new Hashtable();
private static Hashtable _reverse_name_correspondence = new Hashtable();
static {
_name_correspondence.put("anopheles_gambiae", "A. gambiae");
_name_correspondence.put("apis_mellifera", "A. mellifera");
_name_correspondence.put("arabidopsis_thaliana", "A. thaliana");
_name_correspondence.put("caenorhabditis_briggsae", "C. briggsae");
_name_correspondence.put("caenorhabditis_elegans", "C. elegans");
_name_correspondence.put("canis_familiaris", "C. familiaris");
_name_correspondence.put("ciona_intestinalis", "C. intestinalis");
_name_correspondence.put("danio_rerio", "D. rerio");
_name_correspondence.put("drosophila_melanogaster", "D. melanogaster");
_name_correspondence.put("fugu_rubripes", "F. rubripes");
_name_correspondence.put("gallus_gallus", "G. gallus");
_name_correspondence.put("homo_sapiens", "H. sapiens");
_name_correspondence.put("macaca_mulatta", "M. mulatta");
_name_correspondence.put("mus_musculus", "M. musculus");
_name_correspondence.put("pan_troglodytes", "P. troglodytes");
_name_correspondence.put("rattus_norvegicus", "R. norvegicus");
_name_correspondence.put("saccharomyces_cerevisiae", "S. cerevisiae");
_name_correspondence.put("tetraodon_nigroviridis", "T. nigroviridis");
_name_correspondence.put("xenopus_tropicalis", "X. tropicalis");
Set names = _name_correspondence.keySet();
for (Iterator i = names.iterator(); i.hasNext();) {
String value = (String) i.next();
String key = (String) _name_correspondence.get(value);
_reverse_name_correspondence.put(key, value);
}
}
public static String getCommonSpeciesName(String dbName) {
if (dbName == null) {
throw new IllegalArgumentException("Species name is NULL");
}
if (!_name_correspondence.containsKey(dbName)) {
System.err.println("Species " + dbName + " not available");
}
return (String) _name_correspondence.get(dbName);
}
public static String getScientificName(String species) {
if (species == null) {
throw new IllegalArgumentException("Species name is NULL");
}
if (!_reverse_name_correspondence.containsKey(species))
System.err.println("Species " + species + " not available");
return (String) _reverse_name_correspondence.get(species);
}
public static Set getAllCommonNames() {
return _reverse_name_correspondence.keySet();
}
}package ca.bcgsc.sockeye.gui.retrievaldialog;
import java.awt.CardLayout;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.io.File;
import java.util.Vector;
import javax.swing.DefaultListModel;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ListSelectionModel;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import ca.bcgsc.util.gui.scomponents.SockeyeTextField;
public class SpeciesPane extends JPanel {
private GridBagConstraints c = new GridBagConstraints();
private JList sourceList;
private DefaultListModel sourceModel = new DefaultListModel();
private JLabel dataLabel;
private JPanel rightPanel;
private SearchRangePane rangePane;
private SearchEnsemblIdPane idPane;
private SearchEnsemblPane ensPane;
private SearchEnsemblIdListPane seIDListPane;
private CardLayout cards;
private int dataSelection = 0;
private String selected_specie = "";
private String selected_find_type = "";
private RetrievalWizard _parent;
public SpeciesPane(RetrievalWizard parent) {
super(new GridBagLayout());
this._parent = parent;
jbinit();
}
void jbinit() {
JPanel p = new JPanel(new GridBagLayout());
c.gridx = 0;
c.gridy = 0;
c.gridwidth = 1;
c.gridheight = 1;
c.anchor = GridBagConstraints.NORTHWEST;
dataLabel = new JLabel("<HTML>1. Please select<br></HTML>");
add(dataLabel, c);
sourceModel.addElement("Get annotations by range");
sourceModel.addElement("Get annotations by EnsEMBL ID");
sourceModel.addElement("Search EnsEMBL");
sourceModel.addElement("Get EnsEMBL ID List (from file)");
sourceList = new JList(sourceModel);
sourceList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
sourceList.setSelectedIndex(0);
sourceList.setVisibleRowCount(5);
sourceList.addListSelectionListener(new ListSelectionListener() {
public void valueChanged(ListSelectionEvent e) {
list_valueChanged();
}
});
JScrollPane listScrollPane = new JScrollPane(sourceList,
JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,
JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
listScrollPane.setPreferredSize(new Dimension(200, 70));
c.gridx = 0;
c.gridy = 1;
c.gridheight = 2;
c.anchor = GridBagConstraints.WEST;
c.insets = new Insets(10, 0, 0, 0);
add(listScrollPane, c);
cards = new CardLayout();
rightPanel = new JPanel(cards);
rangePane = new SearchRangePane(_parent);
idPane = new SearchEnsemblIdPane(_parent);
ensPane = new SearchEnsemblPane(_parent);
seIDListPane = new SearchEnsemblIdListPane(_parent);
rightPanel.add(rangePane, "range");
rightPanel.add(idPane, "id");
rightPanel.add(ensPane, "ensembl");
rightPanel.add(seIDListPane, "idList");
c.gridx = 1;
c.gridy = 0;
c.gridheight = 5;
c.gridwidth = 2;
c.insets = new Insets(0, 20, 0, 0);
c.fill = GridBagConstraints.NONE;
c.anchor = GridBagConstraints.NORTHWEST;
add(rightPanel, c);
}
int getCurrentSelection() {
return dataSelection;
}
void setSpeciesPane(Vector versions_list) {
if (versions_list == null)
throw new IllegalArgumentException("Vector can not be null");
rangePane.removeVersionsList();
ensPane.removeSpeciesList();
ensPane.setSpeciesList(SpeciesNameContainer.getAllCommonNames());
rangePane.setVersionsList(versions_list);
rangePane.setCharList();
rangePane.setEndCombo();
rangePane.addVersionsComboListener();
idPane.setVersionComboBox(_parent.getEnsemblVersion());
}
void setGeneId(String geneId) {
idPane.setGeneId(geneId);
}
boolean updateVariables() {
if (dataSelection == 0)
return rangePane.updateVariables();
else if (dataSelection == 1)
return idPane.updateVariables();
else
return false;
}
void list_valueChanged() {
dataSelection = sourceList.getSelectedIndex();
if (dataSelection == 0) {
cards.show(rightPanel, "range");
_parent.set_viewer_status(0, true, true);
_parent.set_viewer_status(1, true, false);
_parent.set_viewer_status(2, true, false);
if (rangePane.getSelectedSpecie().substring(0, 8)
.equals("C.elegan"))
_parent.set_viewer_status(3, true, false);
else
_parent.set_viewer_status(3, false, false);
_parent.set_viewer_status(4, false, false);
} else if (dataSelection == 1) {
_parent.set_viewer_status(0, true, true);
_parent.set_viewer_status(1, true, false);
_parent.set_viewer_status(2, true, false);
_parent.set_viewer_status(3, false, false);
_parent.set_viewer_status(4, false, false);
cards.show(rightPanel, "id");
} else if (dataSelection == 2) {
_parent.set_viewer_status(0, false, false);
_parent.set_viewer_status(1, false, false);
_parent.set_viewer_status(2, false, false);
_parent.set_viewer_status(3, false, false);
_parent.set_viewer_status(4, true, true);
cards.show(rightPanel, "ensembl");
} else if (dataSelection == 3) {
_parent.set_viewer_status(0, false, false);
_parent.set_viewer_status(1, false, false);
_parent.set_viewer_status(2, false, false);
_parent.set_viewer_status(3, false, false);
_parent.set_viewer_status(4, true, true);
cards.show(rightPanel, "idList");
} else
System.out.println("Mouse Selection Error");
}
void searchEnsemblWeb() {
ensPane.searchEnsemblWeb();
}
public File getIdListFile() {
return seIDListPane.getIdListFile();
}
public SockeyeTextField getPlus3Text() {
return seIDListPane.getPlus3Text();
}
public SockeyeTextField getPlus5Text() {
return seIDListPane.getPlus5Text();
}
Component getDefaultComponent() {
return sourceList;
}
Component getBeforeComponent(Component current) {
if (dataSelection == 0)
return rangePane.getBeforeComponent(current);
else if (dataSelection == 1)
return idPane.getBeforeComponent(current);
else if (dataSelection == 2)
return ensPane.getBeforeComponent(current);
return null;
}
Component getNextComponent(Component current) {
if (dataSelection == 0)
if (current == sourceList)
return rangePane.getDefaultComponent();
else
return rangePane.getNextComponent(current);
else if (dataSelection == 1)
if (current == sourceList)
return idPane.getDefaultComponent();
else
return idPane.getNextComponent(current);
else if (dataSelection == 2)
if (current == sourceList)
return ensPane.getDefaultComponent();
else
return ensPane.getNextComponent(current);
return null;
}
Component getLastDefaultComponent() {
if (dataSelection == 0)
return rangePane.getLastComponent();
else if (dataSelection == 1)
return idPane.getLastComponent();
else if (dataSelection == 2)
return ensPane.getLastComponent();
return null;
}
}package ca.bcgsc.sockeye.gui.retrievaldialog;
import java.awt.Component;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.GridLayout;
import java.awt.Insets;
import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.Border;
public class ViewerPane extends JPanel {
private GridBagConstraints c = new GridBagConstraints();
private JCheckBox[] viewer;
private JLabel bLabel;
private JButton chgButton;
public ViewerPane() {
super(new GridBagLayout());
jbinit();
}
void jbinit() {
c.gridx = 0;
c.gridy = 0;
c.gridwidth = 1;
c.gridheight = 1;
c.insets = new Insets(0, 0, 0, 0);
c.anchor = GridBagConstraints.NORTHWEST;
String inputtxt = "<HTML>Please select any of the following viewers.<br>For any other viewer than Sockeye<br>"
+ "a separate browser window will open</HTML>";
String inputtxt2 = "<HTML>If you want to use a browser other than<br>your default, please choose one below";
JLabel descLabel = new JLabel(inputtxt);
add(descLabel, c);
c.gridx = 1;
c.gridy = 0;
c.gridwidth = 1;
c.gridheight = 1;
c.insets = new Insets(0, 20, 0, 0);
JLabel descLabel2 = new JLabel(inputtxt2);
add(descLabel2, c);
c.gridx = 0;
c.gridy = 1;
c.gridheight = 1;
c.insets = new Insets(0, 0, 0, 0);
c.anchor = GridBagConstraints.NORTHWEST;
c.fill = GridBagConstraints.HORIZONTAL;
;
JPanel leftPanel = new JPanel(new GridLayout(5, 1));
viewer = new JCheckBox[5];
viewer[0] = new JCheckBox("Sockeye 3D");
viewer[1] = new JCheckBox("EnsEMBL ContigView");
viewer[2] = new JCheckBox("NCBI Map View");
viewer[3] = new JCheckBox("WarmBas DAS View");
viewer[4] = new JCheckBox("Web Text View");
viewer[0].setSelected(true);
viewer[3].setEnabled(false);
viewer[4].setEnabled(false);
leftPanel.add(viewer[0]);
leftPanel.add(viewer[1]);
leftPanel.add(viewer[2]);
leftPanel.add(viewer[3]);
leftPanel.add(viewer[4]);
Border etch = BorderFactory.createEtchedBorder();
leftPanel.setBorder(BorderFactory.createTitledBorder(etch,
"Available viewer"));
add(leftPanel, c);
c.gridx = 1;
c.gridy = 1;
c.insets = new Insets(0, 20, 0, 0);
c.gridheight = 1;
c.fill = GridBagConstraints.HORIZONTAL;
c.anchor = GridBagConstraints.NORTH;
JPanel rightPanel = new JPanel(new GridLayout(2, 1));
String input = "<HTML>Default: Default Browser</HTML>";
bLabel = new JLabel(input);
chgButton = new JButton("Change");
chgButton.setEnabled(false);
JPanel innerPanel = new JPanel();
innerPanel.add(chgButton);
rightPanel.add(bLabel);
rightPanel.add(innerPanel);
rightPanel.setBorder(BorderFactory.createTitledBorder(etch, "Browser"));
add(rightPanel, c);
}
void setViewerStatus(int index, boolean enabled, boolean selected) {
viewer[index].setEnabled(enabled);
viewer[index].setSelected(selected);
}
boolean getViewerEnabled(int index) {
return viewer[index].isEnabled();
}
boolean getViewerSelected(int index) {
return viewer[index].isSelected();
}
Component getDefaultComponent() {
if (viewer[0].isEnabled())
return viewer[0];
else
return viewer[viewer.length - 1];
}
Component getBeforeComponent(Component current) {
if (current == viewer[0])
return null;
if (current == chgButton) {
for (int j = viewer.length - 1; j >= 0; j--) {
if (viewer[j].isEnabled())
return viewer[j];
}
}
for (int i = viewer.length - 1; i > 0; i--) {
if (current == viewer[i])
if (viewer[i - 1].isEnabled())
return viewer[i - 1];
else {
for (int j = i - 1; i >= 0; i--) {
if (viewer[j].isEnabled())
return viewer[j];
}
}
}
return null;
}
Component getNextComponent(Component current) {
if (current == viewer[viewer.length - 1])
return chgButton;
for (int i = 0; i < viewer.length; i++) {
if (current == viewer[i])
if (viewer[i + 1].isEnabled())
return viewer[i + 1];
else
return chgButton;
}
if (current == chgButton)
return null;
if (viewer[0].isEnabled())
return viewer[0];
else
return viewer[viewer.length - 1];
}
Component getLastDefaultComponent() {
return chgButton;
}
}/*------
package ca.bcgsc.sockeye.gui.scomponents;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics;
import javax.swing.Icon;
import javax.swing.JCheckBox;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTree;
import javax.swing.UIManager;
import javax.swing.plaf.ColorUIResource;
import javax.swing.tree.TreeCellRenderer;
import javax.swing.tree.TreePath;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.util.gui.scomponents.CheckboxTreeNode;
public class CheckboxTreeRenderer
extends JPanel implements TreeCellRenderer{
protected JCheckBox check;
protected TreeLabel label;
protected Icon leafIcon_uncheck;
protected Icon leafIcon_checked;
protected boolean featureTreeRendering;
protected boolean visible = true;
public CheckboxTreeRenderer() {
setLayout(null);
add(check = new JCheckBox());
add(label = new TreeLabel());
check.setBackground(UIManager.getColor("Tree.textBackground"));
leafIcon_uncheck = check.getIcon();
leafIcon_checked = check.getSelectedIcon();
featureTreeRendering = true;
}
public void setFeatureTreeStyle(){
featureTreeRendering = true;
}
public void setTrackTreeStyle(){
featureTreeRendering = false;
}
public Component getTreeCellRendererComponent(JTree tree, Object value,
boolean isSelected,
boolean expanded,
boolean leaf, int row,
boolean hasFocus) {
String stringValue = tree.convertValueToText(value, isSelected,
expanded, leaf, row, hasFocus);
setEnabled(tree.isEnabled());
check.setSelected( ( (CheckboxTreeNode) value).isChecked());
visible = ( (CheckboxTreeNode) value).getVisible();
label.setText(stringValue);
label.setSelected(isSelected);
label.setFocus(hasFocus);
if (!featureTreeRendering)
{
int i = -1;
TreePath p = tree.getPathForRow(row);
check.setVisible(true);
if (p!=null)
i = p.getPathCount();
if (i==1 || i==2 || i==4) {
check.setIcon(Configuration.ftShowNodeOff);
check.setSelectedIcon(Configuration.ftShowNodeOn);
}
else
{
check.setVisible(false);
}
}
else{
check.setEnabled(((CheckboxTreeNode) value).getEnabled());
label.setEnabled(((CheckboxTreeNode) value).getEnabled());
}
if (leaf && ((CheckboxTreeNode) value).getLevel()>1) {
check.setBackground(UIManager.getColor("Tree.textBackground"));
if (featureTreeRendering)
{
if ( ((CheckboxTreeNode) value).getAlwaysOn() && !check.isSelected())
check.setIcon(Configuration.ftShowNodeAlwaysOn_off);
else
check.setIcon(leafIcon_uncheck);
check.setDisabledIcon(null);
check.setSelectedIcon(leafIcon_checked);
}
label.unhighlight();
}
else
{
check.setBackground(UIManager.getColor("Tree.textBackground"));
if (featureTreeRendering){
check.setIcon(Configuration.ftShowNodeOff);
check.setSelectedIcon(Configuration.ftShowNodeOn);
check.setDisabledIcon(null);
}
if (expanded) {
label.highlight();
}
else {
label.highlight();
}
}
return this;
}
public int getCheckBoxWidth(){
return check.getWidth();
}
public Dimension getPreferredSize() {
if (!visible)
return new Dimension();
Dimension d_check = check.getPreferredSize();
Dimension d_label = label.getPreferredSize();
return new Dimension(d_check.width + d_label.width,
(d_check.height < d_label.height ?
d_label.height : d_check.height));
}
public void doLayout() {
if (!visible)
return;
Dimension d_check = check.getPreferredSize();
Dimension d_label = label.getPreferredSize();
int y_check = 0;
int y_label = 0;
if (d_check.height < d_label.height) {
y_check = (d_label.height - d_check.height) / 2;
}
else {
y_label = (d_check.height - d_label.height) / 2;
}
check.setLocation(0, y_check);
check.setBounds(0, y_check, d_check.width, d_check.height);
if (check.isVisible()){
label.setLocation(d_check.width, y_label);
label.setBounds(d_check.width, y_label, d_label.width, d_label.height);
}
else{
label.setLocation(0, y_label);
label.setBounds(0, y_label, d_label.width, d_label.height);
}
}
public void setBackground(Color color) {
if (color instanceof ColorUIResource) {
color = null;
}
super.setBackground(color);
}
class TreeLabel
extends JLabel {
boolean isSelected;
boolean hasFocus;
TreeLabel() {
}
public void setBackground(Color color) {
if (color instanceof ColorUIResource) {
color = null;
}
super.setBackground(color);
}
public void highlight(){
this.setFont(new Font("SansSerif", Font.BOLD, 12));
}
public void unhighlight(){
this.setFont(new Font("SansSerif", Font.PLAIN, 12));
}
public void paint(Graphics g) {
String str;
if ( (str = getText()) != null) {
if (0 < str.length()) {
if (isSelected) {
g.setColor(UIManager.getColor("Tree.selectionBackground"));
}
else {
g.setColor(UIManager.getColor("Tree.textBackground"));
}
Dimension d = getPreferredSize();
int imageOffset = 0;
Icon currentI = getIcon();
if (currentI != null) {
imageOffset = currentI.getIconWidth() +
Math.max(0, getIconTextGap() - 1);
}
g.fillRect(imageOffset, 0, d.width - 1 - imageOffset, d.height);
if (hasFocus) {
g.setColor(UIManager.getColor("Tree.selectionBorderColor"));
g.drawRect(imageOffset, 0, d.width - 1 - imageOffset, d.height - 1);
}
}
}
super.paint(g);
}
public Dimension getPreferredSize() {
Dimension retDimension = super.getPreferredSize();
if (retDimension != null) {
retDimension = new Dimension(retDimension.width + 3,
retDimension.height);
}
return retDimension;
}
void setSelected(boolean isSelected) {
this.isSelected = isSelected;
}
void setFocus(boolean hasFocus) {
this.hasFocus = hasFocus;
}
}
}
package ca.bcgsc.sockeye.gui.scomponents;
import java.awt.Component;
import javax.swing.JList;
import javax.swing.plaf.basic.BasicComboBoxRenderer;
public class ComboBoxRenderer extends BasicComboBoxRenderer {
String[] tooltips = null;
public ComboBoxRenderer(String[] tooltips_) {
tooltips = tooltips_;
}
public Component getListCellRendererComponent(
JList list,
Object value,
int index,
boolean isSelected,
boolean cellHasFocus) {
if (isSelected) {
setBackground(list.getSelectionBackground());
setForeground(list.getSelectionForeground());
if (-1 < index) {
list.setToolTipText(tooltips[index]);
}
} else {
setBackground(list.getBackground());
setForeground(list.getForeground());
}
setFont(list.getFont());
setText((value == null) ? "" : value.toString());
return this;
}
}
package ca.bcgsc.sockeye.gui.session;
import nu.xom.Attribute;
import nu.xom.Element;
import ca.bcgsc.util.serialization.AbstractElement;
public class Feature extends AbstractElement {
final static String _FEATURE_ELEMENT = "feature";
final static String _NAME_ATTRIBUTE = "name";
final static String _PARENT_ATTRIBUTE = "parent";
public Feature(String name, String parent) {
super(_FEATURE_ELEMENT);
addAttribute(new Attribute(_NAME_ATTRIBUTE, name));
addAttribute(new Attribute(_PARENT_ATTRIBUTE, parent));
}
public Feature (Element elem) {
super(_FEATURE_ELEMENT);
if(elem == null)
return;
addAttribute(new Attribute(_NAME_ATTRIBUTE, elem.getAttribute(_NAME_ATTRIBUTE).getValue()));
addAttribute(new Attribute(_PARENT_ATTRIBUTE, elem.getAttribute(_PARENT_ATTRIBUTE).getValue()));
}
}
package ca.bcgsc.sockeye.gui.session;
import java.util.ArrayList;
import javax.swing.JTree;
import javax.swing.tree.TreeModel;
import nu.xom.Element;
import nu.xom.Elements;
import ca.bcgsc.util.gui.scomponents.CheckboxTreeNode;
import ca.bcgsc.util.serialization.AbstractElement;
public class Features extends AbstractElement {
final static String _TAG_NAME = "features";
ArrayList features_list = new ArrayList();
public Features() {
super(_TAG_NAME);
}
public Features(Element elem) {
super(_TAG_NAME);
Elements elements = elem.getChildElements();
for (int i = 0; i < elements.size(); i++) {
addFeature(new Feature(elements.get(i)));
}
}
public Features(JTree tree) {
super(_TAG_NAME);
TreeModel model = tree.getModel();
CheckboxTreeNode root = (CheckboxTreeNode) model.getRoot();
marshal(root);
}
void marshal(CheckboxTreeNode node) {
for (int i = 0; i < node.getChildCount(); i++) {
CheckboxTreeNode child = (CheckboxTreeNode) node.getChildAt(i);
if (child.isChecked())
addFeature(new Feature(child.toString(), child.getParent().toString()));
if (!child.isLeaf()) {
marshal(child);
}
}
}
public boolean addFeature(Feature feature) {
if (feature == null)
return false;
this.appendChild(feature);
return features_list.add(feature);
}
public Feature getFeature(String attr_name, String attr_parent) {
for (int i = 0; i < getFeatureCount(); i++) {
Feature feature = (Feature) features_list.get(i);
if (feature
.getAttribute(Feature._NAME_ATTRIBUTE)
.getValue()
.equals(attr_name))
return feature;
}
return null;
}
int getFeatureCount() {
return features_list.size();
}
public ArrayList getFeatures() {
ArrayList features = new ArrayList();
for (int i = 0; i < getFeatureCount(); i++) {
String[] feature = new String[2];
feature[0] =
((Feature) features_list.get(i))
.getAttribute(Feature._NAME_ATTRIBUTE)
.getValue();
feature[1] =
((Feature) features_list.get(i))
.getAttribute(Feature._PARENT_ATTRIBUTE)
.getValue();
features.add(feature);
}
return features;
}
}
package ca.bcgsc.sockeye.gui.session;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.Rectangle;
import java.awt.event.ActionEvent;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.WindowEvent;
import java.io.File;
import javax.help.CSH;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JDialog;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.JTextPane;
import javax.swing.SwingConstants;
import javax.swing.UIManager;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.gui.navigation.FeaturePanel;
import ca.bcgsc.sockeye.gui.util.ImageLoader;
import ca.bcgsc.sockeye.util.Log;
import ca.bcgsc.util.gui.scomponents.SockeyeButton;
public class NewSessionDialog extends JDialog {
public static final int __CREATE_OPTION = 0;
public static final int __CANCEL_OPTION = 1;
JPanel p_center = new JPanel();
JPanel p_buttons = new JPanel();
BorderLayout main_layout = new BorderLayout();
ImageIcon help_icon = ImageLoader.loadIcon("Help24.gif");
JLabel l_name = new JLabel("Name:");
JTextField tf_name = new JTextField();
JLabel l_directory = new JLabel("Directory:");
JTextField tf_directory = new JTextField();
JButton b_browser = new JButton("...");
JTextPane tp_info = new JTextPane();
String work_dir = SessionManager.getLastSessionPath();
static boolean _save_data;
static boolean _close_application;
BorderLayout buttons_borderLayout = new BorderLayout();
JPanel p_bcenter = new JPanel();
JButton b_cancel = new JButton("Cancel");
JButton b_create = new JButton();
JPanel p_help = new JPanel();
SockeyeButton b_help = new SockeyeButton(help_icon);
static int _option;
private NewSessionDialog(
JFrame parent,
String title,
String text_button,
boolean save_data,
boolean close_application) {
super(parent, title, true);
NewSessionDialog._save_data = save_data;
NewSessionDialog._close_application = close_application;
initHelp();
jbInit(text_button);
}
public static int show(
JFrame parent,
String title,
String text_button,
boolean save_data,
boolean close_application) {
new NewSessionDialog(
parent,
title,
text_button,
save_data,
close_application);
return _option;
}
private void jbInit(String text_button) {
this.setSize(new Dimension(495, 185));
this.setLocationRelativeTo(null);
this.getContentPane().setLayout(main_layout);
if (work_dir == null)
work_dir =
Configuration.USER_DIR
+ Configuration.SEP
+ SessionManager.__SESSION_FOLDER;
l_directory.setHorizontalAlignment(SwingConstants.RIGHT);
l_name.setHorizontalAlignment(SwingConstants.RIGHT);
b_cancel.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
b_cancel_actionPerformed(e);
}
});
b_create.setText(text_button);
b_create.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
b_create_actionPerformed(e);
}
});
getRootPane().setDefaultButton(b_create);
this.getContentPane().add(p_center, BorderLayout.CENTER);
this.getContentPane().add(p_buttons, BorderLayout.SOUTH);
p_buttons.setLayout(buttons_borderLayout);
l_name.setBounds(new Rectangle(17, 60, 63, 25));
tf_name.setText(setDefaultName());
tf_name.setPreferredSize(new Dimension(6, 25));
tf_name.setBounds(new Rectangle(90, 62, 345, 20));
tf_name.addKeyListener(new KeyListener() {
public void keyPressed(KeyEvent e) {
}
public void keyReleased(KeyEvent e) {
}
public void keyTyped(KeyEvent e) {
char c = e.getKeyChar();
if (!Character.isLetterOrDigit(c)
&& c != KeyEvent.VK_BACK_SPACE
&& c != '_') {
tf_name.getToolkit().beep();
e.consume();
}
if (tf_name.getText().length() < 2)
b_create.setEnabled(false);
else
b_create.setEnabled(true);
}
});
l_directory.setBounds(new Rectangle(1, 86, 79, 25));
tf_directory.setPreferredSize(new Dimension(6, 25));
tf_directory.setText(work_dir);
tf_directory.setBounds(new Rectangle(90, 89, 346, 20));
b_browser.setBounds(new Rectangle(440, 89, 40, 20));
b_browser.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
b_browser_actionPerformed(e);
}
});
tp_info.setBackground(UIManager.getColor("Label.background"));
tp_info.setEditable(false);
tp_info.setText(
"Enter a name for your new Sockeye session and the path to the directory "
+ "where it is to be saved.");
tp_info.setBounds(new Rectangle(10, 14, 471, 41));
if (_save_data)
b_create.setText("Save data...");
p_buttons.add(p_bcenter, BorderLayout.CENTER);
p_center.setLayout(null);
p_center.add(tf_name, null);
p_center.add(l_name, null);
p_center.add(l_directory, null);
p_center.add(tf_directory, null);
p_center.add(b_browser, null);
p_center.add(tp_info, null);
p_bcenter.add(b_create, null);
p_bcenter.add(b_cancel, null);
p_buttons.add(p_help, BorderLayout.EAST);
this.show();
}
void b_cancel_actionPerformed(ActionEvent e) {
_option = __CANCEL_OPTION;
dispose();
}
void b_create_actionPerformed(ActionEvent e){
String dir_path = tf_directory.getText();
if (!isFileExist(Configuration.USER_DIR, dir_path))
createDirectory(dir_path);
String session_name = tf_name.getText();
String session_path =
dir_path
+ Configuration.SEP
+ session_name
+ SessionManager.__SESSION_FILE_EXTENSION;
if (!isFileExist(dir_path, session_path)) {
try {
File session_config_file = new File(session_path);
if (!session_config_file.exists()) {
session_config_file.createNewFile();
}
SessionManager.setLastSessionPath(dir_path);
SessionManager.resetConfig(session_config_file, true, FeaturePanel.getTree());
} catch (Exception ioe) {
ioe.printStackTrace();
JOptionPane.showMessageDialog(
this,
"Error occurs to create new session.",
"Error",
JOptionPane.ERROR_MESSAGE);
}
} else {
JOptionPane.showMessageDialog(
this,
"File: "
+ session_path
+ " exists already. \nSpecify another name or directory.",
"Message",
JOptionPane.ERROR_MESSAGE);
return;
}
if (_save_data) {
try {
SessionManager.getInstance().saveSession(false, false);
} catch (Exception es) {
es.printStackTrace();
Log.printStackTrace(es);
}
if (_close_application)
System.exit(0);
}
_option = __CREATE_OPTION;
dispose();
}
void b_browser_actionPerformed(ActionEvent e) {
if (!isFileExist(String.valueOf(Configuration.SEP), work_dir))
createDirectory(work_dir);
JFileChooser fc = new JFileChooser(work_dir);
fc.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
fc.addChoosableFileFilter(new DirectoriesChooser());
if (fc.showDialog(this, "Save session to") == JFileChooser.APPROVE_OPTION)
tf_directory.setText(fc.getSelectedFile().getPath());
}
String setDefaultName() {
String def_session_name = "Session1";
if (isFileExist(Configuration.USER_DIR, work_dir)) {
boolean stop = false;
int count = 1;
while (!stop) {
def_session_name = "Session" + String.valueOf(count);
if (isFileExist(work_dir,
work_dir
+ Configuration.SEP
+ def_session_name
+ SessionManager.__SESSION_FILE_EXTENSION))
count++;
else
stop = true;
}
}
return def_session_name;
}
boolean isFileExist(String location, String file_path) {
try {
File file = new File(location);
File[] files = file.listFiles();
if (files != null) {
for (int i = 0; i < files.length; i++) {
if (files[i].getPath().equals(file_path)) {
return true;
}
}
}
} catch (Exception ioe) {
ioe.printStackTrace();
}
return false;
}
void createDirectory(String path) {
try {
File f = new File(path);
if (!f.exists()) {
f.mkdir();
}
} catch (Exception ioe) {
ioe.printStackTrace();
JOptionPane.showMessageDialog(
this,
"Error occurs to create new directory.",
"Error",
JOptionPane.ERROR_MESSAGE);
}
}
protected void processWindowEvent(WindowEvent e) {
if (e.getID() == WindowEvent.WINDOW_CLOSING) {
dispose();
}
super.processWindowEvent(e);
}
class DirectoriesChooser extends javax.swing.filechooser.FileFilter {
public DirectoriesChooser() {
}
public boolean accept(File file) {
return file.isDirectory();
}
public String getDescription() {
return "Directories";
}
}
protected void initHelp() {
CSH.setHelpIDString(this, "working_with_sessions");
}
}
package ca.bcgsc.sockeye.gui.session;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.File;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import ca.bcgsc.sockeye.gui.session.SessionManager;
public class OpenSessionDialog extends JFileChooser{
public OpenSessionDialog(String path) {
super(path);
this.setDialogTitle("Open session");
this.setApproveButtonText("Open session");
this.addPropertyChangeListener(JFileChooser.DIRECTORY_CHANGED_PROPERTY,
(new PropertyChangeListener() {
public void propertyChange(PropertyChangeEvent e) {
setSelectedFile(getCurrentDirectory().getPath());
}
}));
if (SessionManager.getLastSessionPath() == null) setSelectedFile(path);
else setCurrentDirectory(new File(SessionManager.getLastSessionPath()));
}
void setSelectedFile(String path){
File file = new File(path);
File[] files = file.listFiles();
if(files != null){
for (int i = 0; i < files.length; i++) {
if (files[i].getName().equals(this.getCurrentDirectory().getName() +
SessionManager.
__SESSION_FILE_EXTENSION)) {
this.setSelectedFile(files[i]);
return;
}
}
}
this.setSelectedFile(new File("*" + SessionManager.__SESSION_FILE_EXTENSION));
}
public void approveSelection() {
File selectedFile = this.getSelectedFile();
String filename = selectedFile.getName();
if (!(filename.endsWith(SessionManager.__SESSION_FILE_EXTENSION))) {
JOptionPane.showMessageDialog(getParent(),
"Filename must end in " + SessionManager.__SESSION_FILE_EXTENSION,
"Invalid Filename",
JOptionPane.ERROR_MESSAGE);
return;
}
SessionManager.setLastSessionPath(selectedFile.getParent());
super.approveSelection();
}
}
package ca.bcgsc.sockeye.gui.session;
import java.util.StringTokenizer;
import nu.xom.Element;
import nu.xom.Elements;
import ca.bcgsc.util.serialization.AbstractElement;
public class Properties extends AbstractElement {
static final String _TAG_NAME = "properties";
final static String _NAME_ATTRIBUTE = "name";
final static String _VERSION_ATTRIBUTE = "version";
final static String _VIEW_ATTRIBUTE = "view";
final static String _PHRASE_DIVIDER = ",";
final static String _WORD_DIVIDER = "_";
static final int _NAME_INDEX = 0;
static final int _VERSION_INDEX = 1;
static final int _VIEW_INDEX = 2;
public Properties() {
super(_TAG_NAME);
}
public Properties(Element elem) {
super(_TAG_NAME);
Elements elements = elem.getChildElements();
for (int i = 0; i < elements.size(); i++) {
Property property = new Property(elements.get(i));
appendChild(property);
}
}
public Properties(String name, String version, String view) {
super(_TAG_NAME);
addProperty(new Property(_NAME_ATTRIBUTE, name), _NAME_INDEX);
addProperty(new Property(_VERSION_ATTRIBUTE, version), _VERSION_INDEX);
addProperty(new Property(_VIEW_ATTRIBUTE, view),_VIEW_INDEX);
}
public void addProperty(Property property, int index) {
if (property == null)
return;
insertChild(property, getIndex(index));
}
public Property getProperty(String attr_name_value) {
Elements elements = getChildElements();
for (int i = 0; i < elements.size(); i++) {
Element element = elements.get(i);
if (element.getAttributeValue(_NAME_ATTRIBUTE).equals(attr_name_value))
return (Property) element;
}
return null;
}
public boolean removeProperty(String attr_name_value) {
Elements elements = getChildElements();
for (int i = 0; i < elements.size(); i++) {
Element element = elements.get(i);
if (element.getAttributeValue(_NAME_ATTRIBUTE).equals(attr_name_value)) {
removeChild(element);
return true;
}
}
return false;
}
public Properties setSessionName(String name) {
Property property = getProperty(_NAME_ATTRIBUTE);
removeChild(property);
addProperty(property.setValueAttr(name), _NAME_INDEX);
return this;
}
public String getSessionName() {
return getProperty(_NAME_ATTRIBUTE).getValueAttr();
}
public Properties setSessionVersion(String ver) {
Property property = getProperty(_VERSION_ATTRIBUTE);
removeChild(property);
addProperty(property.setValueAttr(ver), _VERSION_INDEX);
return this;
}
public String getSessionVersion() {
return getProperty(_VERSION_ATTRIBUTE).getValueAttr();
}
public Properties setSessionView(String view) {
Property property = getProperty(_VIEW_ATTRIBUTE);
removeChild(property);
addProperty(property.setValueAttr(view), _VIEW_INDEX);
return this;
}
public float[] getSessionView() {
String v = getProperty(_VIEW_ATTRIBUTE).getValueAttr();
if (v == null)
return null;
float[] view_value = new float[5];
StringTokenizer view = new StringTokenizer(v);
int j = 0;
while (view.hasMoreTokens()) {
view_value[j] = Float.parseFloat(view.nextToken("_"));
j++;
}
return view_value;
}
}
package ca.bcgsc.sockeye.gui.session;
import nu.xom.Attribute;
import nu.xom.Element;
import ca.bcgsc.util.serialization.AbstractElement;
public class Property extends AbstractElement {
final static String _PROPERTY_ELEMENT = "property";
final static String _NAME_ATTRIBUTE = "name";
final static String _VALUE_ATTRIBUTE = "value";
public Property(String new_name, String new_value) {
super(_PROPERTY_ELEMENT);
addAttribute(new Attribute(_NAME_ATTRIBUTE, new_name));
addAttribute(new Attribute(_VALUE_ATTRIBUTE, new_value));
}
public Property(Element elem) {
super(_PROPERTY_ELEMENT);
addAttribute(
new Attribute(
_NAME_ATTRIBUTE,
elem.getAttribute(_NAME_ATTRIBUTE).getValue()));
addAttribute(
new Attribute(
_VALUE_ATTRIBUTE,
elem.getAttribute(_VALUE_ATTRIBUTE).getValue()));
}
public Property setValueAttr(String new_value) {
getAttribute(_VALUE_ATTRIBUTE).setValue(new_value);
return this;
}
public String getValueAttr() {
return getAttribute(_VALUE_ATTRIBUTE).getValue();
}
}
package ca.bcgsc.sockeye.gui.session;
import java.util.List;
import javax.swing.JTree;
import nu.xom.Element;
import nu.xom.Elements;
import ca.bcgsc.util.serialization.AbstractElement;
import ca.bcgsc.util.serialization.DataElement;
public class Session extends AbstractElement {
static final String _TAG_NAME = "session";
static final int _PROPERTIES_INDEX = 0;
static final int _FEATURES_INDEX = 1;
static final int _DATA_INDEX = 2;
public Session(Element elem) throws Exception {
super(_TAG_NAME);
Elements elements = elem.getChildElements();
for (int i = 0; i < elements.size(); i++) {
Element child = elements.get(i);
if (child.getLocalName().equals(Properties._TAG_NAME)) {
addProperties(new Properties(child));
continue;
}
if (child.getLocalName().equals(DataElement._TAG_NAME)) {
addData(new DataElement(child));
continue;
}
if (child.getLocalName().equals(Features._TAG_NAME)) {
addFeatures(new Features(child));
continue;
}
}
}
public Session(
String file_session_name,
String sockeye_version,
String view,
JTree faeture_tree)
throws Exception {
super(_TAG_NAME);
addProperties(new Properties(file_session_name, sockeye_version, view));
addFeatures(new Features(faeture_tree));
addData(new DataElement());
}
public Session() {
super(_TAG_NAME);
}
public String getName() {
return getProperties().getSessionName();
}
public void setName(String name) throws Exception {
Properties properties = getProperties();
removeChild(Properties._TAG_NAME);
addProperties(properties.setSessionName(name));
}
public void setVersion(String ver) throws Exception {
Properties properties = getProperties();
removeChild(Properties._TAG_NAME);
addProperties(properties.setSessionVersion(ver));
}
public Properties getProperties() {
Element elem = getChildElement(Properties._TAG_NAME);
if (elem == null)
return null;
return new Properties(elem);
}
public DataElement getData() {
Element elem = getChildElement(DataElement._TAG_NAME);
if (elem == null)
return null;
return (DataElement) elem;
}
public void addProperties(Properties properties) throws Exception {
if (properties == null)
throw new Exception("Properties object is null");
insertChild(properties, getIndex(_PROPERTIES_INDEX));
}
public void addData(DataElement data) throws Exception {
if (data == null)
throw new Exception("DataElement is null");
removeData();
insertChild(data, getIndex(_DATA_INDEX));
}
public void removeData() {
removeChild(DataElement._TAG_NAME);
}
public List getFeaturesList() throws Exception {
Features features = getFeatures();
if (features == null)
throw new Exception(" Cannot get feature list");
return features.getFeatures();
}
public Features getFeatures() {
Element elem = getChildElement(Features._TAG_NAME);
if (elem == null)
return null;
return new Features(elem);
}
public void addFeatures(JTree feature_tree) throws Exception {
try {
addFeatures(new Features(feature_tree));
} catch (Exception e) {
throw new Exception(e.getMessage());
}
}
public void addFeatures(Features features) throws Exception {
if (features == null)
throw new Exception("Fetaures element is null");
removeFeatures();
insertChild(features, getIndex(_FEATURES_INDEX));
}
public void removeFeatures() {
removeChild(Features._TAG_NAME);
}
public float[] getView() {
return getProperties().getSessionView();
}
public void setView(String view) throws Exception{
Properties properties = getProperties();
removeChild(Properties._TAG_NAME);
addProperties(properties.setSessionView(view));
}
}
package ca.bcgsc.sockeye.gui.session;
import java.awt.Color;
import java.io.File;
import java.io.FileOutputStream;
import java.io.Reader;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JOptionPane;
import javax.swing.JTree;
import nu.xom.Builder;
import nu.xom.Document;
import nu.xom.Serializer;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.dataretrieval.DataSourceManager;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.datastorage.SockeyeTrackList;
import ca.bcgsc.sockeye.datastorage.events.StorageEvent;
import ca.bcgsc.sockeye.datastorage.events.StorageEventListener;
import ca.bcgsc.sockeye.gui.MainFrame;
import ca.bcgsc.sockeye.gui.ProgressBar;
import ca.bcgsc.sockeye.gui.Sockeye;
import ca.bcgsc.sockeye.gui.navigation.FeaturePanel;
import ca.bcgsc.sockeye.trackmanager.TrackManager;
import ca.bcgsc.sockeye.trackmanager.TrackManagerFactory;
import ca.bcgsc.sockeye.util.Log;
import ca.bcgsc.sockeye.util.ResourceLoader;
import ca.bcgsc.util.serialization.DataElement;
import ca.bcgsc.util.serialization.ObjectSerializer;
public class SessionManager implements StorageEventListener {
private static SessionManager __instance = null;
public final static String __SESSION_FILE_EXTENSION = ".sks";
public final static String __SESSION_FOLDER = "sessions";
private final static String _ENCODER = "ISO-8859-1";
private Session session;
private File file_session = null;
private String session_name = null;
private boolean _new_data = false;
private ProgressBar progress_bar = null;
private int _ds_event_cheker = 0;
private boolean stop = false;
private float[] view;
private static String _last_session_path = null;
Document doc = null;
static public void resetConfig(String session_name) throws Exception {
__instance = new SessionManager(null, session_name, false, null);
}
static public void resetConfig(
File file_session_,
boolean create_new,
JTree feature_tree)
throws Exception {
__instance =
new SessionManager(file_session_, null, create_new, feature_tree);
}
static public void resetConfig() {
__instance = null;
}
static public SessionManager getInstance() {
return __instance;
}
private SessionManager(
final File file_session_,
String session_name_,
boolean create_new,
JTree feature_tree)
throws Exception {
DataStoreUser.getInstance().getSockeyeTrackList().addStorageListener(this);
file_session = file_session_;
session_name = session_name_;
if (create_new) {
try {
session =
new Session(
file_session.getName(),
Configuration.getVersion(),
getViewString(),
feature_tree);
writeToXML();
Sockeye.__frame.setTitle(getSessionName());
} catch (Exception e) {
e.printStackTrace();
Log.printStackTrace(e);
}
} else {
_ds_event_cheker = 0;
stop = false;
Thread thread = new Thread(new Runnable() {
public void run() {
try {
List objects = getNewObjects();
if (stop) {
return;
}
if (objects == null) {
progress_bar.stop(
" cannot be completed.",
"Error occurs to unserialize object from "
+ getSessionName()
+ ". \nFile may be corrupted or check file format.");
}
loadSession(objects);
Sockeye.__frame.setTitle(getSessionName());
_new_data = false;
} catch (Exception e) {
e.printStackTrace();
Log.printStackTrace(e);
progress_bar.stop(
" cannot be completed.",
"Error occurs to unserialize object from "
+ getSessionName()
+ ". \nFile may be corrupted or check file format.\n"
+ e.getMessage());
} catch (OutOfMemoryError e) {
e.printStackTrace();
Log.printStackTrace(e);
progress_bar.stop(
" cannot be completed.",
"OutOfMemoryError. \nThe Session file "
+ getSessionName()
+ " is too large for the current memory settings.\n"
+ "If you are running Sockeye from a downloaded installer, please, see the online help for how to increase the Java memory size.\n"
+ "If you are running a WebStart it is not possible to increase the memory settings.");
}
}
});
thread.start();
progress_bar =
new ProgressBar(
"Loading session...",
Sockeye.__frame,
getSessionSize() / 1000) {
public void cancel() {
stop = true;
}
};
}
}
private int getSessionSize() {
if (getSessionFile() == null)
return 0;
return (int) getSessionFile().length();
}
public static String getLastSessionPath() {
return _last_session_path;
}
public static void setLastSessionPath(String path) {
_last_session_path = path;
}
public void storageEventReceived(StorageEvent e) {
_ds_event_cheker++;
_new_data = true;
}
public void setNewDataAdded(boolean b) {
_new_data = b;
}
public boolean isNewDataAdded() {
if (!_new_data) {
float[] cur_view = getCurrent3DView();
if (view == null)
return false;
for (int i = 0; i < view.length; i++)
if (view[i] != cur_view[i]) {
_new_data = true;
break;
}
}
return _new_data;
}
public Session getSession() {
return session;
}
public List getFeatureDisplayList() throws Exception {
return getSession().getFeaturesList();
}
public File getSessionFile() {
return file_session;
}
public String getSessionName() {
File file = getSessionFile();
if (file == null)
if (session_name != null)
return session_name;
else
return "Session";
return file.getName().split(__SESSION_FILE_EXTENSION)[0];
}
public List getNewObjects() throws Exception {
Builder builder = new Builder();
if (file_session == null) {
if (session_name != null) {
Reader reader = ResourceLoader.getReader(session_name);
doc = builder.build(reader);
reader.close();
}
} else
doc = builder.build(file_session);
session = new Session(doc.getRootElement());
doc = new Document(session);
if (session == null)
return null;
else {
ObjectSerializer ser = new ObjectSerializer() {
public void processDone() {
if (progress_bar != null)
progress_bar.processDone();
}
};
return (List) ser.unserialize(session.getData());
}
}
void setView() {
view = session.getView();
MainFrame.getVis3D().setViewValues(view);
}
public void setNewName(String name) throws Exception {
session.setName(name);
File session_file = getSessionFile();
File sessions_folder = session_file.getParentFile();
File new_file_session =
new File(
sessions_folder.getPath()
+ Configuration.SEP
+ name
+ __SESSION_FILE_EXTENSION);
session_file.renameTo(new_file_session);
session_file = new_file_session;
writeToXML();
Sockeye.__frame.setTitle(getSessionName());
}
public boolean loadSession(List objects) throws Exception {
try {
if (objects != null && objects.size() == 3) {
FeaturePanel.clearWholeTree();
DataStoreUser.getInstance().setSockeyeTrackList(
(SockeyeTrackList) objects.get(0));
DataStoreUser.getInstance().setDataSourceManager(
(DataSourceManager) objects.get(1));
TrackManagerFactory.getInstance().setTrackManager(
(TrackManager) objects.get(2));
objects = null;
Sockeye.__frame.setVisualizer();
Sockeye.__frame.setEventListeners();
Sockeye.__frame.registerNewStorageManager(
DataStoreUser.getInstance().getSockeyeTrackList());
int _ds_event_count =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.rebuildEventListener();
setView();
FeaturePanel.resetTree(session.getFeaturesList());
while (true) {
if (_ds_event_cheker >= _ds_event_count)
break;
}
progress_bar.processDone();
_new_data = false;
}
} catch (Throwable e) {
e.printStackTrace(System.out);
throw new Exception(e.getMessage());
}
return true;
}
public void closeSession() {
List to_remove =
new ArrayList(
DataStoreUser.getInstance().getSockeyeTrackList().getAllTrackIds());
try {
for (int i = 0; i < to_remove.size(); i++) {
TrackManagerFactory.getInstance().removeTrack(
((Integer) to_remove.get(i)).intValue());
}
} catch (Exception e) {
e.printStackTrace(System.out);
}
DataStoreUser.getInstance().getSockeyeTrackList().removeallTracks();
FeaturePanel.resetPanel();
Sockeye.__frame.setTitle("Sockeye");
MainFrame.getVis3D().setBackgroundColor(Color.BLACK);
MainFrame.getVis3D().setTrackTextColor(Color.WHITE);
resetConfig();
}
public void saveSession(final boolean close, final boolean exit)
throws Exception {
final ObjectSerializer ser = new ObjectSerializer() {
public void processDone() {
if (progress_bar != null)
progress_bar.processDone();
}
};
final List objects = new ArrayList();
objects.add(DataStoreUser.getInstance().getSockeyeTrackList());
objects.add(DataStoreUser.getInstance().getDataSourceManager());
objects.add(TrackManagerFactory.getInstance());
final int feature_count =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getVisibleFeatureCount();
stop = false;
try {
if (DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getAllOrderedTrackIds()
.size()
== 0) {
String mes = "Order track list ";
if (DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getAllTrackIds()
.size()
== 0)
mes = mes + "and Track list ";
throw new Exception(mes + "is empty");
}
DataElement data = ser.serialize(objects);
if (stop)
return;
session.addFeatures(FeaturePanel.getTree());
session.addData(data);
session.setView(getViewString());
writeToXML();
_new_data = false;
if (progress_bar != null)
progress_bar.done();
Sockeye.__frame.setTitle(getSessionName());
if (close)
closeSession();
if (exit)
System.exit(0);
} catch (Exception e) {
e.printStackTrace();
Log.printStackTrace(e);
String mes = e.getMessage();
if (mes == null)
mes = "";
if (progress_bar == null)
progress_bar =
new ProgressBar(
"Saving session...",
Sockeye.__frame,
feature_count / 3) {
public void cancel() {
if (close)
closeSession();
stop = true;
}
};
progress_bar.stop(
" cannot be completed.",
"Error occurs to serialize objects.\n" + e.getMessage());
} catch (OutOfMemoryError e) {
e.printStackTrace();
Log.printStackTrace(e);
if (progress_bar == null)
progress_bar =
new ProgressBar(
"Saving session...",
Sockeye.__frame,
feature_count / 3) {
public void cancel() {
if (close)
closeSession();
stop = true;
}
};
progress_bar.stop(
" cannot be completed.",
"OutOfMemoryError. \nAmount of features: "
+ feature_count
+ ". It is too much for the current memory settings to save the session.\n"
+ "If you are running Sockeye from a downloaded installer, please, see the online help for how to increase the Java memory size.\n"
+ "If you are running a WebStart it is not possible to increase the memory settings.");
}
}
String getViewString() {
float[] view_value = MainFrame.getVis3D().getViewValues();
StringBuffer view = new StringBuffer();
for (int i = 0; i < view_value.length; i++) {
view.append(view_value[i]).append('_');
}
return new String(view);
}
void writeToXML() throws Exception {
if(doc == null)
doc = new Document(session);
FileOutputStream out = new FileOutputStream(getSessionFile());
Serializer ser = new Serializer(out, _ENCODER);
ser.setIndent(1);
ser.write(doc);
}
void createFolder(File parent_file, String folder_name) {
File folder =
new File(parent_file.getPath() + Configuration.SEP + folder_name);
if (!folder.exists())
folder.mkdir();
}
File createFile(File parent_file, String file_name) {
String file_path = parent_file.getPath() + Configuration.SEP + file_name;
try {
File file = new File(file_path);
if (!file.exists())
file.createNewFile();
return file;
} catch (Exception e) {
e.printStackTrace();
Log.printStackTrace(e);
}
return null;
}
void deleteFile(java.io.File file) {
if (!file.delete())
JOptionPane.showMessageDialog(
null,
"Problem to delete " + file.getName(),
"Error",
JOptionPane.ERROR_MESSAGE);
}
public float[] getCurrent3DView() {
return MainFrame.getVis3D().getViewValues();
}
public void setView(float[] view) {
MainFrame.getVis3D().setViewValues(view);
}
}
package ca.bcgsc.sockeye.gui.setoperationdialog;
import javax.swing.*;
import javax.swing.table.*;
import java.awt.event.*;
import java.awt.Component;
public class ResultSetHeaderPopup
extends JPopupMenu {
private TableColumnModel _cmdl;
private TableModel _dmdl;
private JTable _my_table;
private int _column = -1;
private Component _parent;
public ResultSetHeaderPopup(Component parentFrame, JTable t, int column) {
super("Result Set Column Options");
_column = column;
_cmdl = t.getColumnModel();
_dmdl = t.getModel();
_my_table = t;
_parent = parentFrame;
initPopup();
}
private void initPopup() {
JMenuItem search_column = new JMenuItem("Search this column");
JMenuItem hide_column = new JMenuItem("Hide this column");
JMenuItem show_all_columns = new JMenuItem("Show hidden columns");
this.add(search_column);
this.addSeparator();
this.add(hide_column);
this.add(show_all_columns);
if (_cmdl.getColumnCount()==0)
search_column.setEnabled(false);
if (_cmdl.getColumnCount() < 2)
hide_column.setEnabled(false);
if (_dmdl.getColumnCount() == _cmdl.getColumnCount())
show_all_columns.setEnabled(false);
hide_column.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
hideColumnsAction(_column);
}
});
show_all_columns.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
restoreAllColumns();
}
});
search_column.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
searchColumn();
}
});
}
private void hideColumnsAction(int col) {
System.out.println("Hiding columns " + col);
_my_table.setAutoCreateColumnsFromModel(false);
_cmdl.removeColumn(_cmdl.getColumn(col));
}
private void restoreAllColumns() {
System.out.println("Restoring all columns");
_my_table.setAutoCreateColumnsFromModel(true);
}
private void searchColumn() {
String name = _my_table.getColumnName(_column);
SearchDialog dlg = new SearchDialog((JDialog)_parent, _my_table, _column);
dlg.setLocationRelativeTo(null);
dlg.show();
}
}
package ca.bcgsc.sockeye.gui.setoperationdialog;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.JMenuItem;
import javax.swing.JPopupMenu;
public class ResultSetPopup
extends JPopupMenu {
private SetOperationPanel _my_panel;
private int _row_clicked;
private JMenuItem _mi_retain_row = new JMenuItem("Retain only this row");
private JMenuItem _mi_retain_selection = new JMenuItem("Retain only selection");
private JMenuItem _mi_delete_row = new JMenuItem("Delete this row");
private JMenuItem _mi_delete_selection = new JMenuItem("Delete selection");
private JMenuItem _mi_invert = new JMenuItem("Invert selection");
private JMenuItem _mi_clear = new JMenuItem("Clear result set");
public ResultSetPopup(SetOperationPanel p, int row) {
super("Result Set Operations");
_my_panel = p;
_row_clicked = row;
init();
pack();
}
public void init() {
boolean has_selected_rows = _my_panel.getSelectedRowCount() == 0;
add(_mi_retain_row);
add(_mi_retain_selection);
addSeparator();
add(_mi_delete_row);
add(_mi_delete_selection);
addSeparator();
add(_mi_invert);
add(_mi_clear);
if (has_selected_rows){
_mi_delete_selection.setEnabled(false);
_mi_retain_selection.setEnabled(false);
_mi_invert.setEnabled(false);
}
else
_mi_delete_selection.setText("Delete " + _my_panel.getSelectedRowCount() +
" selected features");
_mi_invert.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
_my_panel.invertTableSelection();
}
});
_mi_retain_selection.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
_my_panel.retainSelection();
}
});
_mi_retain_row.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
_my_panel.retainRow(_row_clicked);
}
});
_mi_delete_row.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
_my_panel.deleteRow(_row_clicked);
}
});
_mi_delete_selection.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
_my_panel.deleteSelectedRows();
}
});
_mi_clear.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
_my_panel.deleteResultSet();
}
});
}
}
package ca.bcgsc.sockeye.gui.setoperationdialog;
import java.awt.BorderLayout;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.HeadlessException;
import java.awt.Insets;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.text.NumberFormat;
import java.text.ParseException;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.InputVerifier;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTable;
import javax.swing.JTextField;
public class SearchDialog
extends JDialog
implements ActionListener {
private static final String _ACTION_CLOSE = "_CLOSE_";
private static final String _ACTION_APPLY = "_APPLY_";
private static final String _ACTION_OK = "_OK_";
private final NumberFormat _my_formatter = NumberFormat.getNumberInstance();
private String[] _comp_smaller = new String[] {
"<=", "<"};
private String[] _comp_greater = new String[] {
">=", ">"};
private JComboBox _cmp_gt_cb = new JComboBox(_comp_greater);
private JComboBox _cmp_st_cb = new JComboBox(_comp_smaller);
private JTextField _regex_tf = new JTextField(10);
private NumberFormat n1 = NumberFormat.getNumberInstance();
private JTextField _min_val_tf = new JTextField();
private JTextField _max_val_tf = new JTextField();
private JTable _my_table;
private int _column;
public SearchDialog(JDialog owner, JTable t, int c) throws HeadlessException {
super(owner, "Search Column \"" + t.getColumnName(c)+"\"", false);
_my_table = t;
_column = c;
init();
owner.addWindowListener(new WindowAdapter() {
public void windowClosing(WindowEvent e) {
SearchDialog.this.hide();
}
});
}
public void actionPerformed(ActionEvent e) {
String regex = _regex_tf.getText();
double min = 0;
double max = 0;
Number min_o = null;
Number max_o = null;
if (e.getActionCommand().equals(_ACTION_CLOSE) ||
e.getActionCommand().equals(_ACTION_OK)) {
hide();
}
try {
min_o = _my_formatter.parse(_min_val_tf.getText());
min = min_o.doubleValue();
}
catch (ParseException ex1) {
}
try {
max_o = _my_formatter.parse(_max_val_tf.getText());
max = max_o.doubleValue();
}
catch (ParseException ex2) {
}
boolean min_valid = !(min_o==null && _min_val_tf.getText().trim().length()>0);
boolean max_valid = !(max_o==null && _max_val_tf.getText().trim().length()>0);
if (regex.length() == 0 && _min_val_tf.getText().trim().length()==0 && _max_val_tf.getText().trim().length()==0) {
_my_table.clearSelection();
return;
}
if (e.getActionCommand().equals(_ACTION_APPLY) ||
e.getActionCommand().equals(_ACTION_OK)) {
_my_table.clearSelection();
for (int i = 0; i < _my_table.getRowCount(); i++) {
Object value_o = _my_table.getModel().getValueAt(i, _column);
boolean matches = (regex.length() == 0) ||
value_o.toString().matches(regex);
boolean min_match;
boolean max_match;
double value = Double.NaN;
try {
value = Double.parseDouble(value_o.toString());
}
catch (NumberFormatException ex) {
}
min_match = (min_o == null) || (value != Double.NaN && (_cmp_st_cb.getSelectedIndex()==0?value <= min:value<min));
max_match = (max_o == null) || (value != Double.NaN && (_cmp_gt_cb.getSelectedIndex()==0?value >= max:value>max));
if (matches && min_match && max_match)
_my_table.addRowSelectionInterval(i, i);
}
int r = _my_table.getSelectedRow();
if (r >=0 )
_my_table.scrollRectToVisible(_my_table.getCellRect(r, 0, false));
}
}
private void init() {
setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);
this.getContentPane().setLayout(new BorderLayout());
SearchFieldVerifier v1 = new SearchFieldVerifier();
SearchFieldVerifier v2 = new SearchFieldVerifier();
JLabel regex_label = new JLabel("Matching regEx:");
JLabel value_label = new JLabel("Value ");
if (_my_table.getModel().getColumnClass(_column).getSuperclass() != java.lang.Number.class){
_min_val_tf.setEnabled(false);
_max_val_tf.setEnabled(false);
value_label.setEnabled(false);
_cmp_gt_cb.setEnabled(false);
_cmp_st_cb.setEnabled(false);
}
_min_val_tf.setInputVerifier(v1);
_max_val_tf.setInputVerifier(v2);
GridBagLayout gbl = new GridBagLayout();
GridBagConstraints gbc = new GridBagConstraints();
JPanel main_panel = new JPanel(gbl);
JButton done_button = new JButton("OK");
JButton apply_button = new JButton("Apply");
JButton close_button = new JButton("Close");
this.getRootPane().setDefaultButton(apply_button);
done_button.setActionCommand(_ACTION_OK);
apply_button.setActionCommand(_ACTION_APPLY);
close_button.setActionCommand(_ACTION_CLOSE);
done_button.addActionListener(this);
apply_button.addActionListener(this);
close_button.addActionListener(this);
gbc.anchor = GridBagConstraints.CENTER;
gbc.gridx = 0;
gbc.gridy = 0;
gbc.gridwidth = 2;
gbc.insets = new Insets(0, 0, 10, 10);
main_panel.add(regex_label, gbc);
gbc.fill = GridBagConstraints.HORIZONTAL;
gbc.insets = new Insets(0, 10, 10, 0);
gbc.gridwidth = 1;
gbc.gridx = 2;
main_panel.add(_regex_tf, gbc);
gbc.insets = new Insets(0, 0, 0, 0);
gbc.gridx = 1;
gbc.gridy = 2;
main_panel.add(_cmp_st_cb, gbc);
gbc.gridx = 1;
gbc.gridy = 3;
main_panel.add(_cmp_gt_cb, gbc);
gbc.gridx = 2;
gbc.gridy = 2;
gbc.insets = new Insets(0, 10, 0, 0);
main_panel.add(_min_val_tf, gbc);
gbc.gridx = 2;
gbc.gridy = 3;
main_panel.add(_max_val_tf, gbc);
gbc.fill = GridBagConstraints.HORIZONTAL;
gbc.gridheight = 2;
gbc.insets = new Insets(0, 0, 0, 10);
gbc.gridx = 0;
gbc.gridy = 1;
main_panel.add(value_label, gbc);
Box b = Box.createHorizontalBox();
b.add(Box.createHorizontalGlue());
b.add(done_button);
b.add(apply_button);
b.add(close_button);
b.add(Box.createHorizontalGlue());
main_panel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
b.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
this.getContentPane().add(main_panel, BorderLayout.CENTER);
this.getContentPane().add(b, BorderLayout.SOUTH);
pack();
}
class SearchFieldVerifier
extends InputVerifier
implements ActionListener {
NumberFormat format = NumberFormat.getInstance();
public boolean shouldYieldFocus(JComponent input) {
boolean inputOK = verify(input);
if (inputOK) {
return true;
}
else {
Toolkit.getDefaultToolkit().beep();
return false;
}
}
public boolean verify(JComponent input) {
boolean wasValid = true;
JTextField tf = (JTextField) input;
double value = 0;
if (tf.getText().trim().length() == 0)
return true;
try {
value = format.parse(tf.getText()).doubleValue();
}
catch (ParseException pe) {
wasValid = false;
}
tf.setText(format.format(value));
tf.selectAll();
return wasValid;
}
public void actionPerformed(ActionEvent e) {
JTextField source = (JTextField) e.getSource();
shouldYieldFocus(source);
source.selectAll();
}
}
}
package ca.bcgsc.sockeye.gui.setoperationdialog;
import java.awt.BorderLayout;
import java.awt.Frame;
import java.awt.HeadlessException;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.JButton;
import javax.swing.JDialog;
import javax.swing.JSplitPane;
import ca.bcgsc.sockeye.datastorage.SockeyeTrackList;
public class SetOperationDialog extends JDialog {
private TrackFeatureSetSelectionPanel _tfsp = new TrackFeatureSetSelectionPanel();
private SetOperationPanel _sop = new SetOperationPanel();
private JSplitPane _main_split_pane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, _tfsp, _sop);
private JButton _exit_button = new JButton("Close");
private SockeyeTrackList _my_storage_manager;
public SetOperationDialog(Frame owner, SockeyeTrackList stl) throws HeadlessException {
super (owner, "Set Operation", false);
_my_storage_manager = stl;
_tfsp.setSockeyeTrackList(stl);
_sop.setSockeyeTrackList(stl);
_sop.registerTFSP(_tfsp);
_tfsp.registerSOP(_sop);
initDialog();
pack();
}
public void registerNewStorageManager(SockeyeTrackList stl){
_my_storage_manager = stl;
_tfsp.setSockeyeTrackList(stl);
_sop.setSockeyeTrackList(stl);
}
private void initDialog(){
_tfsp.setToolTipText("Select tracks and features that operations should work on");
_sop.setToolTipText("Select the operation here. The result set is displayed in the center-table.");
_main_split_pane.setContinuousLayout(true);
_main_split_pane.setOneTouchExpandable(false);
Box button_box_south = Box.createHorizontalBox();
button_box_south.add(Box.createHorizontalGlue());
button_box_south.add(_exit_button);
button_box_south.add(Box.createHorizontalGlue());
button_box_south.setBorder(BorderFactory.createEmptyBorder(10,10,10,10));
_exit_button.setToolTipText("Close this dialog");
_exit_button.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
SetOperationDialog.this.hide();
}});
this.setDefaultCloseOperation(JDialog.HIDE_ON_CLOSE);
this.getContentPane().add(_main_split_pane, BorderLayout.CENTER);
this.getContentPane().add(button_box_south, BorderLayout.SOUTH);
}
}
package ca.bcgsc.sockeye.gui.setoperationdialog;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Vector;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;
import javax.swing.UIManager;
import javax.swing.border.TitledBorder;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import javax.swing.event.TableModelEvent;
import javax.swing.event.TableModelListener;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.JTableHeader;
import javax.swing.table.TableColumnModel;
import org.biojava.bio.program.gff.GFFTools;
import ca.bcgsc.sockeye.datastorage.SockeyeTrackList;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.gui.MarkRegionDialog;
import ca.bcgsc.sockeye.gui.util.ImageLoader;
public class SetOperationPanel
extends JPanel
implements ActionListener, TableModelListener, ListSelectionListener {
private static final String _ACTION_INTERS = "__intersect__";
private static final String _ACTION_SUB = "__subtract__";
private static final String _ACTION_ADD = "__add__";
private static final String _ACTION_SAVE = "__save__";
private static final String _ACTION_CLEAR = "__clear__";
private static final String _ACTION_PREVIEW = "__preview__";
private static final String _ACTION_CREATE_REGIONS = "__create_regions__";
private static final String _NO_SCORE_AVAIL = "n/a";
private static final String _NEG_FEAT_PREF = "NEG_FEAT";
private static final String _RESULT_TABLE_BORDER_TITLE = "Result Set";
private TitledBorder _result_set_border;
private JButton button_inters = new JButton("Intersect");
private JButton button_sub = new JButton("Subtract");
private JButton button_add = new JButton("Add/Union");
private JButton button_save = new JButton("Store");
private JButton button_clear = new JButton("Clear");
private JButton button_prev = new JButton("Highlight 3D");
private JButton button_create_regions = new JButton("Create regions");
private JTable _result_set_table;
private DefaultTableModel _result_set_tm;
private JTextField _new_feature_name_tf;
private SockeyeTableSorter _result_set_sorter;
private SockeyeTrackList _my_storage_manager;
private TrackFeatureSetSelectionPanel _tfsp;
private ArrayList _op_feature_set = new ArrayList();
private ArrayList _op_feature_set_neg = new ArrayList();
private ArrayList _op_tracks = new ArrayList();
private static final int __MSG_BOX_NEG_FEAT_ADD = 0;
private static final int __MSG_BOX_FEAT_DELETE = 1;
private boolean[] _do_ask_me = new boolean[2];
public SetOperationPanel() {
initPanel();
}
public void setSockeyeTrackList(SockeyeTrackList t) {
_my_storage_manager = t;
}
synchronized public void availableTrackOrFeatureStateChanged() {
_op_feature_set_neg.clear();
_op_feature_set.clear();
_op_tracks.clear();
_tfsp.getSelectedFeatureSets(_op_feature_set, _op_feature_set_neg);
_tfsp.getSelectedTrackIds(_op_tracks);
updateButtonEnableState();
}
public void registerTFSP(TrackFeatureSetSelectionPanel p) {
this._tfsp = p;
}
void retainRow(int row) {
Vector data = _result_set_tm.getDataVector();
Vector newdata = (Vector) data.elementAt(row);
if (this
.popupWarningMessage(
__MSG_BOX_FEAT_DELETE,
String.valueOf(data.size() - 1))) {
deleteResultSet();
_result_set_tm.addRow(newdata);
}
}
void retainSelection() {
invertTableSelection();
deleteSelectedRows();
}
void invertTableSelection() {
int[] rows = _result_set_table.getSelectedRows();
_result_set_table.selectAll();
for (int r = 0; r < rows.length; r++)
_result_set_table.removeRowSelectionInterval(rows[r], rows[r]);
}
void deleteResultSet() {
if (this.popupWarningMessage(__MSG_BOX_FEAT_DELETE, " all "))
_result_set_tm.setRowCount(0);
}
void createRegions() {
Enumeration table_data = _result_set_tm.getDataVector().elements();
ArrayList fl = null;
while (table_data.hasMoreElements()) {
Vector row = (Vector) table_data.nextElement();
Integer track = (Integer) row.get(6);
String acc_id = row.get(1).toString();
String feature_name = row.get(0).toString();
if (fl == null) {
fl = new ArrayList();
}
fl.add(
_my_storage_manager.getFeature(track.intValue(), feature_name, acc_id));
}
MarkRegionDialog.show(this, fl, true);
}
void deleteSelectedRows() {
int[] rows = _result_set_table.getSelectedRows();
if (this
.popupWarningMessage(
__MSG_BOX_FEAT_DELETE,
String.valueOf(rows.length))) {
deleteRows(rows);
_result_set_table.clearSelection();
}
}
void deleteRow(int row) {
if (row < 0 || row >= _result_set_tm.getRowCount())
throw new IllegalArgumentException(
"Illegal row to remove in result set table: " + row);
if (this.popupWarningMessage(__MSG_BOX_FEAT_DELETE, " 1 "))
_result_set_tm.removeRow(_result_set_sorter.getUnSortedRowIndex(row));
}
int getSelectedRowCount() {
return _result_set_table.getSelectedRowCount();
}
private void deleteRows(int[] rows) {
int counter;
for (counter = 0; counter < rows.length; counter++)
rows[counter] = _result_set_sorter.getUnSortedRowIndex(rows[counter]);
Arrays.sort(rows);
for (counter = rows.length - 1; counter >= 0; counter--)
_result_set_tm.removeRow(rows[counter]);
}
private void intersectActionPerformed() {
int overl_val = _tfsp.getOverlapValue();
int units = _tfsp.getOverlapUnit();
int num_match_sets = _tfsp.getNumOverlapSet() - 1;
ArrayList argument_feature_sets = new ArrayList();
ArrayList neg_argument_feature_sets = new ArrayList();
ArrayList result_set = new ArrayList();
HashMap feature_hit_reference_map = new HashMap();
TrackFeature dummy = new TrackFeature();
if (overl_val <= 0
|| (overl_val > 100
&& units == TrackFeatureSetSelectionPanel.OVERLAP_UNIT_PERCENT)) {
JOptionPane.showMessageDialog(
null,
"You specified an invalid number in the overlap value field!\nPlease correct this first...",
"Overlap value error",
JOptionPane.WARNING_MESSAGE);
return;
}
for (Iterator fit = _op_feature_set.iterator(); fit.hasNext();) {
ArrayList tmplist = new ArrayList();
String feature = fit.next().toString();
if (feature.equals(_tfsp.getCurrentResultSetCheckBoxTitle()))
tmplist.addAll(resultSet2TrackFeatures());
else
for (Iterator tit = _op_tracks.iterator(); tit.hasNext();) {
int track_id = Integer.parseInt(tit.next().toString());
Collection fcol = _my_storage_manager.getFeatures(track_id, feature);
if (fcol != null && !fcol.isEmpty())
tmplist.addAll(fcol);
}
if (tmplist != null && !tmplist.isEmpty())
argument_feature_sets.add(tmplist);
}
for (Iterator nfit = _op_feature_set_neg.iterator(); nfit.hasNext();) {
ArrayList tmplist = new ArrayList();
String feature = nfit.next().toString();
if (feature.equals(_tfsp.getCurrentResultSetCheckBoxTitle()))
tmplist.addAll(resultSet2TrackFeatures());
else
for (Iterator tit = _op_tracks.iterator(); tit.hasNext();) {
int track_id = Integer.parseInt(tit.next().toString());
Collection fcol = _my_storage_manager.getFeatures(track_id, feature);
if (fcol != null && !fcol.isEmpty())
tmplist.addAll(fcol);
}
if (tmplist != null && !tmplist.isEmpty()) {
neg_argument_feature_sets.add(tmplist);
}
}
for (int set_index = 0;
set_index < argument_feature_sets.size();
set_index++) {
Collection arg_set = (Collection) argument_feature_sets.get(set_index);
for (Iterator arg_set_feature_it = arg_set.iterator();
arg_set_feature_it.hasNext();
) {
TrackFeature arg_set_feature = (TrackFeature) arg_set_feature_it.next();
for (int comp_set_index = set_index + 1;
comp_set_index < argument_feature_sets.size();
comp_set_index++) {
Collection comp_set =
(Collection) argument_feature_sets.get(comp_set_index);
for (Iterator comp_set_feature_it = comp_set.iterator();
comp_set_feature_it.hasNext();
) {
TrackFeature comp_set_feature =
(TrackFeature) comp_set_feature_it.next();
if (doesOverlap(arg_set_feature,
comp_set_feature,
overl_val,
units)) {
ArrayList f1_o =
(ArrayList) feature_hit_reference_map.get(arg_set_feature);
ArrayList f2_o =
(ArrayList) feature_hit_reference_map.get(comp_set_feature);
if (f1_o == null) {
f1_o = new ArrayList();
feature_hit_reference_map.put(arg_set_feature, f1_o);
}
if (f2_o == null) {
f2_o = new ArrayList();
feature_hit_reference_map.put(comp_set_feature, f2_o);
}
f1_o.add(comp_set_feature);
f2_o.add(arg_set_feature);
}
}
}
for (int comp_set_index = 0;
comp_set_index < neg_argument_feature_sets.size();
comp_set_index++) {
Collection neg_comp_set =
(Collection) neg_argument_feature_sets.get(comp_set_index);
boolean does_match_one = false;
for (Iterator comp_set_feature_it = neg_comp_set.iterator();
comp_set_feature_it.hasNext();
) {
TrackFeature neg_comp_set_feature =
(TrackFeature) comp_set_feature_it.next();
if (doesOverlap(arg_set_feature,
neg_comp_set_feature,
overl_val,
units)) {
does_match_one = true;
break;
}
}
if (!does_match_one) {
ArrayList f1_o =
(ArrayList) feature_hit_reference_map.get(arg_set_feature);
if (f1_o == null) {
f1_o = new ArrayList();
feature_hit_reference_map.put(arg_set_feature, f1_o);
}
f1_o.add(dummy);
}
}
}
}
for (Iterator inters_set_it = feature_hit_reference_map.keySet().iterator();
inters_set_it.hasNext();
) {
TrackFeature tf = (TrackFeature) inters_set_it.next();
if (tf == dummy)
continue;
if (tf.getFeature().startsWith(_NEG_FEAT_PREF))
continue;
List matchlist = (List) (feature_hit_reference_map.get(tf));
int net_matchcount = matchlist.size();
if (net_matchcount >= num_match_sets) {
for (Iterator it =
((List) (feature_hit_reference_map.get(tf))).iterator();
it.hasNext();
) {
TrackFeature f = (TrackFeature) it.next();
if (f == dummy)
continue;
List ml_cpy =
new ArrayList((List) (feature_hit_reference_map.get(f)));
ml_cpy.retainAll(matchlist);
if (!(ml_cpy.size() >= num_match_sets - 1))
net_matchcount--;
}
if (net_matchcount >= num_match_sets)
result_set.add(tf);
}
}
addTrackFeaturesToResultSetTable(result_set);
}
private Collection negateFeatureSet(List tfs) {
ArrayList neg_list = new ArrayList();
int start, end;
if (tfs == null || tfs.size() == 0)
return neg_list;
Collections.sort(tfs);
for (int i = 0; i < tfs.size() - 1; i++) {
start = ((TrackFeature) tfs.get(i)).getEnd();
end = ((TrackFeature) tfs.get(i + 1)).getStart();
TrackFeature new_region =
new TrackFeature(
"NO__ACC",
"Set operation dialog",
_NEG_FEAT_PREF,
start,
end,
GFFTools.NO_SCORE,
0,
GFFTools.NO_FRAME);
neg_list.add(new_region);
}
start = ((TrackFeature) tfs.get(tfs.size() - 1)).getEnd();
end = Integer.MAX_VALUE;
neg_list.add(
new TrackFeature(
"NO__ACC",
"Set operation dialog",
_NEG_FEAT_PREF,
start,
end,
GFFTools.NO_SCORE,
0,
GFFTools.NO_FRAME));
start = 0;
end = ((TrackFeature) tfs.get(0)).getStart();
if (end > 0)
neg_list.add(
new TrackFeature(
"NO__ACC",
"Set operation dialog",
_NEG_FEAT_PREF,
start,
end,
GFFTools.NO_SCORE,
0,
GFFTools.NO_FRAME));
return neg_list;
}
private boolean doesOverlap(
TrackFeature tfa,
TrackFeature tfb,
int ovl,
int metric) {
if (tfa.getEnd() < tfb.getStart() || tfb.getEnd() < tfa.getStart())
return false;
int ovl_thres = ovl;
if (metric == TrackFeatureSetSelectionPanel.OVERLAP_UNIT_PERCENT)
if ((tfa.getEnd() - tfa.getStart()) <= (tfb.getEnd() - tfb.getStart()))
ovl_thres = (tfa.getEnd() - tfa.getStart()) * ovl / 100;
else
ovl_thres = (tfb.getEnd() - tfb.getStart()) * ovl / 100;
int true_ovl =
(int) (Math.min(tfa.getEnd(), tfb.getEnd())
- Math.max(tfa.getStart(), tfb.getStart()));
return true_ovl >= ovl_thres;
}
private void addActionPerformed() {
popupWarningMessage(__MSG_BOX_NEG_FEAT_ADD, null);
for (Iterator tit = _op_tracks.iterator(); tit.hasNext();) {
int track_id = Integer.parseInt(tit.next().toString());
for (Iterator fit = _op_feature_set.iterator(); fit.hasNext();) {
Collection fcol =
_my_storage_manager.getFeatures(track_id, fit.next().toString());
addTrackFeaturesToResultSetTable(fcol);
}
}
}
private void subActionPerformed() {
_result_set_table.clearSelection();
for (Iterator tit = _op_tracks.iterator(); tit.hasNext();) {
int track_id = Integer.parseInt(tit.next().toString());
for (Iterator fit = _op_feature_set.iterator(); fit.hasNext();) {
Collection fcol =
_my_storage_manager.getFeatures(track_id, fit.next().toString());
addTrackFeaturesToTableSelection(fcol);
}
}
deleteSelectedRows();
}
private void addTrackFeaturesToTableSelection(Collection fs) {
if (fs == null || fs.isEmpty())
return;
Vector table_data = _result_set_tm.getDataVector();
for (Iterator fit = fs.iterator(); fit.hasNext();) {
Vector row_v =
new Vector(
Arrays.asList(trackFeature2TableRow((TrackFeature) fit.next())));
int index = table_data.indexOf(row_v);
if (index < 0)
continue;
int row = _result_set_sorter.getSortedRowIndex(index);
_result_set_table.addRowSelectionInterval(row, row);
}
}
private Collection resultSet2TrackFeatures() {
ArrayList res_fs = new ArrayList();
Vector table_data = _result_set_tm.getDataVector();
for (Iterator tr_it = table_data.iterator(); tr_it.hasNext();) {
Vector row = (Vector) tr_it.next();
String fname = (String) row.get(0);
String acc_id = (String) row.get(1);
int track_id = Integer.parseInt(row.get(5).toString());
int start = Integer.parseInt(row.get(2).toString());
int end = Integer.parseInt(row.get(3).toString());
TrackFeature tf = _my_storage_manager.getFeature(track_id, fname, acc_id);
System.out.println("NAme: " + fname + " + TF " + tf);
if (tf == null && fname.equals("region")){
System.out.println("Creating region!!!!!!");
tf = new TrackFeature(acc_id, "SOI", fname, start, end, GFFTools.NO_SCORE, 0, GFFTools.NO_FRAME);
tf.setAccessionID(acc_id);
}
res_fs.add(tf);
}
return res_fs;
}
public void addTrackFeaturesToResultSetTable(Collection tf_col) {
if (tf_col == null)
return;
Vector oldValues = _result_set_tm.getDataVector();
Vector newValues = new Vector();
for (Iterator tf_it = tf_col.iterator(); tf_it.hasNext();) {
newValues.add(
new Vector(
Arrays.asList(trackFeature2TableRow((TrackFeature) tf_it.next()))));
}
newValues.removeAll(oldValues);
for (Iterator rit = newValues.iterator(); rit.hasNext();)
_result_set_tm.addRow((Vector) rit.next());
}
private Object[] trackFeature2TableRow(TrackFeature tf) {
boolean scored = (tf.getScore() != GFFTools.NO_SCORE);
Object[] row =
new Object[] {
tf.getFeature(),
tf.getAccessionID(),
new Integer(tf.getStart()),
new Integer(tf.getEnd()),
scored ? String.valueOf(tf.getScore()) : _NO_SCORE_AVAIL,
tf.getStrand().toString(),
new Integer(tf.getTrackId())};
return row;
}
private void updateButtonEnableState() {
boolean op_feat_avail = _op_feature_set.size() > 0;
boolean rows_avail = _result_set_tm.getRowCount() > 0;
button_add.setEnabled(op_feat_avail);
button_inters.setEnabled(
_op_feature_set.size() + _op_feature_set_neg.size() > 1);
button_sub.setEnabled(rows_avail && op_feat_avail);
button_clear.setEnabled(rows_avail);
button_save.setEnabled(rows_avail);
button_create_regions.setEnabled(rows_avail);
}
public void tableChanged(TableModelEvent e) {
_tfsp.setCurrentResultSetCheckBoxVisible(_result_set_tm.getRowCount() > 0);
updateButtonEnableState();
updateTableBorder();
}
public void actionPerformed(ActionEvent e) {
if (e.getActionCommand().equals(_ACTION_ADD))
addActionPerformed();
if (e.getActionCommand().equals(_ACTION_SUB))
subActionPerformed();
if (e.getActionCommand().equals(_ACTION_CLEAR))
deleteResultSet();
if (e.getActionCommand().equals(_ACTION_SAVE))
saveResultSetActionPerformed();
if (e.getActionCommand().equals(_ACTION_INTERS))
intersectActionPerformed();
if (e.getActionCommand().equals(_ACTION_CREATE_REGIONS))
createRegions();
}
public void valueChanged(ListSelectionEvent e) {
if (e.getValueIsAdjusting())
return;
updateTableBorder();
}
private void saveResultSetActionPerformed() {
String name = _new_feature_name_tf.getText().trim();
if (name.length() == 0) {
JOptionPane.showMessageDialog(
null,
"Please provide a name for the new feature set\nusing the text field above the button row",
"Missing name",
JOptionPane.WARNING_MESSAGE);
return;
}
if (_my_storage_manager.getFeatureNames().contains(name)) {
JOptionPane.showMessageDialog(
null,
"The feature set name you specified already exists!\nPlease specify a unique name!",
"Missing name",
JOptionPane.WARNING_MESSAGE);
return;
}
Enumeration table_data = _result_set_tm.getDataVector().elements();
Map features_to_add = new HashMap();
while (table_data.hasMoreElements()) {
Vector row = (Vector) table_data.nextElement();
Integer track = (Integer) row.get(6);
String acc_id = row.get(1).toString();
String feature_name = row.get(0).toString();
ArrayList fl = (ArrayList) features_to_add.get(track);
if (fl == null) {
fl = new ArrayList();
features_to_add.put(track, fl);
}
int start = Integer.parseInt(row.get(2).toString());
int end = Integer.parseInt(row.get(3).toString());
TrackFeature tf = _my_storage_manager.getFeature(track.intValue(), feature_name, acc_id);
if (tf == null && feature_name.equals("region")){
tf = new TrackFeature(acc_id, "SOI", feature_name, start, end, GFFTools.NO_SCORE, 0, GFFTools.NO_FRAME);
tf.setAccessionID(acc_id);
}
fl.add(tf);
}
for (Iterator it = features_to_add.keySet().iterator(); it.hasNext();) {
Integer track = (Integer) it.next();
_my_storage_manager.addFeatures(
track.intValue(),
name,
(ArrayList) features_to_add.get(track));
}
_new_feature_name_tf.setText("");
}
private void updateTableBorder() {
String title = _RESULT_TABLE_BORDER_TITLE;
int rows = _result_set_tm.getRowCount();
int selected = _result_set_table.getSelectedRowCount();
if (rows > 0) {
title += " (" + rows + " entries";
if (selected > 0)
title += " - " + selected + " selected";
title += ")";
}
_result_set_border.setTitle(title);
this.repaint();
}
private boolean popupWarningMessage(int type, Object parameters) {
JCheckBox _cb_ask_me_again = new JCheckBox("Don't show this warning again");
_cb_ask_me_again.setHorizontalTextPosition(JCheckBox.LEFT);
if (type < 0 || type > _do_ask_me.length - 1 || !_do_ask_me[type])
return true;
Object[] options_OK = { _cb_ask_me_again, "OK" };
Object[] options_OK_CANCEL = { _cb_ask_me_again, "OK", "CANCEL" };
int index = 0;
switch (type) {
case __MSG_BOX_NEG_FEAT_ADD :
if (_op_feature_set_neg.size() > 0)
index =
JOptionPane.showOptionDialog(
null,
"Some of the features sets you selected are negated!\nThose are not added to the result set!",
"Warning",
JOptionPane.DEFAULT_OPTION,
JOptionPane.WARNING_MESSAGE,
null,
options_OK,
options_OK[1]);
break;
case __MSG_BOX_FEAT_DELETE :
index =
JOptionPane.showOptionDialog(
null,
"You are about to delete "
+ parameters.toString()
+ " features\n"
+ "from the result set. Are you shure you want to do this?",
"Warning",
JOptionPane.DEFAULT_OPTION,
JOptionPane.WARNING_MESSAGE,
null,
options_OK_CANCEL,
options_OK_CANCEL[1]);
break;
}
_do_ask_me[type] = !_cb_ask_me_again.isSelected();
return (index == 1);
}
private void initPanel() {
Arrays.fill(_do_ask_me, true);
Box button_box_north = Box.createHorizontalBox();
Box button_box_south = Box.createHorizontalBox();
button_box_north.setToolTipText("Available set operations");
button_box_south.setToolTipText("Result set table content handling");
button_box_north.setBorder(
BorderFactory.createCompoundBorder(
BorderFactory.createTitledBorder("Operation"),
BorderFactory.createEmptyBorder(5, 5, 5, 5)));
JPanel result_set_panel = new JPanel();
result_set_panel.setToolTipText(
"The set resulting from the last set operation.");
GridBagLayout result_gbl = new GridBagLayout();
GridBagConstraints result_gbc = new GridBagConstraints();
result_set_panel.setLayout(result_gbl);
_result_set_border =
BorderFactory.createTitledBorder(_RESULT_TABLE_BORDER_TITLE);
result_set_panel.setBorder(_result_set_border);
String[] column_names =
new String[] {
"Feature",
"Acc.-ID",
"Start",
"End",
"Score",
"Strand",
"Track" };
_result_set_tm =
new DefaultTableModel(new String[0][column_names.length], column_names) {
public boolean isCellEditable(int row, int column) {
return false;
}
};
_result_set_sorter = new SockeyeTableSorter(_result_set_tm);
_result_set_table = new JTable(_result_set_sorter);
_result_set_sorter.addMouseListenerToHeaderInTable(_result_set_table);
_result_set_table.getTableHeader().setToolTipText(
"Click on a column to sort. Click multiple times to change sort order. Right-click to get options.");
_result_set_sorter.setColumnClass(2, Integer.class);
_result_set_sorter.setColumnClass(3, Integer.class);
_result_set_sorter.setColumnClass(4, Integer.class);
_result_set_sorter.setColumnClass(6, Integer.class);
_result_set_table.setToolTipText(
"The set resulting from the last set operation.");
_result_set_table.setPreferredScrollableViewportSize(
new Dimension(600, 200));
for (int col = 0;
col
< _result_set_table.getTableHeader().getColumnModel().getColumnCount();
col++)
_result_set_table
.getTableHeader()
.getColumnModel()
.getColumn(col)
.setHeaderRenderer(new IconTextCellRenderer());
_result_set_tm.addTableModelListener(this);
_result_set_table.getSelectionModel().addListSelectionListener(this);
JScrollPane scrollPane = new JScrollPane(_result_set_table);
scrollPane.setToolTipText("The set resulting from the last set operation.");
_new_feature_name_tf = new JTextField(15);
_new_feature_name_tf.setToolTipText(
"Enter a name for the new result set here");
button_inters.setEnabled(false);
button_sub.setEnabled(false);
button_add.setEnabled(false);
button_save.setEnabled(false);
button_clear.setEnabled(false);
button_prev.setEnabled(false);
button_create_regions.setEnabled(false);
button_inters.setToolTipText(
"Add the intersection of all seleccted sets to the result set table");
button_sub.setToolTipText(
"Subtract the selected feature sets from the result set");
button_add.setToolTipText(
"Add all seleccted features sets to the result set table");
button_save.setToolTipText(
"Save the current result sat under the specified name");
button_clear.setToolTipText("Clear the result set table");
button_prev.setToolTipText("Preview the result set in 3D");
button_create_regions.setToolTipText(
"Create regions for all features in result set table");
button_inters.setActionCommand(_ACTION_INTERS);
button_sub.setActionCommand(_ACTION_SUB);
button_add.setActionCommand(_ACTION_ADD);
button_save.setActionCommand(_ACTION_SAVE);
button_clear.setActionCommand(_ACTION_CLEAR);
button_prev.setActionCommand(_ACTION_PREVIEW);
button_create_regions.setActionCommand(_ACTION_CREATE_REGIONS);
button_inters.addActionListener(this);
button_sub.addActionListener(this);
button_add.addActionListener(this);
button_save.addActionListener(this);
button_clear.addActionListener(this);
button_prev.addActionListener(this);
button_create_regions.addActionListener(this);
button_box_north.add(Box.createHorizontalGlue());
button_box_north.add(button_inters);
button_box_north.add(button_sub);
button_box_north.add(button_add);
button_box_north.add(Box.createHorizontalGlue());
button_box_south.add(button_save);
button_box_south.add(button_clear);
button_box_south.add(button_prev);
button_box_south.add(button_create_regions);
result_gbc.insets = new Insets(5, 5, 5, 5);
result_gbc.weightx = 1;
result_gbc.weighty = 0.5;
result_gbc.gridwidth = 3;
result_gbc.fill = GridBagConstraints.BOTH;
result_gbc.anchor = GridBagConstraints.CENTER;
result_gbc.gridx = 0;
result_gbc.gridy = GridBagConstraints.RELATIVE;
result_set_panel.add(scrollPane, result_gbc);
result_gbc.insets = new Insets(20, 5, 5, 5);
result_gbc.anchor = GridBagConstraints.SOUTH;
result_gbc.weighty = 0;
result_gbc.gridwidth = 1;
result_gbc.gridx = 1;
result_set_panel.add(_new_feature_name_tf, result_gbc);
result_gbc.insets = new Insets(0, 5, 5, 5);
result_gbc.fill = GridBagConstraints.NONE;
result_gbc.gridx = GridBagConstraints.RELATIVE;
result_gbc.gridy = 2;
result_set_panel.add(Box.createHorizontalGlue(), result_gbc);
result_set_panel.add(button_box_south, result_gbc);
result_set_panel.add(Box.createHorizontalGlue(), result_gbc);
GridBagLayout gbl = new GridBagLayout();
GridBagConstraints gbc = new GridBagConstraints();
gbc.insets = new Insets(10, 5, 5, 5);
gbc.fill = GridBagConstraints.BOTH;
gbc.gridx = 0;
gbc.gridy = GridBagConstraints.RELATIVE;
gbc.weightx = 1;
gbc.weighty = 0;
this.setLayout(gbl);
this.add(button_box_north, gbc);
gbc.weightx = 1;
gbc.weighty = 1;
this.add(result_set_panel, gbc);
_result_set_table.addMouseListener(new MouseAdapter() {
public void mouseClicked(MouseEvent e) {
int row = _result_set_table.rowAtPoint(e.getPoint());
if (SwingUtilities.isRightMouseButton(e)
&& e.getClickCount() == 1
&& row != -1) {
ResultSetPopup p = new ResultSetPopup(SetOperationPanel.this, row);
p.show(_result_set_table, e.getX() + 10, e.getY() + 10);
}
}
});
MouseAdapter listMouseListener = new MouseAdapter() {
public void mouseClicked(MouseEvent e) {
TableColumnModel columnModel = _result_set_table.getColumnModel();
int viewColumn = columnModel.getColumnIndexAtX(e.getX());
if (SwingUtilities.isRightMouseButton(e)
&& e.getClickCount() == 1
&& viewColumn != -1) {
Component t = SwingUtilities.getRoot(SetOperationPanel.this);
ResultSetHeaderPopup p =
new ResultSetHeaderPopup(t, _result_set_table, viewColumn);
p.show(_result_set_table, e.getX() + 10, e.getY() + 10);
}
}
};
_result_set_table.getTableHeader().addMouseListener(listMouseListener);
}
private class IconTextCellRenderer extends DefaultTableCellRenderer {
private ImageIcon _icon_sort_asc =
ImageLoader.loadIcon("sort_ascending.gif");
private ImageIcon _icon_sort_desc =
ImageLoader.loadIcon("sort_descending.gif");
public Component getTableCellRendererComponent(
JTable table,
Object value,
boolean isSelected,
boolean hasFocus,
int row,
int column) {
if (table != null) {
JTableHeader header = table.getTableHeader();
if (header != null) {
setForeground(header.getForeground());
setBackground(header.getBackground());
setFont(header.getFont());
}
}
this.setHorizontalTextPosition(LEFT);
this.setText(value.toString());
int sort = _result_set_sorter.getSortStatus(column);
switch (sort) {
case SockeyeTableSorter._STS_ASCENDING :
this.setIcon(_icon_sort_asc);
break;
case SockeyeTableSorter._STS_DESCENDING :
this.setIcon(_icon_sort_desc);
break;
case SockeyeTableSorter._STS_NONE :
this.setIcon(null);
break;
}
setBorder(UIManager.getBorder("TableHeader.cellBorder"));
setHorizontalAlignment(JLabel.CENTER);
return this;
};
};
}
package ca.bcgsc.sockeye.gui.setoperationdialog;
import javax.swing.table.*;
import javax.swing.event.*;
import javax.swing.*;
import java.awt.event.*;
import java.util.*;
public class SockeyeTableSorter
extends AbstractTableModel
implements TableModelListener {
public final static int _STS_ASCENDING = 1;
public final static int _STS_DESCENDING = 2;
public final static int _STS_NONE = 0;
private int indexes[];
private Vector sortingColumns = new Vector();
private boolean ascending = false;
private int compares;
protected TableModel _model;
protected List _hiddenColumns = new ArrayList();
protected Map _col_classes = new HashMap();
public SockeyeTableSorter(TableModel t) {
setModel(t);
}
public SockeyeTableSorter() {
indexes = new int[0];
}
public int getSortStatus(int column) {
if (sortingColumns.contains(new Integer(column))) {
return ascending ? _STS_ASCENDING : _STS_DESCENDING;
}
return _STS_NONE;
}
public TableModel getModel() {
return _model;
}
public void setModel(TableModel model) {
if (_model != null)
_model.removeTableModelListener(this);
_model = model;
model.addTableModelListener(this);
reallocateIndexes();
}
public int getSortedRowIndex(int row){
for (int i=0; i<indexes.length; i++)
if (indexes[i]==row)
return i;
return -1;
}
public int getUnSortedRowIndex(int row){
return indexes[row];
}
public Object getValueAt(int aRow, int aColumn) {
checkModel();
return _model.getValueAt(indexes[aRow], aColumn);
}
public void setValueAt(Object aValue, int aRow, int aColumn) {
checkModel();
_model.setValueAt(aValue, indexes[aRow], aColumn);
}
public int getRowCount() {
return (_model == null) ? 0 : _model.getRowCount();
}
public int getColumnCount() {
return (_model == null) ? 0 : _model.getColumnCount();
}
public String getColumnName(int aColumn) {
return _model.getColumnName(aColumn);
}
public Class getColumnClass(int aColumn) {
Class c = (Class)_col_classes.get(new Integer(aColumn));
return c==null?_model.getColumnClass(aColumn):c;
}
public void setColumnClass(int aColumn, Class c) {
_col_classes.put(new Integer(aColumn), c);
}
public boolean isCellEditable(int row, int column) {
return _model.isCellEditable(row, column);
}
public int compareRowsByColumn(int row1, int row2, int column) {
Class type = getColumnClass(column);
TableModel data = _model;
Object o1 = data.getValueAt(row1, column);
Object o2 = data.getValueAt(row2, column);
if (o1 == null && o2 == null) {
return 0;
}
else if (o1 == null) {
return -1;
}
else if (o2 == null) {
return 1;
}
if (type.getSuperclass() == java.lang.Number.class) {
double d1=Double.NEGATIVE_INFINITY;
double d2=Double.NEGATIVE_INFINITY;
try{
d1 = Double.parseDouble(o1.toString());
}
catch(Exception e){
}
try{
d2 = Double.parseDouble(o2.toString());
}
catch(Exception e){
}
if (d1 < d2) {
return -1;
}
else if (d1 > d2) {
return 1;
}
else {
return 0;
}
}
else if (type == java.util.Date.class) {
Date d1 = (Date) o1;
long n1 = d1.getTime();
Date d2 = (Date) o2;
long n2 = d2.getTime();
if (n1 < n2) {
return -1;
}
else if (n1 > n2) {
return 1;
}
else {
return 0;
}
}
else if (type == String.class) {
String s1 = (String)o1;
String s2 = (String)o2;
int result = s1.compareTo(s2);
if (result < 0) {
return -1;
}
else if (result > 0) {
return 1;
}
else {
return 0;
}
}
else if (type == Boolean.class) {
Boolean bool1 = (Boolean)o1;
boolean b1 = bool1.booleanValue();
Boolean bool2 = (Boolean) o2;
boolean b2 = bool2.booleanValue();
if (b1 == b2) {
return 0;
}
else if (b1) {
return 1;
}
else {
return -1;
}
}
else {
Object v1 = o1;
String s1 = v1.toString();
Object v2 = o2;
String s2 = v2.toString();
int result = s1.compareTo(s2);
if (result < 0) {
return -1;
}
else if (result > 0) {
return 1;
}
else {
return 0;
}
}
}
public int compare(int row1, int row2) {
compares++;
for (int level = 0; level < sortingColumns.size(); level++) {
Integer column = (Integer) sortingColumns.elementAt(level);
int result = compareRowsByColumn(row1, row2, column.intValue());
if (result != 0) {
return ascending ? result : -result;
}
}
return 0;
}
public void reallocateIndexes() {
int rowCount = _model.getRowCount();
indexes = new int[rowCount];
for (int row = 0; row < rowCount; row++) {
indexes[row] = row;
}
}
public void tableChanged(TableModelEvent e) {
reallocateIndexes();
fireTableChanged(e);
}
public void checkModel() {
if (indexes.length != _model.getRowCount()) {
System.err.println("Sorter not informed of a change in model.");
}
}
public void sort(Object sender) {
checkModel();
compares = 0;
shuttlesort( (int[]) indexes.clone(), indexes, 0, indexes.length);
}
public void shuttlesort(int from[], int to[], int low, int high) {
if (high - low < 2) {
return;
}
int middle = (low + high) / 2;
shuttlesort(to, from, low, middle);
shuttlesort(to, from, middle, high);
int p = low;
int q = middle;
check to see if the elements in this subset are already
ordered. If so, no further comparisons are needed; the
sub-array can just be copied. The array must be copied rather
than assigned otherwise sister calls in the recursion might
get out of sinc. When the number of elements is three they
are partitioned so that the first set, [low, mid), has one
element and and the second, [mid, high), has two. We skip the
optimisation when the number of elements is three or less as
the first compare in the normal merge will produce the same
sequence of steps. This optimisation seems to be worthwhile
for partially ordered lists but some analysis is needed to
find out how the performance drops to Nlog(N) as the initial
order diminishes - it may drop very quickly. */
if (high - low >= 4 && compare(from[middle - 1], from[middle]) <= 0) {
for (int i = low; i < high; i++) {
to[i] = from[i];
}
return;
}
for (int i = low; i < high; i++) {
if (q >= high || (p < middle && compare(from[p], from[q]) <= 0)) {
to[i] = from[p++];
}
else {
to[i] = from[q++];
}
}
}
public void swap(int i, int j) {
int tmp = indexes[i];
indexes[i] = indexes[j];
indexes[j] = tmp;
}
public void sortByColumn(int column) {
sortByColumn(column, true);
}
public void sortByColumn(int column, boolean ascending) {
this.ascending = ascending;
sortingColumns.removeAllElements();
sortingColumns.addElement(new Integer(column));
sort(this);
fireTableChanged(new TableModelEvent(this));
}
public void addMouseListenerToHeaderInTable(JTable table) {
final SockeyeTableSorter sorter = this;
final JTable tableView = table;
tableView.setColumnSelectionAllowed(false);
MouseAdapter listMouseListener = new MouseAdapter() {
public void mouseClicked(MouseEvent e) {
TableColumnModel columnModel = tableView.getColumnModel();
int viewColumn = columnModel.getColumnIndexAtX(e.getX());
if (SwingUtilities.isLeftMouseButton(e) && e.getClickCount() == 1 && viewColumn != -1) {
ascending = !ascending;
sorter.sortByColumn(viewColumn, ascending);
}
}
};
JTableHeader th = tableView.getTableHeader();
th.addMouseListener(listMouseListener);
}
}
package ca.bcgsc.sockeye.gui.setoperationdialog;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.List;
import javax.swing.BorderFactory;
import javax.swing.DefaultListModel;
import javax.swing.JCheckBox;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JSpinner;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.ListCellRenderer;
import javax.swing.SpinnerNumberModel;
import javax.swing.SwingUtilities;
import javax.swing.UIManager;
import ca.bcgsc.sockeye.datastorage.SockeyeTrackList;
import ca.bcgsc.sockeye.datastorage.events.StorageEvent;
import ca.bcgsc.sockeye.datastorage.events.StorageEventListener;
import ca.bcgsc.sockeye.util.StringUtils;
public class TrackFeatureSetSelectionPanel
extends JPanel
implements StorageEventListener, ActionListener {
public static final int OVERLAP_UNIT_PERCENT = 0;
public static final int OVERLAP_UNIT_BASES = 1;
private DefaultListModel _track_list_model = new DefaultListModel();
private DefaultListModel _feature_list_model = new DefaultListModel();
private static final String[] _overlap_units = {
"Percent", "Bases"};
private JTextField _overlap_tf = new JTextField(5);
private JComboBox _overlap_unit_cb = new JComboBox(_overlap_units);
private JCheckBox _always_max_cb = new JCheckBox ("Always max", true);
private SpinnerNumberModel spin_model = new SpinnerNumberModel(2,2,2,1);
private JSpinner min_num_set_js = new JSpinner(spin_model);
private FeatureSetCheckBox _curr_result_set_cb = new FeatureSetCheckBox("Current result set");
private boolean _show_result_set_box = false;
private SockeyeTrackList _my_storage_manager;
private List _index2tid = new ArrayList();
private List _known_features = new ArrayList();
SetOperationPanel _sop;
public TrackFeatureSetSelectionPanel() {
initPanel();
}
public void registerSOP(SetOperationPanel s){
this._sop = s;
}
public void setSockeyeTrackList(SockeyeTrackList l) {
_my_storage_manager = l;
_my_storage_manager.addStorageListener(this);
}
public int selectedFeatureSetsCount(){
int checked_sets = 0;
Enumeration cboxes = _feature_list_model.elements();
while (cboxes.hasMoreElements())
if (((FeatureSetCheckBox)cboxes.nextElement()).isSelected())
checked_sets++;
return checked_sets;
}
public Collection getSelectedFeatureSets(boolean negated){
ArrayList s = new ArrayList();
ArrayList n = new ArrayList();
getSelectedFeatureSets(s,n);
return (negated?n:s);
}
public void getSelectedFeatureSets(Collection non_negated, Collection negated){
Enumeration cboxes = _feature_list_model.elements();
while (cboxes.hasMoreElements()){
FeatureSetCheckBox cb = (FeatureSetCheckBox)cboxes.nextElement();
if (cb.isSelected())
if (cb.isInvertedSet())
negated.add(cb.getFeatureText());
else
non_negated.add(cb.getFeatureText());
}
}
public void getSelectedTrackIds(Collection c){
for (int i = 0; i< _track_list_model.size(); i++){
JCheckBox b = (JCheckBox)_track_list_model.get(i);
if (b.isSelected())
c.add(_index2tid.get(i));
}
}
public Collection getSelectedTrackIds(){
ArrayList ids = new ArrayList();
getSelectedTrackIds(ids);
return ids;
}
public int getOverlapValue(){
int val = -1;
try {
val = Integer.parseInt(_overlap_tf.getText().trim());
}
catch (NumberFormatException ex) {
}
return val;
}
public int getOverlapUnit(){
return _overlap_unit_cb.getSelectedIndex();
}
public int getNumOverlapSet(){
return ((Number)spin_model.getValue()).intValue();
}
public String getCurrentResultSetCheckBoxTitle(){
return _curr_result_set_cb.getFeatureText();
}
public void setCurrentResultSetCheckBoxVisible(boolean b){
if ( (_feature_list_model.getElementAt(0) == _curr_result_set_cb) && !b){
_feature_list_model.remove(0);
if (_curr_result_set_cb.isSelected())
_sop.availableTrackOrFeatureStateChanged();
}
if ( (_feature_list_model.getElementAt(0) != _curr_result_set_cb) && b)
_feature_list_model.add(0, _curr_result_set_cb);
_show_result_set_box = b;
}
public void actionPerformed (ActionEvent e){
if (e.getSource() == _always_max_cb){
min_num_set_js.setEnabled(!_always_max_cb.isSelected());
if (_always_max_cb.isSelected())
spin_model.setValue(new Integer(Math.max(2, selectedFeatureSetsCount())));
}
}
private void setFeatureList(Collection feature_names) {
if (feature_names == null)
throw new IllegalArgumentException("Null Argument in list parameter when setting new feature list in track feature se selection panel");
_feature_list_model.removeAllElements();
if (_show_result_set_box)
_feature_list_model.addElement(_curr_result_set_cb);
for (Iterator fit = feature_names.iterator(); fit.hasNext(); ) {
String feature = fit.next().toString();
FeatureSetCheckBox fbox = new FeatureSetCheckBox(feature);
_feature_list_model.addElement(fbox);
}
_known_features.clear();
_known_features.addAll(feature_names);
}
private void addToFeatureList(Collection feature_names) {
if (feature_names == null)
throw new IllegalArgumentException("Null Argument in list parameter when setting new feature list in track feature se selection panel");
for (Iterator fit = feature_names.iterator(); fit.hasNext(); ) {
String feature = fit.next().toString();
FeatureSetCheckBox fbox = new FeatureSetCheckBox(feature);
_feature_list_model.addElement(fbox);
}
_known_features.addAll(feature_names);
}
private void removeFromFeatureList(Collection feature_names) {
if (feature_names == null)
throw new IllegalArgumentException("Null Argument in list parameter when setting new feature list in track feature se selection panel");
for (Iterator fit = feature_names.iterator(); fit.hasNext(); ) {
String feature = fit.next().toString();
JCheckBox fbox = new FeatureSetCheckBox(feature);
_feature_list_model.removeElement(fbox);
}
_known_features.removeAll(feature_names);
}
public void storageEventReceived(StorageEvent e) {
switch (e.getEventType()) {
case StorageEvent.STORAGE_EVENT_TRACK_ADD:
for (Iterator it = ((List)e.getAttribute()).iterator(); it.hasNext();)
addTrackToList(((Integer)it.next()).intValue());
break;
case StorageEvent.STORAGE_EVENT_TRACK_REMOVE:
for (Iterator it = ((List)e.getAttribute()).iterator(); it.hasNext();)
removeTrackFromList(((Integer)it.next()).intValue());
break;
case StorageEvent.STORAGE_EVENT_TRACK_ATTRIBUTE_CHANGED:
refreshTrackInList(getTrackIdFromStorageEvent(e));
break;
case StorageEvent.STORAGE_EVENT_TRACK_ADD_FEATURES:
int track_id = getTrackIdFromStorageEvent(e);
int index = _index2tid.indexOf(new Integer(track_id));
if (index == -1) break;
if ( ( (JCheckBox) _track_list_model.get(index)).isSelected())
this.addFeaturesForTrackListIndex(index);
break;
}
}
private void addFeaturesForTrackListIndex(int index) {
if (index < 0 || index > _index2tid.size())
throw new IllegalArgumentException(
"Inconsistent state: Illegal index value");
int track_id = Integer.parseInt(_index2tid.get(index).toString());
Collection name_set = _my_storage_manager.getFeatureNames(track_id);
name_set.remove("sequence");
name_set.removeAll(_known_features);
this.addToFeatureList(name_set);
}
private void removeFeaturesForTrackListIndex(int index) {
if (index < 0 || index > _index2tid.size())
throw new IllegalArgumentException(
"Inconsistent state: Illegal index value");
int track_id = Integer.parseInt(_index2tid.get(index).toString());
Collection name_set = _my_storage_manager.getFeatureNames(track_id);
ArrayList remaining_features = new ArrayList();
for (int track = 0; track < _track_list_model.size(); track++)
if (track != track_id &&
( (JCheckBox) _track_list_model.get(track)).isSelected())
remaining_features.addAll(_my_storage_manager.getFeatureNames(Integer.
parseInt(_index2tid.get(track).toString())));
ArrayList to_delete = new ArrayList(name_set);
name_set.retainAll(remaining_features);
to_delete.removeAll(name_set);
removeFromFeatureList(to_delete);
}
private int getTrackIdFromStorageEvent(StorageEvent e) {
Object attr = e.getAttribute();
if (! (attr instanceof List))
return -1;
Object t_id = ( (List) attr).get(0);
if (! (t_id instanceof Integer))
return -1;
return ( (Integer) t_id).intValue();
}
private void addTrackToList(int track_id) {
Object tno = StringUtils.getShortNameForTrackID(track_id);
if (tno == null) {
System.out.println(">Error: Track with id " + track_id +
" has no name!");
tno = new String("Track with unknown name");
}
int new_index = _track_list_model.getSize();
JCheckBox listelt = new JCheckBox(tno.toString());
_track_list_model.insertElementAt(listelt, new_index);
_index2tid.add(new Integer(track_id));
}
private void removeTrackFromList(int track_id) {
int index = _index2tid.indexOf(new Integer(track_id));
if (index == -1) {
System.out.println("ERROR: Inconsistent track list!");
return;
}
_track_list_model.remove(index);
_index2tid.remove(index);
}
private void refreshTrackInList(int track_id) {
int index = _index2tid.indexOf(new Integer(track_id));
if (index == -1) {
System.out.println("ERROR: Inconsistent track list!");
return;
}
Object tno = StringUtils.getShortNameForTrackID(track_id);
if (tno == null) {
System.out.println("Error: Track with id " + track_id +
" has no name!");
return;
}
JCheckBox listelt = new JCheckBox(tno.toString());
_track_list_model.remove(index);
_track_list_model.insertElementAt(listelt, index);
}
private void initPanel() {
JList track_list = new JList(_track_list_model);
JList feature_list = new JList(_feature_list_model);
track_list.setCellRenderer(new CheckBoxRenderer());
feature_list.setCellRenderer(new CheckBoxRenderer());
track_list.addMouseListener(new CheckBoxListMouseAdapter());
feature_list.addMouseListener(new CheckBoxListMouseAdapter());
JScrollPane track_sp = new JScrollPane(track_list);
JScrollPane feature_sp = new JScrollPane(feature_list);
track_sp.setToolTipText("Select the tracks whose feature you are interested in. Those are then displayed below.");
feature_sp.setToolTipText("These are all currently available features. Click on text to use the \"inverted\" set.");
_overlap_tf.setToolTipText(
"This overlap is necessary to call two features to be \"in the same place\"");
_overlap_unit_cb.setToolTipText("The units used for overlaps");
track_list.setToolTipText(track_sp.getToolTipText());
feature_list.setToolTipText(feature_sp.getToolTipText());
_always_max_cb.addActionListener(this);
min_num_set_js.setEnabled(!_always_max_cb.isSelected());
_overlap_tf.setText("80");
GridBagLayout gbl = new GridBagLayout();
GridBagConstraints gbc = new GridBagConstraints();
JPanel p = new JPanel(gbl);
gbc.fill = GridBagConstraints.BOTH;
gbc.anchor = GridBagConstraints.EAST;
gbc.gridx = 0; gbc.gridy = 0;
p.add(new JLabel("Min # of sets:"), gbc);
gbc.gridx = 1; gbc.gridy = 0;
p.add(min_num_set_js, gbc);
gbc.gridx = 2; gbc.gridy = 0;
p.add(_always_max_cb, gbc);
gbc.gridx = 0; gbc.gridy = 1;
gbc.insets=new Insets(3,0,0,0);
p.add(new JLabel("Min overlap:"), gbc);
gbc.gridx = 1; gbc.gridy = 1;
p.add(_overlap_tf, gbc);
gbc.gridx = 2; gbc.gridy = 1;
p.add(_overlap_unit_cb, gbc);
track_sp.setBorder(BorderFactory.createCompoundBorder(BorderFactory.
createTitledBorder("Available Tracks"),
BorderFactory.createEmptyBorder(5, 5, 5, 5)));
feature_sp.setBorder(BorderFactory.createCompoundBorder(BorderFactory.
createTitledBorder("Available feature sets"),
BorderFactory.createEmptyBorder(5, 5, 5, 5)));
p.setBorder(BorderFactory.createCompoundBorder(BorderFactory.
createTitledBorder("Overlap"),
BorderFactory.createEmptyBorder(5, 5, 5, 5)));
this.setLayout(new BorderLayout());
JPanel northpanel = new JPanel(new BorderLayout());
JPanel southpanel = new JPanel(new BorderLayout());
JSplitPane split_pane = new JSplitPane(JSplitPane.VERTICAL_SPLIT,
northpanel, southpanel);
split_pane.setContinuousLayout(true);
split_pane.setOneTouchExpandable(true);
this.add(split_pane);
northpanel.add(track_sp);
northpanel.setBorder(BorderFactory.createEmptyBorder(10, 5, 5, 5));
southpanel.add(feature_sp, BorderLayout.CENTER);
southpanel.add(p, BorderLayout.SOUTH);
southpanel.setBorder(BorderFactory.createEmptyBorder(10, 5, 5, 5));
}
private void trackOrFeatureStateChanged(){
int checked_sets = selectedFeatureSetsCount();
Integer max = new Integer (Math.max(2,checked_sets));
spin_model.setMaximum(max);
if (_always_max_cb.isSelected())
spin_model.setValue(max);
if (_sop != null)
_sop.availableTrackOrFeatureStateChanged();
}
class FeatureSetCheckBox
extends JCheckBox {
private final String plain_not_prefix = "NOT ";
private String _my_string = new String();
private boolean inverted = false;
public boolean equals(Object o) {
return ( ( (o instanceof FeatureSetCheckBox) &&
( ( (FeatureSetCheckBox) o).getFeatureText().equals(_my_string))) ||
( (o instanceof JCheckBox) &&
( ( (JCheckBox) o).getText().equals(_my_string))));
}
public FeatureSetCheckBox(String t) {
_my_string = t;
super.setText(makeCheckBoxString());
}
public boolean isInvertedSet() {
return inverted;
}
public void invert() {
setInverted(!inverted);
}
public void setInverted(boolean b) {
inverted = b;
super.setText(makeCheckBoxString());
}
public void setText(String s) {
_my_string = s;
super.setText(makeCheckBoxString());
}
public String getFeatureText() {
return _my_string;
}
private String makeCheckBoxString() {
if (inverted)
return plain_not_prefix + _my_string;
else
return "<html><body><font color = #d3d3d3>" + plain_not_prefix +
"</font>" + _my_string + "<body></HTML>";
}
}
class CheckBoxRenderer
extends JCheckBox
implements ListCellRenderer {
public CheckBoxRenderer() {
setBackground(UIManager.getColor("List.textBackground"));
setForeground(UIManager.getColor("List.textForeground"));
}
public Component getListCellRendererComponent(JList listBox, Object obj,
int currentindex,
boolean isChecked,
boolean hasFocus) {
setSelected( ( (JCheckBox) obj).isSelected());
this.setText( ( (JCheckBox) obj).getText());
return this;
}
}
class CheckBoxListMouseAdapter
extends MouseAdapter {
private int icon_width = (int)new JCheckBox().getPreferredSize().getWidth();
private int text_start = (int)new JCheckBox("NOT").getPreferredSize().
getWidth();
public void mouseClicked(MouseEvent me) {
if (me.getClickCount() == 1 && SwingUtilities.isLeftMouseButton(me)) {
JList l = (JList) me.getSource();
int selectedIndex = l.locationToIndex(me.getPoint());
if (selectedIndex < 0)
return;
Object item = l.getModel().getElementAt(selectedIndex);
boolean selected = ! ( (JCheckBox) item).isSelected();
if (item instanceof FeatureSetCheckBox) {
if (me.getX() > icon_width && me.getX() < text_start) {
( (FeatureSetCheckBox) item).invert();
}
else {
( (FeatureSetCheckBox) item).setSelected(selected);
}
}
else {
( (JCheckBox) item).setSelected(selected);
if (selected)
TrackFeatureSetSelectionPanel.this.addFeaturesForTrackListIndex(
selectedIndex);
else{
TrackFeatureSetSelectionPanel.this.removeFeaturesForTrackListIndex(
selectedIndex);
}
}
l.repaint();
TrackFeatureSetSelectionPanel.this.trackOrFeatureStateChanged();
}
}
}
}
package ca.bcgsc.sockeye.gui.sevents;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.tree.*;
import ca.bcgsc.sockeye.gui.scomponents.CheckboxTreeRenderer;
import ca.bcgsc.util.gui.scomponents.*;
public abstract class SockeyeNodeSelectionListener
extends MouseAdapter {
JTree tree;
CheckboxTreeNode node;
int row;
public boolean check_event;
public SockeyeNodeSelectionListener(JTree tree) {
this.tree = tree;
}
public void mousePressed(MouseEvent e) {
super.mousePressed(e);
}
public boolean action(MouseEvent e) {
int x = e.getX();
int y = e.getY();
row = tree.getRowForLocation(x, y);
TreePath path = tree.getPathForRow(row);
if (path != null) {
node = (CheckboxTreeNode) path.getLastPathComponent();
int x_path = tree.getPathBounds(path).x;
int x_cb = ( (CheckboxTreeRenderer) tree.getCellRenderer()).
getCheckBoxWidth();
if ( (x - (x_path) + 7) < x_cb ){
if(SwingUtilities.isLeftMouseButton(e)) {
check_event = true;
node.setChecked(!node.isChecked());
}
}
else {
check_event = false;
}
( (DefaultTreeModel) tree.getModel()).nodeChanged(node);
return true;
}
return false;
}
protected CheckboxTreeNode getSelectedNode(MouseEvent e){
int x = e.getX();
int y = e.getY();
row = tree.getRowForLocation(x, y);
TreePath path = tree.getPathForRow(row);
if (path != null)
return (CheckboxTreeNode) path.getLastPathComponent();
else
return null;
}
protected CheckboxTreeNode getSelectedNode(){
return node;
}
protected int getSelectedRow(){
return row;
}
}
package ca.bcgsc.sockeye.gui.sevents;
import java.awt.Point;
import java.awt.datatransfer.Transferable;
import java.awt.dnd.DnDConstants;
import java.awt.dnd.DragGestureEvent;
import java.awt.dnd.DragGestureListener;
import java.awt.dnd.DragSource;
import java.awt.dnd.DragSourceDragEvent;
import java.awt.dnd.DragSourceDropEvent;
import java.awt.dnd.DragSourceEvent;
import java.awt.dnd.DragSourceListener;
import java.awt.dnd.DropTarget;
import java.awt.dnd.DropTargetDragEvent;
import java.awt.dnd.DropTargetDropEvent;
import java.awt.dnd.DropTargetEvent;
import java.awt.dnd.DropTargetListener;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import javax.swing.JLabel;
import javax.swing.JPopupMenu;
import javax.swing.JTree;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreePath;
import ca.bcgsc.util.gui.scomponents.CheckboxTreeNode;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
public class SockeyeTreeTransferHandler
implements DragGestureListener, DragSourceListener, DropTargetListener {
static JTree tree;
DragSource drag_source;
DropTarget drop_target;
CheckboxTreeNode dragged_node;
CheckboxTreeNode dragged_node_parent;
BufferedImage image;
JPopupMenu popup;
static ArrayList expended_paths = new ArrayList();
public SockeyeTreeTransferHandler(JTree tree) {
SockeyeTreeTransferHandler.tree = tree;
drag_source = new DragSource();
int action = DnDConstants.ACTION_MOVE;
drag_source.createDefaultDragGestureRecognizer(tree, action, this);
drop_target = new DropTarget(tree, action, this);
}
public void dragDropEnd(DragSourceDropEvent dsde) {
if (dsde.getDropSuccess() &&
dsde.getDropAction() == DnDConstants.ACTION_MOVE && dragged_node_parent != null) {
( (DefaultTreeModel) tree.getModel()).nodeStructureChanged(
dragged_node_parent);
}
popup = null;
TreePath path = new TreePath(((DefaultTreeModel)tree.getModel()).
getPathToRoot(dragged_node));
tree.setSelectionPath(path);
}
public void dragEnter(DragSourceDragEvent dsde) {
int action = dsde.getDropAction();
if (action == DnDConstants.ACTION_MOVE) {
dsde.getDragSourceContext().setCursor(DragSource.DefaultMoveDrop);
}
else {
dsde.getDragSourceContext().setCursor(DragSource.DefaultMoveNoDrop);
}
}
public void dragOver(DragSourceDragEvent dsde) {
int action = dsde.getDropAction();
if (action == DnDConstants.ACTION_MOVE) {
dsde.getDragSourceContext().setCursor(DragSource.DefaultMoveDrop);
}
else {
dsde.getDragSourceContext().setCursor(DragSource.DefaultMoveNoDrop);
}
}
public void dropActionChanged(DragSourceDragEvent dsde) {
int action = dsde.getDropAction();
if (action == DnDConstants.ACTION_MOVE) {
dsde.getDragSourceContext().setCursor(DragSource.DefaultMoveDrop);
}
else {
dsde.getDragSourceContext().setCursor(DragSource.DefaultMoveNoDrop);
}
}
public void dragExit(DragSourceEvent dse) {
dse.getDragSourceContext().setCursor(DragSource.DefaultMoveNoDrop);
if (popup != null){
popup.setVisible(false);
}
}
public void dragGestureRecognized(DragGestureEvent dge) {
TreePath path = tree.getSelectionPath();
if (path != null) {
dragged_node = (CheckboxTreeNode) path.getLastPathComponent();
dragged_node_parent = (CheckboxTreeNode) dragged_node.getParent();
drag_source.startDrag(dge, DragSource.DefaultMoveNoDrop, image,
new Point(0, 0), new CheckboxTreeNode(dragged_node), this);
}
}
public void dragEnter(DropTargetDragEvent dtde) {
Point pt = dtde.getLocation();
int action = dtde.getDropAction();
if ( ( (CheckboxTreeNode) dragged_node.getParent()).isRoot()) {
if(popup == null){
JLabel label = new JLabel();
label.setBackground(java.awt.Color.gray);
label.setText(dragged_node.toString());
popup = new JPopupMenu();
popup.add(label);
}
popup.show(tree, (int) pt.getX() + 20, (int) pt.getY());
if (canPerformAction(tree, dragged_node, action, pt))
dtde.acceptDrag(action);
}
else
dtde.rejectDrag();
}
public void dragExit(DropTargetEvent dte) {
}
public void dragOver(DropTargetDragEvent dtde) {
Point pt = dtde.getLocation();
int action = dtde.getDropAction();
if (canPerformAction(tree, dragged_node, action, pt)) {
dtde.acceptDrag(action);
}
else {
dtde.rejectDrag();
}
if(popup != null)
popup.show(tree, (int) pt.getX() + 20, (int) pt.getY());
}
public void dropActionChanged(DropTargetDragEvent dtde) {
Point pt = dtde.getLocation();
int action = dtde.getDropAction();
if (canPerformAction(tree, dragged_node, action, pt)) {
dtde.acceptDrag(action);
}
else {
dtde.rejectDrag();
}
}
public void drop(DropTargetDropEvent dtde) {
try {
int action = dtde.getDropAction();
Transferable transferable = dtde.getTransferable();
Point pt = dtde.getLocation();
if (transferable.isDataFlavorSupported(CheckboxTreeNode._NODE_FLAVOR) &&
canPerformAction(tree, dragged_node, action, pt)) {
TreePath pathTarget = tree.getPathForLocation(pt.x, pt.y);
CheckboxTreeNode order_node = (CheckboxTreeNode)
pathTarget.getLastPathComponent();
if (executeDrop(tree, dragged_node, order_node, action)) {
dtde.acceptDrop(action);
dtde.dropComplete(true);
return;
}
}
dtde.rejectDrop();
dtde.dropComplete(false);
}
catch (Exception e) {
System.out.println(e);
dtde.rejectDrop();
dtde.dropComplete(false);
}
}
public boolean canPerformAction(JTree tree,
CheckboxTreeNode dragged_node,
int action, Point location) {
TreePath path_target = tree.getPathForLocation(location.x, location.y);
if (path_target == null) {
tree.setSelectionPath(null);
return false;
}
tree.setSelectionPath(path_target);
if (action == DnDConstants.ACTION_MOVE) {
CheckboxTreeNode order_node = (CheckboxTreeNode) path_target.
getLastPathComponent();
if (dragged_node.isRoot() || dragged_node.isNodeDescendant(order_node) ||
order_node == dragged_node.getParent() ||
! ( (CheckboxTreeNode) order_node.getParent()).isRoot() ||
! ( (CheckboxTreeNode) dragged_node.getParent()).isRoot()) {
return false;
}
else {
return true;
}
}
else {
return false;
}
}
public boolean executeDrop(JTree tree,
CheckboxTreeNode dragged_node,
CheckboxTreeNode order_node,
int action) {
if (action == DnDConstants.ACTION_MOVE) {
DefaultTreeModel model = (DefaultTreeModel) tree.getModel();
CheckboxTreeNode parent_node = (CheckboxTreeNode) model.getRoot();
int to_index = model.getIndexOfChild(parent_node, order_node);
parent_node.remove(dragged_node);
model.insertNodeInto(dragged_node, parent_node, to_index);
DataStoreUser.getInstance().getSockeyeTrackList().
moveTrack(Integer.valueOf(dragged_node.getId()).intValue(), to_index);
return true;
}
return false;
}
public static void getExpandedStatus(){
DefaultTreeModel model = (DefaultTreeModel) tree.getModel();
expended_paths.clear();
CheckboxTreeNode root = (CheckboxTreeNode)model.getRoot();
for(int i=0; i<root.getChildCount(); i++){
if(!root.getChildAt(i).isLeaf()){
Object[] path = new Object[2];
path[0] = root.toString();
path[1] = root.getChildAt(i).toString();
TreePath expended_path = new TreePath(path);
if (tree.isExpanded(expended_path))
expended_paths.add(expended_path);
}
}
}
void setExpendedStatus(){
for(int i=0; i<expended_paths.size(); i++)
tree.expandPath((TreePath)expended_paths.get(i));
}
}
package ca.bcgsc.sockeye.gui.util;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import ca.bcgsc.sockeye.service.featureloader.common.ConnectionManager;
public class ConnectionGUIUtil {
public ConnectionGUIUtil() {
super();
}
public static DefaultTreeModel getCurrentDataStructureTreeModel(
DefaultMutableTreeNode root) {
DefaultTreeModel tm = null;
root.removeAllChildren();
List types = ConnectionManager.getAllConnectionTypes();
for (Iterator i = types.iterator(); i.hasNext(); ) {
String type = (String) i.next();
if(type.equals("TFBS"))
continue;
DefaultMutableTreeNode type_node = new DefaultMutableTreeNode(type);
ArrayList conn_names = ConnectionManager.getConnectionNames(type);
for (Iterator j = conn_names.iterator(); j.hasNext(); ) {
String conn_name = (String) j.next();
DefaultMutableTreeNode conn_name_node = new DefaultMutableTreeNode(
conn_name);
DefaultMutableTreeNode conn_host_node = new DefaultMutableTreeNode(
ConnectionManager.getConnectionForName(conn_name).getHost());
DefaultMutableTreeNode conn_user_node = new DefaultMutableTreeNode(
ConnectionManager.getConnectionForName(conn_name).getUser());
DefaultMutableTreeNode conn_pass_node = new DefaultMutableTreeNode(
ConnectionManager.getConnectionForName(conn_name).getPass());
DefaultMutableTreeNode conn_port_node = new DefaultMutableTreeNode(
ConnectionManager.getConnectionForName(conn_name).getPort());
conn_name_node.add(conn_host_node);
conn_name_node.add(conn_user_node);
conn_name_node.add(conn_pass_node);
conn_name_node.add(conn_port_node);
type_node.add(conn_name_node);
}
root.add(type_node);
}
tm = new DefaultTreeModel(root);
return tm;
}
}
package ca.bcgsc.sockeye.gui.util;
import java.awt.Dimension;
import java.awt.Insets;
import java.awt.Point;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.JDialog;
import javax.swing.JSplitPane;
import javax.swing.plaf.basic.BasicSplitPaneDivider;
import javax.swing.plaf.basic.BasicSplitPaneUI;
public class FoldingSplitPaneDivider extends BasicSplitPaneDivider
{
JDialog parent_frame;
float last_loc_ratio = 0;
public FoldingSplitPaneDivider(BasicSplitPaneUI ui, JDialog window) {
super(ui);
parent_frame = window;
}
protected void oneTouchExpandableChanged() {
if (splitPane.isOneTouchExpandable() &&
leftButton == null &&
rightButton == null) {
expand/collapse it. */
leftButton = createLeftOneTouchButton();
if (leftButton != null)
leftButton.addActionListener(new OneTouchActionHandler(true));
expand/collapse it. */
rightButton = createRightOneTouchButton();
if (rightButton != null)
rightButton.addActionListener(new OneTouchActionHandler
(false));
if (leftButton != null && rightButton != null) {
add(leftButton);
add(rightButton);
}
}
invalidate();
validate();
}
private class OneTouchActionHandler implements ActionListener {
private boolean toMinimum;
OneTouchActionHandler(boolean toMinimum) {
this.toMinimum = toMinimum;
}
public void actionPerformed(ActionEvent e) {
Insets insets = splitPane.getInsets();
int lastLoc = splitPane.getLastDividerLocation();
int currentLoc = splitPaneUI.getDividerLocation(splitPane);
int newLoc = currentLoc;
float cur_loc_ratio = (float)currentLoc / splitPane.getHeight();
Dimension f_size = parent_frame.getSize();
Point f_loc = parent_frame.getLocation();
if (toMinimum) {
if (orientation == JSplitPane.VERTICAL_SPLIT) {
if (currentLoc >= (splitPane.getHeight() -
insets.bottom - getHeight())) {
newLoc = lastLoc;
} else if (currentLoc != insets.top){
f_size.height = Math.round(f_size.height * (1.0f - cur_loc_ratio));
last_loc_ratio = cur_loc_ratio;
newLoc = insets.top;
}
}
else {
if (currentLoc >= (splitPane.getWidth() -
insets.right - getWidth()))
newLoc = lastLoc;
else
newLoc = insets.left;
}
}
else {
if (orientation == JSplitPane.VERTICAL_SPLIT) {
if (currentLoc == insets.top) {
f_size.height /= 1.0f - last_loc_ratio;
newLoc = (int)(f_size.height * last_loc_ratio) - getHeight();
} else {
newLoc = splitPane.getHeight() - getHeight() - 5;
f_loc.y -= lastLoc;
}
}
else {
if (currentLoc == insets.left)
newLoc = lastLoc;
else
newLoc = splitPane.getWidth() - getWidth() -
insets.left;
}
}
if (currentLoc != newLoc) {
parent_frame.setLocation(f_loc);
parent_frame.setSize(f_size);
splitPane.setDividerLocation(newLoc);
splitPane.setLastDividerLocation(currentLoc);
splitPane.doLayout();
}
}
}
}
package ca.bcgsc.sockeye.gui.util;
import java.io.File;
import java.net.URL;
import javax.swing.ImageIcon;
import ca.bcgsc.sockeye.config.Configuration;
public class ImageLoader {
public static ImageIcon quickLoadIcon(String filename) {
String imgPath = Configuration.getQuickImagePath() + filename;
File file = new File(Configuration.USER_DIR + "/" + imgPath);
ImageIcon icon = null;
if (file.exists()) {
icon = new ImageIcon(Configuration.USER_DIR + "/" + imgPath);
} else {
URL url =
ImageLoader.class.getClassLoader().getResource(
imgPath.replaceAll("\\\\", "/"));
icon = new ImageIcon(url);
}
return icon;
}
public static ImageIcon loadIcon(String filename) {
String imgPath = Configuration.getImagePath() + filename;
File file = new File(Configuration.USER_DIR + "/" + imgPath);
ImageIcon icon = null;
if (file.exists()) {
icon = new ImageIcon(Configuration.USER_DIR + "/" + imgPath);
} else {
URL url =
ImageLoader.class.getClassLoader().getResource(
imgPath.replaceAll("\\\\", "/"));
icon = new ImageIcon(url);
}
return icon;
}
}
package ca.bcgsc.sockeye.gui.util;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import javax.swing.BoxLayout;
import javax.swing.JFormattedTextField;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JSlider;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
public class PercentileDistributionGraph
extends JPanel
implements ChangeListener, PropertyChangeListener {
private JSlider vert_slider = new JSlider(JSlider.VERTICAL);
private JSlider horiz_slider = new JSlider(JSlider.HORIZONTAL);
private NumberFormat tf_top_format = NumberFormat.getNumberInstance();
private NumberFormat tf_bottom_format = NumberFormat.getNumberInstance();
private JFormattedTextField tf_top;
private JFormattedTextField tf_bottom;
private PlotCanvas canvas = new PlotCanvas();
private JLabel horiz_label = new JLabel("Label ");
private JLabel vert_label = new JLabel("Percentile ");
private float slider_scale_h = 1;
private float slider_scale_v = 1;
private final int slider_min_resolution = 100;
private float x_value = 0;
private List changeListeners = new ArrayList();
boolean init_change = false;
public PercentileDistributionGraph(String horiz_label_str) {
init();
horiz_label.setText(horiz_label_str + " ");
}
public void setBackgroundColor(Color c) {
canvas.setBackground(c);
}
public void setGraphColor(Color c) {
canvas.setForegroundColor(c);
}
public void setCrossColor(Color c) {
canvas.setCrossColor(c);
}
public float getCursorX() {
return Float.parseFloat(tf_bottom.getText().toString());
}
public float getCursorY() {
String value = tf_top.getText().toString();
return Float.parseFloat(value);
}
public void setCursorX(float value) {
horiz_slider.setValue( (int) (value * slider_scale_h + 0.5f));
x_value = value;
}
public void setCursorY(float value) {
vert_slider.setValue( (int) (value * slider_scale_v + 0.5f));
}
public float getXValue() {
return x_value;
}
public void setDistributionValues(float[] x, float[] y, float
initial_value) {
canvas.setPlotValues(x, y);
float h_min = canvas.getMinX();
float h_max = canvas.getMaxX();
float v_min = canvas.getMinY();
float v_max = canvas.getMaxY();
slider_scale_h = 1;
if ( (h_max - h_min) < slider_min_resolution)
slider_scale_h = slider_min_resolution / (h_max - h_min);
slider_scale_v = 1;
if ( (v_max - v_min) < slider_min_resolution)
slider_scale_v = slider_min_resolution / (v_max - v_min);
horiz_slider.setMinimum(0);
horiz_slider.setMaximum( (int) (slider_scale_h + 0.5f));
vert_slider.setMinimum(0);
vert_slider.setMaximum( (int) (100 * slider_scale_v + 0.5f));
x_value = initial_value;
init_change = true;
horiz_slider.setValue( (int) (x_value * slider_scale_h + 0.5f));
init_change = false;
}
public void stateChanged(ChangeEvent e) {
JSlider source = (JSlider) e.getSource();
float value = source.getValue();
if (source.equals(horiz_slider)) {
if (init_change) value = x_value * slider_scale_h;
canvas.setCrosshairVertical(value / slider_scale_h);
vert_slider.removeChangeListener(this);
vert_slider.setValue( (int) (canvas.getCrossHairHorizontal() *
slider_scale_v + 0.5f));
vert_slider.addChangeListener(this);
}
else {
canvas.setCrosshairHorizontal(value / slider_scale_v);
horiz_slider.removeChangeListener(this);
horiz_slider.setValue( (int) (canvas.getCrossHairVertical() *
slider_scale_h + 0.5f));
horiz_slider.addChangeListener(this);
}
tf_top.setText(tf_top_format.format(canvas.getArrayValueY()));
tf_bottom.setText(tf_top_format.format(canvas.getArrayValueX()));
x_value = canvas.getArrayValueX();
ChangeEvent event = new ChangeEvent(this);
for (Iterator itr = changeListeners.iterator(); itr.hasNext(); ) {
ChangeListener listener = (ChangeListener) itr.next();
listener.stateChanged(event);
}
}
public void addChangeListener(ChangeListener listener) {
if (!changeListeners.contains(listener))
changeListeners.add(listener);
}
public void removeChangeListener(ChangeListener listener) {
changeListeners.remove(listener);
}
private void init() {
tf_top_format.setMaximumFractionDigits(2);
tf_bottom_format.setMaximumFractionDigits(1);
tf_top_format.setMinimumIntegerDigits(1);
tf_bottom_format.setMinimumIntegerDigits(1);
tf_top = new JFormattedTextField(tf_top_format);
tf_bottom = new JFormattedTextField(tf_bottom_format);
tf_top.setColumns(4);
tf_bottom.setColumns(4);
tf_top.setMinimumSize(new Dimension(40, 20));
tf_bottom.setMinimumSize(new Dimension(40, 20));
GridBagLayout gridbag = new GridBagLayout();
GridBagConstraints gbc = new GridBagConstraints();
Dimension d_vert = vert_slider.getMinimumSize();
Dimension d_hor = horiz_slider.getMinimumSize();
vert_label.setUI(new VerticalLabelUI(false));
JPanel panel1 = new JPanel();
panel1.setLayout(new BoxLayout(panel1,BoxLayout.Y_AXIS));
panel1.add(tf_top);
panel1.add(vert_label);
gbc.gridx = 0;
gbc.gridy = 0;
gbc.weightx = 10;
gbc.weighty = 10;
gridbag.setConstraints(panel1, gbc);
JPanel panel2 = new JPanel();
panel2.setLayout(new BoxLayout(panel2,BoxLayout.X_AXIS));
panel2.add(horiz_label);
panel2.add(tf_bottom);
gbc.gridx = 2;
gbc.gridy = 2;
gridbag.setConstraints(panel2, gbc);
gbc.fill = GridBagConstraints.BOTH;
gbc.gridx = 1;
gbc.gridy = 0;
gridbag.setConstraints(vert_slider, gbc);
gbc.gridx = 2;
gbc.gridy = 1;
gridbag.setConstraints(horiz_slider, gbc);
gbc.gridx = 2;
gbc.gridy = 0;
gbc.weightx = 100;
gbc.weighty = 100;
gbc.insets = new Insets( (int) d_vert.getWidth() / 2,
(int) d_hor.getHeight() / 2,
(int) d_vert.getWidth() / 2,
(int) d_hor.getHeight() / 2);
gridbag.setConstraints(canvas, gbc);
gbc.insets = new Insets(0, (int) d_hor.getHeight() / 2, 0,
(int) d_hor.getHeight() / 2);
gbc.anchor = GridBagConstraints.WEST;
gbc.gridx = 2;
gbc.gridy = 0;
gridbag.setConstraints(tf_top, gbc);
gbc.anchor = GridBagConstraints.EAST;
gbc.gridx = 2;
gbc.gridy = 3;
gridbag.setConstraints(tf_bottom, gbc);*/
this.setLayout(gridbag);
this.add(panel1);
this.add(panel2);
this.add(vert_slider);
this.add(horiz_slider);
this.add(canvas);
vert_slider.addChangeListener(this);
horiz_slider.addChangeListener(this);
tf_top.addPropertyChangeListener(this);
tf_bottom.addPropertyChangeListener(this);
}
public void propertyChange(PropertyChangeEvent e) {
if ("value".equals(e.getPropertyName())) {
Number value = (Number) e.getNewValue();
if (e.getSource().equals(tf_top)) {
vert_slider.setValue( (int) (value.floatValue() * slider_scale_v
+ 0.5f));
}
else {
horiz_slider.setValue( (int) (value.floatValue() * slider_scale_h +
0.5f));
}
}
}
}
class PlotCanvas
extends JPanel {
private float[] x_values;
private float[] y_values;
private float min_x;
private float max_x;
private float min_y;
private float max_y;
private int last_x_width = -1;
private int last_y_width = -1;
private float scale_x;
private float scale_y;
private float cross_vertical_percent = 0.5f;
private float cross_horizontal_percent = 0.5f;
Color bg_color = Color.white;
Color fg_color = Color.black;
Color cross_color = Color.blue;
private int array_pos_x;
public void setPlotValues(float[] x, float[] y) {
if (x.length != y.length)
throw new IllegalArgumentException(
"Sumbitted arrays have different lengthes");
x_values = x;
y_values = y;
float[] x_clone = (float[]) x.clone();
float[] y_clone = (float[]) y.clone();
Arrays.sort(x_clone);
Arrays.sort(y_clone);
min_x = x_clone[0];
max_x = x_clone[x_clone.length - 1];
min_y = y_clone[0];
max_y = y_clone[y_clone.length - 1];
if (min_x < 0 || max_x > 1)
throw new IllegalArgumentException(
"PercentileDistributionGraph: X values have to be between 0 and 1!");
if (min_y < 0 || max_y > 100.001f)
throw new IllegalArgumentException(
"PercentileDistributionGraph: Y values have to be between 0 and 100!");
}
public void setBackgroundColor(Color c) {
bg_color = c;
}
public void setForegroundColor(Color c) {
fg_color = c;
}
public void setCrossColor(Color c) {
cross_color = c;
}
public float getMinX() {
return min_x;
}
public float getMaxX() {
return max_x;
}
public float getMinY() {
return min_y;
}
public float getMaxY() {
return max_y;
}
public float getArrayValueX() {
return array_pos_x < 0 ? 0 : x_values[array_pos_x];
}
public float getArrayValueY() {
return array_pos_x < 0 ? 0 : y_values[array_pos_x];
}
private void rescale(int w, int h) {
last_x_width = w;
last_y_width = h;
if (x_values == null || x_values.length == 0 || w == 0 || h == 0)
return;
scale_x = 1f / (w - 1);
scale_y = 100f / h;
}
protected void plotDistribution(Graphics g, int w, int h) {
int x1 = 0, x2;
int y1 = h, y2;
for (int x = 0; x < x_values.length; x++) {
x2 = (int) (x_values[x] / scale_x);
y2 = h - Math.round(y_values[x] / scale_y);
if ( (x2 - x1) > 2) {
g.drawLine(x1, y1, x2, y1);
g.drawLine(x2, y1, x2, y2);
}
else
g.drawLine(x1, y1, x2, y2);
x1 = x2;
y1 = y2;
}
}
public void setCrosshairVertical(float x_val) {
cross_vertical_percent = x_val;
array_pos_x = Arrays.binarySearch(x_values, x_val);
if (array_pos_x < 0) {
array_pos_x = Math.abs(array_pos_x) - 2;
if (array_pos_x >= y_values.length)
array_pos_x = y_values.length - 1;
}
float y_value = array_pos_x < 0 ? 0 : y_values[array_pos_x];
cross_horizontal_percent = y_value / 100;
this.repaint();
}
public void setCrosshairHorizontal(float y_val) {
y_val = Math.round(y_val * 100) / 100f;
cross_horizontal_percent = y_val / 100;
array_pos_x = Arrays.binarySearch(y_values, y_val);
if (array_pos_x < 0) {
array_pos_x = Math.abs(array_pos_x) - 2;
if (array_pos_x >= x_values.length)
array_pos_x = x_values.length - 1;
}
float x_value = array_pos_x < 0 ? 0 : x_values[array_pos_x];
cross_vertical_percent = x_value;
this.repaint();
}
public float getCrossHairVertical() {
return cross_vertical_percent;
}
public float getCrossHairHorizontal() {
return 100 * cross_horizontal_percent;
}
protected void paintComponent(Graphics g) {
int w = getWidth();
int h = getHeight();
if (w != last_x_width && h != last_y_width)
rescale(w, h);
g.setColor(bg_color);
g.fillRect(0, 0, w, h);
g.setColor(fg_color);
plotDistribution(g, w, h);
g.setColor(cross_color);
int y_draw_cross = (int) (h * cross_horizontal_percent + 0.5f);
int x_draw_cross = (int) (w * cross_vertical_percent + 0.5f);
g.drawLine(x_draw_cross, 0, x_draw_cross, h);
g.drawLine(0, h - y_draw_cross, w, h - y_draw_cross);
}
}
package ca.bcgsc.sockeye.gui.util;
public class SockeyeMenuCreator{
public static void fillMenu(SockeyeThreadedMenuFiller a){
Thread t = new Thread(a);
t.start();
}
}
package ca.bcgsc.sockeye.gui.util;
import javax.swing.ImageIcon;
import javax.swing.JMenu;
abstract public class SockeyeThreadedMenuFiller implements Runnable{
protected JMenu _menu_to_fill;
protected static ImageIcon f = ImageLoader.loadIcon("hourglass.gif");
public SockeyeThreadedMenuFiller(JMenu jm){
if (jm == null)
throw new IllegalArgumentException("SockeyeThreadedMenuFiller: Can not accept null argument!");
_menu_to_fill = jm;
}
abstract public void fillMenu();
public void run(){
ImageIcon oldIcon = (ImageIcon)_menu_to_fill.getIcon();
boolean was_enabled = _menu_to_fill.isEnabled();
_menu_to_fill.setIcon(f);
_menu_to_fill.setEnabled(false);
fillMenu();
_menu_to_fill.setDisabledIcon(null);
_menu_to_fill.setIcon(oldIcon);
if (_menu_to_fill.getItemCount()==0){
_menu_to_fill.setDisabledIcon(new ImageIcon(javax.swing.GrayFilter.createDisabledImage(((ImageIcon)oldIcon).getImage())));
}
else
_menu_to_fill.setEnabled(was_enabled);
}
}
package ca.bcgsc.sockeye.gui.util;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Insets;
import java.awt.Rectangle;
import java.awt.geom.AffineTransform;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.plaf.basic.BasicLabelUI;
public class VerticalLabelUI extends BasicLabelUI {
static {
labelUI = new VerticalLabelUI(false);
}
protected boolean clockwise;
public VerticalLabelUI(boolean clockwise) {
super();
this.clockwise = clockwise;
}
public Dimension getPreferredSize(JComponent c) {
Dimension dim = super.getPreferredSize(c);
return new Dimension(dim.height, dim.width);
}
private static Rectangle paintIconR = new Rectangle();
private static Rectangle paintTextR = new Rectangle();
private static Rectangle paintViewR = new Rectangle();
private static Insets paintViewInsets = new Insets(0, 0, 0, 0);
public void paint(Graphics g, JComponent c) {
JLabel label = (JLabel) c;
String text = label.getText();
FontMetrics fm = g.getFontMetrics();
paintViewInsets = c.getInsets(paintViewInsets);
paintViewR.x = paintViewInsets.left;
paintViewR.y = paintViewInsets.top;
paintViewR.height = c.getWidth() -
(paintViewInsets.left + paintViewInsets.right);
paintViewR.width = c.getHeight() -
(paintViewInsets.top + paintViewInsets.bottom);
paintIconR.x = paintIconR.y = paintIconR.width = paintIconR.height = 0;
paintTextR.x = paintTextR.y = paintTextR.width = paintTextR.height = 0;
String clippedText =
layoutCL(label, fm, text, null, paintViewR, paintIconR, paintTextR);
Graphics2D g2 = (Graphics2D) g;
AffineTransform tr = g2.getTransform();
if (clockwise) {
g2.rotate(Math.PI / 2);
g2.translate(0, -c.getWidth());
}
else {
g2.rotate( -Math.PI / 2);
g2.translate( -c.getHeight(), 0);
}
if (text != null) {
int textX = paintTextR.x;
int textY = paintTextR.y + fm.getAscent();
if (label.isEnabled()) {
paintEnabledText(label, g, clippedText, textX, textY);
}
else {
paintDisabledText(label, g, clippedText, textX, textY);
}
}
g2.setTransform(tr);
}
}
package ca.bcgsc.sockeye.io;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintStream;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.datastorage.SockeyeTrackList;
import ca.bcgsc.sockeye.util.Log;
import ca.bcgsc.sockeye.util.StringUtils;
public class ALNExporter {
private static final int SEQ_LINE_LENGTH = 60;
public static void exportToClustalw(int[] tracks, String file_name) {
StringBuffer buf = new StringBuffer();
String[] seqs = new String[tracks.length];
SockeyeTrackList dsm = DataStoreUser.getInstance().getSockeyeTrackList();
String[] lines = new String[tracks.length + 1];
String[] names = new String[tracks.length + 1];
int lastLine = lines.length - 1;
buf.append("CLUSTAL X (1.83) multiple sequence alignment\n\n\n");
int max_name_length = 0;
for (int i = 0; i < tracks.length; i++) {
names[i] = StringUtils.getShortNameForTrackID(tracks[i]);
seqs[i] = dsm.getTrackSequence(tracks[i]);
if (names[i].length() > max_name_length) max_name_length = names[i].length();
}
names[lastLine] = "";
for (int i = 0; i < names.length; i++) {
names[i] = format(names[i], max_name_length);
}
int cutoff = 0;
while (seqs[0].length() > 0) {
for (int l = 0; l < seqs.length; l++) {
cutoff = Math.min(SEQ_LINE_LENGTH, seqs[l].length());
lines[l] = seqs[l].substring(0, cutoff);
if (cutoff >= seqs[l].length()) seqs[l] = "";
else seqs[l] = seqs[l].substring(cutoff);
}
lines[lastLine] = "";
for (int i = 0; i < lines[0].length(); i++) {
boolean agree = true;
for (int j = 1; j < seqs.length; j++) {
if (lines[j].charAt(i) != lines[0].charAt(i)) {
agree = false;
break;
}
}
lines[lastLine] += agree ? "*" : " ";
}
for (int i = 0; i < lines.length; i++) {
buf.append(names[i] + "\t");
buf.append(lines[i]);
buf.append("\n");
}
buf.append("\n");
}
File file = new File(file_name);
try {
PrintStream fout;
FileWriter fwrite;
fwrite = new FileWriter(file);
fwrite.write(buf.toString());
fwrite.close();
} catch (IOException ioe) {
Log.printStackTrace(ioe);
}
}
private static String format(String str, int length) {
if (str.length() > length) {
str = str.substring(0, length);
} else while (str.length() < length) {
str += " ";
}
return str;
}
}
package ca.bcgsc.sockeye.io;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.util.List;
import javax.swing.JOptionPane;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.gui.Sockeye;
import ca.bcgsc.sockeye.util.StringUtils;
import ca.bcgsc.util.SequenceUtils;
public class FASTAExporter {
public static final int _CHARS_PER_LINE = 80;
public static void exportToMultiFASTA(
List features,
String file_name,
int reverse_mode) {
StringBuffer buf = new StringBuffer();
for (int i = 0; i < features.size(); i++) {
TrackFeature feature = (TrackFeature) features.get(i);
int track_id = feature.getTrackId();
int window_start =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackDataWindowStart(
track_id);
int window_end =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackDataWindowEnd(
track_id);
String seq =
DataStoreUser.getInstance().getSockeyeTrackList().getTrackSequence(
track_id);
if (seq.length() == 0) {
String track_name =
(String) DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackAttribute(
feature.getTrackId(),
"track_name");
JOptionPane.showMessageDialog(
Sockeye.__frame,
"No sequence available for the track "
+ track_name
+ ".\nNo sequence will be added to the multiFasta file.",
"Warning",
JOptionPane.WARNING_MESSAGE);
return;
}
seq =
seq.substring(
feature.getStart() - window_start,
feature.getEnd() - window_start + 1);
boolean negative_strand = reverse_mode == -1 ? true : false;
if (reverse_mode == 0) negative_strand = feature.getStrand().getValue() == -1;
if (negative_strand) {
seq = SequenceUtils.reverseComplementSequence(seq);
}
String header = feature.getAccessionID() + (negative_strand ? "_[RevComp]" : "");
header = header.replaceAll(" ", "_");
buf.append(prepareFileData(header, seq));
}
File file = new File(file_name);
try {
PrintStream fout;
FileWriter fwrite;
PrintWriter pwrite;
fwrite = new FileWriter(file);
fwrite.write(buf.toString());
fwrite.close();
} catch (IOException ioe) {
}
}
int line_length,
int line_space,
int trackID,
String file_name) {
int[] trackIDs = { trackID };
exportToMultiFASTA(line_length, line_space, trackIDs, file_name);
}*/
public static void exportToMultiFASTA(
int trackID,
int strand,
String file_name) {
int[] trackIDs = { trackID };
exportToMultiFASTA(trackIDs, strand, file_name);
}
public static void exportToMultiFASTA(
int[] trackIDs,
String file_name) {
exportToMultiFASTA(trackIDs, 1, file_name);
}
public static void exportToMultiFASTA(
int[] trackIDs,
int strand,
String file_name) {
StringBuffer buf = new StringBuffer();
for (int i = 0; i < trackIDs.length; i++) {
int track_id = trackIDs[i];
int window_start =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackDataWindowStart(
track_id);
int window_end =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackDataWindowEnd(
track_id);
String display_str =
StringUtils.getShortNameForTrackID(track_id);
display_str = display_str.replaceAll(" ", "_");
String seq =
DataStoreUser.getInstance().getSockeyeTrackList().getTrackSequence(
track_id);
display_str += ":"
+ window_start
+ ".."
+ window_end
+ "("
+ (window_end - window_start + 1)
+ "bp)";
if (strand == -1 ) {
seq = SequenceUtils.reverseComplementSequence(seq);
display_str = display_str.concat("_[RevComp]");
}
if (seq.length() == 0) {
String track_name =
(String) DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackAttribute(
track_id,
"track_name");
JOptionPane.showMessageDialog(
null,
"No sequence available for the track "
+ track_name
+ ".\nNo sequence will be added to the multiFasta file.",
"Warning",
JOptionPane.WARNING_MESSAGE);
return;
}
buf.append(prepareFileData(display_str, seq));
}
File file = new File(file_name);
try {
PrintStream fout;
FileWriter fwrite;
PrintWriter pwrite;
fwrite = new FileWriter(file);
fwrite.write(buf.toString());
fwrite.close();
} catch (IOException ioe) {
}
}
public static void exportToFASTA(String header, String sequence, String file_name) throws IOException {
String data = prepareFileData(header, sequence);
File file = new File(file_name);
FileWriter fwrite;
fwrite = new FileWriter(file, false);
fwrite.write(data);
fwrite.close();
}
public static void appendToMultiFASTA(String header, String sequence, String file_name) throws IOException {
String data = prepareFileData(header, sequence);
File file = new File(file_name);
FileWriter fwrite;
fwrite = new FileWriter(file, true);
fwrite.write(data);
fwrite.close();
}
private static String prepareFileData(String header, String sequence) {
if (header.lastIndexOf("\n") == header.length() - 1) header = header.substring(0, header.length() - 1);
if (header.charAt(0) != '>')header = ">" + header;
if (header.length() > 79) header = header.substring(0, 79);
StringBuffer seq_buf = new StringBuffer();
char ch;
for (int i = 0; i < sequence.length(); i++) {
ch = sequence.charAt(i);
if (Character.isLetter(ch) || ch == '-') {
seq_buf.append(ch);
} else if (!Character.isWhitespace(ch)) {
throw new IllegalArgumentException("Input sequence contains invalid characters.");
}
}
int est_file_length = header.length() + seq_buf.length() + seq_buf.length() / _CHARS_PER_LINE;
StringBuffer buf = new StringBuffer(est_file_length);
buf.append(header + "\n");
buf.append(SequenceUtils.cutString(seq_buf.toString(), _CHARS_PER_LINE, 0, ""));
if (buf.charAt(buf.length() - 1) != '\n') buf.append('\n');
return buf.toString();
}
}
package ca.bcgsc.sockeye.io;
import java.io.FileOutputStream;
import java.io.PrintWriter;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import org.biojava.bio.program.gff.GFFTools;
import org.biojava.bio.program.gff.GFFWriter;
import ca.bcgsc.sockeye.dataretrieval.DataSource;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.util.Log;
import ca.bcgsc.sockeye.util.StringUtils;
public class GFFExporter {
public static void exportToGFF(List t_ids, String file_name) {
}
public static void exportEnsemblTrackToGFF(int t_id, String file_name) {
int track_window_start =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackDataWindowStart(
t_id);
int track_window_end =
DataStoreUser.getInstance().getSockeyeTrackList().getTrackDataWindowEnd(
t_id);
int track_data_start =
DataStoreUser.getInstance().getSockeyeTrackList().getTrackDataStart(t_id);
int track_data_end =
DataStoreUser.getInstance().getSockeyeTrackList().getTrackDataEnd(t_id);
int track_offset =
DataStoreUser.getInstance().getSockeyeTrackList().getTrackOffset(t_id);
try {
List ds_list =
DataStoreUser.getInstance().getSockeyeTrackList().getDataSources(t_id);
Iterator ds_it = ds_list.iterator();
GFFWriter writer =
new GFFWriter(new PrintWriter(new FileOutputStream(file_name)));
writer.startDocument("");
while (ds_it.hasNext()) {
DataSource ds =
DataStoreUser.getInstance().getDataSourceManager().getDataSource(
Integer.parseInt(ds_it.next().toString()));
if (ds != null
&& !DataStoreUser
.getInstance()
.getDataSourceManager()
.isSingleShotSource(
ds.getId())) {
String s = ds.toString();
if (s != null && s.length() > 0)
writer.commentLine("#data_source:" + ds.toString());
}
}
String seq_name = StringUtils.getShortNameForTrackID(t_id);
TrackFeature track =
new TrackFeature(
seq_name,
"EnsEMBL",
"track",
track_window_start,
track_window_end,
GFFTools.NO_SCORE,
0,
GFFTools.NO_FRAME);
track.setAttribute("data_start", String.valueOf(track_data_start));
track.setAttribute("data_end", String.valueOf(track_data_end));
track.setAttribute("offset", String.valueOf(track_offset));
if (DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackHasFeature(t_id, "sequence")) {
String sequence =
DataStoreUser.getInstance().getSockeyeTrackList().getTrackSequence(
t_id);
if (sequence != null && sequence.length() > 0) {
track.setAttribute("sequence", sequence);
}
}
Iterator fn =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getFeatureNames(t_id)
.iterator();
while (fn.hasNext()) {
String feature_name = (String) fn.next();
if (!DataStoreUser.getInstance().getSockeyeTrackList().getFeatureVisibility(feature_name))
continue;
if (feature_name.equals("track"))
continue;
Collection features =
DataStoreUser.getInstance().getSockeyeTrackList().getFeatures(
t_id,
feature_name);
TrackFeature tf = null;
for (Iterator f = features.iterator(); f.hasNext();) {
tf = new TrackFeature((TrackFeature) f.next());
tf.setSeqName(seq_name);
try {
} catch (Exception e) {
e.printStackTrace();
} finally {
writer.recordLine(tf);
}
}
if (tf != null)
track.setSeqName(tf.getSeqName());
}
writer.recordLine(track);
writer.endDocument();
} catch (Exception e) {
e.printStackTrace();
Log.printStackTrace(e);
}
}
}
package ca.bcgsc.sockeye.io;
import java.awt.Color;
import java.awt.Frame;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.util.List;
import java.util.Vector;
import javax.swing.JFileChooser;
import ca.bcgsc.sockeye.analysis.scprofile.SCProfile;
import ca.bcgsc.sockeye.analysis.scprofile.SCProfileList;
import ca.bcgsc.sockeye.util.Log;
import ca.bcgsc.util.gui.scomponents.SockeyeFileChooser;
public class SCProfileExporter {
private static JButton ok_button, cancel_button;
private static JCheckBox[] checkboxes;
private static JPanel buttonPanel, dialogPanel, middlePanel, topPanel;
private static JLabel label;*/
private static Vector selected;
private static Frame parent;
private static SCProfileList scprofileList;
private static final int _default_track_name_length = 50;
private static final Color bgColor = Color.WHITE;
public static void exportSCProfileList(
Frame parent,
List profiles, SCProfileList scp) {
SCProfileExporter.parent = parent;
SCProfileExporter.scprofileList = scp;
int[] int_list = new int[profiles.size()];
for (int i = 0; i < profiles.size(); i++) {
int_list[i] = ((Integer)profiles.get(i)).intValue();
}
exportSequences(int_list);
new JDialog(parent, "Export", true);
chooseProfileDialog.setBackground(Color.white);
chooseProfileDialog.setSize(500, scprofileList.size() * 30 + 70);
chooseProfileDialog.setLocation(400, 450);
dialogPanel = new JPanel(new BorderLayout());
dialogPanel.setBackground(bgColor);
topPanel = new JPanel();
topPanel.setLayout(new BoxLayout(topPanel, BoxLayout.Y_AXIS));
topPanel.setBackground(bgColor);
middlePanel = new JPanel(new GridLayout(0, 1, 5, 5));
middlePanel.setBackground(bgColor);
buttonPanel = new JPanel();
buttonPanel.setBackground(bgColor);
buttonPanel.setLayout(new BoxLayout(buttonPanel, BoxLayout.X_AXIS));
label = new JLabel("Choose the sequence conservation profiles to export: ");
topPanel.add(label);
topPanel.add(Box.createRigidArea(new Dimension(0, 10)));
ok_button = new JButton("OK");
ok_button.setPreferredSize(new Dimension(100, 30));
ok_button.setMaximumSize(new Dimension(100, 30));
cancel_button = new JButton("Cancel");
cancel_button.setPreferredSize(new Dimension(100, 30));
cancel_button.setMaximumSize(new Dimension(100, 30));
buttonPanel.add(Box.createRigidArea(new Dimension(125, 0)));
buttonPanel.add(ok_button);
buttonPanel.add(Box.createRigidArea(new Dimension(50, 0)));
buttonPanel.add(cancel_button);
final int profileSize = scprofileList.size();
checkboxes = new JCheckBox[profileSize];
selected = new Vector();
for (int index = 0; index < profileSize; index++) {
SCProfile profile = scprofileList.getProfile(index);
String title = profile.getName();
checkboxes[index] =
new JCheckBox(title);
checkboxes[index].setBackground(bgColor);
middlePanel.add(checkboxes[index]);
if (index == profileSize - 1) {
checkboxes[index].setSelected(true);
}
}
dialogPanel.add(topPanel, BorderLayout.NORTH);
dialogPanel.add(middlePanel, BorderLayout.CENTER);
dialogPanel.add(buttonPanel, BorderLayout.SOUTH);
chooseProfileDialog.getContentPane().add(dialogPanel);
ok_button.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
for (int index = 0; index < profileSize; index++) {
if (checkboxes[index].getSelectedObjects() != null) {
selected.add(new Integer(index));
}
}
if (checkValidity(selected)) {
int[] selected_scprofile = new int[selected.size()];
for (int index = 0; index < selected.size(); index++) {
selected_scprofile[index] =
((Integer) selected.get(index)).intValue();
}
chooseProfileDialog.hide();
exportSequences(selected_scprofile);
}
selected = new Vector();
}
});
cancel_button.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
chooseProfileDialog.hide();
}
});
chooseProfileDialog.show();*/
}
private static boolean checkValidity(Vector selectedBox) {
return (selectedBox.size() > 0);
}
private static void exportSequences(int[] selected) {
String file_name = "";
File file = new File(".");
SockeyeFileChooser export_dialog =
SockeyeFileChooser.getSockeyeFileChooser("SCProfileExporter");
export_dialog.setDialogTitle("Export Profile Scores To...");
int result =
export_dialog.showSaveDialog(
parent,
"raw",
new File("ProfileScores.txt"));
try {
file_name =
export_dialog.getSelectedFile().getCanonicalPath();
file = export_dialog.getSelectedFile();
}
catch (Exception ex) {
Log.printStackTrace(ex);
System.out.println("Cannot handle file!!!!!");
return;
}
if (result == JFileChooser.APPROVE_OPTION) {
writeFile(file, selected);
}
}
private static void writeFile(File file, int[] selected) {
StringBuffer output_buffer = new StringBuffer("");
for (int index = 0; index < selected.length; index++) {
if (index != 0)
output_buffer.append("\n\n");
int select = selected[index];
SCProfile scprofile = scprofileList.getProfile(select);
String title = scprofile.getName();
output_buffer.append(title + "\n");
float[] scores = scprofile.getSmoothedScores();
String score = "NA";
for (int i = 0; i < scores.length; i++) {
float f_score = scores[i];
if (f_score == Float.NEGATIVE_INFINITY) score = "\tNA";
else score = "\t" + f_score;
output_buffer.append( (i + 1) + score + "\n");
}
output_buffer.append("\n");
}
try {
PrintStream fout;
FileWriter fwrite;
PrintWriter pwrite;
fwrite = new FileWriter(file);
fwrite.write(output_buffer.toString());
fwrite.close();
}
catch (IOException ioException) {
Log.printStackTrace(ioException);
}
}
}
package ca.bcgsc.sockeye.io;
import java.io.File;
import java.io.FileWriter;
import java.io.PrintWriter;
import java.util.Iterator;
import java.util.List;
import javax.swing.JOptionPane;
import ca.bcgsc.chinook.server.comobj.MotifDiscoveryHit;
import ca.bcgsc.chinook.server.comobj.MotifMatrix;
import ca.bcgsc.chinook.server.comobj.SerializableSimpleGFFRecord;
import ca.bcgsc.sockeye.util.Log;
public class TRANSFACExporter {
static int acc_id = 1;
public void exportToTRANSFAC(List items, File file) {
try {
FileWriter fw = new FileWriter(file);
PrintWriter pw = new PrintWriter(fw);
pw.println("VV TRANSFAC format MATRIX TABLE");
pw.println("XX" + "\n" + "
for (int i = 0; i < items.size(); i++) {
MotifDiscoveryHit hit = (MotifDiscoveryHit) items.get(i);
pw.print(createTRANSFAC(hit));
}
pw.close();
JOptionPane.showMessageDialog(
null,
"TRANSFAC File Created",
"File Created",
JOptionPane.INFORMATION_MESSAGE);
} catch (Throwable e) {
JOptionPane.showMessageDialog(
null,
"Error Writing to TRANSFAC File\nFile Not Created",
"Warning",
JOptionPane.WARNING_MESSAGE);
Log.printStackTrace(e);
e.printStackTrace();
}
}
private String createTRANSFAC(MotifDiscoveryHit input) {
StringBuffer sb = new StringBuffer();
String space_txt = " ";
String source = "";
MotifMatrix pwm = input.getPWM();
String concensus = input.getConsensus();
String zeros = "";
if (acc_id < 10)
zeros = "0000";
else if (acc_id < 100)
zeros = "000";
else if (acc_id < 1000)
zeros = "00";
else if (acc_id < 10000)
zeros = "0";
sb.append("AC M" + zeros + acc_id++ + "\n");
sb.append("XX\n");
sb.append("NA " + input.getConsensus() + "\n");
sb.append("XX\n");
List gffs = input.getGffRecord();
for (Iterator i = gffs.iterator(); i.hasNext();) {
SerializableSimpleGFFRecord gff = (SerializableSimpleGFFRecord) i.next();
source = gff.getSource();
sb.append("BF T00xxx; xxxxxxxx; Species: " + "\n");
}
sb.append("XX\n");
sb.append(
"P0"
+ space_txt
+ "A"
+ space_txt
+ "C"
+ space_txt
+ "G"
+ space_txt
+ "T"
+ space_txt
+ "\n");
for (int i = 0; i < pwm.size(); i++) {
String pos = "" + i;
if (i < 10) {
pos = "0" + i;
}
sb.append(pos);
float[] row = pwm.getRow(i);
for (int j = 0; j < row.length; j++) {
String space = " ";
if ((int) row[j] >= 10) {
space = " ";
}
sb.append(space + (int) row[j]);
}
sb.append(space_txt + concensus.charAt(i) + "\n");
}
sb.append("XX" + "\n");
sb.append("BA The consensus is the result of " + source + " discovery\n");
sb.append("XX\n");
sb.append("
return (new String(sb));
}
}
package ca.bcgsc.sockeye.j3d;
import java.util.Date;
import java.util.Enumeration;
import java.util.Hashtable;
import javax.media.j3d.Behavior;
import javax.media.j3d.Shape3D;
import javax.media.j3d.Transform3D;
import javax.media.j3d.TransformGroup;
import javax.media.j3d.WakeupCondition;
import javax.media.j3d.WakeupCriterion;
import javax.media.j3d.WakeupOnCollisionEntry;
import javax.media.j3d.WakeupOnCollisionMovement;
import javax.media.j3d.WakeupOr;
import javax.vecmath.Vector3d;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
public class CollisionDetectionBehavior3D
extends Behavior {
private WakeupCondition m_wakeup_condition;
private TransformGroup target;
private Shape3D shape;
private boolean isInitialized;
private static Hashtable messageQueue;
public CollisionDetectionBehavior3D(TransformGroup target,
Shape3D arming_shape) {
WakeupCriterion criterionArray[] = new WakeupCriterion[2];
criterionArray[0] = new WakeupOnCollisionEntry(arming_shape,
WakeupOnCollisionEntry.USE_GEOMETRY);
criterionArray[1] = new WakeupOnCollisionMovement(arming_shape,
WakeupOnCollisionEntry.USE_GEOMETRY);
m_wakeup_condition = new WakeupOr(criterionArray);
shape = arming_shape;
this.target = target;
isInitialized = false;
}
public static void startUpMessageQueue() {
messageQueue = new Hashtable();
messageQueue.clear();
}
public static boolean messageQueueIsEmpty() {
return messageQueue.isEmpty();
}
public void initialize() {
wakeupOn(m_wakeup_condition);
Date s = new Date();
long t1 = s.getTime();
isInitialized = true;
}
public void processStimulus(Enumeration criteria) {
while (criteria.hasMoreElements()) {
WakeupCriterion wakeUp = (WakeupCriterion) criteria.nextElement();
if (wakeUp instanceof WakeupOnCollisionEntry) {
Transform3D zAxis = new Transform3D();
target.getTransform(zAxis);
Vector3d vect = new Vector3d();
zAxis.get(vect);
getPlatformBranchGroup());
pickTool.setMode(PickTool.BOUNDS);
PickBounds pickBoundsBox = new PickBounds(boundbox);
pickTool.setShape(pickBoundsBox, new Point3d(0, 0, 0));
Appearance appx = new Appearance();
TransparencyAttributes tatts = new TransparencyAttributes();
tatts.setTransparencyMode(TransparencyAttributes.BLENDED);
tatts.setTransparency(0.5f);
ColoringAttributes catts = new ColoringAttributes(new Color3f(1.0f, 0.0f, 0.0f), ColoringAttributes.SHADE_FLAT);
appx.setTransparencyAttributes(tatts);
appx.setColoringAttributes(catts);
BranchGroup collision_bg = new BranchGroup();
Point3d lower = new Point3d();
boundbox.getLower(lower);
Point3d upper = new Point3d();
boundbox.getUpper(upper);
Box box = new Box((float) (upper.x - lower.x), (float) (upper.y - lower.y), (float) (upper.z - lower.z), appx);
box.setCapability(Shape3D.ALLOW_GEOMETRY_READ);
collision_bg.addChild(box);
target.addChild(collision_bg);
1 */
TrackFeature trigger;
TrackFeature armed;
if (wakeUp instanceof WakeupOnCollisionMovement) {
trigger = (TrackFeature) ( (WakeupOnCollisionMovement) wakeUp).
getTriggeringPath().getObject().getUserData();
armed = (TrackFeature) ( (WakeupOnCollisionMovement) wakeUp).
getArmingPath().getObject().getUserData();
}
else {
trigger = (TrackFeature) ( (WakeupOnCollisionEntry) wakeUp).
getTriggeringPath().getObject().getUserData();
armed = (TrackFeature) ( (WakeupOnCollisionEntry) wakeUp).
getArmingPath().getObject().getUserData();
}
if (trigger != null && armed != null) {
if (trigger.getFeature().equals(armed.getFeature())) {
String armed_acc = armed.getAccessionID();
String trigger_acc = trigger.getAccessionID();
if (messageQueue.containsKey(trigger_acc) &&
messageQueue.get(trigger_acc).equals(armed_acc)) {
messageQueue.remove(trigger_acc);
this.printTime();
}
else if (messageQueue.containsKey(armed_acc) &&
messageQueue.get(armed_acc).equals(trigger_acc)) {
messageQueue.remove(armed_acc);
this.printTime();
}
else {
this.printTime();
vect.z = vect.z + 0.1;
zAxis.setTranslation(vect);
target.setTransform(zAxis);
messageQueue.put(armed_acc, trigger_acc);
}
}
}
PickResult[] resultArray = pickTool.pickAll();
boolean executeTransform = false;
if (resultArray != null) {
for (int n = 0; n < resultArray.length; n++) {
Primitive track = (Primitive) resultArray[n].getNode(PickResult.
PRIMITIVE);
Object userData;
if (track != null) {
userData = (String) track.getUserData();
}
else {
userData = (TrackFeature) resultArray[n].getObject().getUserData();
}
TrackFeature shapeUserData = (TrackFeature) shape.getUserData();
if (track == null) {
System.out.println("Collision between: " +
shapeUserData.getFeatureName() + "," +
shapeUserData.getAccessionId() +
" and: " +
( (TrackFeature) userData).getFeatureName() +
"," +
( (TrackFeature) userData).getAccessionId());
}
else {
System.out.println("Collision between: " +
shapeUserData.getFeatureName() + "," +
shapeUserData.getAccessionId() +
" and: " + userData);
}
if (userData != null) {
executeTransform = true;
}
}
}
if (executeTransform == true) {
vect.z = vect.z + 0.2;
zAxis.setTranslation(vect);
target.setTransform(zAxis);
}
2*/
}
}
wakeupOn(m_wakeup_condition);
}
private void printTime() {
Date s = new Date();
long t1 = s.getTime();
}
}
package ca.bcgsc.sockeye.j3d;
import java.awt.Color;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import javax.media.j3d.Appearance;
import javax.media.j3d.ColoringAttributes;
import javax.media.j3d.Font3D;
import javax.media.j3d.FontExtrusion;
import javax.media.j3d.Geometry;
import javax.media.j3d.GeometryArray;
import javax.media.j3d.PolygonAttributes;
import javax.media.j3d.QuadArray;
import javax.media.j3d.Shape3D;
import javax.media.j3d.Text3D;
import javax.media.j3d.Transform3D;
import javax.media.j3d.TransformGroup;
import javax.media.j3d.TransparencyAttributes;
import javax.vecmath.Color3f;
import javax.vecmath.Point3f;
import javax.vecmath.Vector3d;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.datastorage.TrackDistribution;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.service.featureloader.common.DistributionContainer;
import com.sun.j3d.utils.geometry.GeometryInfo;
import com.sun.j3d.utils.geometry.NormalGenerator;
public class DistributionFeature3D extends Feature3D {
protected TrackDistribution userdata;
private static boolean GAUSS = false;
private static boolean SKYSCRAPER = true;
protected static boolean stackInYDirection = true;
protected int grid_length_gu;
protected static int grid_width_gu;
protected static double increment_3Du = 0.01;
protected static float defaultTransparency = 0.2f;
protected float start_x_3Du;
protected float start_y_3Du;
protected float start_z_3Du;
protected int offsetPosition;
protected static float scale = 0.7f;
private float stdev = -1;
private float skyscraper_width_gu = 2;
private static float global_maximum_Z_value = -1;
private static boolean normalize_to_global_max = false;
private HashMap height_rec = new HashMap();
private Color3f staticFeatureColor = null;
private static boolean useStaticFeatureColor = false;
protected static boolean show_text_annotations = false;
private static boolean showCoordSystem = false;
private static boolean showCoordZAxis = true;
protected static float tickWidth = 2f;
protected static float coordTransparencyVal = 0f;
private Appearance distribAppearance;
protected Appearance distCoordSystemApp;
protected TransformGroup coordSystemTextGroup;
protected TransformGroup textAnnotationGroup;
public DistributionFeature3D() {
};
public DistributionFeature3D(
Track3D track3d,
TrackFeature userdata,
SharedFeatureComponent3D shared_comp) {
this.userdata = (TrackDistribution) userdata;
this.track3d = track3d;
if (this.userdata.getMaxScore() > global_maximum_Z_value)
global_maximum_Z_value = (float) this.userdata.getMaxScore();
if (shared_comp != null)
staticFeatureColor =
new Color3f(shared_comp.getFeatureDisplay().getColor());
else
staticFeatureColor = new Color3f(Color.MAGENTA);
this.offsetPosition = track3d.getDistributionFeatureCount();
this.grid_length_gu = (int) (Platform3D.platform_x_length / increment_3Du);
grid_width_gu = 5;
this.stdev = (float) (2 * increment_3Du);
this.start_x_3Du = (float) - (grid_length_gu * increment_3Du) / 2;
this.start_y_3Du = (float) - ((grid_width_gu * increment_3Du) / 2);
scale_vector_tg.setCapability(TransformGroup.ALLOW_TRANSFORM_WRITE);
feat_pos_tg.setCapability(TransformGroup.ALLOW_TRANSFORM_WRITE);
feat_rot_tg.setCapability(TransformGroup.ALLOW_TRANSFORM_WRITE);
this.resetFeature();
track3d.getFeatureTransformGroup().addChild(feat_pos_tg);
feat_pos_tg.addChild(feat_rot_tg);
feat_rot_tg.addChild(scale_vector_tg);
distribAppearance = new Appearance();
if (shared_comp != null)
distribAppearance.setMaterial(shared_comp.getAppearance().getMaterial());
ColoringAttributes ca = new ColoringAttributes();
ca.setShadeModel(ColoringAttributes.SHADE_GOURAUD);
distribAppearance.setColoringAttributes(ca);
distCoordSystemApp = new Appearance();
PolygonAttributes a = new PolygonAttributes();
a.setBackFaceNormalFlip(true);
a.setCullFace(PolygonAttributes.CULL_NONE);
distCoordSystemApp.setPolygonAttributes(a);
shape = new Shape3D();
shape.setUserData(this.userdata);
shape.setCapability(Shape3D.ALLOW_PICKABLE_READ);
shape.setCapability(Shape3D.ALLOW_GEOMETRY_READ);
shape.setCapability(Shape3D.ALLOW_GEOMETRY_WRITE);
shape.setCapability(Shape3D.ALLOW_APPEARANCE_READ);
shape.setCapability(Shape3D.ALLOW_APPEARANCE_WRITE);
shape.setPickable(true);
scale_vector_tg.addChild(shape);
coordSystemTextGroup = new TransformGroup();
textAnnotationGroup = new TransformGroup();
scale_vector_tg.addChild(coordSystemTextGroup);
scale_vector_tg.addChild(textAnnotationGroup);
}
protected TransformGroup createTextLabel(
String text,
double zPos,
double rotDeg,
boolean alignLeft,
Color3f color) {
Shape3D textShape = new Shape3D();
Transform3D rot = new Transform3D();
Transform3D scale_rot_trans = new Transform3D();
TransformGroup textloc = new TransformGroup();
Font3D font3d = new Font3D(Configuration.getFont("Feature Label"), new FontExtrusion());
Text3D text3d = new Text3D(font3d, text);
double text_x =
(alignLeft
? start_x_3Du - 0.02
: start_x_3Du + Platform3D.platform_x_length + 0.02);
double text_y = start_y_3Du + (double) grid_width_gu * increment_3Du / 2.0;
if (color != null) {
Appearance text_app = new Appearance();
ColoringAttributes text_ca =
new ColoringAttributes(color, ColoringAttributes.FASTEST);
text_app.setColoringAttributes(text_ca);
textShape.setAppearance(text_app);
}
textShape.setCapability(Shape3D.ALLOW_GEOMETRY_READ);
textShape.setCapability(Shape3D.ALLOW_GEOMETRY_WRITE);
textShape.setCapability(Shape3D.ALLOW_APPEARANCE_READ);
textShape.setCapability(Shape3D.ALLOW_APPEARANCE_WRITE);
textShape.setPickable(false);
text3d.setPath(Text3D.PATH_RIGHT);
if (alignLeft)
text3d.setAlignment(Text3D.ALIGN_LAST);
else
text3d.setAlignment(Text3D.ALIGN_FIRST);
scale_rot_trans.set(0.03d, new Vector3d(text_x, text_y, zPos));
rot.rotX(Math.toRadians(rotDeg));
scale_rot_trans.mul(rot);
textShape.setGeometry(text3d);
textloc.setTransform(scale_rot_trans);
textloc.addChild(textShape);
return textloc;
}
public void kill() {
super.kill();
height_rec = null;
}
protected void generate3DFeature() {
start_z_3Du = (stackInYDirection ? 0 : scale * (float) offsetPosition);
this.start_y_3Du = (float) - ((grid_width_gu * increment_3Du) / 2);
float y_3Du =
(float)
+ (Platform3D.platform_y_width_default)
+ (float) (grid_width_gu * increment_3Du)
+ (stackInYDirection
? offsetPosition * ((float) (grid_width_gu * increment_3Du * 2))
: 0);
double offset_center_local =
(track3d.getLength() / track3d.getCurrentScale()) / 2;
feat_pos_v3d.set(offset_center_local, y_3Du, 0);
feat_pos_T3D.set(feat_pos_v3d);
feat_pos_tg.setTransform(feat_pos_T3D);
shape.removeAllGeometries();
shape.addGeometry(buildGeometry());
coordSystemTextGroup.removeAllChildren();
if (showCoordSystem)
buildZAxis();
textAnnotationGroup.removeAllChildren();
if (show_text_annotations)
fillTextAnnotationTG();
distribAppearance.setTransparencyAttributes(
new TransparencyAttributes(
TransparencyAttributes.NICEST,
defaultTransparency));
shape.setAppearance(distribAppearance);
}
protected void fillTextAnnotationTG() {
textAnnotationGroup.addChild(
createTextLabel(
userdata.getFeature(),
start_z_3Du,
45,
true,
staticFeatureColor));
}
protected Geometry buildZAxis() {
double w = grid_width_gu * increment_3Du;
double l = grid_length_gu * increment_3Du;
double h = scale;
double t = 0.01;
double x = start_x_3Du;
double y = start_y_3Du;
double z = start_z_3Du;
int numTicks =
(int) ((normalize_to_global_max
? global_maximum_Z_value
: userdata.getMaxScore())
/ tickWidth);
double tickHeight =
h
/ ((normalize_to_global_max
? global_maximum_Z_value
: userdata.getMaxScore())
/ tickWidth);
Shape3D coordSystemShape = new Shape3D();
coordSystemShape.setPickable(false);
coordSystemShape.setCapability(Shape3D.ALLOW_GEOMETRY_READ);
coordSystemShape.setCapability(Shape3D.ALLOW_GEOMETRY_WRITE);
coordSystemShape.setCapability(Shape3D.ALLOW_APPEARANCE_READ);
coordSystemShape.setCapability(Shape3D.ALLOW_APPEARANCE_WRITE);
double zAxisBoxCoord[] = new double[] {
x, y, z, x, y + w, z, x, y + w, z + h, x, y, z + h,
x - t, y, z, x - t, y + w, z, x - t, y + w, z + h, x - t, y, z + h,
x, y, z, x - t, y, z, x - t, y, z + h, x, y, z + h,
x, y + w, z, x - t, y + w, z, x - t, y + w, z + h, x, y + w, z + h,
x, y, z, x - t, y, z, x - t, y + w, z, x, y + w, z,
x, y, z + h, x - t, y, z + h, x - t, y + w, z + h, x, y + w, z + h, };
double[] tickBoxes = new double[numTicks * 4 * 3];
if (!showCoordZAxis && numTicks == 0)
return null;
for (int tick = 1; tick <= numTicks; tick++) {
int n = (tick - 1) * 12;
tickBoxes[n] = x;
tickBoxes[n + 1] = y;
tickBoxes[n + 2] = z + tickHeight * tick;
tickBoxes[n + 3] = x + l;
tickBoxes[n + 4] = y;
tickBoxes[n + 5] = z + tickHeight * tick;
tickBoxes[n + 6] = x + l;
tickBoxes[n + 7] = y + w;
tickBoxes[n + 8] = z + tickHeight * tick;
tickBoxes[n + 9] = x;
tickBoxes[n + 10] = y + w;
tickBoxes[n + 11] = z + tickHeight * tick;
if (showCoordZAxis)
coordSystemTextGroup.addChild(
createTextLabel(
Float.toString((float) (tick * tickWidth)),
z + tickHeight * tick,
90,
true,
null));
}
Color3f bcolor = new Color3f(java.awt.Color.blue);
Color3f tcolor = new Color3f(java.awt.Color.gray);
Color3f[] boxPointColor = new Color3f[zAxisBoxCoord.length];
Color3f[] tickPointColor = new Color3f[tickBoxes.length];
Arrays.fill(boxPointColor, bcolor);
Arrays.fill(tickPointColor, tcolor);
QuadArray box_quads =
new QuadArray(
showCoordZAxis
? zAxisBoxCoord.length + tickBoxes.length
: tickBoxes.length,
GeometryArray.COORDINATES | GeometryArray.COLOR_3);
box_quads.setCoordinates(0, tickBoxes);
box_quads.setColors(0, tickPointColor);
if (showCoordZAxis) {
box_quads.setCoordinates(tickBoxes.length, zAxisBoxCoord);
box_quads.setColors(tickBoxes.length, boxPointColor);
}
coordSystemShape.addGeometry(box_quads);
distCoordSystemApp.setTransparencyAttributes(
new TransparencyAttributes(
TransparencyAttributes.NICEST,
coordTransparencyVal));
coordSystemShape.setAppearance(distCoordSystemApp);
coordSystemTextGroup.addChild(coordSystemShape);
return box_quads;
}
protected Geometry buildGeometry() {
Point3f[] my_coords = generateGridPoints();
Color3f[] my_colors = generateColorPoints(my_coords);
QuadArray my_quads =
new QuadArray(
my_coords.length,
GeometryArray.COORDINATES | GeometryArray.COLOR_3);
my_quads.setCoordinates(0, my_coords);
my_quads.setColors(0, my_colors);
my_quads.setCapability(GeometryArray.ALLOW_COLOR_WRITE);
my_quads.setCapability(GeometryArray.ALLOW_COLOR_READ);
my_quads.setCapability(GeometryArray.ALLOW_COUNT_READ);
my_quads.setCapability(GeometryArray.ALLOW_FORMAT_READ);
my_quads.setCapability(GeometryArray.ALLOW_COORDINATE_READ);
if (useStaticFeatureColor) {
GeometryInfo gi = new GeometryInfo(my_quads);
NormalGenerator ng = new NormalGenerator();
ng.generateNormals(gi);
GeometryArray ga_with_normals = gi.getGeometryArray();
ga_with_normals.setCapability(GeometryArray.ALLOW_COORDINATE_READ);
ga_with_normals.setCapability(GeometryArray.ALLOW_COLOR_WRITE);
ga_with_normals.setCapability(GeometryArray.ALLOW_COLOR_READ);
ga_with_normals.setCapability(GeometryArray.ALLOW_COUNT_READ);
ga_with_normals.setCapability(GeometryArray.ALLOW_FORMAT_READ);
ga_with_normals.setCapability(GeometryArray.ALLOW_COORDINATE_READ);
return ga_with_normals;
}
return my_quads;
}
private Point3f[] generateGridPoints() {
Point3f[] my_coords = new Point3f[grid_length_gu * grid_width_gu * 4];
int point_number = 0;
if (stdev == -1) {
stdev = (float) increment_3Du;
}
for (int i = 0; i < grid_length_gu; i++) {
for (int j = 0; j < grid_width_gu; j++) {
float x, y, z;
x = (float) (start_x_3Du + (increment_3Du * i));
y = (float) (start_y_3Du + (increment_3Du * j));
z = start_z_3Du + height_model_z(x, y);
my_coords[point_number] = new Point3f(x, y, z);
point_number++;
x = (float) (start_x_3Du + ((increment_3Du * i) + increment_3Du));
y = (float) (start_y_3Du + (increment_3Du * j));
z = start_z_3Du + height_model_z(x, y);
my_coords[point_number] = new Point3f(x, y, z);
point_number++;
x = (float) (start_x_3Du + ((increment_3Du * i) + increment_3Du));
y = (float) (start_y_3Du + ((increment_3Du * j) + increment_3Du));
z = start_z_3Du + height_model_z(x, y);
my_coords[point_number] = new Point3f(x, y, z);
point_number++;
x = (float) (start_x_3Du + (increment_3Du * i));
y = (float) (start_y_3Du + ((increment_3Du * j) + increment_3Du));
z = start_z_3Du + height_model_z(x, y);
my_coords[point_number] = new Point3f(x, y, z);
point_number++;
}
}
height_rec.clear();
return my_coords;
}
private Color3f[] generateColorPoints(Point3f[] my_points) {
Color3f[] my_colors = new Color3f[my_points.length];
double score = 0;
if ((useStaticFeatureColor == true) && (this.staticFeatureColor != null)) {
Arrays.fill(my_colors, this.staticFeatureColor);
return my_colors;
}
for (int i = 0; i < my_points.length; i++) {
score = ((my_points[i].z - start_z_3Du) / scale) * 100.0;
if (score == 0) {
my_colors[i] = new Color3f(new Color(0, 0, 255));
} else if (score >= 0 && score < 10) {
my_colors[i] = new Color3f(new Color(0, 0, 128));
} else if (score >= 10 && score < 20) {
my_colors[i] = new Color3f(new Color(135, 206, 250));
} else if (score >= 20 && score < 30) {
my_colors[i] = new Color3f(new Color(0, 205, 0));
} else if (score >= 30 && score < 40) {
my_colors[i] = new Color3f(new Color(0, 255, 0));
} else if (score >= 40 && score < 50) {
my_colors[i] = new Color3f(new Color(255, 255, 0));
} else if (score >= 50 && score < 60) {
my_colors[i] = new Color3f(new Color(255, 215, 0));
} else if (score >= 60 && score <= 70) {
my_colors[i] = new Color3f(new Color(255, 165, 0));
} else if (score >= 70 && score < 80) {
my_colors[i] = new Color3f(new Color(178, 58, 238));
} else if (score >= 80 && score < 90) {
my_colors[i] = new Color3f(new Color(255, 99, 71));
} else if (score >= 90 && score <= 100) {
my_colors[i] = new Color3f(new Color(255, 0, 0));
} else {
my_colors[i] = new Color3f(1.0f, 0.0f, 0.0f);
}
}
return my_colors;
}
private float height_model_z(float x, float y) {
float value = 0.0f;
if (DistributionFeature3D.GAUSS) {
double max_score = this.getMaxScore(x);
if (max_score > 0) {
max_score = max_score / userdata.getMaxScore();
value =
(float) (scale
}
} else {
float grid_width_min_3Du = (float) (start_y_3Du + increment_3Du);
float grid_width_max_3Du =
(float) (start_y_3Du
+ ((this.skyscraper_width_gu + 1) * increment_3Du));
if (y >= grid_width_min_3Du && y <= grid_width_max_3Du) {
if (height_rec.containsKey(Float.toString(x))) {
Object val = (Object) height_rec.get(Float.toString(x));
value = Float.valueOf((String) val).floatValue();
} else {
double max_score = this.getMaxScore(x);
max_score =
max_score
/ (normalize_to_global_max
? global_maximum_Z_value
: userdata.getMaxScore());
value = (float) ((scale * max_score));
height_rec.put(String.valueOf(x), String.valueOf(value));
}
}
}
if (value == Float.NaN) {
return 0;
} else {
return value;
}
}
private double getMaxScore(float x) {
double track_length_abs = track3d.getLength() / track3d.getCurrentScale();
double length_scale =
(this.grid_length_gu * increment_3Du) / track_length_abs;
double x_nt =
((x + (0.5 * this.grid_length_gu * increment_3Du)) / length_scale)
x_nt = x_nt + (double) track3d.getStart();
double incr_nt =
0.5 * ((increment_3Du / length_scale) * track3d.getCurrentScale());
DistributionContainer dc_ranged;
double max_score = 0;
for (Iterator i = userdata.getDistributionInfo().iterator();
i.hasNext();
) {
DistributionContainer dc = (DistributionContainer) i.next();
if (dc.getStart() >= (x_nt - incr_nt)
&& dc.getStart() <= (x_nt + incr_nt)) {
if (dc.getScore() > max_score) {
max_score = dc.getScore();
}
} else if (
dc.getEnd() >= (x_nt - incr_nt) && dc.getEnd() <= (x_nt + incr_nt)) {
if (dc.getScore() > max_score) {
max_score = dc.getScore();
}
} else if (
dc.getStart() <= (x_nt - incr_nt) && dc.getEnd() >= (x_nt + incr_nt)) {
if (dc.getScore() > max_score) {
max_score = dc.getScore();
}
} else {
continue;
}
}
return max_score;
}
public void resetFeature() {
double Xscale =
(track3d.getLength() / track3d.getCurrentScale())
/ (grid_length_gu * increment_3Du);
double Yscale = 2;
double Zscale = scale;
scale_vector.set(Xscale, Yscale, Zscale);
scale_vector_t3d.setScale(scale_vector);
scale_vector_tg.setTransform(scale_vector_t3d);
double offset_center_local =
(track3d.getLength() / track3d.getCurrentScale()) / 2;
float y_3Du =
(float)
+ (Platform3D.platform_y_width_default)
+ (float) (grid_width_gu * increment_3Du)
+ (stackInYDirection
? offsetPosition * ((float) (grid_width_gu * increment_3Du * 2))
: 0);
feat_pos_v3d.set(offset_center_local, y_3Du, 0);
feat_pos_T3D.set(feat_pos_v3d);
feat_pos_tg.setTransform(feat_pos_T3D);
if (track3d.getReverse()) {
feat_rot_T3D.rotZ(Math.toRadians(180d));
} else {
feat_rot_T3D.rotZ(0d);
}
feat_rot_tg.setTransform(feat_rot_T3D);
}
public String getAccessionId() {
return userdata.getAccessionID();
}
public void setAppearance(Appearance highlight_ap) {
}
public void increaseSize() {
}
public void resetSize() {
}
public void setStaticColor(Color3f c) {
staticFeatureColor = c;
}
public static void setUseStaticFeatureColor(boolean usf) {
useStaticFeatureColor = usf;
}
public static boolean getUseStaticFeatureColor() {
return useStaticFeatureColor;
}
public static float getScale() {
return scale;
}
public static void setScale(float s) {
scale = (s < 0.1f ? 0.1f : s);
}
public static double getWidth3Dunits() {
return grid_width_gu * increment_3Du;
}
public static boolean getStackInYDirection() {
return stackInYDirection;
}
public static void setStackInYDirection(boolean ydir) {
stackInYDirection = ydir;
}
public static float getDefaultTransparency() {
return defaultTransparency;
}
public static void setDefaultTransparency(float t) {
defaultTransparency = t;
}
public void setOffset(int order) {
offsetPosition = order;
generate3DFeature();
}
public int getOffset() {
return offsetPosition;
}
public static float getGlobalZMaximum() {
return global_maximum_Z_value;
}
public static void setGlobalZMaximum(float o) {
global_maximum_Z_value = o;
}
public float getLocalZMaximum() {
return (float) userdata.getMaxScore();
}
public static void set3DNormalizeToGlobalMax(boolean n) {
normalize_to_global_max = n;
}
public static boolean get3DNormalizeToGlobalMax() {
return normalize_to_global_max;
}
public static boolean getShowCoordSystem() {
return showCoordSystem;
}
public static void setShowCoordSystem(boolean b) {
showCoordSystem = b;
}
public static boolean getShowCoordZAxis() {
return showCoordZAxis;
}
public static void setShowCoordZAxis(boolean b) {
showCoordZAxis = b;
}
public static float getCoordSystemTickWidth() {
return tickWidth;
}
public static void setCoordSystemTickWidth(float i) {
tickWidth = i;
}
public static double getCoordTransparency() {
return coordTransparencyVal;
}
public static void setCoordTransparency(float d) {
coordTransparencyVal = d;
}
public static boolean getShowTextAnnotation() {
return show_text_annotations;
}
public static void setShowTextAnnotation(boolean b) {
show_text_annotations = b;
}
}
package ca.bcgsc.sockeye.j3d;
import javax.media.j3d.Appearance;
import javax.media.j3d.Billboard;
import javax.media.j3d.BoundingSphere;
import javax.media.j3d.Shape3D;
import javax.media.j3d.Transform3D;
import javax.media.j3d.TransformGroup;
import javax.vecmath.Color3f;
import javax.vecmath.Point3d;
import javax.vecmath.Point3f;
import javax.vecmath.Vector3d;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.config.FeatureDisplay;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.j3d.CollisionDetectionBehavior3D;
import ca.bcgsc.sockeye.j3d.SharedFeatureComponent3D;
import ca.bcgsc.sockeye.j3d.Track3D;
import com.sun.j3d.utils.geometry.Text2D;
public class Feature3D {
public Feature3D() {
}
private static final float stick_out_length=
Configuration.getPlatformLength() * Configuration.getPlatformStickOut();
protected static final float percent_to_local_scale= 300;
protected double shape_thickness;
protected double shape_width;
protected double shape_z_offset;
protected double shape_y_offset;
protected double shape_start, shape_end;
protected TrackFeature userdata;
protected FeatureDisplay feature_display;
protected Vector3d shape_dims;
protected Shape3D shape;
protected double offset_center_nt;
protected Track3D track3d;
protected Vector3d feat_pos_v3d= new Vector3d();
protected Transform3D feat_pos_T3D= new Transform3D();
protected TransformGroup feat_pos_tg= new TransformGroup();
protected Transform3D feat_rot_T3D= new Transform3D();
protected TransformGroup feat_rot_tg= new TransformGroup();
protected Vector3d scale_vector= new Vector3d();
protected Transform3D scale_vector_t3d= new Transform3D();
protected TransformGroup scale_vector_tg= new TransformGroup();
protected Vector3d shape_transform_v3d;
protected Transform3D shape_transform_t3d= new Transform3D();
protected TransformGroup shape_transform_tg= new TransformGroup();
protected boolean text_added;
protected Vector3d text_pos_v3d;
protected Transform3D text_pos_t3d;
protected TransformGroup text_pos_tg;
protected static boolean _set_text_2D= false;
protected static boolean _set_billboard= false;
protected static boolean _set_truncate_text= true;
private static final double text_x_offset= 0d,
text_y_offset= 0d,
text_z_offset= Configuration.getFeatureDisplay("Gene text label", false, false).getZOffset();
public Feature3D(
Track3D track3d,
TrackFeature userdata,
SharedFeatureComponent3D sfc3d) {
this.userdata= userdata;
this.feature_display= sfc3d.getFeatureDisplay();
this.shape_dims= sfc3d.getShapeDims();
this.track3d= track3d;
shape= new Shape3D(sfc3d.getGeometry(), sfc3d.getAppearance());
shape.setBoundsAutoCompute(true);
shape.setPickable(true);
shape.setCapability(Shape3D.ALLOW_APPEARANCE_WRITE);
shape.setCapability(Shape3D.ALLOW_APPEARANCE_READ);
shape.setCapability(Shape3D.ALLOW_PICKABLE_READ);
shape.setCapability(Shape3D.ALLOW_GEOMETRY_READ);
shape.setCapability(Shape3D.ALLOW_BOUNDS_READ);
shape.setUserData(userdata);
shape_transform_v3d= sfc3d.getShapeTransform();
shape_transform_t3d.set(shape_transform_v3d);
shape_transform_tg.setTransform(shape_transform_t3d);
scale_vector_tg.setCapability(TransformGroup.ALLOW_TRANSFORM_WRITE);
feat_rot_tg.setCapability(TransformGroup.ALLOW_TRANSFORM_WRITE);
feat_pos_tg.setCapability(TransformGroup.ALLOW_TRANSFORM_WRITE);
shape_transform_tg.setCapability(TransformGroup.ALLOW_TRANSFORM_WRITE);
scale_vector_tg.setCapability(TransformGroup.ALLOW_TRANSFORM_READ);
feat_rot_tg.setCapability(TransformGroup.ALLOW_TRANSFORM_READ);
feat_pos_tg.setCapability(TransformGroup.ALLOW_TRANSFORM_READ);
shape_transform_tg.setCapability(TransformGroup.ALLOW_TRANSFORM_READ);
scale_vector_tg.setCapability(TransformGroup.ALLOW_BOUNDS_READ);
feat_rot_tg.setCapability(TransformGroup.ALLOW_BOUNDS_READ);
feat_pos_tg.setCapability(TransformGroup.ALLOW_BOUNDS_READ);
shape_transform_tg.setCapability(TransformGroup.ALLOW_BOUNDS_READ);
scale_vector_tg.setCapability(TransformGroup.ALLOW_CHILDREN_EXTEND);
feat_rot_tg.setCapability(TransformGroup.ALLOW_CHILDREN_EXTEND);
feat_pos_tg.setCapability(TransformGroup.ALLOW_CHILDREN_EXTEND);
shape_transform_tg.setCapability(TransformGroup.ALLOW_CHILDREN_EXTEND);
scale_vector_tg.setCapability(TransformGroup.ALLOW_CHILDREN_WRITE);
feat_rot_tg.setCapability(TransformGroup.ALLOW_CHILDREN_WRITE);
feat_pos_tg.setCapability(TransformGroup.ALLOW_CHILDREN_WRITE);
shape_transform_tg.setCapability(TransformGroup.ALLOW_CHILDREN_WRITE);
scale_vector_tg.setCapability(TransformGroup.ALLOW_CHILDREN_READ);
feat_rot_tg.setCapability(TransformGroup.ALLOW_CHILDREN_READ);
feat_pos_tg.setCapability(TransformGroup.ALLOW_CHILDREN_READ);
shape_transform_tg.setCapability(TransformGroup.ALLOW_CHILDREN_READ);
shape_width= feature_display.getWidth();
setThicknessAndZOffset();
shape_y_offset= feature_display.getYOffset();
text_added=
feature_display.isText()
&& _set_text_2D
&& userdata.getAttribute("display_string") != null
&& !userdata.getAttribute("display_string").equals("");
if (text_added)
addText();
resetFeature();
track3d.getFeatureTransformGroup().addChild(feat_pos_tg);
feat_pos_tg.addChild(feat_rot_tg);
feat_rot_tg.addChild(scale_vector_tg);
scale_vector_tg.addChild(shape_transform_tg);
if (feature_display.canDetectCollisions()) {
CollisionDetectionBehavior3D collision_detector=
new CollisionDetectionBehavior3D(feat_pos_tg, shape);
BoundingSphere bounds=
new BoundingSphere(new Point3d(0.0, 0.0, 0.0), 100.0);
collision_detector.setSchedulingBounds(bounds);
shape_transform_tg.addChild(collision_detector);
shape_transform_tg.addChild(shape);
}
else {
shape_transform_tg.addChild(shape);
}
}
public String getAccessionId() {
return userdata.getAccessionID();
}
public void setAppearance(Appearance highlight_ap) {
shape.setAppearance(highlight_ap);
}
public void increaseSize() {
shape_thickness= shape_thickness * 1.2f;
shape_width= shape_width * 1.2f;
if (feature_display.isZOffsetHalfHeight()) {
shape_z_offset= shape_thickness / 2d;
}
resetFeature();
}
public void resetSize() {
shape_width= feature_display.getWidth();
setThicknessAndZOffset();
resetFeature();
}
private void setThicknessAndZOffset() {
if (feature_display.isThicknessScored()) {
shape_thickness= userdata.getScore() / percent_to_local_scale;
}
else {
shape_thickness= feature_display.getThickness();
}
if (feature_display.isZOffsetHalfHeight()) {
shape_z_offset= shape_thickness / 2d;
}
else {
shape_z_offset= feature_display.getZOffset();
}
}
public void kill() {
feat_pos_tg.removeChild(feat_rot_tg);
feat_rot_tg.removeChild(scale_vector_tg);
scale_vector_tg.removeChild(shape);
track3d.getFeatureTransformGroup().removeChild(feat_pos_tg);
shape.setUserData(null);
shape= null;
feature_display= null;
track3d= null;
userdata= null;
}
public void resetFeature() {
double Xscale;
double Yscale;
double Zscale;
double shape_x_length;
double offset_center_local;
double rotation= -90d;
int track_start, track_end, feature_start, feature_end;
track_start= track3d.getWorkingStart();
track_end= track3d.getWorkingEnd();
if (track3d.getReverse()) {
feature_start= track3d.getEnd() - userdata.getEnd();
feature_end= track3d.getEnd() - userdata.getStart() + 1;
if (feature_display.isYOffsetStranded()) {
shape_y_offset=
(-1) * feature_display.getYOffset() * userdata.getStrand().getValue();
}
}
else {
feature_start= userdata.getStart();
feature_end= userdata.getEnd() + 1;
if (feature_display.isYOffsetStranded()) {
shape_y_offset=
feature_display.getYOffset() * userdata.getStrand().getValue();
}
}
if (feature_display.getScaleable()) {
double min_start=
track_start - (stick_out_length * track3d.getCurrentScale());
shape_start= Math.max(feature_start, min_start);
double max_end=
track_end + 1 + (stick_out_length * track3d.getCurrentScale());
shape_end= Math.min(feature_end, max_end);
}
else {
double fixed_length_nt=
feature_display.getLength() * track3d.getCurrentScale();
int alignment = feature_display.getAlignment();
if (track3d.getReverse()) {
alignment *= -1;
}
if (alignment == -1) {
shape_start= feature_start;
shape_end= shape_start + fixed_length_nt + 1;
}
else if (alignment == 1) {
shape_end= feature_end;
shape_start= shape_end - fixed_length_nt + 1;
}
else {
double avg= ((feature_start + feature_end) / 2);
double half_length= fixed_length_nt / 2;
shape_start= avg - half_length;
shape_end= avg + half_length + 1;
}
}
shape_x_length= (shape_end - shape_start) / track3d.getCurrentScale();
if (text_added) {
text_pos_v3d.x= shape_x_length / (-2d);
text_pos_t3d.set(text_pos_v3d);
text_pos_tg.setTransform(text_pos_t3d);
}
offset_center_nt= ((shape_start + shape_end) / 2) - track_start;
offset_center_local= (offset_center_nt / track3d.getCurrentScale());
if (feature_display.getOrientation()
== FeatureDisplay.__ORIENT_SWITCH_XY) {
if (feature_display.isYOffsetStranded()
&& userdata.getStrand().getValue() != 0) {
rotation= rotation * userdata.getStrand().getValue();
if (track3d.getReverse())
rotation= rotation * (-1d);
}
Xscale= shape_width / shape_dims.x;
Yscale= shape_x_length / shape_dims.y;
Zscale= shape_thickness / shape_dims.z;
feat_rot_T3D.rotZ(Math.toRadians(rotation));
}
else if (
feature_display.getOrientation() == FeatureDisplay.__ORIENT_SWITCH_YZ) {
rotation= rotation * (-1d);
Xscale= shape_x_length / shape_dims.x;
Yscale= shape_thickness / shape_dims.y;
Zscale= shape_width / shape_dims.z;
feat_rot_T3D.rotX(Math.toRadians(rotation));
}
else if (
feature_display.getOrientation()
== FeatureDisplay.__ORIENT_SWITCH_YZ_DOWN) {
Xscale= shape_x_length / shape_dims.x;
Yscale= shape_thickness / shape_dims.y;
Zscale= shape_width / shape_dims.z;
feat_rot_T3D.rotX(Math.toRadians(rotation));
}
else {
Xscale= shape_x_length / shape_dims.x;
Yscale= shape_width / shape_dims.y;
Zscale= shape_thickness / shape_dims.z;
}
scale_vector.set(Xscale, Yscale, Zscale);
scale_vector_t3d.setScale(scale_vector);
scale_vector_tg.setTransform(scale_vector_t3d);
feat_rot_tg.setTransform(feat_rot_T3D);
feat_pos_v3d.set(offset_center_local, shape_y_offset, shape_z_offset);
feat_pos_T3D.set(feat_pos_v3d);
feat_pos_tg.setTransform(feat_pos_T3D);
}
private void addText() {
double x_rotation= Math.toRadians(45),
y_rotation= Math.toRadians(-10),
z_rotation= Math.toRadians(30);
int scale= 2;
String display_string= userdata.getAttribute("display_string");
if (_set_truncate_text) {
display_string=
display_string.substring(0, Math.min(display_string.length(), 15));
}
else {
display_string=
display_string.substring(0, Math.min(display_string.length(), 100));
}
text_pos_v3d= new Vector3d(text_x_offset, text_y_offset, text_z_offset);
text_pos_t3d= new Transform3D();
text_pos_t3d.set(text_pos_v3d);
text_pos_tg= new TransformGroup(text_pos_t3d);
text_pos_tg.setCapability(TransformGroup.ALLOW_TRANSFORM_WRITE);
TransformGroup text_rot_tg= new TransformGroup();
if (_set_billboard) {
text_rot_tg.setCapability(TransformGroup.ALLOW_TRANSFORM_WRITE);
Billboard bb=
new Billboard(text_rot_tg, Billboard.ROTATE_ABOUT_POINT, new Point3f());
bb.setSchedulingBounds(new BoundingSphere(new Point3d(), 1000d));
text_rot_tg.addChild(bb);
}
else {
if (userdata.getStrand().getValue() != 0)
z_rotation= z_rotation * userdata.getStrand().getValue();
Transform3D rot_x_t3d= new Transform3D();
Transform3D rot_y_t3d= new Transform3D();
Transform3D rot_z_t3d= new Transform3D();
rot_x_t3d.rotX(x_rotation);
rot_y_t3d.rotY(y_rotation);
rot_z_t3d.rotZ(z_rotation);
rot_y_t3d.mul(rot_x_t3d);
rot_z_t3d.mul(rot_y_t3d);
text_rot_tg.setTransform(rot_z_t3d);
}
TransformGroup text_scale_tg= new TransformGroup();
Transform3D text_scale_t3d= new Transform3D();
text_scale_t3d.setScale(1d / scale);
text_scale_tg.setTransform(text_scale_t3d);
Shape3D text_shape=
new Text2D(
display_string,
new Color3f(java.awt.Color.white),
feature_display.getFont().getFontName(),
feature_display.getFont().getSize() * scale,
feature_display.getFont().getStyle());
text_shape.setPickable(false);
feat_pos_tg.addChild(text_pos_tg);
text_pos_tg.addChild(text_rot_tg);
text_rot_tg.addChild(text_scale_tg);
text_scale_tg.addChild(text_shape);
}
public static void setShowText2D(boolean b) {
_set_text_2D= b;
}
public static boolean getShowtext2D() {
return _set_text_2D;
}
public static void setBillboard(boolean b) {
_set_billboard= b;
}
public static boolean getBillboard() {
return _set_billboard;
}
public static void setTruncated(boolean b) {
_set_truncate_text= b;
}
public static boolean getTruncated() {
return _set_truncate_text;
}
}
package ca.bcgsc.sockeye.j3d;
import java.util.Hashtable;
import javax.media.j3d.Appearance;
import javax.media.j3d.Geometry;
import javax.media.j3d.GeometryArray;
import javax.media.j3d.Material;
import javax.media.j3d.TransparencyAttributes;
import javax.swing.JOptionPane;
import javax.vecmath.Color3f;
import javax.vecmath.Vector3d;
import org.biojava.bio.program.gff.GFFTools;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.config.FeatureDisplay;
import ca.bcgsc.sockeye.datastorage.MultiDimTrackDistribution;
import ca.bcgsc.sockeye.datastorage.TrackDistribution;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.util.Log;
class FeatureCreator3D {
private static Hashtable __shared_hash = new Hashtable();
private static Appearance __exon_highlight_appearance = null;
public static void initializeFeature(String feature_name, boolean scored) {
if (! (__shared_hash.containsKey(feature_name))) {
FeatureDisplay fd = Configuration.getFeatureDisplay(feature_name, scored, false);
if (fd == null) {
String message = "Unable to get configuration from xml file";
JOptionPane.showMessageDialog(null,
message,
"XML File Error",
JOptionPane.ERROR_MESSAGE);
__shared_hash.put(feature_name, "getFeatureDisplay Failed");
Log.println("Didn't initialize feature " + feature_name +
": " + message);
return;
}
else {
VRMLShapeLoader3D vrml_loader = new VRMLShapeLoader3D();
boolean didLoadSucceed = vrml_loader.loadShape(fd.getShapeFile());
if (!didLoadSucceed) {
__shared_hash.put(feature_name, "Shape Load Failed");
Log.println("Didn't initialize feature " + feature_name +
": Shape load failed.");
return;
}
Geometry geometry = vrml_loader.getGeometry();
geometry.setCapability(Geometry.ALLOW_INTERSECT);
geometry.setCapability(GeometryArray.ALLOW_COUNT_READ);
geometry.setCapability(GeometryArray.ALLOW_FORMAT_READ);
Vector3d shape_dims = vrml_loader.getDims();
Vector3d shape_transform = vrml_loader.getShapeTransform();
Color3f feature_color = new Color3f(fd.getColor());
Appearance feature_ap = new Appearance();
Material feature_mat = new Material();
feature_mat.setDiffuseColor(feature_color);
feature_mat.setAmbientColor(feature_color.x * 0.5f,
feature_color.y * 0.5f,
feature_color.z * 0.5f);
feature_mat.setSpecularColor(0f, 0f, 0f);
feature_mat.setShininess(1f);
feature_mat.setLightingEnable(true);
feature_ap.setMaterial(feature_mat);
if (fd.getTransparency() != 0d) {
TransparencyAttributes feature_trans = new TransparencyAttributes(
TransparencyAttributes.FASTEST, (float) fd.getTransparency());
feature_ap.setTransparencyAttributes(feature_trans);
}
SharedFeatureComponent3D shared_comp = new SharedFeatureComponent3D(fd,
geometry, shape_dims,
feature_ap, shape_transform);
__shared_hash.put(feature_name, shared_comp);
}
}
}
public static Feature3D createFeature(Track3D track3d, TrackFeature userdata) {
SharedFeatureComponent3D shared_comp = null;
initializeFeature(userdata.getFeature(), (userdata.getScore() != GFFTools.NO_SCORE) );
if (__shared_hash.get(userdata.getFeature())instanceof
SharedFeatureComponent3D) {
shared_comp = (SharedFeatureComponent3D) __shared_hash.get(userdata.
getFeature());
}
else {
Log.println("Didn't add feature " + userdata.getAccessionID() +
": Configuration or shape load failed in the past, won't try again.");
return null;
}
if (userdata instanceof MultiDimTrackDistribution){
MultiDimDistributionFeature3D d = new MultiDimDistributionFeature3D(track3d, userdata, shared_comp);
d.generate3DFeature();
return d;
}
else
if (userdata instanceof TrackDistribution){
DistributionFeature3D d = new DistributionFeature3D(track3d, userdata, shared_comp);
d.generate3DFeature();
return d;
}
return new Feature3D(track3d, userdata, shared_comp);
}
public static Appearance getAppearance(String feature_name, boolean scored) {
initializeFeature(feature_name, scored);
if ((__shared_hash.get(feature_name)instanceof SharedFeatureComponent3D)) {
SharedFeatureComponent3D shared_comp = (SharedFeatureComponent3D)
__shared_hash.get(feature_name);
return shared_comp.getAppearance();
}
else {
return null;
}
}
public static Appearance getExonHighlightAppearance() {
if (__exon_highlight_appearance == null) {
SharedFeatureComponent3D shared_comp = (SharedFeatureComponent3D)
__shared_hash.get("exon");
Color3f highlight_color;
if (shared_comp != null) {
highlight_color = new Color3f(shared_comp.getFeatureDisplay().getHcolor());
}
else {
highlight_color = new Color3f(0f, 1f, 1f);
}
Material exon_highlight_material = new Material();
exon_highlight_material.setSpecularColor(0f, 0f, 0f);
exon_highlight_material.setDiffuseColor(highlight_color);
exon_highlight_material.setAmbientColor(highlight_color.x * 0.7f,
highlight_color.y * 0.7f,
highlight_color.z * 0.7f);
exon_highlight_material.setShininess(1f);
__exon_highlight_appearance = new Appearance();
__exon_highlight_appearance.setMaterial(exon_highlight_material);
}
return __exon_highlight_appearance;
}
}
package ca.bcgsc.sockeye.j3d;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.List;
import javax.media.j3d.Appearance;
import org.biojava.bio.program.gff.GFFTools;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.util.Log;
class FeatureList3D {
private String _feature_name;
private Hashtable _feature_hash = new Hashtable();
private ArrayList __exon_transcripted = new ArrayList();
public FeatureList3D(String feature_name) {
this._feature_name = feature_name;
}
public String getFeatureName() {
return _feature_name;
}
public Collection getFeatures3D() {
return _feature_hash.values();
}
public int size() {
if (_feature_name.equals("select"))
return 0;
return _feature_hash.size();
}
public boolean addFeature(Track3D track3d, TrackFeature userdata) {
if (!_feature_hash.containsKey(userdata.getAccessionID())) {
Feature3D new_feature = FeatureCreator3D.createFeature(track3d, userdata);
if (new_feature != null) {
_feature_hash.put(userdata.getAccessionID(), new_feature);
}
} else {
Log.println(
"Didn't add feature "
+ userdata.getAccessionID()
+ ": already have a feature with that accession id on this track.");
return false;
}
return true;
}
public Feature3D removeFeature(String accession_id) {
if (_feature_hash.containsKey(accession_id)) {
Feature3D this_feature = (Feature3D) _feature_hash.get(accession_id);
this_feature.kill();
_feature_hash.remove(accession_id);
return this_feature;
} else {
Log.println(
"Didn't remove feature "
+ accession_id
+ ": couldn't find it in _feature_hash.");
}
return null;
}
public void resetFeatures() {
Enumeration enum = _feature_hash.elements();
while (enum.hasMoreElements()) {
Feature3D thisfeature = (Feature3D) enum.nextElement();
thisfeature.resetFeature();
}
}
public void redrawFeatures() {
Enumeration enum = _feature_hash.elements();
while (enum.hasMoreElements()) {
Feature3D thisfeature = (Feature3D) enum.nextElement();
thisfeature.resetSize();
}
}
public void redrawDistributionFeaturesReduceOffset(int pos) {
Enumeration enum = _feature_hash.elements();
while (enum.hasMoreElements()) {
Feature3D thisfeature = (Feature3D) enum.nextElement();
if (thisfeature instanceof DistributionFeature3D) {
int oldOffset = ((DistributionFeature3D) thisfeature).getOffset();
if (oldOffset > pos)
((DistributionFeature3D) thisfeature).setOffset(oldOffset - 1);
}
}
}
public float getDistributionMaxScore() {
float max = 0f;
Enumeration enum = _feature_hash.elements();
while (enum.hasMoreElements()) {
Feature3D thisfeature = (Feature3D) enum.nextElement();
if (thisfeature instanceof DistributionFeature3D)
if (((DistributionFeature3D) thisfeature).getLocalZMaximum() > max)
max = ((DistributionFeature3D) thisfeature).getLocalZMaximum();
}
return max;
}
public void redrawDistributionFeatures() {
Enumeration enum = _feature_hash.elements();
while (enum.hasMoreElements()) {
Feature3D thisfeature = (Feature3D) enum.nextElement();
if (thisfeature instanceof DistributionFeature3D) {
((DistributionFeature3D) thisfeature).generate3DFeature();
}
}
}
public void kill() {
Enumeration enum = _feature_hash.elements();
while (enum.hasMoreElements()) {
Feature3D this_feature = (Feature3D) enum.nextElement();
String accession_id = this_feature.getAccessionId();
this_feature.kill();
_feature_hash.remove(accession_id);
}
}
public void highlightTranscript(List accession_ids) {
int num_acc = accession_ids.size();
Appearance highlight_ap = FeatureCreator3D.getExonHighlightAppearance();
for (int j = 0; j < num_acc; j++) {
if (accession_ids.get(j) instanceof String
&& _feature_hash.containsKey(accession_ids.get(j))) {
Feature3D this_feature =
(Feature3D) _feature_hash.get((String) accession_ids.get(j));
this_feature.setAppearance(highlight_ap);
String accId = this_feature.getAccessionId();
if (!__exon_transcripted.contains(accId))
__exon_transcripted.add(accId);
this_feature.increaseSize();
} else {
Log.println(
"Didn't highlight "
+ accession_ids.get(j)
+ ": couldn't find it in _feature_hash.");
}
}
}
public void unHighlightTranscript(List accession_ids) {
int num_acc = accession_ids.size();
Appearance normal_exon_ap = FeatureCreator3D.getAppearance("exon", false);
for (int j = 0; j < num_acc; j++) {
if (accession_ids.get(j) instanceof String
&& _feature_hash.containsKey(accession_ids.get(j))) {
Feature3D this_feature =
(Feature3D) _feature_hash.get(accession_ids.get(j));
this_feature.setAppearance(normal_exon_ap);
this_feature.resetSize();
} else {
Log.println(
"Didn't unhighlight "
+ accession_ids.get(j)
+ ": couldn't find it in _feature_hash.");
}
}
}
public void setNormalAppearance(TrackFeature track_feature) {
Appearance normal_appearance = null;
if (track_feature.getFeature().equals("exon")
&& __exon_transcripted.contains(track_feature.getAccessionID())) {
normal_appearance = FeatureCreator3D.getExonHighlightAppearance();
} else {
normal_appearance =
FeatureCreator3D.getAppearance(
track_feature.getFeature(),
(track_feature.getScore() != GFFTools.NO_SCORE));
}
setAppearance(track_feature, normal_appearance);
}
public void setAppearance(
TrackFeature track_feature,
Appearance appearance) {
String root_accession_id = track_feature.getAttribute("pieces");
if (root_accession_id != null && root_accession_id.length() > 0) {
Feature3D feature;
int i = 0;
String composite_accession_id;
feature = (Feature3D) _feature_hash.get(root_accession_id);
boolean none_set = true;
while (feature != null) {
feature.setAppearance(appearance);
i++;
composite_accession_id = root_accession_id + "_" + String.valueOf(i);
feature = (Feature3D) _feature_hash.get(composite_accession_id);
if (feature != null)
none_set = false;
}
if (none_set) {
Log.println(
"Didn't set "
+ track_feature.getAccessionID()
+ " pieces to given appearance: pieces attribute not empty but no pieces found in _feature_hash.");
}
} else {
Feature3D feature =
(Feature3D) _feature_hash.get(track_feature.getAccessionID());
if (feature != null) {
feature.setAppearance(appearance);
} else {
Log.println(
"Didn't set "
+ track_feature.getAccessionID()
+ " to given appearance: couldn't find it in _feature_hash.");
}
}
}
}
package ca.bcgsc.sockeye.j3d;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import javax.media.j3d.Appearance;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.Material;
import javax.media.j3d.Shape3D;
import javax.media.j3d.Transform3D;
import javax.media.j3d.TransformGroup;
import javax.media.j3d.TransparencyAttributes;
import javax.media.j3d.View;
import javax.media.j3d.WakeupOnElapsedFrames;
import javax.swing.JPopupMenu;
import javax.swing.SwingUtilities;
import javax.vecmath.Point3d;
import javax.vecmath.Vector3f;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.gui.MainFrame;
import ca.bcgsc.sockeye.gui.optionsdialog.OptionsDialog;
import ca.bcgsc.sockeye.popup.FeatureRightPopup;
import ca.bcgsc.sockeye.popup.TrackRightPopupNZ;
import ca.bcgsc.sockeye.util.Log;
import com.sun.j3d.utils.geometry.Primitive;
import com.sun.j3d.utils.picking.PickCanvas;
import com.sun.j3d.utils.picking.PickResult;
import com.sun.j3d.utils.picking.PickTool;
import javax.swing.Timer;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
class MouseListener3D
implements MouseListener, MouseMotionListener {
protected Visualizer3D canvas;
protected TransformGroup vp_tg;
protected View view;
protected boolean anti_aliasing_on;
protected boolean anti_aliasing_desired;
protected PickCanvas pickCanvas;
protected JPopupMenu mop = new JPopupMenu();
private FeatureRightPopup rp = null;
protected static Hashtable selected_shape_hash = new Hashtable();
protected Appearance select_appearance;
protected Appearance select_transparent_appearance;
protected Shape3D curr_shape;
private TrackFeature currently_highlighted_track_feature = null;
private Appearance highlight_appearance;
protected Appearance highlight_transparent_appearance;
protected TrackFeature region_select;
protected int start_base;
protected Track3D curr_track = null;
protected Track3D start_track = null;
protected boolean selection_in_progress = false;
protected int startx, starty;
protected boolean x_axis_rotation_enable = true;
protected boolean z_axis_rotation_enable = true;
private static float _x_axis_angle = 60f;
private Transform3D x_axis_angle_t3d = new Transform3D();
private static float _z_axis_angle = 65f;
private Transform3D z_axis_angle_t3d = new Transform3D();
private static float _horiz_dist = 0.5f;
private static float _vert_dist = -0.6f;
private static float _zoom_dist = 4f;
private Vector3f dist_v3f = new Vector3f();
private Transform3D dist_t3d = new Transform3D();
protected WakeupOnElapsedFrames frameWakeup;
private int _mouse_x;
private int _mouse_y;
private static boolean isMac = false;
static {
isMac = System.getProperty("os.name").startsWith("Mac");
}
private Timer _timer = new Timer(500, new ActionListener() {
public void actionPerformed(ActionEvent evt) {
PickResult pickResult = null;
pickCanvas.setShapeLocation(_mouse_x, _mouse_y);
pickResult = pickCanvas.pickClosest();
if (pickResult != null) {
pickResult.setFirstIntersectOnly(true);
Point3d pickpoint =
pickResult.getIntersection(0).getPointCoordinatesVW();
Primitive track =
(Primitive) pickResult.getNode(PickResult.PRIMITIVE);
if (track != null) {
mop.setVisible(false);
curr_shape = null;
} else {
Shape3D shape3d =
(Shape3D) pickResult.getNode(PickResult.SHAPE3D);
if (shape3d != curr_shape) {
TrackFeature shape_userdata =
(TrackFeature) shape3d.getUserData();
mop.setVisible(false);
if (OptionsDialog.__setMouseOverPopups
&& shape_userdata != region_select) {
mop.removeAll();
if (shape_userdata.getAttribute("display_string")
== null
|| shape_userdata.getAttribute(
"display_string").equals(
"")) {
mop.add(
shape_userdata.getFeature()
+ ": "
+ shape_userdata.getAccessionID());
} else {
mop.add(
shape_userdata.getAttribute(
"display_string"));
}
mop.show(canvas, _mouse_x - 150, _mouse_y - 50);
}
curr_shape = shape3d;
}
}
} else {
mop.setVisible(false);
curr_shape = null;
}
}
});
protected MouseListener3D(
Visualizer3D canvas,
BranchGroup root,
TransformGroup vp_tg,
View view) {
_timer.setRepeats(false);
this.canvas = canvas;
this.vp_tg = vp_tg;
this.view = view;
anti_aliasing_on = view.getSceneAntialiasingEnable();
anti_aliasing_desired = false;
canvas.addMouseListener(this);
canvas.addMouseMotionListener(this);
pickCanvas = new PickCanvas(canvas, root);
pickCanvas.setMode(PickTool.GEOMETRY_INTERSECT_INFO);
Material select_material = new Material();
select_material.setSpecularColor(0f, 0f, 0f);
select_material.setDiffuseColor(1f, 0.5f, 0.87f);
select_material.setAmbientColor(0.5f, 0.25f, 0.44f);
select_material.setShininess(1f);
select_appearance = new Appearance();
select_appearance.setMaterial(select_material);
Material highlight_material = new Material();
highlight_material.setSpecularColor(0f, 0f, 0f);
highlight_material.setDiffuseColor(0.7f, 0.7f, 0f);
highlight_material.setAmbientColor(0.4f, 0.4f, 0f);
highlight_material.setShininess(1f);
highlight_appearance = new Appearance();
highlight_appearance.setMaterial(highlight_material);
TransparencyAttributes ta =
new TransparencyAttributes(TransparencyAttributes.FASTEST, 0.4f);
highlight_transparent_appearance = new Appearance();
highlight_transparent_appearance.setMaterial(highlight_material);
highlight_transparent_appearance.setTransparencyAttributes(ta);
select_transparent_appearance = new Appearance();
select_transparent_appearance.setMaterial(select_material);
select_transparent_appearance.setTransparencyAttributes(ta);
region_select = new TrackFeature("select");
region_select.setTrackId(-1);
resetView();
}
public void manualRotateX(float deg) {
if (x_axis_rotation_enable) {
_x_axis_angle = (_x_axis_angle - deg + 360) % 360;
resetView();
}
}
public void manualRotateZ(float deg) {
if (z_axis_rotation_enable) {
float horiz_degrees = (deg * 0.1f);
_z_axis_angle = (_z_axis_angle - horiz_degrees + 360) % 360;
resetView();
}
}
public void manualZoom(float z) {
_zoom_dist -= z;
resetView();
}
public void manualMove(float x, float y) {
float incr_horiz_dist = (x * 0.01f);
float incr_vert_dist = (y * -0.01f);
_horiz_dist -= incr_horiz_dist;
_vert_dist -= incr_vert_dist;
resetView();
}
protected void kill() {
unHighlightFeature();
unSelectAllFeatures();
canvas.removeMouseListener(this);
canvas.removeMouseMotionListener(this);
this.canvas = null;
this.vp_tg = null;
this.view = null;
this.pickCanvas = null;
this.mop = null;
this.rp = null;
MouseListener3D.selected_shape_hash.clear();
MouseListener3D.selected_shape_hash = null;
this.select_appearance = null;
this.select_transparent_appearance = null;
this.curr_shape = null;
this.currently_highlighted_track_feature = null;
this.highlight_appearance = null;
this.highlight_transparent_appearance = null;
this.region_select = null;
this.curr_track = null;
this.start_track = null;
this.x_axis_angle_t3d = null;
this.z_axis_angle_t3d = null;
this.dist_v3f = null;
this.dist_t3d = null;
}
protected void cancelResetAppearance(int track_id, List accession_ids) {
if (currently_highlighted_track_feature != null) {
int num_features = accession_ids.size();
for (int i = 0; i < num_features; i++) {
String this_accession_id = (String) accession_ids.get(i);
if (track_id
== currently_highlighted_track_feature.getTrackId()
&& "exon".equals(
currently_highlighted_track_feature.getFeature())
&& this_accession_id.equals(
currently_highlighted_track_feature
.getAccessionID())) {
cancelHighlightFeature();
break;
}
}
}
}
private final void resetView() {
dist_v3f.set(_horiz_dist, _vert_dist, _zoom_dist);
dist_t3d.set(dist_v3f);
x_axis_angle_t3d.rotX(Math.toRadians(_x_axis_angle));
x_axis_angle_t3d.mul(dist_t3d);
z_axis_angle_t3d.rotZ(Math.toRadians(_z_axis_angle));
z_axis_angle_t3d.mul(x_axis_angle_t3d);
vp_tg.setTransform(z_axis_angle_t3d);
}
private void highlightTrack(int track_id) {
canvas.highlightTrack(track_id);
}
protected void unSelectAllFeatures() {
for (Iterator it = selected_shape_hash.values().iterator();
it.hasNext();
) {
TrackFeature track_feature = (TrackFeature) it.next();
canvas.setNormalAppearance(track_feature);
if (isFeatureHighlighted(track_feature)) {
cancelHighlightFeature();
}
}
selected_shape_hash.clear();
canvas.fireUnselectAllEvent();
}
protected void unSelectAllFeatures(TrackFeature track_feature) {
boolean not_found = true;
for (Iterator it = selected_shape_hash.values().iterator();
it.hasNext();
) {
TrackFeature this_track_feature = (TrackFeature) it.next();
if (this_track_feature != track_feature) {
canvas.setNormalAppearance(this_track_feature);
canvas.fireFeatureSelectedEvent(track_feature, false);
if (isFeatureHighlighted(this_track_feature)) {
cancelHighlightFeature();
}
it.remove();
} else {
if (isFeatureHighlighted(this_track_feature)) {
unHighlightFeature();
canvas.fireFeatureSelectedEvent(track_feature, false);
} else {
not_found = false;
canvas.fireFeatureSelectedEvent(track_feature, true);
}
}
}
if (not_found) {
selectFeature(track_feature);
canvas.fireFeatureSelectedEvent(track_feature, true);
}
}
protected void selectFeature(TrackFeature track_feature) {
int track_id = track_feature.getTrackId();
TrackFeature previously_selected =
(TrackFeature) selected_shape_hash.get(new Integer(track_id));
if (previously_selected != track_feature) {
if (previously_selected != null) {
canvas.setNormalAppearance(previously_selected);
selected_shape_hash.remove(new Integer(track_id));
canvas.fireFeatureSelectedEvent(previously_selected, false);
}
if (track_feature.getFeature().equals("region")
|| track_feature.getFeature().equals("search_region")) {
canvas.setAppearance(
track_feature,
select_transparent_appearance);
canvas.fireFeatureSelectedEvent(track_feature, true);
}
else {
canvas.setAppearance(track_feature, select_appearance);
canvas.fireFeatureSelectedEvent(track_feature, true);
}
selected_shape_hash.put(new Integer(track_id), track_feature);
}
if (isFeatureHighlighted(previously_selected)
|| isFeatureHighlighted(track_feature)) {
cancelHighlightFeature();
}
}
protected void highlightMultipleFeatures(TrackFeature track_feature) {
int track_id = track_feature.getTrackId();
TrackFeature previously_selected =
(TrackFeature) selected_shape_hash.get(new Integer(track_id));
if (previously_selected != track_feature) {
if (previously_selected != null) {
canvas.setNormalAppearance(previously_selected);
selected_shape_hash.remove(new Integer(track_id));
canvas.fireFeatureSelectedEvent(previously_selected, false);
}
canvas.setAppearance(
track_feature,
FeatureCreator3D.getExonHighlightAppearance());
canvas.fireFeatureSelectedEvent(track_feature, true);
selected_shape_hash.put(new Integer(track_id), track_feature);
}
if (isFeatureHighlighted(previously_selected)
|| isFeatureHighlighted(track_feature)) {
cancelHighlightFeature();
}
}
protected void unSelectFeature(TrackFeature track_feature) {
int track_id = track_feature.getTrackId();
TrackFeature previously_selected =
(TrackFeature) selected_shape_hash.get(new Integer(track_id));
if (previously_selected == track_feature) {
canvas.fireFeatureSelectedEvent(track_feature, false);
canvas.setNormalAppearance(previously_selected);
selected_shape_hash.remove(new Integer(track_id));
if (isFeatureHighlighted(track_feature)) {
cancelHighlightFeature();
}
}
}
protected void unSelectFeature(
int track_id,
String feature_name,
String accession_id) {
TrackFeature previously_selected =
(TrackFeature) selected_shape_hash.get(new Integer(track_id));
if (previously_selected != null
&& previously_selected.getFeature().equals(feature_name)
&& previously_selected.getAccessionID().equals(accession_id)) {
canvas.setNormalAppearance(previously_selected);
canvas.fireFeatureSelectedEvent(previously_selected, false);
selected_shape_hash.remove(new Integer(track_id));
if (isFeatureHighlighted(previously_selected)) {
cancelHighlightFeature();
}
}
}
private boolean isFeatureSelected(TrackFeature track_feature) {
int track_id = track_feature.getTrackId();
Integer track_id_obj = new Integer(track_id);
if (selected_shape_hash.containsKey(track_id_obj)) {
TrackFeature previously_selected =
(TrackFeature) selected_shape_hash.get(track_id_obj);
return isSameFeature(track_feature, previously_selected);
}
return false;
}
private boolean isFeatureHighlighted(TrackFeature track_feature) {
return isSameFeature(
track_feature,
currently_highlighted_track_feature);
}
private boolean isSameFeature(TrackFeature tf1, TrackFeature tf2) {
return
tf1 != null && tf2 != null
&& tf1.getTrackId() == tf2.getTrackId()
&& tf1.getFeature().equals(tf2.getFeature())
&& tf1.getAccessionID().equals(tf2.getAccessionID());
}
protected void highlightFeature(TrackFeature track_feature) {
if (track_feature.getFeature().equals("region")
|| track_feature.getFeature().equals("search_region")) {
canvas.setAppearance(
track_feature,
highlight_transparent_appearance);
} else {
canvas.setAppearance(track_feature, highlight_appearance);
}
currently_highlighted_track_feature = track_feature;
}
protected void unHighlightFeature() {
if (currently_highlighted_track_feature != null) {
if (isFeatureSelected(currently_highlighted_track_feature)) {
if (currently_highlighted_track_feature
.getFeature()
.equals("region")) {
canvas.setAppearance(
currently_highlighted_track_feature,
select_transparent_appearance);
} else {
canvas.setAppearance(
currently_highlighted_track_feature,
select_appearance);
}
} else {
canvas.setNormalAppearance(currently_highlighted_track_feature);
}
currently_highlighted_track_feature = null;
}
}
private void cancelHighlightFeature() {
currently_highlighted_track_feature = null;
}
public void mouseClicked(MouseEvent mouseEvent) {
try {
_timer.stop();
int xpos = mouseEvent.getX();
int ypos = mouseEvent.getY();
pickCanvas.setShapeLocation(xpos, ypos);
PickResult pickResult = pickCanvas.pickClosest();
if (isPlainLeftClick(mouseEvent)) {
if (pickResult != null) {
Primitive track =
(Primitive) pickResult.getNode(PickResult.PRIMITIVE);
if (track != null) {
highlightTrack(
((Track3D) track.getUserData()).getTrackId());
unHighlightFeature();
} else {
Shape3D shape3d =
(Shape3D) pickResult.getNode(PickResult.SHAPE3D);
if (shape3d != null) {
TrackFeature track_feature =
(TrackFeature) shape3d.getUserData();
if (track_feature.getFeature().equals("region")) {
if (!isFeatureHighlighted(track_feature)) {
unSelectAllFeatures();
selectFeature(track_feature);
}
} else {
highlightTrack(track_feature.getTrackId());
if (track_feature != region_select) {
if (!isFeatureHighlighted(track_feature)) {
unHighlightFeature();
}
unSelectAllFeatures(track_feature);
} else {
unHighlightFeature();
}
}
}
}
} else {
unSelectAllFeatures();
unHighlightFeature();
cancelSelection();
canvas.unHighlightTrack();
}
}
else if (isControlLeftClick(mouseEvent)) {
if (pickResult != null) {
Primitive track =
(Primitive) pickResult.getNode(PickResult.PRIMITIVE);
if (track != null) {
highlightTrack(
((Track3D) track.getUserData()).getTrackId());
unHighlightFeature();
} else {
Shape3D shape3d =
(Shape3D) pickResult.getNode(PickResult.SHAPE3D);
if (shape3d != null) {
TrackFeature track_feature =
(TrackFeature) shape3d.getUserData();
if (track_feature.getFeature().equals("region")) {
selectFeature(track_feature);
} else {
highlightTrack(track_feature.getTrackId());
if (track_feature != region_select) {
if (isFeatureSelected(track_feature)) {
unSelectFeature(track_feature);
} else {
selectFeature(track_feature);
}
}
unHighlightFeature();
}
}
}
} else {
unHighlightFeature();
canvas.fireUnselectAllEvent();
}
}
else if (isRightClick(mouseEvent)) {
if (pickResult != null) {
Primitive track =
(Primitive) pickResult.getNode(PickResult.PRIMITIVE);
if (track != null) {
unHighlightFeature();
int track_id =
((Track3D) track.getUserData()).getTrackId();
highlightTrack(track_id);
TrackRightPopupNZ trp = new TrackRightPopupNZ(track_id);
trp.show(canvas, xpos, ypos);
} else {
Shape3D shape3d =
(Shape3D) pickResult.getNode(PickResult.SHAPE3D);
if (shape3d != null) {
TrackFeature track_feature =
(TrackFeature) shape3d.getUserData();
if (track_feature.getFeature().equals("region")) {
if (mouseEvent.isControlDown()) {
} else {
unHighlightFeature();
}
} else {
highlightTrack(track_feature.getTrackId());
if (!isFeatureHighlighted(track_feature)) {
unHighlightFeature();
}
if (track_feature != region_select) {
highlightFeature(track_feature);
}
}
ArrayList array_list = new ArrayList();
array_list.add(track_feature);
if (isFeatureSelected(track_feature)) {
for (Iterator it =
selected_shape_hash.values().iterator();
it.hasNext();
) {
TrackFeature this_track_feature =
(TrackFeature) it.next();
if (this_track_feature != track_feature) {
array_list.add(this_track_feature);
}
}
}
Point3d pickpoint =
pickResult
.getIntersection(0)
.getPointCoordinatesVW();
Track3D t3d =
MainFrame.getVis3D().getTrack3D(
track_feature.getTrackId());
highlightFeature(track_feature);
rp =
new FeatureRightPopup(
array_list,
t3d.getBase(pickpoint.x));
rp.show(canvas, xpos, ypos);
}
}
} else {
unHighlightFeature();
}
} else {
unHighlightFeature();
}
} catch (Throwable e) {
e.printStackTrace();
Log.printStackTrace(e);
}
}
private boolean isRightClick(MouseEvent mouseEvent) {
if (isMac()) {
return mouseEvent.isMetaDown();
} else {
return SwingUtilities.isRightMouseButton(mouseEvent)
&& !(mouseEvent.isAltDown() || mouseEvent.isShiftDown());
}
}
private boolean isControlLeftClick(MouseEvent mouseEvent) {
if (isMac() && mouseEvent.isMetaDown()) {
return false;
}
return SwingUtilities.isLeftMouseButton(mouseEvent)
&& mouseEvent.isControlDown();
}
private boolean isPlainLeftClick(MouseEvent mouseEvent) {
if (isMac() && mouseEvent.isMetaDown()) {
return false;
}
return SwingUtilities.isLeftMouseButton(mouseEvent)
&& !(mouseEvent.isAltDown()
|| mouseEvent.isShiftDown()
|| mouseEvent.isControlDown());
}
private static boolean isMac() {
return isMac;
}
public void mouseEntered(MouseEvent mouseEvent) {
vp_tg.setTransform(z_axis_angle_t3d);
_timer.start();
}
public void mouseExited(MouseEvent mouseEvent) {
_timer.stop();
}
public void mousePressed(MouseEvent mouseEvent) {
startx = mouseEvent.getX();
starty = mouseEvent.getY();
if (SwingUtilities.isLeftMouseButton(mouseEvent)
&& OptionsDialog.__setEnableRegionSelect) {
PickResult pickResult = null;
pickCanvas.setShapeLocation(startx, starty);
pickResult = pickCanvas.pickClosest();
if (pickResult != null) {
pickResult.setFirstIntersectOnly(true);
Point3d pickpoint =
pickResult.getIntersection(0).getPointCoordinatesVW();
Primitive track =
(Primitive) pickResult.getNode(PickResult.PRIMITIVE);
if (track != null) {
selection_in_progress = true;
start_track = (Track3D) track.getUserData();
start_base = start_track.getBase(pickpoint.x);
highlightTrack(start_track.getTrackId());
} else {
Shape3D shape3d =
(Shape3D) pickResult.getNode(PickResult.SHAPE3D);
if (shape3d != null) {
TrackFeature track_feature =
(TrackFeature) shape3d.getUserData();
if (track_feature == region_select
|| track_feature.getFeature().equals("region")) {
start_track =
canvas.getTrack3D(track_feature.getTrackId());
if (start_track != null) {
selection_in_progress = true;
start_base = start_track.getBase(pickpoint.x);
}
}
}
}
}
}
}
public void mouseReleased(MouseEvent mouseEvent) {
selection_in_progress = false;
if (!anti_aliasing_on && anti_aliasing_desired) {
view.setSceneAntialiasingEnable(true);
anti_aliasing_on = true;
}
}
public void mouseDragged(MouseEvent mouseEvent) {
int xpos = mouseEvent.getX();
int ypos = mouseEvent.getY();
if (rp != null) {
rp.setVisible(false);
rp = null;
}
if (selection_in_progress) {
PickResult pickResult = null;
pickCanvas.setShapeLocation(xpos, ypos);
pickResult = pickCanvas.pickClosest();
if (pickResult != null) {
pickResult.setFirstIntersectOnly(true);
Point3d pickpoint =
pickResult.getIntersection(0).getPointCoordinatesVW();
int this_base = start_track.getBase(pickpoint.x);
if (this_base > start_base) {
region_select.setEnd(this_base);
region_select.setStart(start_base);
canvas.fireTrack3DMouseDraggedEvent(
start_track.getTrackId(),
start_base,
this_base);
} else {
region_select.setStart(this_base);
region_select.setEnd(start_base);
canvas.fireTrack3DMouseDraggedEvent(
start_track.getTrackId(),
this_base,
start_base);
}
if (start_track != curr_track) {
cancelSelection();
curr_track = start_track;
region_select.setTrackId(curr_track.getTrackId());
canvas.addFeature(region_select);
return;
}
curr_track.resetFeatureList(region_select.getFeature());
}
return;
}
if (anti_aliasing_on) {
view.setSceneAntialiasingEnable(false);
anti_aliasing_on = false;
}
if (SwingUtilities.isLeftMouseButton(mouseEvent)) {
if (z_axis_rotation_enable) {
float horiz_degrees = ((startx - xpos) * 0.1f);
_z_axis_angle = (_z_axis_angle + horiz_degrees + 360) % 360;
}
if (x_axis_rotation_enable) {
float vert_degrees = ((starty - ypos) * 0.1f);
_x_axis_angle = (_x_axis_angle + vert_degrees + 360) % 360;
}
if (x_axis_rotation_enable || z_axis_rotation_enable) {
resetView();
}
} else if (SwingUtilities.isMiddleMouseButton(mouseEvent)) {
float distance = ((starty - ypos) * 0.01f);
_zoom_dist += distance;
resetView();
} else if (SwingUtilities.isRightMouseButton(mouseEvent)) {
float incr_horiz_dist = ((startx - xpos) * 0.01f);
float incr_vert_dist = ((starty - ypos) * -0.01f);
_horiz_dist += incr_horiz_dist;
_vert_dist += incr_vert_dist;
resetView();
}
startx = xpos;
starty = ypos;
}
public void mouseMoved(MouseEvent mouseEvent) {
vp_tg.setTransform(z_axis_angle_t3d);
this._mouse_x = mouseEvent.getX();
this._mouse_y = mouseEvent.getY();
_timer.restart();
}
protected void cancelSelection() {
if (curr_track != null) {
canvas.removeFeature(
curr_track.getTrackId(),
region_select.getFeature(),
region_select.getAccessionID());
region_select.setTrackId(-1);
curr_track = null;
}
}
protected final void setViewValues(
float x_axis_angle,
float z_axis_angle,
float horiz_dist,
float vert_dist,
float zoom_dist) {
_x_axis_angle = x_axis_angle;
_z_axis_angle = z_axis_angle;
_horiz_dist = horiz_dist;
_vert_dist = vert_dist;
_zoom_dist = zoom_dist;
resetView();
}
protected final void setViewValues(float[] view_values) {
_x_axis_angle = view_values[0];
_z_axis_angle = view_values[1];
_horiz_dist = view_values[2];
_vert_dist = view_values[3];
_zoom_dist = view_values[4];
resetView();
}
protected final float[] getViewValues() {
float[] view_values =
{
_x_axis_angle,
_z_axis_angle,
_horiz_dist,
_vert_dist,
_zoom_dist };
return view_values;
}
protected final double getXAxisAngle() {
return _x_axis_angle;
}
protected final void setXAxisAngle(float degrees) {
_x_axis_angle = degrees;
resetView();
}
protected final void setXAxisRotationEnable(boolean b) {
x_axis_rotation_enable = b;
}
protected final void setZAxisRotationEnable(boolean b) {
z_axis_rotation_enable = b;
}
protected final double getZAxisAngle() {
return _z_axis_angle;
}
protected final void setZAxisAngle(float degrees) {
_z_axis_angle = degrees;
resetView();
}
protected final void setAntialiasing(boolean b) {
view.setSceneAntialiasingEnable(b);
anti_aliasing_on = b;
anti_aliasing_desired = b;
}
protected final boolean getAntialiasing() {
return anti_aliasing_on;
}
protected final void updateRegionSelect(int start, int end) {
if (curr_track != null && start_track == curr_track) {
region_select.setStart(Math.max(start, curr_track.getStart()));
region_select.setEnd(Math.min(end, curr_track.getEnd()));
curr_track.resetFeatureList(region_select.getFeature());
} else {
Log.println(
"Unable to adjust start and end of selected region: no current track.");
}
}
class MouseRestTimer extends Timer {
protected int _x;
protected int _y;
public MouseRestTimer(int i, ActionListener a) {
super(i, a);
}
public void setMouseCoord(int x, int y) {
_x = x;
_y = y;
}
}
}
package ca.bcgsc.sockeye.j3d;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import javax.media.j3d.Appearance;
import javax.media.j3d.Geometry;
import javax.media.j3d.GeometryArray;
import javax.media.j3d.PolygonAttributes;
import javax.media.j3d.QuadArray;
import javax.media.j3d.Shape3D;
import javax.media.j3d.TransformGroup;
import javax.media.j3d.TransparencyAttributes;
import javax.vecmath.Color3f;
import javax.vecmath.Point3f;
import ca.bcgsc.sockeye.datastorage.MultiDimTrackDistribution;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.service.featureloader.common.DistributionContainer;
public class MultiDimDistributionFeature3D extends DistributionFeature3D {
private static boolean showCoordSystem = false;
private static boolean showCoordZAxis = true;
private static boolean plotReverse = false;
private static boolean plotThresholds = true;
private static float lineHeight_3Du = 0.002f;
private static float lineWidth_3Du = 0.01f;
private static float textOffset = 0.1f;
protected Appearance threshold_appearance;
protected Shape3D threshold_plane;
TransformGroup textLabelGroup;
private float[] distributionPositions;
public static final int MDTF_PLOT_ALL_IN_ONE = 0;
public static final int MDTF_PLOT_STACKED_SAME_HEIGHT = 1;
public static final int MDTF_PLOT_STACKED_SHRINK_FIT = 2;
PolygonAttributes shape_poly_attrib = new PolygonAttributes();
private static int _plot_style_in_use = MDTF_PLOT_ALL_IN_ONE;
private static float _distrib_feature_width = 0.5f;
private static Color3f red = new Color3f(1.0f, 0.0f, 0.0f);
private static Color3f green = new Color3f(0.0f, 1.0f, 0.0f);
private static Color3f blue = new Color3f(0.0f, 0.0f, 1.0f);
private static Color3f lightblue = new Color3f(0.6f, 0.6f, 1.0f);
private static Color3f cyan = new Color3f(0.0f, 1.0f, 1.0f);
private static Color3f white = new Color3f(1.0f, 1.0f, 1.0f);
private static Color3f magenta = new Color3f(1.0f, 0.0f, 1.0f);
private static Color3f yellow = new Color3f(1.0f, 1.0f, 0.0f);
public static Color3f[] color_set =
{ red, green, lightblue, cyan, magenta, yellow, blue };
public MultiDimDistributionFeature3D(
Track3D track3d,
TrackFeature userdata,
SharedFeatureComponent3D shared_comp) {
super(track3d, userdata, shared_comp);
threshold_plane = new Shape3D();
threshold_plane.setCapability(Shape3D.ALLOW_PICKABLE_READ);
threshold_plane.setCapability(Shape3D.ALLOW_GEOMETRY_READ);
threshold_plane.setCapability(Shape3D.ALLOW_GEOMETRY_WRITE);
threshold_plane.setCapability(Shape3D.ALLOW_APPEARANCE_READ);
threshold_plane.setCapability(Shape3D.ALLOW_APPEARANCE_WRITE);
threshold_plane.setPickable(false);
threshold_appearance = new Appearance();
textLabelGroup = new TransformGroup();
scale_vector_tg.addChild(threshold_plane);
scale_vector_tg.addChild(textLabelGroup);
distributionPositions =
new float[((MultiDimTrackDistribution) userdata).getSize()];
show_text_annotations = true;
showCoordZAxis = true;
shape_poly_attrib.setBackFaceNormalFlip(true);
shape_poly_attrib.setCullFace(PolygonAttributes.CULL_NONE);
}
protected void generate3DFeature() {
start_z_3Du = (stackInYDirection ? 0 : scale * (float) offsetPosition);
this.start_y_3Du = (float) - ((grid_width_gu * increment_3Du) / 2);
float y_3Du =
(float)
+ (Platform3D.platform_y_width_default)
+ (float) (grid_width_gu * increment_3Du)
+ (stackInYDirection
? offsetPosition * ((float) (grid_width_gu * increment_3Du * 2))
: 0);
double offset_center_local =
(track3d.getLength() / track3d.getCurrentScale()) / 2;
feat_pos_v3d.set(offset_center_local, y_3Du, 0);
feat_pos_T3D.set(feat_pos_v3d);
feat_pos_tg.setTransform(feat_pos_T3D);
shape.removeAllGeometries();
shape.addGeometry(buildGeometry());
MultiDimTrackDistribution inputdata = (MultiDimTrackDistribution) userdata;
drawDistributionList(inputdata, _plot_style_in_use);
textAnnotationGroup.removeAllChildren();
if (show_text_annotations)
fillTextAnnotationTG();
coordSystemTextGroup.removeAllChildren();
if (showCoordSystem)
buildZAxis();
Appearance sa = shape.getAppearance();
if (sa == null)
sa = new Appearance();
sa.setPolygonAttributes(shape_poly_attrib);
sa.setTransparencyAttributes(
new TransparencyAttributes(
TransparencyAttributes.NICEST,
defaultTransparency));
shape.setAppearance(sa);
}
protected void drawDistributionList(
MultiDimTrackDistribution all_distributions,
int drawstyle) {
int color_set_size = color_set.length;
double maxScore = all_distributions.getMax();
float grid_height = scale / all_distributions.getSize();
float offset = 0.0f;
int total_size = all_distributions.getSize();
Geometry distGeometry = null;
for (int i = 0; i < total_size; i++) {
int pos = i;
if (plotReverse) {
pos = total_size - (i + 1);
}
Color3f current_color = ((MultiDimTrackDistribution) userdata).getDistributionColour(pos);
if (current_color == null)
current_color = color_set[pos % color_set_size];
double local_max_score = all_distributions.getMax(pos);
float local_threshold = -1;
if (drawstyle == MDTF_PLOT_ALL_IN_ONE) {
distGeometry =
getDistGeometry(
offset,
scale,
maxScore,
current_color,
(List) all_distributions.getDataset(pos));
if (distGeometry != null) {
shape.addGeometry(distGeometry);
distributionPositions[pos] = (pos * textOffset) + offset;
if (plotThresholds) {
local_threshold = all_distributions.getDistributionThreshold(pos);
Geometry local_plane =
drawTreshholdPlane(
offset,
scale,
maxScore,
local_threshold,
current_color);
if (threshold_plane != null) {
threshold_plane.addGeometry(local_plane);
}
}
}
}
else if (drawstyle == MDTF_PLOT_STACKED_SAME_HEIGHT) {
distGeometry =
getDistGeometry(
offset,
grid_height,
maxScore,
current_color,
(List) all_distributions.getDataset(pos));
if (distGeometry != null) {
shape.addGeometry(distGeometry);
distributionPositions[pos] = offset;
if (plotThresholds) {
local_threshold = all_distributions.getDistributionThreshold(pos);
Geometry local_plane =
drawTreshholdPlane(
offset,
grid_height,
maxScore,
local_threshold,
current_color);
if (threshold_plane != null) {
threshold_plane.addGeometry(local_plane);
}
}
}
offset += grid_height + (2 * lineHeight_3Du);
}
else if (drawstyle == MDTF_PLOT_STACKED_SHRINK_FIT) {
grid_height =
scale * (float) (local_max_score / all_distributions.getTotalScore());
distGeometry =
getDistGeometry(
offset,
grid_height,
local_max_score,
current_color,
(List) all_distributions.getDataset(pos));
if (distGeometry != null) {
shape.addGeometry(distGeometry);
distributionPositions[pos] = offset;
if (plotThresholds) {
local_threshold = all_distributions.getDistributionThreshold(pos);
Geometry local_plane =
drawTreshholdPlane(
offset,
grid_height,
local_max_score,
local_threshold,
current_color);
if (threshold_plane != null) {
threshold_plane.addGeometry(local_plane);
}
}
}
offset = offset + grid_height + (2 * lineHeight_3Du);
}
else {
System.out.println("Drawing Style Specification Unkown");
}
}
}
protected Geometry buildGeometry() {
float length_3Du = grid_length_gu * (float) increment_3Du;
float width_3Du = grid_width_gu * (float) increment_3Du;
lineWidth_3Du = _distrib_feature_width * width_3Du;
threshold_plane.removeAllGeometries();
threshold_appearance.setTransparencyAttributes(
new TransparencyAttributes(
TransparencyAttributes.NICEST,
coordTransparencyVal));
threshold_plane.setAppearance(threshold_appearance);
Point3f[] my_coords =
{
new Point3f(start_x_3Du, start_y_3Du, start_z_3Du),
new Point3f(start_x_3Du + length_3Du, start_y_3Du, start_z_3Du),
new Point3f(
start_x_3Du + length_3Du,
start_y_3Du + width_3Du,
start_z_3Du),
new Point3f(start_x_3Du, start_y_3Du + width_3Du, start_z_3Du),
};
Color3f[] my_colors = new Color3f[my_coords.length];
for (int i = 0; i < my_coords.length; i++) {
my_colors[i] = blue;
}
QuadArray my_quads =
new QuadArray(
my_coords.length,
GeometryArray.COORDINATES | GeometryArray.COLOR_3);
my_quads.setCapability(GeometryArray.ALLOW_COLOR_WRITE);
my_quads.setCapability(GeometryArray.ALLOW_COLOR_READ);
my_quads.setCapability(GeometryArray.ALLOW_COUNT_READ);
my_quads.setCapability(GeometryArray.ALLOW_FORMAT_READ);
my_quads.setCapability(GeometryArray.ALLOW_COORDINATE_READ);
my_quads.setCoordinates(0, my_coords);
my_quads.setColors(0, my_colors);
return my_quads;
}
protected Geometry drawTreshholdPlane(
float z_offset_3Du,
float z_height_3Du,
double max_z,
float threshold,
Color3f line_colour) {
if (threshold > max_z) {
System.out.println(
"Threshold value higher than maximum score; Threshold is not drawn");
return null;
}
float length_3Du = grid_length_gu * (float) increment_3Du;
float width_3Du = grid_width_gu * (float) increment_3Du;
lineWidth_3Du = _distrib_feature_width * width_3Du;
float z_3Du = z_offset_3Du + getZScale(max_z, z_height_3Du, threshold);
float y_3Du = getYScale(start_y_3Du);
Point3f[] thresh_coords = {
new Point3f(start_x_3Du, start_y_3Du, z_3Du),
new Point3f(start_x_3Du + length_3Du, y_3Du, z_3Du),
new Point3f(start_x_3Du + length_3Du, y_3Du + lineWidth_3Du, z_3Du),
new Point3f(start_x_3Du, y_3Du + lineWidth_3Du, z_3Du),
new Point3f(start_x_3Du, y_3Du, z_3Du),
new Point3f(start_x_3Du, y_3Du + lineWidth_3Du, z_3Du),
new Point3f(start_x_3Du + length_3Du, y_3Du + lineWidth_3Du, z_3Du),
new Point3f(start_x_3Du + length_3Du, y_3Du, z_3Du),
};
Color3f[] my_colors = new Color3f[thresh_coords.length];
for (int i = 0; i < thresh_coords.length; i++) {
my_colors[i] = line_colour;
}
QuadArray my_quads =
new QuadArray(
thresh_coords.length,
GeometryArray.COORDINATES | GeometryArray.COLOR_3);
my_quads.setCapability(GeometryArray.ALLOW_COLOR_WRITE);
my_quads.setCapability(GeometryArray.ALLOW_COLOR_READ);
my_quads.setCapability(GeometryArray.ALLOW_COUNT_READ);
my_quads.setCapability(GeometryArray.ALLOW_FORMAT_READ);
my_quads.setCapability(GeometryArray.ALLOW_COORDINATE_READ);
my_quads.setCoordinates(0, thresh_coords);
my_quads.setColors(0, my_colors);
return my_quads;
}
protected List correctStartEnd(List my_list) {
int i = 0;
while (i < my_list.size()) {
DistributionContainer dc = (DistributionContainer) my_list.get(i);
if (((dc.getStart() < track3d.getStart())
&& (dc.getEnd() < track3d.getStart()))
| ((dc.getStart() > (track3d.getEnd()))
&& (dc.getEnd() > (track3d.getEnd())))) {
my_list.remove(dc);
} else {
i++;
}
}
return my_list;
}
protected Geometry getDistGeometry(
float z_offset_3Du,
float z_height_3Du,
double max_z,
Color3f line_colour,
List my_td) {
my_td = correctStartEnd(my_td);
if (my_td.size() < 1) {
return null;
}
Point3f[] my_coords = new Point3f[my_td.size() * 8];
boolean previous = false;
int pos = 0;
float old_z_3Du = 0;
DistributionContainer old_dc = null;
for (Iterator i = my_td.iterator(); i.hasNext();) {
DistributionContainer dc = (DistributionContainer) i.next();
float x_3Du = -1.0f;
float x1_3Du = -1.0f;
if (dc.getStart() <= track3d.getStart()) {
x_3Du = getXScale(track3d.getStart());
old_dc = null;
previous = false;
} else {
x_3Du = getXScale(dc.getStart());
}
if (dc.getEnd() >= track3d.getEnd())
x1_3Du = getXScale(track3d.getEnd() + 1);
else
x1_3Du = getXScale(dc.getEnd());
float y_3Du = getYScale(start_y_3Du);
float yw_3Du = y_3Du + lineWidth_3Du;
float y_middle = y_3Du + lineWidth_3Du / 2f;
float z_3Du =
getZScale(max_z, z_height_3Du, dc.getScore()) + z_offset_3Du;
if ((old_dc != null) && (old_dc.getEnd() != dc.getStart())) {
previous = false;
}
if (!previous) {
old_z_3Du =
getZScale(max_z, z_height_3Du, dc.getScore()) + z_offset_3Du;
previous = true;
}
float old_zh_3Du = old_z_3Du + lineHeight_3Du;
my_coords[pos++] = new Point3f(x_3Du, y_3Du, old_z_3Du);
my_coords[pos++] = new Point3f(x1_3Du, y_3Du, z_3Du);
my_coords[pos++] = new Point3f(x1_3Du, yw_3Du, z_3Du);
my_coords[pos++] = new Point3f(x_3Du, yw_3Du, old_z_3Du);
double phi = Math.atan( (old_z_3Du - z_3Du) / (x1_3Du - x_3Du) );
my_coords[pos++] =
new Point3f(
x_3Du + (float) (lineHeight_3Du * Math.sin(phi)),
y_middle,
old_z_3Du + (float) (lineHeight_3Du * Math.cos(phi)));
my_coords[pos++] =
new Point3f(
x1_3Du + (float) (lineHeight_3Du * Math.sin(phi)),
y_middle,
z_3Du + (float) (lineHeight_3Du * Math.cos(phi)));
my_coords[pos++] = new Point3f(x1_3Du, y_middle, z_3Du);
my_coords[pos++] = new Point3f(x_3Du, y_middle, old_z_3Du);
old_dc = dc;
old_z_3Du = z_3Du;
previous = true;
}
int coords_size = my_coords.length / 3;
Color3f[] my_colors = new Color3f[my_coords.length];
QuadArray my_quads =
new QuadArray(
my_coords.length,
GeometryArray.COORDINATES | GeometryArray.COLOR_3);
for (int i = 0; i < my_coords.length; i++) {
my_colors[i] = line_colour;
}
my_quads.setCapability(GeometryArray.ALLOW_COLOR_WRITE);
my_quads.setCapability(GeometryArray.ALLOW_COLOR_READ);
my_quads.setCapability(GeometryArray.ALLOW_COUNT_READ);
my_quads.setCapability(GeometryArray.ALLOW_FORMAT_READ);
my_quads.setCapability(GeometryArray.ALLOW_INTERSECT);
my_quads.setCapability(GeometryArray.ALLOW_COORDINATE_READ);
my_quads.setCoordinates(0, my_coords);
my_quads.setColors(0, my_colors);
return my_quads;
}
protected void fillTextAnnotationTG() {
for (int i = 0; i < distributionPositions.length; i++) {
String tmpLable =
((MultiDimTrackDistribution) userdata).getDistributionLabel(i);
Color3f current_color = ((MultiDimTrackDistribution) userdata).getDistributionColour(i);
if (current_color == null)
current_color = color_set[i % color_set.length];
if (tmpLable != null) {
textAnnotationGroup.addChild(
createTextLabel(
tmpLable,
distributionPositions[i],
90,
false,
current_color));
textAnnotationGroup.setTransform(feat_rot_T3D);
}
}
}
protected Geometry buildZAxis() {
double w = grid_width_gu * increment_3Du;
double l = grid_length_gu * increment_3Du;
double h = scale;
double t = 0.01;
double x = start_x_3Du;
double y = start_y_3Du;
double z = start_z_3Du;
double maxScore = ((MultiDimTrackDistribution) userdata).getMax();
int numTicks = (int) (maxScore / tickWidth);
double tickHeight = h / maxScore;
Shape3D coordSystemShape = new Shape3D();
coordSystemShape.setPickable(false);
coordSystemShape.setCapability(Shape3D.ALLOW_GEOMETRY_READ);
coordSystemShape.setCapability(Shape3D.ALLOW_GEOMETRY_WRITE);
coordSystemShape.setCapability(Shape3D.ALLOW_APPEARANCE_READ);
coordSystemShape.setCapability(Shape3D.ALLOW_APPEARANCE_WRITE);
double zAxisBoxCoord[] = new double[] {
x, y, z, x, y + w, z, x, y + w, z + h, x, y, z + h,
x - t, y, z, x - t, y + w, z, x - t, y + w, z + h, x - t, y, z + h,
x, y, z, x - t, y, z, x - t, y, z + h, x, y, z + h,
x, y + w, z, x - t, y + w, z, x - t, y + w, z + h, x, y + w, z + h,
x, y, z, x - t, y, z, x - t, y + w, z, x, y + w, z,
x, y, z + h, x - t, y, z + h, x - t, y + w, z + h, x, y + w, z + h, };
if (!showCoordZAxis && numTicks == 0)
return null;
Color3f bcolor = new Color3f(java.awt.Color.blue);
Color3f gray = new Color3f(java.awt.Color.gray);
int total_size = ((MultiDimTrackDistribution) userdata).getSize();
float grid_height = scale / total_size;
float offset_3Du = 0.0f;
if (showCoordZAxis && numTicks > 0) {
if (_plot_style_in_use == MDTF_PLOT_ALL_IN_ONE) {
coordSystemShape.addGeometry(
buildTicks(0.0f, scale, maxScore, tickWidth, gray, white));
} else if (_plot_style_in_use == MDTF_PLOT_STACKED_SAME_HEIGHT) {
for (int i = 0; i < total_size; i++) {
int pos = i;
if (plotReverse) {
pos = total_size - (i + 1);
}
Color3f current_colour = ((MultiDimTrackDistribution) userdata).getDistributionColour(pos);
if (current_colour == null)
current_colour = color_set[i % color_set.length];
coordSystemShape.addGeometry(
buildTicks(
offset_3Du,
grid_height,
maxScore,
tickWidth,
gray,
current_colour));
offset_3Du = offset_3Du + grid_height + (2 * lineHeight_3Du);
}
} else if (_plot_style_in_use == MDTF_PLOT_STACKED_SHRINK_FIT) {
for (int i = 0; i < total_size; i++) {
int pos = i;
if (plotReverse) {
pos = total_size - (i + 1);
}
double total_score =
((MultiDimTrackDistribution) userdata).getTotalScore();
double local_max_score =
((MultiDimTrackDistribution) userdata).getMax(pos);
Color3f current_colour = ((MultiDimTrackDistribution) userdata).getDistributionColour(pos);
if (current_colour==null)
current_colour = color_set[i % color_set.length];
grid_height = scale * (float) (local_max_score / total_score);
coordSystemShape.addGeometry(
buildTicks(
offset_3Du,
grid_height,
local_max_score,
tickWidth,
gray,
current_colour));
offset_3Du = offset_3Du + grid_height + (2 * lineHeight_3Du);
}
}
}
Color3f[] boxPointColor = new Color3f[zAxisBoxCoord.length];
Arrays.fill(boxPointColor, bcolor);
QuadArray box_quads =
new QuadArray(
zAxisBoxCoord.length,
GeometryArray.COORDINATES | GeometryArray.COLOR_3);
if (showCoordZAxis) {
box_quads.setCoordinates(0, zAxisBoxCoord);
box_quads.setColors(0, boxPointColor);
}
coordSystemShape.addGeometry(box_quads);
distCoordSystemApp.setTransparencyAttributes(
new TransparencyAttributes(
TransparencyAttributes.NICEST,
coordTransparencyVal));
coordSystemShape.setAppearance(distCoordSystemApp);
coordSystemTextGroup.addChild(coordSystemShape);
return box_quads;
}
protected Geometry buildTicks(
float z_offset_3Du,
float z_height_3Du,
double max_z,
float tickWidth,
Color3f line_colour,
Color3f text_colour) {
double w = grid_width_gu * increment_3Du;
double l = grid_length_gu * increment_3Du;
double h = max_z;
double t = 0.01;
double x = start_x_3Du;
double y = start_y_3Du;
double z = start_z_3Du;
int numTicks = (int) (max_z / tickWidth);
double[] tickBoxCoord = new double[numTicks * 4 * 3];
for (int i = 1; i <= numTicks; i++) {
int n = (i - 1) * 12;
tickBoxCoord[n] = x;
tickBoxCoord[n + 1] = y;
tickBoxCoord[n + 2] =
z_offset_3Du + getZScale(max_z, z_height_3Du, i * tickWidth);
tickBoxCoord[n + 3] = x + l;
tickBoxCoord[n + 4] = y;
tickBoxCoord[n + 5] =
z_offset_3Du + getZScale(max_z, z_height_3Du, i * tickWidth);
tickBoxCoord[n + 6] = x + l;
tickBoxCoord[n + 7] = y + w;
tickBoxCoord[n + 8] =
z_offset_3Du + getZScale(max_z, z_height_3Du, i * tickWidth);
tickBoxCoord[n + 9] = x;
tickBoxCoord[n + 10] = y + w;
tickBoxCoord[n + 11] =
z_offset_3Du + getZScale(max_z, z_height_3Du, i * tickWidth);
if (showCoordZAxis)
coordSystemTextGroup.addChild(
createTextLabel(
String.valueOf(i * tickWidth),
z_offset_3Du + getZScale(max_z, z_height_3Du, i * tickWidth),
90,
true,
text_colour));
}
QuadArray tickQuads =
new QuadArray(
tickBoxCoord.length,
GeometryArray.COORDINATES | GeometryArray.COLOR_3);
Color3f[] tickPointColor = new Color3f[tickBoxCoord.length];
for (int i = 0; i < tickBoxCoord.length; i++) {
tickPointColor[i] = line_colour;
}
tickQuads.setCoordinates(0, tickBoxCoord);
tickQuads.setColors(0, tickPointColor);
return tickQuads;
}
private float getXScale(int x) {
float trackLength_3Du =
(float) track3d.getLength() / track3d.getCurrentScale();
float dfLength_3Du = grid_length_gu * (float) increment_3Du;
float df_length_scale = dfLength_3Du / trackLength_3Du;
return df_length_scale
- (trackLength_3Du / 2));
}
private float getYScale(float y) {
float width_3Du = grid_width_gu * (float) increment_3Du;
return y + ((width_3Du - lineWidth_3Du) / 2);
}
private float getZScale(double maxscore, float zlimit, double z_score) {
return (float) z_score * (zlimit / (float) maxscore);
}
private double findMaxScore(List td) {
double maxScore = 0;
for (Iterator i = td.iterator(); i.hasNext();) {
DistributionContainer dc = (DistributionContainer) i.next();
if (dc.getScore() > maxScore) {
maxScore = dc.getScore();
}
}
return maxScore;
}
public static void setReverse3D(boolean reverse) {
plotReverse = reverse;
}
public static boolean getReverse3D() {
return plotReverse;
}
public static void setPlotWidth3D(int w) {
if (w > 0 && w <= 100)
_distrib_feature_width = (float) w / 100f;
else
System.out.println("Multi Distrib Feature 3D: Illegal plot width: " + w);
}
public static int getPlotWidth3D() {
return (int) (_distrib_feature_width * 100);
}
public static void setPlotStyle(int i) {
if (i >= 0 && i < 3)
_plot_style_in_use = i;
else
System.out.println("Multi Distrib Feature 3D: Illegal plot style: " + i);
}
public static int getPlotStyle() {
return _plot_style_in_use;
}
public static boolean getShowThresholds() {
return plotThresholds;
}
public static void setShowThresholds(boolean b) {
plotThresholds = b;
}
}
package ca.bcgsc.sockeye.j3d;
import java.awt.Color;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.media.j3d.Appearance;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.Material;
import javax.media.j3d.Transform3D;
import javax.media.j3d.TransformGroup;
import javax.vecmath.Color3f;
import javax.vecmath.Vector3f;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.datastorage.Track;
import ca.bcgsc.sockeye.datastorage.TrackDistribution;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.util.Log;
import com.sun.j3d.utils.geometry.Box;
public class Platform3D {
private float nt_to_local_scale = 100000f;
public static final float platform_y_width_default = Configuration.
getPlatformWidth();
private float platform_y_width = platform_y_width_default;
public static final float platform_z_thickness = Configuration.
getPlatformThickness();
public static final float platform_x_length = Configuration.getPlatformLength();
public static final float stick_out_length = platform_x_length *
Configuration.getPlatformStickOut();
protected static final Color3f platform_color = new Color3f(Configuration.
getPlatformColor());
private float curr_width = 0;
private Box platform;
private BranchGroup platform_bg = new BranchGroup();
private Appearance platform_ap = new Appearance();
private Material platform_mat = new Material();
private TransformGroup platform_tg = new TransformGroup();
private Transform3D platform_t3d = new Transform3D();
private Vector3f platform_v3f = new Vector3f();
private ArrayList TrackList = new ArrayList();
private Color3f _text_color = new Color3f(1f, 1f, 1f);
protected Platform3D() {
platform_bg.setCapability(BranchGroup.ALLOW_DETACH);
platform_mat.setSpecularColor(0f, 0f, 0f);
platform_mat.setDiffuseColor(0f, 0f, 0f);
platform_mat.setAmbientColor(platform_color);
platform_mat.setEmissiveColor(0f, 0f, 0f);
platform_mat.setShininess(1.0f);
platform_ap.setMaterial(platform_mat);
platform_t3d.set(platform_v3f);
platform_tg.setTransform(platform_t3d);
resetPlatform();
platform_bg.addChild(platform_tg);
}
protected final BranchGroup getBranch() {
return platform_bg;
}
protected final void addTrack(Track track) {
TrackList.add(new Track3D(platform_tg, track, _text_color));
resetPlatform();
}
protected final int getFeatureCount(){
int count = 0;
Iterator i = TrackList.iterator();
while (i.hasNext())
count += ((Track3D)i.next()).getFeatureCount();
return count;
}
protected final void addTrack(Track track, int index) {
if (index >= 0 && index < TrackList.size()) {
TrackList.add(index, new Track3D(platform_tg, track,_text_color));
}
else {
TrackList.add(new Track3D(platform_tg, track, _text_color));
}
resetPlatform();
}
protected final int getIndex(int track_id) {
for (int i = 0; i < TrackList.size(); i++) {
Track3D thistrack = (Track3D) TrackList.get(i);
if (thistrack.getTrackId() == track_id) {
return i;
}
}
return TrackList.size();
}
protected final Track3D getTrack3D(int track_id) {
for (int i = 0; i < TrackList.size(); i++) {
Track3D thistrack = (Track3D) TrackList.get(i);
if (thistrack.getTrackId() == track_id) {
return thistrack;
}
}
return null;
}
protected final void updateTrackReverse(int track_id) {
for (int i = 0; i < TrackList.size(); i++) {
Track3D thistrack = (Track3D) TrackList.get(i);
if (thistrack.getTrackId() == track_id) {
thistrack.updateTrackReverse();
}
}
}
protected final void setShowCenterLine(boolean b) {
for (int i = 0; i < TrackList.size(); i++) {
Track3D thistrack = (Track3D) TrackList.get(i);
thistrack.setShowCenterLine(b);
}
}
private boolean containsTrack(int track_id) {
for (int i = 0; i < TrackList.size(); i++) {
Track3D thistrack = (Track3D) TrackList.get(i);
if (thistrack.getTrackId() == track_id) {
return true;
}
}
return false;
}
protected final void moveTrack(int track_id, int new_index) {
for (int i = 0; i < TrackList.size(); i++) {
Track3D thistrack = (Track3D) TrackList.get(i);
if (thistrack.getTrackId() == track_id) {
TrackList.remove(i);
TrackList.add(new_index, thistrack);
resetPlatform();
}
}
}
protected final void printTrackDetails() {
for (int i = 0; i < TrackList.size(); i++) {
Track3D thistrack = (Track3D) TrackList.get(i);
System.out.println("track_name: " + thistrack.getTrackId() +
", index in ArrayList = " + i);
}
}
protected final void removeTrack(int track_id) {
boolean doRedraw = false;
for (int i = 0; i < TrackList.size(); i++) {
Track3D thistrack = (Track3D) TrackList.get(i);
if ( thistrack.getTrackId() == track_id ) {
if ( thistrack.getTrackDistributionMaximum() == DistributionFeature3D.getGlobalZMaximum() )
doRedraw = true;
platform_tg.removeChild(thistrack.kill());
TrackList.remove(i);
if (doRedraw){
this.redrawAllDistributionFeatures();
DistributionFeature3D.setGlobalZMaximum(this.getPlatformDistributionMaximumScore());
}
else
resetPlatform();
}
}
}
protected final float getPlatformDistributionMaximumScore(){
float max = 0f;
for (int i = 0; i < TrackList.size(); i++) {
Track3D thistrack = (Track3D) TrackList.get(i);
max = Math.max(max, thistrack.getTrackDistributionMaximum());
}
return max;
}
public final void redrawAllDistributionFeatures(){
for (int i = 0; i < TrackList.size(); i++) {
Track3D thistrack = (Track3D) TrackList.get(i);
thistrack.redrawAllDistributions();
}
resetPlatform();
}
protected final void resetAllFeatures() {
for (int i = 0; i < TrackList.size(); i++) {
Track3D thistrack = (Track3D) TrackList.get(i);
thistrack.resetAllFeatures();
}
resetPlatform();
}
protected final void redrawAllFeatures() {
for (int i = 0; i < TrackList.size(); i++) {
Track3D thistrack = (Track3D) TrackList.get(i);
thistrack.redrawAllFeatures();
}
resetPlatform();
}
protected final void removeAllTracks() {
for (int i = 0; i < TrackList.size(); ) {
Track3D thistrack = (Track3D) TrackList.get(i);
platform_tg.removeChild(thistrack.kill());
TrackList.remove(i);
}
resetPlatform();
}
protected final void highlightTracks(List track_ids) {
for (Iterator i = TrackList.iterator(); i.hasNext(); ) {
Track3D this_track = (Track3D) i.next();
int this_track_id = this_track.getTrackId();
boolean not_in_list = true;
for (Iterator j = track_ids.iterator(); j.hasNext(); ) {
int this_highlighted_track = Integer.parseInt(j.next().toString());
if (this_highlighted_track == this_track_id) {
this_track.highlightTrack();
not_in_list = false;
break;
}
}
if (not_in_list) {
this_track.unHighlightTrack();
}
}
}
protected final void highlightTracks(int track_id) {
for (Iterator i = TrackList.iterator(); i.hasNext(); ) {
Track3D this_track = (Track3D) i.next();
int this_track_id = this_track.getTrackId();
if (this_track_id == track_id) {
this_track.highlightTrack();
}
else {
this_track.unHighlightTrack();
}
}
}
protected final void unHighlightTrack() {
for (Iterator j = TrackList.iterator(); j.hasNext(); ) {
Track3D this_track = (Track3D) j.next();
this_track.unHighlightTrack();
}
}
protected final void unHighlightTrack(int track_id) {
for (Iterator i = TrackList.iterator(); i.hasNext(); ) {
Track3D this_track = (Track3D) i.next();
int this_track_id = this_track.getTrackId();
if (this_track_id == track_id) {
this_track.unHighlightTrack();
}
}
}
protected final void setAppearance(TrackFeature track_feature, Appearance appearance) {
boolean not_found = true;
for (Iterator j = TrackList.iterator(); j.hasNext(); ) {
Track3D this_track = (Track3D) j.next();
if ( this_track.getTrackId() == track_feature.getTrackId() ) {
this_track.setAppearance(track_feature, appearance);
not_found = false;
break;
}
}
if (not_found) {
Log.println("Didn't set appearance of " + track_feature.getAccessionID() +
": couldn't find track.");
}
}
protected final void highlightTranscript(int track_id,
List accession_ids) {
boolean not_found = true;
for (int i = 0; i < TrackList.size(); i++) {
Track3D thistrack = (Track3D) TrackList.get(i);
if (thistrack.getTrackId() == track_id) {
thistrack.highlightTranscript(accession_ids);
not_found = false;
}
}
if (not_found) {
Log.println("Didn't highlight transcript on track with id" + track_id +
": couldn't find track.");
}
}
protected final void unHighlightTranscript(int track_id,
List accession_ids) {
for (int i = 0; i < TrackList.size(); i++) {
Track3D thistrack = (Track3D) TrackList.get(i);
if (thistrack.getTrackId() == track_id) {
thistrack.unHighlightTranscript(accession_ids);
}
}
}
protected final void setNormalAppearance(TrackFeature track_feature) {
if (track_feature != null) {
for (int i = 0; i < TrackList.size(); i++) {
Track3D thistrack = (Track3D) TrackList.get(i);
if (thistrack.getTrackId() == track_feature.getTrackId()) {
thistrack.setNormalAppearance(track_feature);
return;
}
}
Log.println("Didn't set " + track_feature.getAccessionID() +
" to normal appearance: couldn't find its Track3D.");
}
else {
Log.println(
"Didn't set a feature to normal appearance: Null track_feature object.");
}
}
protected final boolean addFeature(TrackFeature userdata) {
return addFeature (userdata.getFeature(), userdata);
}
protected final boolean addFeature(String name, TrackFeature userdata) {
boolean not_added = true;
for (int i = 0; i < TrackList.size(); i++) {
Track3D thistrack = (Track3D) TrackList.get(i);
if (thistrack.getTrackId() == userdata.getTrackId()) {
thistrack.addFeature(name, userdata);
not_added = false;
}
}
if (not_added) {
Log.println("Didn't " + userdata.getAccessionID() +
": couldn't find track.");
}
return !not_added;
}
protected final void addFeatures(TrackFeature[] userdatas) {
int num_userdatas = userdatas.length;
boolean doResetPlatform = false;
for (int i = 0; i < num_userdatas; i++) {
addFeature(userdatas[i]);
if (userdatas[i] instanceof TrackDistribution)
doResetPlatform = true;
}
if (doResetPlatform)
this.resetPlatform();
}
protected final void addFeatures(List userdatas) {
int num_userdatas = userdatas.size();
boolean doResetPlatform = false;
boolean doRedrawDistrib = false;
for (int i = 0; i < num_userdatas; i++) {
if (userdatas.get(i) instanceof TrackDistribution){
doResetPlatform = true;
if (((TrackDistribution)userdatas.get(i)).getMaxScore() > DistributionFeature3D.getGlobalZMaximum()){
doRedrawDistrib = true;
}
}
addFeature( (TrackFeature) userdatas.get(i));
}
if (doRedrawDistrib)
this.redrawAllDistributionFeatures();
else
if (doResetPlatform)
this.resetPlatform();
}
protected final void addFeatures(String name, List userdatas) {
int num_userdatas = userdatas.size();
boolean doResetPlatform = false;
boolean doRedrawDistrib = false;
for (int i = 0; i < num_userdatas; i++) {
if (userdatas.get(i) instanceof TrackDistribution){
doResetPlatform = true;
if (((TrackDistribution)userdatas.get(i)).getMaxScore() > DistributionFeature3D.getGlobalZMaximum()){
doRedrawDistrib = true;
}
}
addFeature(name, (TrackFeature) userdatas.get(i));
}
if (doRedrawDistrib)
this.redrawAllDistributionFeatures();
else
if (doResetPlatform)
this.resetPlatform();
}
protected final void removeFeature(int track_id, String feature_name,
String accession_id) {
boolean not_removed = true;
int distfeatures;
for (int i = 0; i < TrackList.size(); i++) {
Track3D thistrack = (Track3D) TrackList.get(i);
distfeatures = thistrack.getDistributionFeatureCount();
if (thistrack.getTrackId() == track_id) {
thistrack.removeFeature(feature_name, accession_id);
not_removed = false;
if (DistributionFeature3D.getGlobalZMaximum() <= thistrack.getMaxOfLastRemovedDistribution()
&& DistributionFeature3D.get3DNormalizeToGlobalMax())
redrawAllDistributionFeatures();
else
if (distfeatures != thistrack.getDistributionFeatureCount())
resetPlatform();
}
}
if (not_removed) {
Log.println("Didn't remove feature " + accession_id +
": couldn't find track.");
}
}
protected final void removeFeatureName(int track_id, String feature_name) {
boolean not_removed = true;
boolean doRedrawDistributions = false;
int distfeatures;
for (int i = 0; i < TrackList.size(); i++) {
Track3D thistrack = (Track3D) TrackList.get(i);
if (thistrack.getTrackId() == track_id) {
distfeatures = thistrack.getDistributionFeatureCount();
thistrack.removeFeatureName(feature_name);
if (DistributionFeature3D.getGlobalZMaximum() <= thistrack.getMaxOfLastRemovedDistribution()
&& DistributionFeature3D.get3DNormalizeToGlobalMax())
redrawAllDistributionFeatures();
else
if (distfeatures != thistrack.getDistributionFeatureCount())
resetPlatform();
}
}
if (not_removed) {
Log.println("Didn't remove feature_name " + feature_name +
": couldn't find track.");
}
}
protected final void removeAllFeatures() {
for (int i = 0; i < TrackList.size(); i++) {
Track3D thistrack = (Track3D) TrackList.get(i);
thistrack.removeAllFeatures();
}
DistributionFeature3D.setGlobalZMaximum(0);
resetPlatform();
}
protected final void removeFeatureName(String feature_name) {
int distfeatures;
boolean doReset = false;
boolean doRedrawDistributions = false;
for (int i = 0; i < TrackList.size(); i++) {
Track3D thistrack = (Track3D) TrackList.get(i);
distfeatures = thistrack.getDistributionFeatureCount();
thistrack.removeFeatureName(feature_name);
if (distfeatures != thistrack.getDistributionFeatureCount())
doReset = true;
if (DistributionFeature3D.getGlobalZMaximum() <= thistrack.getMaxOfLastRemovedDistribution())
doRedrawDistributions = true;
}
if (doRedrawDistributions && DistributionFeature3D.get3DNormalizeToGlobalMax()){
DistributionFeature3D.setGlobalZMaximum(getPlatformDistributionMaximumScore());
redrawAllDistributionFeatures();
}
else
if (doReset)
resetPlatform();
}
protected final void setTrackTextColor(Color color) {
_text_color = new Color3f(color);
for (Iterator i= TrackList.iterator();i.hasNext();) {
Track3D track = (Track3D) i.next();
track.setTrackTextColor(_text_color);
}
}
protected final Color getTrackTextColor() {
return _text_color.get();
}
protected final void getBase(int track_id, double x_coord) {
for (int i = 0; i < TrackList.size(); i++) {
Track3D thistrack = (Track3D) TrackList.get(i);
if (thistrack.getTrackId() == track_id) {
thistrack.getBase(x_coord);
}
}
}
protected final void resetPlatform() {
if (TrackList.isEmpty()) {
platform_y_width = platform_y_width_default;
}
else {
double trackOffsets[] = new double[TrackList.size()];
double trackCenterY=0;
double gapBetweenTracksWithDistributions = platform_y_width_default/10.0;
int longest = 0;
platform_y_width = 0;
int min_offset = Integer.MAX_VALUE;
for (int i = 0; i < TrackList.size(); i++) {
Track3D thistrack = (Track3D) TrackList.get(i);
trackOffsets[i] = thistrack.getDistributionFeaturesYDirection() * DistributionFeature3D.getWidth3Dunits();
platform_y_width += trackOffsets[i] + platform_y_width_default +
(trackOffsets[i] > 0 && i<TrackList.size()-1 ?gapBetweenTracksWithDistributions:0);
if (thistrack.getTrueLength() > longest) {
longest = thistrack.getTrueLength();
}
if (thistrack.getTrueOffset() < min_offset) {
min_offset = thistrack.getTrueOffset();
}
}
longest = longest - min_offset;
trackCenterY = ( -platform_y_width + platform_y_width_default) ;
nt_to_local_scale = 0.5f * longest / platform_x_length;
for (int i = TrackList.size()-1; i >= 0; i--) {
Track3D thistrack = (Track3D) TrackList.get(i);
thistrack.updateTrackScale((float)trackCenterY, min_offset, nt_to_local_scale);
trackCenterY += 2*(platform_y_width_default + trackOffsets[i] +
(trackOffsets[i]>0?gapBetweenTracksWithDistributions:0));
}
}
if (curr_width != platform_y_width) {
if (platform_tg.numChildren() > 0) {
platform_tg.removeChild(platform);
}
platform = new Box(platform_x_length, platform_y_width,
platform_z_thickness, platform_ap);
platform.setPickable(false);
platform.setCapability(Box.ALLOW_PICKABLE_READ);
platform_tg.addChild(platform);
curr_width = platform_y_width;
}
}
}
package ca.bcgsc.sockeye.j3d;
import javax.media.j3d.*;
import javax.vecmath.*;
import ca.bcgsc.sockeye.config.*;
class SharedFeatureComponent3D {
private FeatureDisplay fd;
private Geometry geometry;
private Vector3d shape_dims;
private Appearance appearance;
private Vector3d shape_transform;
public SharedFeatureComponent3D(FeatureDisplay fd, Geometry geometry, Vector3d shape_dims, Appearance appearance, Vector3d shape_transform) {
this.fd = fd;
this.geometry = geometry;
this.shape_dims = shape_dims;
this.appearance = appearance;
this.shape_transform = shape_transform;
}
public FeatureDisplay getFeatureDisplay() {
return fd;
}
public Geometry getGeometry() {
return geometry;
}
public Vector3d getShapeDims() {
return shape_dims;
}
public Appearance getAppearance() {
return appearance;
}
public Vector3d getShapeTransform() {
return shape_transform;
}
}
package ca.bcgsc.sockeye.j3d;
import javax.media.j3d.Appearance;
import javax.media.j3d.Billboard;
import javax.media.j3d.BoundingSphere;
import javax.media.j3d.GeometryArray;
import javax.media.j3d.Shape3D;
import javax.media.j3d.TransformGroup;
import javax.vecmath.Color3f;
import javax.vecmath.Point3d;
import javax.vecmath.Point3f;
import ca.bcgsc.sockeye.config.FeatureDisplay;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import com.sun.j3d.utils.geometry.Text2D;
class Text2DFeature3D
extends Feature3D {
Billboard bb;
public Text2DFeature3D(Track3D track3d,
TrackFeature userdata,
FeatureDisplay feature_display) {
this.userdata = userdata;
this.feature_display = feature_display;
this.track3d = track3d;
if (feature_display.isYOffsetStranded()) {
shape_y_offset = feature_display.getYOffset() * userdata.getStrand().getValue();
}
else {
shape_y_offset = feature_display.getYOffset();
}
shape_z_offset = feature_display.getZOffset();
String display_string = userdata.getAccessionID();
this.shape = new Text2D(display_string,
new Color3f(feature_display.getColor()),
feature_display.getFont().getFontName(),
feature_display.getFont().getSize(),
feature_display.getFont().getStyle());
shape.setUserData(userdata);
shape.setPickable(false);
shape.setCapability(Shape3D.ALLOW_GEOMETRY_READ);
shape.setCapability(Shape3D.ALLOW_PICKABLE_READ);
shape.setCapability(Shape3D.ALLOW_APPEARANCE_READ);
shape.setCapability(Shape3D.ALLOW_APPEARANCE_WRITE);
shape.getGeometry().setCapability(GeometryArray.ALLOW_COORDINATE_READ);
shape.getGeometry().setCapability(GeometryArray.ALLOW_COUNT_READ);
shape.getGeometry().setCapability(GeometryArray.ALLOW_FORMAT_READ);
feat_pos_tg.setCapability(TransformGroup.ALLOW_TRANSFORM_WRITE);
feat_rot_tg.setCapability(TransformGroup.ALLOW_TRANSFORM_WRITE);
resetFeature();
if (_set_billboard) {
bb = new Billboard(feat_rot_tg, Billboard.ROTATE_ABOUT_POINT,
new Point3f());
bb.setSchedulingBounds(new BoundingSphere(new Point3d(), 1000d));
feat_rot_tg.addChild(bb);
}
else {
scale_vector_t3d.rotX(Math.toRadians(45));
scale_vector_tg.setTransform(scale_vector_t3d);
}
feat_pos_tg.addChild(feat_rot_tg);
feat_rot_tg.addChild(scale_vector_tg);
scale_vector_tg.addChild(shape);
track3d.getFeatureTransformGroup().addChild(feat_pos_tg);
}
public String getAccessionId() {
return userdata.getAccessionID();
}
public void setAppearance(Appearance highlight_ap) {}
public void increaseSize() {}
public void resetSize() {}
public void resetFeature() {
int shape_start, shape_end;
if (track3d.getReverse()) {
shape_start = track3d.getEnd() - userdata.getEnd();
shape_end = track3d.getEnd() - userdata.getStart();
}
else {
shape_start = userdata.getStart();
shape_end = userdata.getEnd();
}
offset_center_nt = ( (shape_start + shape_end) / 2) -
track3d.getWorkingStart();
double offset_center_local = (offset_center_nt / track3d.getCurrentScale());
feat_pos_v3d.set(offset_center_local, shape_y_offset, shape_z_offset);
feat_pos_T3D.set(feat_pos_v3d);
feat_pos_tg.setTransform(feat_pos_T3D);
}
public void kill() {
track3d.getFeatureTransformGroup().removeChild(feat_pos_tg);
if (_set_billboard) {
feat_rot_tg.removeChild(bb);
}
feat_pos_tg.removeChild(feat_rot_tg);
feat_rot_tg.removeChild(scale_vector_tg);
scale_vector_tg.removeChild(shape);
shape = null;
userdata = null;
track3d = null;
}
}
package ca.bcgsc.sockeye.j3d;
import java.awt.Font;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.media.j3d.Appearance;
import javax.media.j3d.ColoringAttributes;
import javax.media.j3d.Font3D;
import javax.media.j3d.GeometryArray;
import javax.media.j3d.Material;
import javax.media.j3d.Shape3D;
import javax.media.j3d.Text3D;
import javax.media.j3d.Transform3D;
import javax.media.j3d.TransformGroup;
import javax.media.j3d.TransparencyAttributes;
import javax.vecmath.Color3f;
import javax.vecmath.Vector3f;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.datastorage.Track;
import ca.bcgsc.sockeye.datastorage.TrackDistribution;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.util.Log;
import ca.bcgsc.sockeye.util.StringUtils;
import ca.bcgsc.util.CoordinateUtils;
import com.sun.j3d.utils.geometry.Box;
import com.sun.j3d.utils.geometry.Cylinder;
import com.sun.j3d.utils.geometry.Primitive;
class Track3D {
private Track track;
private String trackName;
private int beginning_nt;
private int end_nt;
private int track_id;
private int ungapped_start;
private int ungapped_end;
private ArrayList distributionFeatures = new ArrayList();
private int distributionOffset = 0;
private TransformGroup track_tg = new TransformGroup();
private Transform3D trackT3D = new Transform3D();
private Vector3f trackV3f = new Vector3f();
private float track_y_position = -5000f;
private float track_feature_xpos;
private TransformGroup track_feature_xpos_tg = new TransformGroup();
private Transform3D track_feature_xpos_t3d = new Transform3D();
private Vector3f track_feature_xpos_v3f = new Vector3f();
private float text_track_distance = 0.07f;
private static final float track_box_lift =
-1 * Platform3D.platform_z_thickness;
private static final float track_box_thickness =
Platform3D.platform_z_thickness;
private float track_box_length = 0f;
private static final float track_box_width =
Platform3D.platform_y_width_default * 0.97f;
private Vector3f track_box_v3f = new Vector3f();
private Transform3D track_box_t3d = new Transform3D();
private TransformGroup track_box_tg = new TransformGroup();
private Box track_box;
private static final Color3f black = new Color3f(0f, 0f, 0f);
private static final Color3f track_box_color =
new Color3f(
Platform3D.platform_color.x + 0.1f,
Platform3D.platform_color.y + 0.1f,
Platform3D.platform_color.z + 0.2f);
private static final Color3f track_box_highlight_color =
new Color3f(
Platform3D.platform_color.x + 0.15f,
Platform3D.platform_color.y + 0.15f,
Platform3D.platform_color.z + 0.2f);
private static final Color3f track_box_select_color =
new Color3f(
Platform3D.platform_color.x + 0.3f,
Platform3D.platform_color.y + 0.3f,
Platform3D.platform_color.z + 0.4f);
private Appearance track_box_ap = new Appearance();
private static final Material track_box_mat =
new Material(track_box_color, black, black, black, 1f);
private static final Material track_box_highlight_mat =
new Material(track_box_highlight_color, black, black, black, 1f);
private static final Material track_box_select_mat =
new Material(track_box_select_color, black, black, black, 1f);
private Font track_text_font = Configuration.getFont("Track Name Label");
private Font3D track_text_font3D = new Font3D(track_text_font, null);
private Font pos_neg_text_font = Configuration.getFont("Track Offset Label");
private Font3D pos_neg_text_font3D = new Font3D(pos_neg_text_font, null);
private Font coord_text_font = Configuration.getFont("Track Offset Label");
private Font3D coord_text_font3D = new Font3D(coord_text_font, null);
private Font length_text_font = Configuration.getFont("Track Length Label");
private Font3D length_text_font3D = new Font3D(length_text_font, null);
private Text3D track_text_text3D;
private Shape3D track_text_shape3D;
private ColoringAttributes text_color =
new ColoringAttributes(1f, 1f, 1f, ColoringAttributes.NICEST);
private Appearance text_ap = new Appearance();
private ColoringAttributes highlighttextcolor =
new ColoringAttributes(1f, 1f, 0f, ColoringAttributes.NICEST);
private ColoringAttributes highlightrailcolor =
new ColoringAttributes(1f, 1f, 0f, ColoringAttributes.NICEST);
private final double track_text_scale = 0.15;
private Transform3D track_text_scale_T3D = new Transform3D();
private TransformGroup track_text_scale_tg = new TransformGroup();
private final float track_text_xpos = (-1) * Platform3D.platform_x_length;
private Vector3f track_text_xpos_v3f = new Vector3f(track_text_xpos, 0f, 0f);
private Transform3D track_text_xpos_T3D = new Transform3D();
private TransformGroup track_text_xpos_tg = new TransformGroup();
private float feature_lift =
Platform3D.platform_z_thickness * 2 + track_box_thickness;
private ColoringAttributes railcolor =
new ColoringAttributes(0f, 0f, 0f, ColoringAttributes.NICEST);
private Appearance rail_ap = new Appearance();
private Cylinder rail;
private float rail_length = 0f;
private final float rail_radius = 0.005f;
private Vector3f rail_lift_v3f = new Vector3f();
private Transform3D rail_lift_T3D = new Transform3D();
private Transform3D rail_rot_T3D = new Transform3D();
private TransformGroup rail_lift_tg = new TransformGroup();
private String pos5_text = "5'(+)";
private String neg3_text = "3'(-)";
private String neg5_text = "5'(-)";
private String pos3_text = "3'(+)";
private Text3D upper_text_text3D;
private Shape3D upper_text_shape3D;
private Transform3D upper_text_scale_T3D = new Transform3D();
private TransformGroup upper_text_scale_tg = new TransformGroup();
private Vector3f upper_text_v3f = new Vector3f();
private Transform3D upper_text_T3D = new Transform3D();
private TransformGroup upper_text_tg = new TransformGroup();
private Text3D uppertail_text_text3D;
private Shape3D uppertail_text_shape3D;
private Transform3D uppertail_text_scale_T3D = new Transform3D();
private TransformGroup uppertail_text_scale_tg = new TransformGroup();
private Vector3f uppertail_text_v3f = new Vector3f();
private Transform3D uppertail_text_T3D = new Transform3D();
private TransformGroup uppertail_text_tg = new TransformGroup();
private Text3D lower_text_text3D;
private Shape3D lower_text_shape3D;
private Transform3D lower_text_scale_T3D = new Transform3D();
private TransformGroup lower_text_scale_tg = new TransformGroup();
private Vector3f lower_text_v3f = new Vector3f();
private Transform3D lower_text_T3D = new Transform3D();
private TransformGroup lower_text_tg = new TransformGroup();
private Text3D lowertail_text_text3D;
private Shape3D lowertail_text_shape3D;
private Transform3D lowertail_text_scale_T3D = new Transform3D();
private TransformGroup lowertail_text_scale_tg = new TransformGroup();
private Vector3f lowertail_text_v3f = new Vector3f();
private Transform3D lowertail_text_T3D = new Transform3D();
private TransformGroup lowertail_text_tg = new TransformGroup();
private final double track_ends_text_scale = 0.03;
private final float track_ends_text_offset = -0.1f;
private Text3D track_beginning_text_text3D;
private Shape3D track_beginning_text_shape3D;
private Transform3D track_beginning_text_scale_T3D = new Transform3D();
private TransformGroup track_beginning_text_scale_tg = new TransformGroup();
private Vector3f track_beginning_text_v3f = new Vector3f();
private Transform3D track_beginning_text_T3D = new Transform3D();
private TransformGroup track_beginning_text_tg = new TransformGroup();
private Text3D track_end_text_text3D;
private Shape3D track_end_text_shape3D;
private Transform3D track_end_text_scale_T3D = new Transform3D();
private TransformGroup track_end_text_scale_tg = new TransformGroup();
private Vector3f track_end_text_v3f = new Vector3f();
private Transform3D track_end_text_T3D = new Transform3D();
private TransformGroup track_end_text_tg = new TransformGroup();
private double track_length_scale_length = 0.30;
private Text3D track_length_text_text3D;
private Shape3D track_length_text_shape3D;
private Transform3D track_length_text_scale_T3D = new Transform3D();
private TransformGroup track_length_text_scale_tg = new TransformGroup();
private Vector3f track_length_text_v3f = new Vector3f();
private Transform3D track_length_text_T3D = new Transform3D();
private TransformGroup track_length_text_tg = new TransformGroup();
private Appearance fontAppearance = new Appearance();
private Hashtable FeatureTypeHash = new Hashtable();
private float current_scale = 100000f;
private boolean current_reverse;
private int working_start, working_end;
private int current_offset;
private float lastDeletedDistributionMaximum = -1;
private static boolean _show_centerline = true;
public Track3D(
TransformGroup platform_tg,
Track track,
Color3f label_color) {
this.track = track;
trackName = StringUtils.getShortNameForTrackID(track.getId());
if (trackName == null) {
trackName = "";
}
beginning_nt = track.getDataWindowStart();
end_nt = track.getDataWindowEnd();
track_id = track.getId();
ungapped_start = track.getDataWindowStart();
if (track.getAttribute("ungapped_end") == null)
ungapped_end = track.getDataWindowEnd();
else
ungapped_end =
Integer.parseInt(track.getAttribute("ungapped_end").toString());
track_box_ap.setMaterial(track_box_mat);
track_box_ap.setCapability(Appearance.ALLOW_MATERIAL_WRITE);
rail_ap.setCapability(Appearance.ALLOW_COLORING_ATTRIBUTES_WRITE);
rail_ap.setColoringAttributes(railcolor);
createTrackBox();
text_ap.setCapability(Appearance.ALLOW_COLORING_ATTRIBUTES_WRITE);
text_ap.setCapability(Appearance.ALLOW_COLORING_ATTRIBUTES_READ);
text_color.setCapability(ColoringAttributes.ALLOW_COLOR_WRITE);
text_color.setColor(label_color);
text_ap.setColoringAttributes(text_color);
track_text_text3D =
new Text3D(track_text_font3D, trackName.replace('_', ' '));
track_text_text3D.setAlignment(Text3D.ALIGN_LAST);
track_text_text3D.setPath(Text3D.PATH_RIGHT);
track_text_shape3D = new Shape3D(track_text_text3D, text_ap);
track_text_shape3D.setPickable(false);
track_text_shape3D.setCapability(Shape3D.ALLOW_PICKABLE_READ);
track_text_shape3D.setCapability(Shape3D.ALLOW_APPEARANCE_WRITE);
track_text_scale_T3D.setScale(track_ends_text_scale);
track_text_scale_tg.setTransform(track_text_scale_T3D);
track_text_scale_tg.addChild(track_text_shape3D);
track_text_xpos_tg.addChild(track_text_scale_tg);
track_text_xpos_v3f.set(
track_text_xpos - text_track_distance,
0f,
feature_lift);
track_text_xpos_T3D.set(track_text_xpos_v3f);
track_text_xpos_tg.setTransform(track_text_xpos_T3D);
upper_text_text3D = new Text3D(pos_neg_text_font3D, pos5_text);
upper_text_text3D.setAlignment(Text3D.ALIGN_LAST);
upper_text_text3D.setPath(Text3D.PATH_RIGHT);
upper_text_text3D.setCapability(Text3D.ALLOW_STRING_WRITE);
upper_text_shape3D = new Shape3D(upper_text_text3D, text_ap);
upper_text_shape3D.setPickable(false);
upper_text_shape3D.setCapability(Shape3D.ALLOW_PICKABLE_READ);
upper_text_scale_T3D.setScale(track_ends_text_scale);
upper_text_scale_tg.setTransform(upper_text_scale_T3D);
upper_text_scale_tg.addChild(upper_text_shape3D);
upper_text_tg.addChild(upper_text_scale_tg);
track_feature_xpos_tg.addChild(upper_text_tg);
upper_text_v3f.set(-text_track_distance, -2 * track_ends_text_offset, 0f);
upper_text_T3D.set(upper_text_v3f);
upper_text_tg.setTransform(upper_text_T3D);
uppertail_text_text3D = new Text3D(pos_neg_text_font3D, pos3_text);
uppertail_text_text3D.setAlignment(Text3D.ALIGN_FIRST);
uppertail_text_text3D.setPath(Text3D.PATH_RIGHT);
uppertail_text_text3D.setCapability(Text3D.ALLOW_STRING_WRITE);
uppertail_text_shape3D = new Shape3D(uppertail_text_text3D, text_ap);
uppertail_text_shape3D.setPickable(false);
uppertail_text_shape3D.setCapability(Shape3D.ALLOW_PICKABLE_READ);
uppertail_text_scale_T3D.setScale(track_ends_text_scale);
uppertail_text_scale_tg.setTransform(uppertail_text_scale_T3D);
uppertail_text_scale_tg.addChild(uppertail_text_shape3D);
uppertail_text_tg.addChild(uppertail_text_scale_tg);
track_feature_xpos_tg.addChild(uppertail_text_tg);
uppertail_text_v3f.set(
getLength() / current_scale,
-2 * track_ends_text_offset,
0f);
uppertail_text_T3D.set(uppertail_text_v3f);
uppertail_text_tg.setTransform(uppertail_text_T3D);
lower_text_text3D = new Text3D(pos_neg_text_font3D, neg3_text);
lower_text_text3D.setAlignment(Text3D.ALIGN_LAST);
lower_text_text3D.setPath(Text3D.PATH_RIGHT);
lower_text_text3D.setCapability(Text3D.ALLOW_STRING_WRITE);
lower_text_shape3D = new Shape3D(lower_text_text3D, text_ap);
lower_text_shape3D.setPickable(false);
lower_text_shape3D.setCapability(Shape3D.ALLOW_PICKABLE_READ);
lower_text_scale_T3D.setScale(track_ends_text_scale);
lower_text_scale_tg.setTransform(lower_text_scale_T3D);
lower_text_scale_tg.addChild(lower_text_shape3D);
lower_text_tg.addChild(lower_text_scale_tg);
track_feature_xpos_tg.addChild(lower_text_tg);
lower_text_v3f.set(-text_track_distance, 2 * track_ends_text_offset, 0f);
lower_text_T3D.set(lower_text_v3f);
lower_text_tg.setTransform(lower_text_T3D);
lowertail_text_text3D = new Text3D(pos_neg_text_font3D, neg5_text);
lowertail_text_text3D.setAlignment(Text3D.ALIGN_FIRST);
lowertail_text_text3D.setPath(Text3D.PATH_RIGHT);
lowertail_text_text3D.setCapability(Text3D.ALLOW_STRING_WRITE);
lowertail_text_shape3D = new Shape3D(lowertail_text_text3D, text_ap);
lowertail_text_shape3D.setPickable(false);
lowertail_text_shape3D.setCapability(Shape3D.ALLOW_PICKABLE_READ);
lowertail_text_scale_T3D.setScale(track_ends_text_scale);
lowertail_text_scale_tg.setTransform(lowertail_text_scale_T3D);
lowertail_text_scale_tg.addChild(lowertail_text_shape3D);
lowertail_text_tg.addChild(lowertail_text_scale_tg);
track_feature_xpos_tg.addChild(lowertail_text_tg);
lowertail_text_v3f.set(
getLength() / current_scale,
2 * track_ends_text_offset,
0f);
lowertail_text_T3D.set(lowertail_text_v3f);
lowertail_text_tg.setTransform(lowertail_text_T3D);
track_beginning_text_text3D =
new Text3D(coord_text_font3D, String.valueOf(ungapped_start));
track_beginning_text_text3D.setAlignment(Text3D.ALIGN_LAST);
track_beginning_text_text3D.setPath(Text3D.PATH_RIGHT);
track_beginning_text_text3D.setCapability(Text3D.ALLOW_STRING_WRITE);
track_beginning_text_shape3D =
new Shape3D(track_beginning_text_text3D, text_ap);
track_beginning_text_shape3D.setPickable(false);
track_beginning_text_shape3D.setCapability(Shape3D.ALLOW_PICKABLE_READ);
track_beginning_text_scale_T3D.setScale(track_ends_text_scale);
track_beginning_text_scale_tg.setTransform(track_beginning_text_scale_T3D);
track_beginning_text_scale_tg.addChild(track_beginning_text_shape3D);
track_beginning_text_tg.addChild(track_beginning_text_scale_tg);
track_feature_xpos_tg.addChild(track_beginning_text_tg);
track_beginning_text_v3f.set(
-text_track_distance,
track_ends_text_offset,
0f);
track_beginning_text_T3D.set(track_beginning_text_v3f);
track_beginning_text_tg.setTransform(track_beginning_text_T3D);
track_end_text_text3D =
new Text3D(coord_text_font3D, String.valueOf(ungapped_end));
track_end_text_text3D.setAlignment(Text3D.ALIGN_FIRST);
track_end_text_text3D.setPath(Text3D.PATH_RIGHT);
track_end_text_text3D.setCapability(Text3D.ALLOW_STRING_WRITE);
track_end_text_shape3D = new Shape3D(track_end_text_text3D, text_ap);
track_end_text_shape3D.setPickable(false);
track_end_text_shape3D.setCapability(Shape3D.ALLOW_PICKABLE_READ);
track_end_text_scale_T3D.setScale(track_ends_text_scale);
track_end_text_scale_tg.setTransform(track_end_text_scale_T3D);
track_end_text_scale_tg.addChild(track_end_text_shape3D);
track_end_text_tg.addChild(track_end_text_scale_tg);
track_feature_xpos_tg.addChild(track_end_text_tg);
track_end_text_v3f.set(
(getLength() / current_scale),
track_ends_text_offset,
0f);
track_end_text_T3D.set(track_end_text_v3f);
track_end_text_tg.setTransform(track_end_text_T3D);
String track_length_text =
CoordinateUtils.getAsUnitString(getLength(), null, 2)
+ (track.isReverse() ? " [R]" : "");
track_length_text_text3D =
new Text3D(length_text_font3D, track_length_text);
track_length_text_text3D.setAlignment(Text3D.ALIGN_FIRST);
track_length_text_text3D.setPath(Text3D.PATH_RIGHT);
track_length_text_text3D.setCapability(Text3D.ALLOW_STRING_WRITE);
track_length_text_shape3D = new Shape3D(track_length_text_text3D, text_ap);
track_length_text_shape3D.setPickable(false);
track_length_text_shape3D.setCapability(Shape3D.ALLOW_PICKABLE_READ);
track_length_text_shape3D.setCapability(Shape3D.ALLOW_APPEARANCE_READ);
track_length_text_shape3D.setCapability(Shape3D.ALLOW_APPEARANCE_WRITE);
TransparencyAttributes transpAttr = new TransparencyAttributes();
transpAttr.setTransparencyMode(TransparencyAttributes.NICEST);
transpAttr.setTransparency(0.0f);
fontAppearance.setTransparencyAttributes(transpAttr);
track_length_text_shape3D.setAppearance(fontAppearance);
track_length_text_scale_T3D.setScale(track_ends_text_scale);
track_length_text_scale_tg.setTransform(track_length_text_scale_T3D);
track_length_text_scale_tg.addChild(track_length_text_shape3D);
track_length_text_tg.addChild(track_length_text_scale_tg);
track_feature_xpos_tg.addChild(track_length_text_tg);
track_length_text_v3f.set(
0.05f,
2.7f * track_ends_text_offset,
Platform3D.platform_z_thickness+0.015f);
track_length_text_T3D.set(track_length_text_v3f);
track_length_text_tg.setTransform(track_length_text_T3D);
if (track_box_length < track_length_scale_length) {
transpAttr.setTransparency(1.0f);
}
track_feature_xpos_tg.setCapability(TransformGroup.ALLOW_TRANSFORM_WRITE);
track_end_text_tg.setCapability(TransformGroup.ALLOW_TRANSFORM_WRITE);
track_box_tg.setCapability(TransformGroup.ALLOW_TRANSFORM_WRITE);
rail_lift_tg.setCapability(TransformGroup.ALLOW_TRANSFORM_WRITE);
current_offset = track.getOffset() + 1;
current_reverse = !track.isReverse();
updateTrackReverse();
track_feature_xpos_tg.addChild(track_box_tg);
track_box_tg.addChild(rail_lift_tg);
track_tg.addChild(track_text_xpos_tg);
track_tg.addChild(track_feature_xpos_tg);
platform_tg.addChild(track_tg);
}
public final void setShowCenterLine(boolean b) {
if (b && rail_lift_tg.numChildren() == 0) {
rail_lift_tg.addChild(rail);
} else if (!b) {
rail_lift_tg.removeChild(rail);
}
}
private final void createTrackBox() {
track_box_length = (getLength() * 0.5f) / current_scale;
track_box_v3f.set(track_box_length, 0f, track_box_lift);
track_box_t3d.set(track_box_v3f);
track_box_tg.setTransform(track_box_t3d);
track_box = null;
track_box =
new Box(
track_box_length,
track_box_width,
track_box_thickness,
track_box_ap);
track_box.setPickable(true);
track_box.setUserData(this);
track_box.setCapability(Box.ALLOW_PICKABLE_READ);
track_box.getShape(Box.TOP).setCapability(Shape3D.ALLOW_GEOMETRY_READ);
track_box.getShape(Box.TOP).getGeometry().setCapability(
GeometryArray.ALLOW_COUNT_READ);
track_box.getShape(Box.TOP).getGeometry().setCapability(
GeometryArray.ALLOW_COORDINATE_READ);
track_box.getShape(Box.TOP).getGeometry().setCapability(
GeometryArray.ALLOW_FORMAT_READ);
track_box.getShape(Box.BOTTOM).setCapability(Shape3D.ALLOW_GEOMETRY_READ);
track_box.getShape(Box.BOTTOM).getGeometry().setCapability(
GeometryArray.ALLOW_COORDINATE_READ);
track_box.getShape(Box.BOTTOM).getGeometry().setCapability(
GeometryArray.ALLOW_COUNT_READ);
track_box.getShape(Box.BOTTOM).getGeometry().setCapability(
GeometryArray.ALLOW_FORMAT_READ);
track_box.getShape(Box.FRONT).setCapability(Shape3D.ALLOW_GEOMETRY_READ);
track_box.getShape(Box.FRONT).getGeometry().setCapability(
GeometryArray.ALLOW_COORDINATE_READ);
track_box.getShape(Box.FRONT).getGeometry().setCapability(
GeometryArray.ALLOW_COUNT_READ);
track_box.getShape(Box.FRONT).getGeometry().setCapability(
GeometryArray.ALLOW_FORMAT_READ);
track_box.getShape(Box.BACK).setCapability(Shape3D.ALLOW_GEOMETRY_READ);
track_box.getShape(Box.BACK).getGeometry().setCapability(
GeometryArray.ALLOW_COORDINATE_READ);
track_box.getShape(Box.BACK).getGeometry().setCapability(
GeometryArray.ALLOW_COUNT_READ);
track_box.getShape(Box.BACK).getGeometry().setCapability(
GeometryArray.ALLOW_FORMAT_READ);
track_box.getShape(Box.LEFT).setCapability(Shape3D.ALLOW_GEOMETRY_READ);
track_box.getShape(Box.LEFT).getGeometry().setCapability(
GeometryArray.ALLOW_COORDINATE_READ);
track_box.getShape(Box.LEFT).getGeometry().setCapability(
GeometryArray.ALLOW_COUNT_READ);
track_box.getShape(Box.LEFT).getGeometry().setCapability(
GeometryArray.ALLOW_FORMAT_READ);
track_box.getShape(Box.RIGHT).setCapability(Shape3D.ALLOW_GEOMETRY_READ);
track_box.getShape(Box.RIGHT).getGeometry().setCapability(
GeometryArray.ALLOW_COORDINATE_READ);
track_box.getShape(Box.RIGHT).getGeometry().setCapability(
GeometryArray.ALLOW_COUNT_READ);
track_box.getShape(Box.RIGHT).getGeometry().setCapability(
GeometryArray.ALLOW_FORMAT_READ);
track_box_tg.addChild(track_box);
rail_length = getLength() / current_scale;
rail_lift_v3f.set(0f, 0f, track_box_thickness);
rail_rot_T3D.rotZ(Math.toRadians(90d));
rail_lift_T3D.set(rail_lift_v3f);
rail_lift_T3D.mul(rail_rot_T3D);
rail_lift_tg.setTransform(rail_lift_T3D);
if (_show_centerline && rail_lift_tg.numChildren() > 0) {
rail_lift_tg.removeChild(rail);
}
rail = null;
rail = new Cylinder(rail_radius, rail_length, rail_ap);
rail.setPickable(false);
rail.setCapability(Primitive.ALLOW_PICKABLE_READ);
if (_show_centerline) {
rail_lift_tg.addChild(rail);
}
}
public final void highlightTrack() {
rail_ap.setColoringAttributes(highlightrailcolor);
text_ap.setColoringAttributes(highlighttextcolor);
track_box_ap.setMaterial(track_box_highlight_mat);
}
public final void unHighlightTrack() {
rail_ap.setColoringAttributes(railcolor);
text_ap.setColoringAttributes(text_color);
track_box_ap.setMaterial(track_box_mat);
}
public final void highlightTranscript(List accession_ids) {
FeatureList3D currFeatureList3D = null;
if (FeatureTypeHash.containsKey("exon")) {
currFeatureList3D = (FeatureList3D) FeatureTypeHash.get("exon");
currFeatureList3D.highlightTranscript(accession_ids);
}
}
public final void unHighlightTranscript(List accession_ids) {
FeatureList3D currFeatureList3D = null;
if (FeatureTypeHash.containsKey("exon")) {
currFeatureList3D = (FeatureList3D) FeatureTypeHash.get("exon");
currFeatureList3D.unHighlightTranscript(accession_ids);
}
}
public final void setNormalAppearance(TrackFeature track_feature) {
FeatureList3D currFeatureList3D =
(FeatureList3D) FeatureTypeHash.get(track_feature.getFeature());
if (currFeatureList3D != null) {
currFeatureList3D.setNormalAppearance(track_feature);
} else {
Log.println(
"Didn't set "
+ track_feature.getAccessionID()
+ " to normal appearance: couldn't find its FeatureList3D.");
}
}
public final void resetFeatureList(String feature_name) {
if (FeatureTypeHash.containsKey(feature_name)) {
FeatureList3D currFeatureList3D =
(FeatureList3D) FeatureTypeHash.get(feature_name);
if (currFeatureList3D != null) {
currFeatureList3D.resetFeatures();
}
}
}
public final void updateTrackScale(
float new_y_position,
int min_offset,
float new_scale) {
if (track_y_position != new_y_position) {
track_y_position = new_y_position;
trackV3f.set(0f, track_y_position, 0f);
trackT3D.set(trackV3f);
track_tg.setTransform(trackT3D);
}
int effective_offset = track.getOffset() - min_offset;
current_offset = effective_offset;
track_feature_xpos = track_text_xpos + current_offset / new_scale;
track_feature_xpos_v3f.set(track_feature_xpos, 0f, feature_lift);
track_feature_xpos_t3d.set(track_feature_xpos_v3f);
track_feature_xpos_tg.setTransform(track_feature_xpos_t3d);
if (new_scale != current_scale) {
current_scale = new_scale;
Enumeration enum = FeatureTypeHash.elements();
while (enum.hasMoreElements()) {
FeatureList3D thisfeaturelist = (FeatureList3D) enum.nextElement();
thisfeaturelist.resetFeatures();
}
uppertail_text_v3f.set(
(getLength() / current_scale) + text_track_distance,
-2 * track_ends_text_offset,
0f);
uppertail_text_T3D.set(uppertail_text_v3f);
uppertail_text_tg.setTransform(uppertail_text_T3D);
lowertail_text_v3f.set(
(getLength() / current_scale) + text_track_distance,
2 * track_ends_text_offset,
0f);
lowertail_text_T3D.set(lowertail_text_v3f);
lowertail_text_tg.setTransform(lowertail_text_T3D);
track_end_text_v3f.set(
(getLength() / current_scale) + text_track_distance,
track_ends_text_offset,
0f);
track_end_text_T3D.set(track_end_text_v3f);
track_end_text_tg.setTransform(track_end_text_T3D);
track_box_tg.removeChild(track_box);
setShowCenterLine(false);
createTrackBox();
if (track_box_length < track_length_scale_length)
fontAppearance.getTransparencyAttributes().setTransparency(1.0f);
else
fontAppearance.getTransparencyAttributes().setTransparency(0.0f);
}
}
public final void updateTrackReverse() {
if (track.isReverse() != current_reverse) {
if (!track.isReverse()) {
working_start = beginning_nt;
working_end = end_nt;
track_beginning_text_text3D.setString(String.valueOf(ungapped_start));
track_end_text_text3D.setString(String.valueOf(ungapped_end));
upper_text_text3D.setString(pos5_text);
uppertail_text_text3D.setString(pos3_text);
lower_text_text3D.setString(neg3_text);
lowertail_text_text3D.setString(neg5_text);
String track_length_text =
CoordinateUtils.getAsUnitString(getLength(), null, 2);
track_length_text_text3D.setString(track_length_text);
} else {
working_start = 0;
working_end = end_nt - beginning_nt;
track_beginning_text_text3D.setString(String.valueOf(ungapped_end));
track_end_text_text3D.setString(String.valueOf(ungapped_start));
upper_text_text3D.setString(neg5_text);
uppertail_text_text3D.setString(neg3_text);
lower_text_text3D.setString(pos3_text);
lowertail_text_text3D.setString(pos5_text);
String track_length_text =
CoordinateUtils.getAsUnitString(getLength(), null, 2) + " [R]";
track_length_text_text3D.setString(track_length_text);
}
current_reverse = track.isReverse();
Enumeration enum = FeatureTypeHash.elements();
while (enum.hasMoreElements()) {
FeatureList3D thisfeaturelist = (FeatureList3D) enum.nextElement();
thisfeaturelist.resetFeatures();
}
}
}
protected final int getTrackId() {
return track_id;
}
protected final int getStart() {
return beginning_nt;
}
protected final int getEnd() {
return end_nt;
}
protected final int getWorkingStart() {
return working_start;
}
protected final int getWorkingEnd() {
return working_end;
}
protected final boolean getReverse() {
return current_reverse;
}
protected TransformGroup getFeatureTransformGroup() {
return track_feature_xpos_tg;
}
protected final int getTrueLength() {
return 1 + track.getOffset() + end_nt - beginning_nt;
}
protected final int getTrueOffset() {
return track.getOffset();
}
protected final int getLength() {
return 1 + end_nt - beginning_nt;
}
protected final void setAppearance(
TrackFeature track_feature,
Appearance appearance) {
FeatureList3D currFeatureList3D = null;
if (FeatureTypeHash.containsKey(track_feature.getFeature())) {
currFeatureList3D =
(FeatureList3D) FeatureTypeHash.get(track_feature.getFeature());
currFeatureList3D.setAppearance(track_feature, appearance);
} else {
Log.println(
"Didn't set appearance of feature "
+ track_feature.getAccessionID()
+ ": couldn't find FeatureList3D.");
}
}
protected final void setTrackTextColor(Color3f txtColor) {
text_color.setColor(txtColor);
}
protected final boolean addFeature(TrackFeature userdata) {
return addFeature(userdata.getFeature(), userdata);
}
protected final boolean addFeature(String name, TrackFeature userdata) {
boolean addThisFeature =
!(userdata.getStart() > end_nt || userdata.getEnd() < beginning_nt);
if (addThisFeature) {
FeatureList3D currFeatureList3D = null;
if (FeatureTypeHash.containsKey(name)) {
currFeatureList3D = (FeatureList3D) FeatureTypeHash.get(name);
} else {
currFeatureList3D = new FeatureList3D(name);
FeatureTypeHash.put(name, currFeatureList3D);
}
addThisFeature = currFeatureList3D.addFeature(this, userdata);
if (userdata instanceof TrackDistribution && addThisFeature) {
distributionFeatures.add(name);
}
} else {
Log.println(
"Didn't add feature "
+ userdata.getAccessionID()
+ ": doesn't overlap with track.");
}
return addThisFeature;
}
protected final void removeFeature(
String feature_name,
String accession_id) {
if (FeatureTypeHash.containsKey(feature_name)) {
FeatureList3D currFeatureList3D =
(FeatureList3D) FeatureTypeHash.get(feature_name);
Feature3D f3d = currFeatureList3D.removeFeature(accession_id);
if (f3d instanceof DistributionFeature3D)
distributionFeatures.remove(feature_name);
} else {
Log.println(
"Didn't remove feature "
+ accession_id
+ ": couldn't find FeatureList3D.");
Enumeration enum = FeatureTypeHash.keys();
String key;
Pattern p = Pattern.compile(feature_name);
Matcher m;
while (enum.hasMoreElements()) {
key = (String) enum.nextElement();
m = p.matcher(key);
if (m.find()) {
FeatureList3D currFeatureList3D =
(FeatureList3D) FeatureTypeHash.get(key);
currFeatureList3D.removeFeature(accession_id);
}
}
}
}
public final float getMaxOfLastRemovedDistribution() {
return lastDeletedDistributionMaximum;
}
protected final void removeFeatureName(String feature_name) {
if (FeatureTypeHash.containsKey(feature_name)) {
int pos = distributionFeatures.indexOf(feature_name);
FeatureList3D currFeatureList3D =
(FeatureList3D) FeatureTypeHash.get(feature_name);
lastDeletedDistributionMaximum =
currFeatureList3D.getDistributionMaxScore();
currFeatureList3D.kill();
if (distributionFeatures.remove(feature_name)
&& pos < distributionFeatures.size()) {
Iterator it = distributionFeatures.iterator();
while (it.hasNext()) {
String fName = it.next().toString();
currFeatureList3D = (FeatureList3D) FeatureTypeHash.get(fName);
currFeatureList3D.redrawDistributionFeaturesReduceOffset(pos);
}
}
} else {
Log.println(
"Didn't remove feature_name "
+ feature_name
+ ": couldn't find FeatureList3D.");
Enumeration enum = FeatureTypeHash.keys();
String key;
Pattern p = Pattern.compile(feature_name);
Matcher m;
while (enum.hasMoreElements()) {
key = (String) enum.nextElement();
m = p.matcher(key);
if (m.find()) {
FeatureList3D currFeatureList3D =
(FeatureList3D) FeatureTypeHash.get(key);
currFeatureList3D.kill();
}
}
}
}
public float getTrackDistributionMaximum() {
float max = 0f;
Enumeration enum = FeatureTypeHash.elements();
while (enum.hasMoreElements()) {
FeatureList3D thisfeaturelist = (FeatureList3D) enum.nextElement();
max = Math.max(max, thisfeaturelist.getDistributionMaxScore());
}
return max;
}
public final void redrawAllDistributions() {
Enumeration enum = FeatureTypeHash.elements();
while (enum.hasMoreElements()) {
FeatureList3D thisfeaturelist = (FeatureList3D) enum.nextElement();
thisfeaturelist.redrawDistributionFeatures();
}
}
public final void resetAllFeatures() {
Enumeration enum = FeatureTypeHash.elements();
while (enum.hasMoreElements()) {
FeatureList3D thisfeaturelist = (FeatureList3D) enum.nextElement();
thisfeaturelist.resetFeatures();
}
}
public final void redrawAllFeatures() {
Enumeration enum = FeatureTypeHash.elements();
while (enum.hasMoreElements()) {
FeatureList3D thisfeaturelist = (FeatureList3D) enum.nextElement();
thisfeaturelist.redrawFeatures();
}
}
public final int getFeatureCount() {
Enumeration enum = FeatureTypeHash.elements();
int count = 0;
while (enum.hasMoreElements())
count += ((FeatureList3D) enum.nextElement()).size();
return count;
}
protected final void removeAllFeatures() {
Enumeration enum = FeatureTypeHash.elements();
while (enum.hasMoreElements()) {
FeatureList3D thisfeaturelist = (FeatureList3D) enum.nextElement();
thisfeaturelist.kill();
}
}
protected final float getCurrentScale() {
return current_scale;
}
protected final int getBase(double x_coord) {
double distance_nt =
(x_coord + Platform3D.platform_x_length) * current_scale;
int nearest_base;
if (current_reverse) {
nearest_base = (int) Math.round(current_offset + end_nt - distance_nt);
} else {
nearest_base =
(int) Math.floor(distance_nt + beginning_nt - current_offset);
}
return Math.min(end_nt, Math.max(beginning_nt, nearest_base));
}
protected final TransformGroup kill() {
track_box_tg.removeChild(track_box);
track_box.setUserData(null);
track_box = null;
track_feature_xpos_tg.removeChild(track_box_tg);
setShowCenterLine(false);
track_box_tg.removeChild(rail_lift_tg);
rail = null;
track_text_scale_tg.removeChild(track_text_shape3D);
track_text_xpos_tg.removeChild(track_text_scale_tg);
upper_text_scale_tg.removeChild(upper_text_shape3D);
upper_text_tg.removeChild(upper_text_scale_tg);
track_feature_xpos_tg.removeChild(upper_text_tg);
upper_text_shape3D = null;
uppertail_text_scale_tg.removeChild(uppertail_text_shape3D);
uppertail_text_tg.removeChild(uppertail_text_scale_tg);
track_feature_xpos_tg.removeChild(uppertail_text_tg);
uppertail_text_shape3D = null;
lower_text_scale_tg.removeChild(lower_text_shape3D);
lower_text_tg.removeChild(lower_text_scale_tg);
track_feature_xpos_tg.removeChild(lower_text_tg);
lower_text_shape3D = null;
lowertail_text_scale_tg.removeChild(lowertail_text_shape3D);
lowertail_text_tg.removeChild(lowertail_text_scale_tg);
track_feature_xpos_tg.removeChild(lowertail_text_tg);
lowertail_text_shape3D = null;
track_beginning_text_scale_tg.removeChild(track_beginning_text_shape3D);
track_beginning_text_tg.removeChild(track_beginning_text_scale_tg);
track_feature_xpos_tg.removeChild(track_beginning_text_tg);
track_beginning_text_shape3D = null;
track_end_text_scale_tg.removeChild(track_end_text_shape3D);
track_end_text_tg.removeChild(track_end_text_scale_tg);
track_feature_xpos_tg.removeChild(track_end_text_tg);
track_end_text_shape3D = null;
track_length_text_scale_tg.removeChild(track_beginning_text_shape3D);
track_length_text_tg.removeChild(track_beginning_text_scale_tg);
track_feature_xpos_tg.removeChild(track_length_text_tg);
track_length_text_shape3D = null;
Enumeration enum = FeatureTypeHash.elements();
while (enum.hasMoreElements()) {
FeatureList3D thisfeaturelist = (FeatureList3D) enum.nextElement();
String feature_name = thisfeaturelist.getFeatureName();
thisfeaturelist.kill();
FeatureTypeHash.remove(feature_name);
}
track = null;
track_tg.removeChild(track_text_xpos_tg);
track_tg.removeChild(track_feature_xpos_tg);
return track_tg;
}
public int getDistributionFeatureCount() {
return distributionFeatures.size();
}
public int getDistributionFeaturesYDirection() {
if (DistributionFeature3D.getStackInYDirection())
return distributionFeatures.size();
else
return (distributionFeatures.size() > 0 ? 1 : 0);
}
public Track getTrack() {
return track;
}
public void setShowCenterline(boolean b) {
_show_centerline = b;
}
public boolean getShowCenterline(boolean b) {
return _show_centerline;
}
}
package ca.bcgsc.sockeye.j3d;
import java.io.File;
import java.net.URL;
import java.util.Enumeration;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.Geometry;
import javax.media.j3d.GeometryArray;
import javax.media.j3d.Group;
import javax.media.j3d.Node;
import javax.media.j3d.Shape3D;
import javax.swing.JOptionPane;
import javax.vecmath.Vector3d;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.util.Log;
import com.sun.j3d.loaders.Scene;
import com.sun.j3d.loaders.vrml97.VrmlLoader;
import com.sun.j3d.utils.geometry.GeometryInfo;
import com.sun.j3d.utils.geometry.NormalGenerator;
import com.sun.j3d.utils.geometry.Stripifier;
class VRMLShapeLoader3D {
private Shape3D shape = null;
private Vector3d dims;
private Vector3d shape_transform;
private GeometryArray ga_with_normals;
private Shape3D second_shape = null;
public VRMLShapeLoader3D() {
}
public boolean loadShape(String relativeFilename) {
String filename = Configuration.USER_DIR + "/" + relativeFilename;
VrmlLoader loader = new VrmlLoader();
Scene scene = null;
File file = new File(filename);
if (!file.exists()) {
URL url =
VRMLShapeLoader3D.class.getClassLoader().getResource(
relativeFilename.replaceAll("\\\\", "/"));
if (url != null) {
try {
scene = loader.load(url);
} catch (Throwable e) {
Log.printStackTrace(e);
String message = filename + " does not exist.";
JOptionPane.showMessageDialog(
null,
message,
"VRML File Load Failed",
JOptionPane.ERROR_MESSAGE);
return false;
}
} else {
String message = filename + " does not exist.";
JOptionPane.showMessageDialog(
null,
message,
"VRML File Load Failed",
JOptionPane.ERROR_MESSAGE);
return false;
}
} else {
try {
scene = loader.load(filename);
} catch (Exception e) {
String message = "Unable to load " + filename;
JOptionPane.showMessageDialog(
null,
message,
"VRML File Load Failed",
JOptionPane.ERROR_MESSAGE);
Log.printStackTrace(e);
return false;
}
}
BranchGroup wrlBranch = scene.getSceneGroup();
if (scene != null) {
wrlBranch.setCapability(BranchGroup.ALLOW_CHILDREN_READ);
wrlBranch.setCapability(BranchGroup.ALLOW_CHILDREN_WRITE);
findShape(wrlBranch);
} else {
String message = "Unable to get scenegraph from " + filename;
JOptionPane.showMessageDialog(
null,
message,
"VRML File Load Failed",
JOptionPane.ERROR_MESSAGE);
return false;
}
if (shape != null) {
shape.setBoundsAutoCompute(true);
shape.setPickable(true);
shape.setCapability(Shape3D.ALLOW_APPEARANCE_WRITE);
shape.setCapability(Shape3D.ALLOW_APPEARANCE_READ);
shape.setCapability(Shape3D.ALLOW_PICKABLE_READ);
} else {
String message = "Unable to get shape from " + filename;
JOptionPane.showMessageDialog(
null,
message,
"VRML File Load Failed",
JOptionPane.ERROR_MESSAGE);
return false;
}
boolean isGeometryArray = calculateDimensions();
if (isGeometryArray) {
generateNormals();
return true;
} else {
String message = "Unable to get geometry array from " + filename;
JOptionPane.showMessageDialog(
null,
message,
"VRML File Load Failed",
JOptionPane.ERROR_MESSAGE);
return false;
}
}
public Geometry getGeometry() {
return ga_with_normals;
}
public Vector3d getDims() {
return dims;
}
public Vector3d getShapeTransform() {
return shape_transform;
}
private void findShape(Group g) {
Enumeration enumKids = g.getAllChildren();
Node thisnode;
while (enumKids.hasMoreElements() != false) {
thisnode = (Node) enumKids.nextElement();
if (thisnode instanceof Shape3D) {
if (shape == null)
shape = (Shape3D) thisnode;
break;
} else if (thisnode instanceof Group) {
findShape((Group) thisnode);
}
}
}
private boolean calculateDimensions() {
if (shape.getGeometry() instanceof GeometryArray) {
GeometryArray ga = (GeometryArray) shape.getGeometry();
ga.setCapability(GeometryArray.ALLOW_COORDINATE_READ);
int num_vertices = ga.getVertexCount();
int num_coords = 3 * num_vertices;
double[] coords = new double[num_coords];
ga.getCoordinates(0, coords);
double min_x;
double max_x;
double min_y;
double max_y;
double min_z;
double max_z;
int i = 0;
max_x = coords[i];
min_x = coords[i];
i++;
max_y = coords[i];
min_y = coords[i];
i++;
max_z = coords[i];
min_z = coords[i];
i++;
while (i < num_coords) {
if (coords[i] < min_x) {
min_x = coords[i];
}
if (coords[i] > max_x) {
max_x = coords[i];
}
i++;
if (coords[i] < min_y) {
min_y = coords[i];
}
if (coords[i] > max_y) {
max_y = coords[i];
}
i++;
if (coords[i] < min_z) {
min_z = coords[i];
}
if (coords[i] > max_z) {
max_z = coords[i];
}
i++;
}
double shape_x_length = max_x - min_x;
double shape_y_width = max_y - min_y;
double shape_z_thickness = max_z - min_z;
dims = new Vector3d(shape_x_length, shape_y_width, shape_z_thickness);
double shape_x_transform = -1d * (max_x + min_x) / 2;
double shape_y_transform = -1d * (max_y + min_y) / 2;
double shape_z_transform = -1d * (max_z + min_z) / 2;
shape_transform =
new Vector3d(shape_x_transform, shape_y_transform, shape_z_transform);
return true;
} else {
return false;
}
}
private void generateNormals() {
GeometryInfo gi = new GeometryInfo((GeometryArray) shape.getGeometry());
NormalGenerator ng = new NormalGenerator();
ng.generateNormals(gi);
Stripifier st = new Stripifier();
st.stripify(gi);
ga_with_normals = gi.getGeometryArray();
ga_with_normals.setCapability(GeometryArray.ALLOW_COORDINATE_READ);
}
}
package ca.bcgsc.sockeye.j3d;
import java.awt.Color;
import java.awt.GraphicsConfiguration;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.EventObject;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import javax.media.j3d.AmbientLight;
import javax.media.j3d.Appearance;
import javax.media.j3d.Background;
import javax.media.j3d.BoundingSphere;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.Canvas3D;
import javax.media.j3d.DirectionalLight;
import javax.media.j3d.GraphicsContext3D;
import javax.media.j3d.ImageComponent;
import javax.media.j3d.ImageComponent2D;
import javax.media.j3d.Raster;
import javax.media.j3d.TransformGroup;
import javax.media.j3d.View;
import javax.swing.JOptionPane;
import javax.vecmath.Color3f;
import javax.vecmath.Point3d;
import javax.vecmath.Point3f;
import ca.bcgsc.sockeye.datastorage.Track;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.gui.Sockeye;
import ca.bcgsc.sockeye.j3d.events.EventListener3D;
import ca.bcgsc.sockeye.j3d.events.Feature3DSelectedEvent;
import ca.bcgsc.sockeye.j3d.events.Track3DMouseDragged;
import ca.bcgsc.sockeye.j3d.events.Track3DSelectedEvent;
import ca.bcgsc.sockeye.j3d.events.UnselectAll3DEvent;
import ca.bcgsc.sockeye.j3d.events.UnselectAll3DTracks;
import ca.bcgsc.sockeye.util.Log;
import com.sun.image.codec.jpeg.JPEGCodec;
import com.sun.image.codec.jpeg.JPEGEncodeParam;
import com.sun.image.codec.jpeg.JPEGImageEncoder;
import com.sun.j3d.utils.universe.SimpleUniverse;
public final class Visualizer3D extends Canvas3D {
private BranchGroup _root;
private Platform3D _platform;
private BranchGroup _platform_bg;
private BranchGroup _background_bg = new BranchGroup();
private Color3f _background_color = new Color3f(0f, 0f, 0f);
private SimpleUniverse u;
private View view;
private boolean _writeJPEG = false;
private boolean _image_return_only = false;
Image _user_return_img;
private int _pic_width = 512;
private int _pic_height = 512;
private int _scale_w, _scale_h;
private File _output_file;
private TransformGroup viewplatformTG;
private BoundingSphere bounds = new BoundingSphere(new Point3d(), 1000);
private AmbientLight ambientlight = new AmbientLight();
private DirectionalLight directionallight_top = new DirectionalLight();
private MouseListener3D mouse_listener = null;
private List _registered_event_listeners = new ArrayList();
private List _event_queue = new ArrayList();
public Visualizer3D(GraphicsConfiguration gc) {
super(gc);
_platform = new Platform3D();
_platform_bg = _platform.getBranch();
ambientlight.setInfluencingBounds(bounds);
_platform_bg.addChild(ambientlight);
directionallight_top.setInfluencingBounds(bounds);
directionallight_top.setDirection(0f, 0f, -1f);
_platform_bg.addChild(directionallight_top);
Color3f bgColor = new Color3f(0.05f, 0.05f, 0.5f);
Background bgNode = new Background(_background_color);
bgNode.setApplicationBounds(bounds);
_background_bg.setCapability(BranchGroup.ALLOW_DETACH);
_background_bg.addChild(bgNode);
init();
eventDispatcher dispatcher = new eventDispatcher();
dispatcher.setDaemon(true);
dispatcher.start();
}
private void init() {
_root = new BranchGroup();
_root.setCapability(BranchGroup.ALLOW_CHILDREN_WRITE);
_root.setCapability(BranchGroup.ALLOW_CHILDREN_EXTEND);
_root.setCapability(BranchGroup.ALLOW_DETACH);
u = new SimpleUniverse(this);
viewplatformTG = u.getViewingPlatform().getViewPlatformTransform();
view = u.getViewer().getView();
view.setBackClipDistance(25);
view.setFrontClipDistance(0.05);
mouse_listener = new MouseListener3D(this, _root, viewplatformTG, view);
_root.addChild(_platform_bg);
u.addBranchGraph(_root);
CollisionDetectionBehavior3D.startUpMessageQueue();
}
public void platformRelRotateX(float deg) {
this.mouse_listener.manualRotateX(deg);
}
public void platformRelRotateZ(float deg) {
this.mouse_listener.manualRotateZ(deg);
}
public void platformRelMove(float x, float y) {
this.mouse_listener.manualMove(x, y);
}
public void platformRelZoom(float dist) {
this.mouse_listener.manualZoom(dist);
}
private synchronized void resetSimpleUniverse() {
_root.addChild(_platform_bg);
}
public synchronized final void addTracks(List track_object_col){
_root.removeChild(_platform_bg);
mouse_listener.unSelectAllFeatures();
for (Iterator it = track_object_col.iterator(); it.hasNext();){
Track track = (Track)it.next();
if (_platform.getTrack3D(track.getId()) != null) continue;
_platform.addTrack(track);
}
mouse_listener.cancelSelection();
_root.addChild(_platform_bg);
}
public synchronized final void addTrack(Track track) {
if (_platform.getTrack3D(track.getId()) != null) return;
_root.removeChild(_platform_bg);
mouse_listener.unSelectAllFeatures();
_platform.addTrack(track);
mouse_listener.cancelSelection();
_root.addChild(_platform_bg);
}
public synchronized final void addTrack(Track track, int index) {
if (_platform.getTrack3D(track.getId()) != null) return;
_root.removeChild(_platform_bg);
mouse_listener.unSelectAllFeatures();
_platform.addTrack(track, index);
_root.addChild(_platform_bg);
}
public synchronized int getFeatureCount() {
return _platform.getFeatureCount();
}
public synchronized final void replaceTrack(int track_id, Track track) {
_root.removeChild(_platform_bg);
mouse_listener.unSelectAllFeatures();
int index = _platform.getIndex(track_id);
_platform.removeTrack(track_id);
_platform.addTrack(track, index);
_root.addChild(_platform_bg);
highlightTrack(track_id);
if (track_id == track.getId() && mouse_listener.region_select.getTrackId() == track_id) {
mouse_listener.region_select.setAttribute("track_id", String.valueOf(track_id));
addFeature(mouse_listener.region_select);
}
}
public synchronized final void updateTrackReverse(int track_id) {
_platform.updateTrackReverse(track_id);
}
public synchronized final void updateAllTracks() {
_root.removeChild(_platform_bg);
_platform.resetPlatform();
_root.addChild(_platform_bg);
}
public synchronized void redrawDistributions() {
_root.removeChild(_platform_bg);
_platform.redrawAllDistributionFeatures();
_root.addChild(_platform_bg);
}
public synchronized void resetAllFeatures() {
_root.removeChild(_platform_bg);
_platform.resetAllFeatures();
_platform.resetPlatform();
_root.addChild(_platform_bg);
}
public synchronized void redrawAllFeatures() {
_root.removeChild(_platform_bg);
_platform.redrawAllFeatures();
_platform.resetPlatform();
_root.addChild(_platform_bg);
}
public synchronized final void updateRegionSelect(int start, int end) {
mouse_listener.updateRegionSelect(start, end);
}
public synchronized final void cancelRegionSelect() {
mouse_listener.cancelSelection();
}
public synchronized final void updateAlignmentSequenceHighlights(TrackFeature[] features) {
_root.removeChild(_platform_bg);
for (int index = 0; index < features.length; index++) {
int track_id = features[index].getTrackId();
if (features[index].getFeature().equals("alignment sequence highlight")
|| features[index].getFeature().equals(
"vertical alignment sequence highlight")) {
mouse_listener.unSelectFeature(
track_id,
features[index].getFeature(),
features[index].getAccessionID());
_platform.removeFeature(
track_id,
features[index].getFeature(),
features[index].getAccessionID());
_platform.addFeature(features[index]);
}
}
_root.addChild(_platform_bg);
}
public synchronized final void removeAlignmentSequenceHighlight(TrackFeature feature) {
if (feature.getFeature().equals("alignment sequence highlight")
|| feature.getFeature().equals("vertical alignment sequence highlight")) {
int track_id = feature.getTrackId();
removeFeature(track_id, feature.getFeature(), feature.getAccessionID());
}
}
public synchronized final void moveTrack(int track_id, int new_index) {
_root.removeChild(_platform_bg);
_platform.moveTrack(track_id, new_index);
_root.addChild(_platform_bg);
}
public final void printTrackDetails() {
_platform.printTrackDetails();
}
public synchronized final void highlightTranscript(
int track_id,
List accession_ids,
List utr5p,
List utr3p) {
_platform.highlightTranscript(track_id, accession_ids);
mouse_listener.cancelResetAppearance(track_id, accession_ids);
this.addFeatures(utr5p);
this.addFeatures(utr3p);
}
public synchronized final void unHighlightTranscript(
int track_id,
List accession_ids,
List utr5p,
List utr3p) {
_platform.unHighlightTranscript(track_id, accession_ids);
mouse_listener.cancelResetAppearance(track_id, accession_ids);
this.removeFeatures(utr5p);
this.removeFeatures(utr3p);
}
public synchronized final void removeTracks(Collection track_ids) {
for (Iterator i = track_ids.iterator(); i.hasNext();)
removeTrack(Integer.parseInt(i.next().toString()));
}
public synchronized final void removeTrack(int track_id) {
_root.removeChild(_platform_bg);
mouse_listener.unSelectAllFeatures();
_platform.removeTrack(track_id);
resetSimpleUniverse();
this.fireTrack3DSelectedEvent(track_id, false);
}
public synchronized final void removeAllTracks() {
_root.removeChild(_platform_bg);
mouse_listener.unSelectAllFeatures();
_platform.removeAllTracks();
resetSimpleUniverse();
}
public final void setAntiAliasing(boolean b) {
mouse_listener.setAntialiasing(b);
}
public final boolean getAntiAliasing() {
return mouse_listener.getAntialiasing();
}
public synchronized final void setShowCenterLine(boolean b) {
_root.removeChild(_platform_bg);
_platform.setShowCenterLine(b);
_root.addChild(_platform_bg);
}
public final void setText2DAttributes(
boolean show,
boolean billb,
boolean trunc) {
Feature3D.setShowText2D(show);
Feature3D.setBillboard(billb);
Feature3D.setTruncated(trunc);
}
public final void setShowText2D(boolean b) {
Feature3D.setShowText2D(b);
}
public boolean getShowtext2D() {
return Feature3D.getShowtext2D();
}
public void setBillboard(boolean b) {
Feature3D.setBillboard(b);
}
public boolean getBillboard() {
return Feature3D.getBillboard();
}
public void setTruncated(boolean b) {
Feature3D.setTruncated(b);
}
public boolean getTruncated() {
return Feature3D.getTruncated();
}
public final void highlightTrack(int track_id) {
_platform.highlightTracks(track_id);
fireUnselectAllTracksEvent();
fireTrack3DSelectedEvent(track_id, true);
}
public final void unHighlightTrack() {
_platform.unHighlightTrack();
this.fireUnselectAllTracksEvent();
}
public final void unHighlightTrack(int track_id) {
_platform.unHighlightTrack(track_id);
fireTrack3DSelectedEvent(track_id, false);
}
public final void highlightTracks(List track_names) {
_platform.highlightTracks(track_names);
}
public final void leftClickFeature(TrackFeature track_feature) {
mouse_listener.unSelectAllFeatures(track_feature);
}
public final void unSelectFeature(TrackFeature track_feature) {
mouse_listener.unSelectFeature(track_feature);
}
public final void rightClickFeature(TrackFeature track_feature) {
mouse_listener.unHighlightFeature();
mouse_listener.highlightFeature(track_feature);
}
public final void controlLeftClickFeature(TrackFeature track_feature) {
mouse_listener.selectFeature(track_feature);
}
public final void highlightMultipleFeatures(TrackFeature track_feature) {
mouse_listener.highlightMultipleFeatures(track_feature);
}
public synchronized final void addFeature(TrackFeature userdata) {
_root.removeChild(_platform_bg);
_platform.addFeature(userdata);
_root.addChild(_platform_bg);
}
public synchronized final void addFeatures(TrackFeature[] userdatas) {
if (userdatas != null && userdatas.length > 0) {
_root.removeChild(_platform_bg);
_platform.addFeatures(userdatas);
java.util.Date s = new java.util.Date();
long t1 = s.getTime();
CollisionDetectionBehavior3D.startUpMessageQueue();
_root.addChild(_platform_bg);
}
}
public synchronized final void addFeatures(List userdatas) {
if (userdatas != null && userdatas.size() > 0) {
_root.removeChild(_platform_bg);
_platform.addFeatures(userdatas);
java.util.Date s = new java.util.Date();
long t1 = s.getTime();
CollisionDetectionBehavior3D.startUpMessageQueue();
_root.addChild(_platform_bg);
}
}
public synchronized final void addFeatures(Map feature_map) {
if (feature_map == null || feature_map.size() == 0)
return;
_root.removeChild(_platform_bg);
for (Iterator it=feature_map.keySet().iterator(); it.hasNext(); ){
String name = it.next().toString();
List features = (List)feature_map.get(name);
_platform.addFeatures(name, features);
}
CollisionDetectionBehavior3D.startUpMessageQueue();
_root.addChild(_platform_bg);
}
public synchronized final void addFeatures(String name, List userdatas) {
if (userdatas != null && userdatas.size() > 0) {
_root.removeChild(_platform_bg);
_platform.addFeatures(name, userdatas);
java.util.Date s = new java.util.Date();
long t1 = s.getTime();
CollisionDetectionBehavior3D.startUpMessageQueue();
_root.addChild(_platform_bg);
}
}
public synchronized final void removeFeature(
int track_id,
String feature_name,
String accession_id) {
_root.removeChild(_platform_bg);
mouse_listener.unSelectFeature(track_id, feature_name, accession_id);
_platform.removeFeature(track_id, feature_name, accession_id);
_root.addChild(_platform_bg);
}
public synchronized final void removeSelection() {
mouse_listener.cancelSelection();
}
public synchronized final void removeFeatureName(
int track_id,
String feature_name) {
_root.removeChild(_platform_bg);
mouse_listener.unSelectAllFeatures();
_platform.removeFeatureName(track_id, feature_name);
resetSimpleUniverse();
}
public synchronized final void removeFeatureName(String feature_name) {
_root.removeChild(_platform_bg);
mouse_listener.unSelectAllFeatures();
_platform.removeFeatureName(feature_name);
resetSimpleUniverse();
}
public synchronized final void removeFeatureNames(List feature_names) {
_root.removeChild(_platform_bg);
mouse_listener.unSelectAllFeatures();
for (Iterator it = feature_names.iterator(); it.hasNext();)
_platform.removeFeatureName(it.next().toString());
resetSimpleUniverse();
}
public synchronized final void removeFeatures(List features) {
_root.removeChild(_platform_bg);
mouse_listener.unSelectAllFeatures();
for (int i = 0; i < features.size(); i++) {
TrackFeature tf = (TrackFeature) features.get(i);
_platform.removeFeature(
tf.getTrackId(),
tf.getFeature(),
tf.getAccessionID());
}
resetSimpleUniverse();
}
public synchronized final void removeFeatureNames(String[] feature_names) {
_root.removeChild(_platform_bg);
mouse_listener.unSelectAllFeatures();
int num_feature_names = feature_names.length;
for (int i = 0; i < num_feature_names; i++) {
_platform.removeFeatureName(feature_names[i]);
}
resetSimpleUniverse();
}
public synchronized final void removeAllFeatures() {
_root.removeChild(_platform_bg);
mouse_listener.unSelectAllFeatures();
_platform.removeAllFeatures();
resetSimpleUniverse();
}
protected final void setNormalAppearance(TrackFeature track_feature) {
_platform.setNormalAppearance(track_feature);
}
protected final void setAppearance(
TrackFeature track_feature,
Appearance appearance) {
_platform.setAppearance(track_feature, appearance);
}
protected final Track3D getTrack3D(int track_id) {
return _platform.getTrack3D(track_id);
}
public final float[] getViewValues() {
return mouse_listener.getViewValues();
}
public final void setViewValues(float[] view_values) {
mouse_listener.setViewValues(view_values);
}
public final void setViewValues(
float x_axis_angle,
float z_axis_angle,
float horiz_dist,
float vert_dist,
float zoom_dist) {
mouse_listener.setViewValues(
x_axis_angle,
z_axis_angle,
horiz_dist,
vert_dist,
zoom_dist);
}
public final double getXAxisAngle() {
return mouse_listener.getXAxisAngle();
}
public final double getZAxisAngle() {
return mouse_listener.getZAxisAngle();
}
public final void setXAxisAngle(int degrees) {
mouse_listener.setXAxisAngle(degrees);
}
public final void setZAxisAngle(int degrees) {
mouse_listener.setZAxisAngle(degrees);
}
public final void setXAxisRotationEnable(boolean b) {
mouse_listener.setXAxisRotationEnable(b);
}
public final void setZAxisRotationEnable(boolean b) {
mouse_listener.setZAxisRotationEnable(b);
}
public void postSwap() {
if (_writeJPEG) {
GraphicsContext3D ctx = getGraphicsContext3D();
Raster ras =
new Raster(
new Point3f(-1.0f, -1.0f, -1.0f),
Raster.RASTER_COLOR,
0,
0,
_pic_width,
_pic_height,
new ImageComponent2D(
ImageComponent.FORMAT_RGB,
new BufferedImage(
_pic_width,
_pic_height,
BufferedImage.TYPE_INT_RGB)),
null);
ctx.readRaster(ras);
BufferedImage img = ras.getImage().getImage();
if (_image_return_only) {
_user_return_img =
img.getScaledInstance(_scale_w, _scale_h, BufferedImage.SCALE_SMOOTH);
_image_return_only = false;
} else
try {
FileOutputStream out = new FileOutputStream(_output_file);
JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(out);
JPEGEncodeParam param = encoder.getDefaultJPEGEncodeParam(img);
param.setQuality(1f, false);
encoder.setJPEGEncodeParam(param);
encoder.encode(img);
_writeJPEG = false;
out.close();
String message =
"Canvas Exported to: " + this._output_file.toString();
JOptionPane.showMessageDialog(
Sockeye.__frame,
message,
"Save Successful",
JOptionPane.PLAIN_MESSAGE);
out = null;
encoder = null;
param = null;
} catch (IOException e) {
String message =
"Canvas Export to: "
+ this._output_file.toString()
+ "failed: I/O exception.";
JOptionPane.showMessageDialog(
getParent(),
message,
"Save Failed",
JOptionPane.ERROR_MESSAGE);
Log.println(message + ":\t" + e.toString());
}
ctx = null;
ras = null;
img = null;
}
super.postSwap();
}
public void captureCanvas(int width, int height, File output_file) {
_pic_width = width;
_pic_height = height;
this._output_file = output_file;
_writeJPEG = true;
this.repaint();
}
synchronized public Image captureCanvas(int w, int h) {
GraphicsContext3D ctx = getGraphicsContext3D();
int wo = this.getWidth();
int ho = this.getHeight();
Raster ras =
new Raster(
new Point3f(-1.0f, -1.0f, -1.0f),
Raster.RASTER_COLOR,
0,
0,
wo,
ho,
new ImageComponent2D(
ImageComponent.FORMAT_RGBA,
new BufferedImage(wo, ho, BufferedImage.TYPE_INT_ARGB)),
null);
ctx.readRaster(ras);
BufferedImage img = ras.getImage().getImage();
for (int y = 3; y < ho - 3; y++)
for (int x = 3; x < wo - 3; x++)
if ((img.getRGB(x, y) & 0x00ffffff) == 0)
img.setRGB(x, y, 0x00ffffff);
_user_return_img = img.getScaledInstance(w, h, BufferedImage.SCALE_SMOOTH);
return _user_return_img;
}
public void captureCanvas(File output_file) {
_pic_width = this.getWidth();
_pic_height = this.getHeight();
this._output_file = output_file;
_writeJPEG = true;
this.repaint();
}
public synchronized void unSelectAllFeatures() {
for (Iterator it = MouseListener3D.selected_shape_hash.values().iterator();
it.hasNext();
) {
TrackFeature track_feature = (TrackFeature) it.next();
this.setNormalAppearance(track_feature);
}
MouseListener3D.selected_shape_hash.clear();
}
public synchronized final void addEventListener(EventListener3D l) {
_registered_event_listeners.add(l);
}
public synchronized final void removeEventListener(EventListener3D l) {
_registered_event_listeners.remove(l);
}
protected synchronized final void fireFeatureSelectedEvent(
TrackFeature tf,
boolean b) {
Feature3DSelectedEvent se = new Feature3DSelectedEvent(this, tf, b);
_event_queue.add(se);
notifyAll();
}
protected synchronized final void fireTrack3DMouseDraggedEvent(
int t,
int s,
int e) {
Track3DMouseDragged md = new Track3DMouseDragged(this, t, s, e);
_event_queue.add(md);
notifyAll();
}
protected synchronized final void fireTrack3DSelectedEvent(
int track_id,
boolean b) {
Track3DSelectedEvent tse = new Track3DSelectedEvent(this, track_id, b);
_event_queue.add(tse);
notifyAll();
}
protected synchronized final void fireUnselectAllEvent() {
UnselectAll3DEvent se = new UnselectAll3DEvent(this);
_event_queue.add(se);
notifyAll();
}
protected synchronized void fireUnselectAllTracksEvent() {
UnselectAll3DTracks e = new UnselectAll3DTracks(this);
_event_queue.add(e);
notifyAll();
}
private final synchronized EventObject getEvent() {
while (_event_queue.isEmpty()) {
try {
wait();
} catch (InterruptedException e) {
};
}
return (EventObject) _event_queue.remove(0);
}
public void setTrackTextColor(Color txtColor) {
_platform.setTrackTextColor(txtColor);
}
public Color getTrackTextColor() {
return _platform.getTrackTextColor();
}
public Color getBackgroundColor() {
return _background_color.get();
}
public void setBackgroundColor(Color background) {
_background_color = new Color3f(background);
_root.removeChild(_background_bg);
_background_bg.removeAllChildren();
Background bgNode = new Background(_background_color);
bgNode.setApplicationBounds(bounds);
_background_bg.addChild(bgNode);
_root.addChild(_background_bg);
}
private class eventDispatcher extends Thread {
public void run() {
EventObject e;
while (true) {
while ((e = Visualizer3D.this.getEvent()) == null)
System.out.println("Event Dispatcher3D: No event?");
sendEvent(e);
}
}
synchronized final private void sendEvent(EventObject e) {
Iterator listeners = _registered_event_listeners.iterator();
while (listeners.hasNext()) {
if (e instanceof Feature3DSelectedEvent) {
((EventListener3D) listeners.next()).feature3DSelectedEventReceived(
(Feature3DSelectedEvent) e);
continue;
}
if (e instanceof UnselectAll3DEvent) {
((EventListener3D) listeners.next()).unselectAll3DEventReceived(
(UnselectAll3DEvent) e);
continue;
}
if (e instanceof Track3DMouseDragged) {
(
(EventListener3D) listeners
.next())
.Track3DMouseDraggedEventReceived(
(Track3DMouseDragged) e);
continue;
}
if (e instanceof Track3DSelectedEvent) {
((EventListener3D) listeners.next()).track3DSelectedEventReceived(
(Track3DSelectedEvent) e);
}
if (e instanceof UnselectAll3DTracks) {
(
(EventListener3D) listeners
.next())
.unselectAllTracks3DEventReceived(
(UnselectAll3DTracks) e);
}
}
}
}
}
package ca.bcgsc.sockeye.j3d.events;
public interface EventListener3D {
void feature3DSelectedEventReceived (Feature3DSelectedEvent e);
void unselectAll3DEventReceived (UnselectAll3DEvent e);
void track3DSelectedEventReceived (Track3DSelectedEvent e);
void Track3DMouseDraggedEventReceived (Track3DMouseDragged e);
void unselectAllTracks3DEventReceived (UnselectAll3DTracks e);
}
package ca.bcgsc.sockeye.j3d.events;
import java.util.EventObject;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
public class Feature3DSelectedEvent extends EventObject {
TrackFeature _tf;
boolean _vis;
public Feature3DSelectedEvent(Object source, TrackFeature tf, boolean v) {
super(source);
_tf = tf;
_vis = v;
}
public TrackFeature getTrackFeature(){
return _tf;
}
public boolean isSelected(){
return _vis;
}
}
package ca.bcgsc.sockeye.j3d.events;
import java.util.EventObject;
public class Track3DMouseDragged extends EventObject {
int _start;
int _end;
int _track;
public Track3DMouseDragged(Object source, int track, int start, int end) {
super(source);
_start = start;
_end = end;
_track = track;
}
public int getStart(){
return _start;
}
public int getEnd(){
return _end;
}
public int getTrackId(){
return _track;
}
}
package ca.bcgsc.sockeye.j3d.events;
import java.util.EventObject;
public class Track3DSelectedEvent extends EventObject {
private int _t_id;
boolean _selected;
public Track3DSelectedEvent(Object source, int t_id, boolean b) {
super(source);
_t_id = t_id;
_selected = b;
}
public int getTrackId(){
return _t_id;
}
public boolean isSelected(){
return _selected;
}
}
package ca.bcgsc.sockeye.j3d.events;
import java.util.EventObject;
public class UnselectAll3DEvent
extends EventObject {
public UnselectAll3DEvent(Object source) {
super(source);
}
}
package ca.bcgsc.sockeye.j3d.events;
import java.util.EventObject;
public class UnselectAll3DTracks extends EventObject {
public UnselectAll3DTracks(Object source) {
super(source);
}
}
package ca.bcgsc.sockeye.parser;
import java.io.File;
import java.util.List;
public abstract class AlignmentParser {
protected String _extension;
private int _offset_nt;
protected File _file;
public AlignmentParser(File file) {
this._file = file;
}
public abstract List getAlignmentResults() throws AlignmentFormatException;
public abstract int getAlignmentLength();
public String getExtension() {
return this._extension;
}
}
class AlignmentFormatException
extends Exception {
public AlignmentFormatException(String message) {
super(message);
}
}
package ca.bcgsc.sockeye.parser;
import java.io.*;
import java.util.*;
import java.util.List;
import org.biojava.bio.program.gff.*;
import ca.bcgsc.sockeye.config.*;
import ca.bcgsc.sockeye.datastorage.*;
public class BEDParser
extends Parser {
Hashtable _previously_loaded_features = new Hashtable();
HashSet _feature_names = new HashSet();
public BEDParser(File file) {
super(file);
_extension = "bed";
}
public int getMaxPosition(String dum, String feature_name) {
int max_position = Integer.MIN_VALUE;
Iterator i = this.getFeatures(feature_name).iterator();
while (i.hasNext()) {
TrackFeature tf = (TrackFeature) i.next();
if (tf.getEnd() > max_position) {
max_position = tf.getEnd();
}
if (tf.getStart() > max_position) {
max_position = tf.getStart();
}
}
return max_position;
}
public double getMaxScore(String dum) {
double max_score = Integer.MIN_VALUE;
Iterator i = this.getFeatureNames(dum).iterator();
while (i.hasNext()) {
String feature_name = (String) i.next();
double t_max = this.getMaxScore("", feature_name);
if (t_max > max_score) {
max_score = t_max;
}
}
return max_score;
}
public int getNumberOfRecordsForFeature(String feature_name) {
return this.getFeatures(feature_name).size();
}
public Set getFeatureNames(String dum) {
return getFeatureNames();
}
public Set getFeatureNames() {
if (_feature_names.isEmpty()) {
GFFEntrySet gff_entries = new GFFEntrySet();
GFFRecordFilter.AcceptAll accept_all = new GFFRecordFilter.AcceptAll();
GFFFilterer filterer = new GFFFilterer(gff_entries.getAddHandler(),
accept_all);
org.biojava.bio.program.gff.GFFParser parser = new org.biojava.bio.
program.gff.GFFParser();
try {
parser.parse(
new BufferedReader(new InputStreamReader(new FileInputStream(
_file))),
filterer
);
}
catch (Exception e) {
e.printStackTrace();
}
Iterator i = gff_entries.lineIterator();
while (i.hasNext()) {
Object rec = i.next();
if (rec instanceof SimpleGFFRecord) {
String feature_name = ( (SimpleGFFRecord) rec).getFeature();
_feature_names.add(feature_name);
}
}
}
return _feature_names;
}
public double getMinScore(String dum, String feature_name) {
double min_score = Double.MAX_VALUE;
Iterator i = this.getFeatures(feature_name).iterator();
while (i.hasNext()) {
TrackFeature tf = (TrackFeature) i.next();
if (tf.getScore() < min_score) {
min_score = tf.getScore();
}
}
return min_score;
}
public int getMinPosition(String dum) {
int min_position = Integer.MAX_VALUE;
Iterator i = this.getFeatureNames(dum).iterator();
while (i.hasNext()) {
String feature_name = (String) i.next();
int t_min = this.getMinPosition("", feature_name);
if (t_min < min_position) {
min_position = t_min;
}
}
return min_position;
}
public int getMinPosition(String dum, String feature_name) {
int min_position = Integer.MAX_VALUE;
Iterator i = this.getFeatures(feature_name).iterator();
while (i.hasNext()) {
TrackFeature tf = (TrackFeature) i.next();
if (tf.getStart() < min_position) {
min_position = tf.getStart();
}
if (tf.getEnd() < min_position) {
min_position = tf.getEnd();
}
}
return min_position;
}
public boolean validate() throws FormatException {
GFFEntrySet gff_entries = new GFFEntrySet();
GFFRecordFilter.AcceptAll accept_all = new GFFRecordFilter.AcceptAll();
GFFFilterer filterer = new GFFFilterer(gff_entries.getAddHandler(),
accept_all);
org.biojava.bio.program.gff.GFFParser parser = new org.biojava.bio.program.
gff.GFFParser();
try {
parser.parse(
new BufferedReader(new InputStreamReader(new FileInputStream(
_file))),
filterer
);
return true;
}
catch (Exception e) {
String message = new String(
"No data loaded due to parsing error at line " +
(gff_entries.size() + 1) +
" in selected file.");
throw new FormatException(message);
}
}
public double getMaxScore(String dum, String feature_name) {
double max_score = Double.MIN_VALUE;
Iterator i = this.getFeatures(feature_name).iterator();
while (i.hasNext()) {
TrackFeature tf = (TrackFeature) i.next();
if (tf.getScore() > max_score) {
max_score = tf.getScore();
}
}
return max_score;
}
public Set getKnownFeatureNames(Set feature_names) {
Set sockeye_feature_names = Configuration.getFeatureConfiguration();
Set known_feature_names = new HashSet();
Iterator i = feature_names.iterator();
while (i.hasNext()) {
String feature_name = (String) i.next();
if (sockeye_feature_names.contains(feature_name)) {
known_feature_names.add(feature_name);
}
}
return known_feature_names;
}
public double getMinScore(String dum) {
double min_score = Integer.MAX_VALUE;
Iterator i = this.getFeatureNames(dum).iterator();
while (i.hasNext()) {
String feature_name = (String) i.next();
double t_min = this.getMinScore("",feature_name);
if (t_min < min_score) {
min_score = t_min;
}
}
return min_score;
}
public int getMaxPosition(String dum) {
int max_position = Integer.MIN_VALUE;
Iterator i = this.getFeatureNames(dum).iterator();
while (i.hasNext()) {
String feature_name = (String) i.next();
int t_max = this.getMaxPosition("",feature_name);
if (t_max > max_position) {
max_position = t_max;
}
}
return max_position;
}
public int getTotalNumberOfRecords() {
int total_count = 0;
Iterator i = getFeatureNames("").iterator();
while (i.hasNext()) {
String feature_name = (String) i.next();
total_count += getNumberOfRecordsForFeature(feature_name);
}
return total_count;
}
public List getFeatures(String dum, String feature_name) {
return getFeatures(feature_name);
}
public List getFeatures(String feature_name) {
ArrayList features = new ArrayList();
if (this._previously_loaded_features.containsKey(feature_name)) {
features = (ArrayList)this._previously_loaded_features.get(feature_name);
}
else {
GFFEntrySet gff_entry = new GFFEntrySet();
GFFRecordFilter.FeatureFilter feature_filter =
new GFFRecordFilter.FeatureFilter();
feature_filter.setFeature(feature_name);
GFFFilterer filterer = new GFFFilterer(gff_entry.getAddHandler(),
feature_filter);
org.biojava.bio.program.gff.GFFParser parser = new org.biojava.bio.
program.
gff.GFFParser();
try {
parser.parse(
new BufferedReader(new InputStreamReader(new FileInputStream(
_file))),
filterer);
}
catch (Exception e) {
e.printStackTrace();
}
int count = 0;
Iterator i = gff_entry.lineIterator();
while (i.hasNext()) {
Object rec = i.next();
if (! ( (Object) rec instanceof String)) {
SimpleGFFRecord gff_rec = (SimpleGFFRecord) rec;
String feature_id = _file.getName() + "_" + gff_rec.getFeature() +
"_" + String.valueOf(count++);
TrackFeature track_gff = new TrackFeature(gff_rec);
features.add(track_gff);
}
}
this._previously_loaded_features.put(feature_name, features);
}
return features;
}
public void setFeatureNamesToImport(String seq_id, Set feature_names) {
}
public Set getFeatureNamesToImport(String seq_id) {
return null;
}
public List getDataSources() {
return null;
}
public boolean hasTrackFeature() {
return false;
}
public Set getSequenceNames() {
return null;
}
public String getDisplaySequenceName(String seq_id) {
return null;
}
}
package ca.bcgsc.sockeye.parser;
public class FeatureInfo {
private int max_position = Integer.MIN_VALUE;
private int min_position = Integer.MAX_VALUE;
private double max_score = 0.;
private double min_score = Double.MAX_VALUE;
public FeatureInfo(){
}
public void update(int start, int end, double score) {
min_position = Math.min(min_position, start);
max_position = Math.max(max_position, end);
min_score = Math.min(min_score, score);
max_score = Math.max(max_score, score);
}
public int getMaxPosition() {
return max_position;
}
public double getMaxScore() {
return max_score;
}
public int getMinPosition() {
return min_position;
}
public double getMinScore() {
return min_score;
}
}
package ca.bcgsc.sockeye.parser;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import org.biojava.bio.program.gff.GFFEntrySet;
import org.biojava.bio.program.gff.GFFFilterer;
import org.biojava.bio.program.gff.GFFRecordFilter;
import org.biojava.bio.program.gff.GFFTools;
import org.biojava.bio.program.gff.SimpleGFFRecord;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.util.Log;
public class GFFParser extends Parser {
private ArrayList _data_sources = new ArrayList();
private Map _features = new HashMap();
private Map _info = new HashMap();
private Map _feature_names_to_import = new HashMap();
private int _total_number_of_recoreds;
public GFFParser() {
super();
}
public GFFParser(File file) {
super(file);
_extension = "gff";
}
public int getNumberOfRecordsForFeature(String feature) {
int ret = 0;
for (Iterator seqit = _features.values().iterator(); seqit.hasNext();) {
Collection f = (Collection) ((Map) seqit.next()).get(feature);
if (f == null)
continue;
ret += f.size();
}
return ret;
}
public Set getFeatureNames() {
Set return_set = new TreeSet();
for (Iterator it = _features.values().iterator(); it.hasNext();) {
return_set.addAll(((Map) it.next()).keySet());
}
return return_set;
}
public Set getFeatureNames(String seq_id) {
return ((Map) _features.get(seq_id)).keySet();
}
public void setFeatureNamesToImport(String seq_id, Set feature_names) {
_feature_names_to_import.remove(seq_id);
_feature_names_to_import.put(seq_id, feature_names);
}
public Set getFeatureNamesToImport(String seq_id) {
return (Set)_feature_names_to_import.get(seq_id);
}
public int getMaxPosition(String seq_id) {
int max_position = Integer.MIN_VALUE;
Map temp = (Map) _info.get(seq_id);
for (Iterator it = temp.values().iterator(); it.hasNext();) {
int mp = ((FeatureInfo) it.next()).getMaxPosition();
if (max_position < mp)
max_position = mp;
}
return max_position;
}
public int getMaxPosition(String seq_id, String feature) {
return ((FeatureInfo) ((Map) _info.get(seq_id)).get(feature))
.getMaxPosition();
}
public int getMinPosition(String seq_id) {
int min_position = Integer.MAX_VALUE;
Map temp = (Map) _info.get(seq_id);
for (Iterator it = temp.values().iterator(); it.hasNext();) {
int mp = ((FeatureInfo) it.next()).getMinPosition();
if (min_position > mp)
min_position = mp;
}
return min_position;
}
public int getMinPosition(String seq_id, String feature) {
return ((FeatureInfo) ((Map) _info.get(seq_id)).get(feature))
.getMinPosition();
}
public double getMaxScore(String seq_id) {
double max_score = Double.MIN_VALUE;
Map temp = (Map) _info.get(seq_id);
for (Iterator it = temp.values().iterator(); it.hasNext();) {
double ms = ((FeatureInfo) it.next()).getMaxScore();
if (max_score < ms)
max_score = ms;
}
return max_score;
}
public double getMaxScore(String seq_id, String feature) {
return ((FeatureInfo) ((Map) _info.get(seq_id)).get(feature)).getMaxScore();
}
public double getMinScore(String seq_id) {
double min_score = Double.MAX_VALUE;
Map temp = (Map) _info.get(seq_id);
for (Iterator it = temp.values().iterator(); it.hasNext();) {
double ms = ((FeatureInfo) it.next()).getMinScore();
if (min_score > ms)
min_score = ms;
}
return min_score;
}
public double getMinScore(String seq_id, String feature) {
return ((FeatureInfo) ((Map) _info.get(seq_id)).get(feature)).getMinScore();
}
public Set getKnownFeatureNames(Set feature_names) {
Set sockeye_feature_names = Configuration.getFeatureConfiguration();
Set known_feature_names = new HashSet();
Iterator i = feature_names.iterator();
while (i.hasNext()) {
String feature_name = (String) i.next();
if (sockeye_feature_names.contains(feature_name)) {
known_feature_names.add(feature_name);
}
}
return known_feature_names;
}
public int getTotalNumberOfRecords() {
return this._total_number_of_recoreds;
}
public List getFeatures(String seq_id) {
List temp = new ArrayList();
for(Iterator it = ((Map)_features.get(seq_id)).values().iterator(); it.hasNext(); ) {
Collection f = ((Collection)it.next());
if (f == null)
continue;
temp.addAll(f);
}
return temp;
}
public List getFeatures(String seq_id, String feature) {
return (List) ((Map) _features.get(seq_id)).get(feature);
}
public List getDataSources() {
return _data_sources;
}
public boolean hasTrackFeature() {
return getFeatureNames().contains("track");
}
public String getDisplaySequenceName(String seq_id) {
return seq_id + "(" + getFileName() + ")";
}
public boolean validate() throws FormatException {
GFFEntrySet gff_entries = new GFFEntrySet();
GFFRecordFilter.AcceptAll accept_all = new GFFRecordFilter.AcceptAll();
GFFFilterer filterer =
new GFFFilterer(gff_entries.getAddHandler(), accept_all);
org.biojava.bio.program.gff.GFFParser parser =
new org.biojava.bio.program.gff.GFFParser();
try {
parser.parse(
new BufferedReader(new InputStreamReader(new FileInputStream(_file))),
filterer);
_total_number_of_recoreds = gff_entries.size();
if (_total_number_of_recoreds == 0) {
String message = "Selected file is empty.";
throw new FormatException(message);
}
Iterator i = gff_entries.lineIterator();
while (i.hasNext()) {
Object rec = i.next();
int m = 0;
if (rec instanceof SimpleGFFRecord) {
SimpleGFFRecord record = (SimpleGFFRecord) rec;
String seq_name = record.getSeqName();
String feature = record.getFeature();
if (_features.get(seq_name) == null) {
List temp = new ArrayList();
temp.add(new TrackFeature(record));
Map tempf = new HashMap();
tempf.put(feature, temp);
_features.put(seq_name, tempf);
} else {
Map tempf = (Map) _features.get(seq_name);
if (tempf.get(feature) == null) {
List temp = new ArrayList();
temp.add(new TrackFeature(record));
tempf.put(feature, temp);
} else {
((List) tempf.get(feature)).add(new TrackFeature(record));
}
}
int start = record.getStart();
int end = record.getEnd();
double score = 0.;
if( record.getScore() != GFFTools.NO_SCORE ){
score = record.getScore();
}
if (_info.get(seq_name) == null) {
FeatureInfo temp = new FeatureInfo();
temp.update(start, end, score);
Map tempf = new HashMap();
tempf.put(feature, temp);
_info.put(seq_name, tempf);
} else {
Map tempf = (Map) _info.get(seq_name);
if (tempf.get(feature) == null) {
FeatureInfo temp = new FeatureInfo();
temp.update(start, end, score);
tempf.put(feature, temp);
} else {
((FeatureInfo) ((Map) _info.get(seq_name)).get(feature)).update(
start,
end,
score);
}
}
} else if (rec instanceof String) {
String comment = rec.toString();
System.out.println(">>>>>>>>>>> " + comment);
if (comment.startsWith("#data_source")) {
_data_sources.add(comment.split(":")[1]);
}
System.out.println(">>> " + _data_sources);
}
}
return true;
} catch (Exception e) {
Log.printStackTrace(e);
String message =
new String(
"No data loaded due to parsing error at line "
+ (gff_entries.size() + 1)
+ " in selected file.");
throw new FormatException(message);
}
}
public Set getSequenceNames() {
return _features.keySet();
}
}
package ca.bcgsc.sockeye.parser;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.util.ArrayList;
import java.util.List;
import org.biojava.bio.program.gff.GFFTools;
import org.biojava.bio.seq.Sequence;
import org.biojava.bio.seq.SequenceIterator;
import org.biojava.bio.seq.db.SequenceDB;
import org.biojava.bio.seq.io.SeqIOTools;
import org.biojava.bio.symbol.Alphabet;
import org.biojava.bio.symbol.AlphabetManager;
import ca.bcgsc.chinook.server.comobj.GapMarker;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
public class MFastaParser
extends AlignmentParser {
int length = 0;
public MFastaParser(File f) {
super(f);
}
public List getAlignmentResults() throws AlignmentFormatException {
try {
List ret_list = new ArrayList();
BufferedInputStream is = new BufferedInputStream(new FileInputStream(
_file));
Alphabet alpha = AlphabetManager.alphabetForName("DNA");
SequenceDB db = SeqIOTools.readFasta(is, alpha);
SequenceIterator si = db.sequenceIterator();
while (si.hasNext()) {
Sequence seq = si.nextSequence();
String seqstr = seq.seqString();
ArrayList aa = new ArrayList();
for (int i = 0; i < seqstr.length(); i++) {
int indexer = seqstr.indexOf("-", i);
if (indexer == -1) {
break;
}
int lengther = indexer;
for (int j = indexer; j < seqstr.length(); j++) {
int j_indexer = seqstr.indexOf("-", j);
if (j_indexer != j) {
lengther = j;
break;
}
if (j_indexer == (seqstr.length() - 1)) {
lengther = j + 1;
break;
}
}
length = seqstr.length();
GapMarker agm = new GapMarker();
agm.start = indexer + 1;
agm.end = lengther;
agm.name = seq.getName();
TrackFeature tf = createGapFeature("gap" + aa.size(), agm);
aa.add(tf);
i = lengther;
}
ret_list.add(aa);
}
return ret_list;
}
catch (Exception e) {
e.printStackTrace();
throw new AlignmentFormatException(e.getMessage());
}
}
public int getAlignmentLength() {
return length;
}
private TrackFeature createGapFeature(String accession_id, GapMarker gm) {
TrackFeature gap = new TrackFeature(accession_id, "EnsEMBL",
"gap",
gm.start, gm.end, GFFTools.NO_SCORE,
0, GFFTools.NO_FRAME);
gap.setAccessionID(accession_id);
return gap;
}
}
package ca.bcgsc.sockeye.parser;
import java.io.File;
import java.util.Set;
import java.util.List;
public abstract class Parser {
protected String _extension;
private int _offset_nt;
protected String file_path;
transient protected File _file;
public Parser() {
}
public Parser(File file) {
this._file = file;
this.file_path = file.getPath();
}
public abstract int getTotalNumberOfRecords();
public abstract int getMaxPosition(String seq_id);
public abstract int getMaxPosition(String seq_id, String feature);
public abstract int getMinPosition(String seq_id);
public abstract int getMinPosition(String seq_id, String feature);
public abstract double getMaxScore(String seq_id);
public abstract double getMaxScore(String seq_id, String feature);
public abstract double getMinScore(String seq_id);
public abstract double getMinScore(String seq_id, String feature);
public abstract Set getFeatureNames();
public abstract Set getFeatureNames(String seq_id);
public abstract Set getKnownFeatureNames(Set feature_names);
public String getExtension() { return this._extension; }
public abstract int getNumberOfRecordsForFeature(String feature_name);
public int getFeatureOffset() { return this._offset_nt; }
public void setFeatureOffset(int offset_nt) { this._offset_nt = offset_nt; }
public abstract List getFeatures(String seq_id);
public abstract List getFeatures(String seq_id, String feature_name);
public abstract boolean validate() throws FormatException;
public abstract void setFeatureNamesToImport(String seq_id, Set feature_names);
public abstract Set getFeatureNamesToImport(String seq_id);
public abstract List getDataSources();
public abstract boolean hasTrackFeature();
public abstract Set getSequenceNames() ;
public abstract String getDisplaySequenceName(String seq_id);
public String getFileName(){
if(_file == null)
_file = new File(file_path);
return _file.getName();
}
public String getFilePath(){
return file_path;
}
}
class FormatException
extends Exception {
public FormatException(String message) {
super(message);
}
}
package ca.bcgsc.sockeye.parser;
import java.util.*;
public class ParserManager {
private static Hashtable _available_annotation_parsers;
private static Hashtable _available_alignment_parsers;
public static void initialize() {
_available_annotation_parsers = new Hashtable();
_available_alignment_parsers = new Hashtable();
registerAlignmentParser("ca.bcgsc.sockeye.parser.MFastaParser", "mfa");
registerAnnotationParser("ca.bcgsc.sockeye.parser.TFFINDParser", "tff");
registerAnnotationParser("ca.bcgsc.sockeye.parser.GFFParser", "gff");
}
public static void registerAnnotationParser(String class_name,
String extension) {
_available_annotation_parsers.put(extension.toLowerCase(), class_name);
}
public static void registerAlignmentParser(String class_name,
String extension) {
_available_alignment_parsers.put(extension.toLowerCase(), class_name);
}
public static String getClassNameForAnnotationExtension(String extension) {
String class_name = (String) _available_annotation_parsers.get(extension.
toLowerCase());
return class_name;
}
public static String getClassNameForAlignmentExtension(String extension) {
String class_name = (String) _available_alignment_parsers.get(extension.
toLowerCase());
return class_name;
}
}
package ca.bcgsc.sockeye.parser;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.StringTokenizer;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Set;
import java.util.List;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.util.Log;
public class TFFINDParser extends Parser {
final static String _FWD_FEATURE_NAME = "PWM_score_fwd";
final static String _REV_FEATURE_NAME = "PWM_score_rev";
Hashtable _previously_loaded_features = new Hashtable();
HashSet _feature_names = new HashSet();
public TFFINDParser(File file) {
super(file);
_extension = "tff";
}
public int getMaxPosition(String dum, String feature_name) {
int max_position = Integer.MIN_VALUE;
Iterator i = this.getFeatures(feature_name).iterator();
while (i.hasNext()) {
TrackFeature tf = (TrackFeature) i.next();
if (tf.getEnd() > max_position) {
max_position = tf.getEnd();
}
if (tf.getStart() > max_position) {
max_position = tf.getStart();
}
}
return max_position;
}
public double getMaxScore(String dum) {
double max_score = Integer.MIN_VALUE;
Iterator i = this.getFeatureNames(dum).iterator();
while (i.hasNext()) {
String feature_name = (String) i.next();
double t_max = this.getMaxScore("", feature_name);
if (t_max > max_score) {
max_score = t_max;
}
}
return max_score;
}
public int getNumberOfRecordsForFeature(String feature_name) {
return this.getFeatures(feature_name).size();
}
public Set getFeatureNames(String dum) {
return getFeatureNames();
}
public Set getFeatureNames() {
if (_feature_names.isEmpty()) {
_feature_names.add(_FWD_FEATURE_NAME);
_feature_names.add(_REV_FEATURE_NAME);
}
return _feature_names;
}
public double getMinScore(String dum, String feature_name) {
double min_score = Double.MAX_VALUE;
Iterator i = this.getFeatures(feature_name).iterator();
while (i.hasNext()) {
TrackFeature tf = (TrackFeature) i.next();
if (tf.getScore() < min_score) {
min_score = tf.getScore();
}
}
return min_score;
}
public int getMinPosition(String dum) {
int min_position = Integer.MAX_VALUE;
Iterator i = this.getFeatureNames(dum).iterator();
while (i.hasNext()) {
String feature_name = (String) i.next();
if (feature_name.equals("track")) {
List track = getFeatures("track");
if (track.size() > 1) {
return ((TrackFeature) track.get(0)).getStart();
}
}
int t_min = this.getMinPosition("", feature_name);
if (t_min < min_position) {
min_position = t_min;
}
}
return min_position;
}
public int getMinPosition(String dum, String feature_name) {
int min_position = Integer.MAX_VALUE;
Iterator i = this.getFeatures(feature_name).iterator();
while (i.hasNext()) {
TrackFeature tf = (TrackFeature) i.next();
if (tf.getStart() < min_position) {
min_position = tf.getStart();
}
if (tf.getEnd() < min_position) {
min_position = tf.getEnd();
}
}
return min_position;
}
public boolean validate() throws FormatException {
boolean in_footer = false, data_found = false;
try {
BufferedReader in =
new BufferedReader(new InputStreamReader(new FileInputStream(_file)));
String inLine, seq_str, start_str, end_str;
HashMap sequences = new HashMap();
ArrayList feature_strings = new ArrayList();
while (in.ready()) {
inLine = in.readLine();
if (!in_footer) {
if (inLine.equals("Sequence key:")) {
in_footer = true;
in.readLine();
continue;
}
StringTokenizer tok = new StringTokenizer(inLine);
if (tok.countTokens() != 6) {
continue;
}
seq_str = tok.nextToken();
start_str = tok.nextToken();
end_str = tok.nextToken();
try {
int test = Integer.parseInt(seq_str);
test = Integer.parseInt(start_str);
test = Integer.parseInt(end_str);
} catch (NumberFormatException f) {
continue;
}
data_found = true;
in_footer = true;
} else {
if (inLine.length() > 7 && inLine.charAt(7) == '.') {
in_footer = false;
break;
}
}
}
in.close();
} catch (Exception e) {
throw new FormatException(e.getMessage());
}
if (!data_found || in_footer) {
throw new FormatException("File contains no data.");
}
return true;
}
public double getMaxScore(String dum, String feature_name) {
double max_score = Double.MIN_VALUE;
Iterator i = this.getFeatures(feature_name).iterator();
while (i.hasNext()) {
TrackFeature tf = (TrackFeature) i.next();
if (tf.getScore() > max_score) {
max_score = tf.getScore();
}
}
return max_score;
}
public Set getKnownFeatureNames(Set feature_names) {
Set sockeye_feature_names = Configuration.getFeatureConfiguration();
Set known_feature_names = new HashSet();
Iterator i = feature_names.iterator();
while (i.hasNext()) {
String feature_name = (String) i.next();
if (sockeye_feature_names.contains(feature_name)) {
known_feature_names.add(feature_name);
}
}
return known_feature_names;
}
public double getMinScore(String dum) {
double min_score = Integer.MAX_VALUE;
Iterator i = this.getFeatureNames(dum).iterator();
while (i.hasNext()) {
String feature_name = (String) i.next();
double t_min = this.getMinScore("", feature_name);
if (t_min < min_score) {
min_score = t_min;
}
}
return min_score;
}
public int getMaxPosition(String dum) {
int max_position = Integer.MIN_VALUE;
Iterator i = this.getFeatureNames(dum).iterator();
while (i.hasNext()) {
String feature_name = (String) i.next();
if (feature_name.equals("track")) {
List track = getFeatures("track");
if (track.size() > 1) {
return ((TrackFeature) track.get(0)).getEnd();
}
}
int t_max = this.getMaxPosition("", feature_name);
if (t_max > max_position) {
max_position = t_max;
}
}
return max_position;
}
public int getTotalNumberOfRecords() {
int total_count = 0;
Iterator i = getFeatureNames("").iterator();
while (i.hasNext()) {
String feature_name = (String) i.next();
total_count += getNumberOfRecordsForFeature(feature_name);
}
return total_count;
}
public List getFeatures(String dum, String feature_name) {
return getFeatures(feature_name);
}
public List getFeatures(String feature_name) {
ArrayList features = new ArrayList();
if (this._previously_loaded_features.containsKey(feature_name)) {
features = (ArrayList) this._previously_loaded_features.get(feature_name);
} else {
try {
BufferedReader in =
new BufferedReader(new InputStreamReader(new FileInputStream(_file)));
String inLine,
seq_str,
start_str,
end_str,
strand_str,
score_str,
pattern;
boolean in_footer = false;
HashMap sequences = new HashMap();
ArrayList feature_strings = new ArrayList();
while (in.ready()) {
inLine = in.readLine();
if (!in_footer) {
if (inLine.equals("Sequence key:")) {
in_footer = true;
in.readLine();
continue;
}
StringTokenizer tok = new StringTokenizer(inLine);
if (tok.countTokens() != 6) {
continue;
}
seq_str = tok.nextToken();
start_str = tok.nextToken();
end_str = tok.nextToken();
try {
int test = Integer.parseInt(seq_str);
test = Integer.parseInt(start_str);
test = Integer.parseInt(end_str);
} catch (NumberFormatException f) {
continue;
}
feature_strings.add(inLine);
} else {
if (inLine.indexOf(">region:") > -1) {
String[] str = inLine.trim().split(">region: ");
sequences.put(str[0].substring(0, str[0].indexOf(".")), str[1]);
} else if (inLine.length() > 7 && inLine.charAt(7) == '.') {
inLine = inLine.trim();
String seq = inLine.substring(0, inLine.indexOf("."));
String name = inLine.substring(8);
sequences.put(seq, name);
}
}
}
in.close();
int start, end;
float score;
for (Iterator itr = feature_strings.iterator(); itr.hasNext();) {
inLine = (String) itr.next();
StringTokenizer tok = new StringTokenizer(inLine);
seq_str = tok.nextToken();
start_str = tok.nextToken();
end_str = tok.nextToken();
strand_str = tok.nextToken();
score_str = tok.nextToken();
pattern = tok.nextToken();
String seq_name = (String) sequences.get(seq_str);
start = Integer.parseInt(start_str);
end = Integer.parseInt(end_str);
int strand_val = strand_str.equals("-") ? -1 : 1;
score = Float.parseFloat(score_str);
String featurename =
strand_val == 1 ? _FWD_FEATURE_NAME : _REV_FEATURE_NAME;
TrackFeature newHit =
new TrackFeature(
seq_name,
_file.getName(),
featurename,
start,
end,
score,
strand_val,
0);
newHit.setAttribute("Pattern", pattern);
ArrayList tempList = new ArrayList();
tempList.add(score + "");
newHit.setAttribute("unnormalized_score", tempList);
features.add(newHit);
}
} catch (Exception e) {
Log.printStackTrace(e);
e.printStackTrace();
return null;
}
this._previously_loaded_features.put(feature_name, features);
}
return features;
}
public void setFeatureNamesToImport(String seq_id, Set feature_names) {
}
public Set getFeatureNamesToImport(String seq_id) {
return null;
}
public List getDataSources() {
return null;
}
public boolean hasTrackFeature() {
return false;
}
public Set getSequenceNames() {
return null;
}
public String getDisplaySequenceName(String seq_id) {
return seq_id + "(" + getFileName() + ")";
}
}
package ca.bcgsc.sockeye.popup;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import ca.bcgsc.sockeye.config.Configuration;
public class BrowserLauncher {
private static int jvm;
private static Object browser;
private static boolean loadedWithoutErrors;
private static Class mrjFileUtilsClass;
private static Class mrjOSTypeClass;
private static Class aeDescClass;
private static Constructor aeTargetConstructor;
private static Constructor appleEventConstructor;
private static Constructor aeDescConstructor;
private static Method findFolder;
private static Method getFileCreator;
private static Method getFileType;
private static Method openURL;
private static Method makeOSType;
private static Method putParameter;
private static Method sendNoReply;
private static Object kSystemFolderType;
private static Integer keyDirectObject;
private static Integer kAutoGenerateReturnID;
private static Integer kAnyTransactionID;
private static Object linkage;
private static final String JDirect_MacOSX = "/System/Library/Frameworks/Carbon.framework/Frameworks/HIToolbox.framework/HIToolbox";
private static final int MRJ_2_0 = 0;
private static final int MRJ_2_1 = 1;
private static final int MRJ_3_0 = 3;
private static final int MRJ_3_1 = 4;
private static final int WINDOWS_NT = 5;
private static final int WINDOWS_9x = 6;
private static final int OTHER = -1;
private static final String FINDER_TYPE = "FNDR";
private static final String FINDER_CREATOR = "MACS";
private static final String GURL_EVENT = "GURL";
private static final String FIRST_WINDOWS_PARAMETER = "/c";
private static final String SECOND_WINDOWS_PARAMETER = "start";
private static final String THIRD_WINDOWS_PARAMETER = "\"\"";
private static final String NETSCAPE_REMOTE_PARAMETER = "-remote";
private static final String NETSCAPE_OPEN_PARAMETER_START = "'openURL(";
private static final String NETSCAPE_OPEN_PARAMETER_END = ")'";
private static String errorMessage;
static {
loadedWithoutErrors = true;
String osName = System.getProperty("os.name");
if (osName.startsWith("Mac OS")) {
String mrjVersion = System.getProperty("mrj.version");
String majorMRJVersion = null;
if (mrjVersion.length() < 3) {
majorMRJVersion = mrjVersion;
} else {
majorMRJVersion = mrjVersion.substring(0, 3);
}
try {
double version = Double.valueOf(majorMRJVersion).doubleValue();
if (version == 2) {
jvm = MRJ_2_0;
} else if (version >= 2.1 && version < 3) {
jvm = MRJ_2_1;
} else if (version == 3.0) {
jvm = MRJ_3_0;
} else if (version >= 3.1) {
jvm = MRJ_3_1;
} else {
loadedWithoutErrors = false;
errorMessage = "Unsupported MRJ version: " + version;
}
} catch (NumberFormatException nfe) {
loadedWithoutErrors = false;
errorMessage = "Invalid MRJ version: " + mrjVersion;
}
} else if (osName.startsWith("Windows")) {
if (osName.indexOf("9") != -1) {
jvm = WINDOWS_9x;
} else {
jvm = WINDOWS_NT;
}
} else {
jvm = OTHER;
}
if (loadedWithoutErrors) {
loadedWithoutErrors = loadClasses();
}
}
private BrowserLauncher() { }
private static boolean loadClasses() {
switch (jvm) {
case MRJ_2_0:
try {
Class aeTargetClass = Class.forName("com.apple.MacOS.AETarget");
Class osUtilsClass = Class.forName("com.apple.MacOS.OSUtils");
Class appleEventClass = Class.forName("com.apple.MacOS.AppleEvent");
Class aeClass = Class.forName("com.apple.MacOS.ae");
aeDescClass = Class.forName("com.apple.MacOS.AEDesc");
aeTargetConstructor = aeTargetClass.getDeclaredConstructor(new Class [] { int.class });
appleEventConstructor = appleEventClass.getDeclaredConstructor(new Class[] { int.class, int.class, aeTargetClass, int.class, int.class });
aeDescConstructor = aeDescClass.getDeclaredConstructor(new Class[] { String.class });
makeOSType = osUtilsClass.getDeclaredMethod("makeOSType", new Class [] { String.class });
putParameter = appleEventClass.getDeclaredMethod("putParameter", new Class[] { int.class, aeDescClass });
sendNoReply = appleEventClass.getDeclaredMethod("sendNoReply", new Class[] { });
Field keyDirectObjectField = aeClass.getDeclaredField("keyDirectObject");
keyDirectObject = (Integer) keyDirectObjectField.get(null);
Field autoGenerateReturnIDField = appleEventClass.getDeclaredField("kAutoGenerateReturnID");
kAutoGenerateReturnID = (Integer) autoGenerateReturnIDField.get(null);
Field anyTransactionIDField = appleEventClass.getDeclaredField("kAnyTransactionID");
kAnyTransactionID = (Integer) anyTransactionIDField.get(null);
} catch (ClassNotFoundException cnfe) {
errorMessage = cnfe.getMessage();
return false;
} catch (NoSuchMethodException nsme) {
errorMessage = nsme.getMessage();
return false;
} catch (NoSuchFieldException nsfe) {
errorMessage = nsfe.getMessage();
return false;
} catch (IllegalAccessException iae) {
errorMessage = iae.getMessage();
return false;
}
break;
case MRJ_2_1:
try {
mrjFileUtilsClass = Class.forName("com.apple.mrj.MRJFileUtils");
mrjOSTypeClass = Class.forName("com.apple.mrj.MRJOSType");
Field systemFolderField = mrjFileUtilsClass.getDeclaredField("kSystemFolderType");
kSystemFolderType = systemFolderField.get(null);
findFolder = mrjFileUtilsClass.getDeclaredMethod("findFolder", new Class[] { mrjOSTypeClass });
getFileCreator = mrjFileUtilsClass.getDeclaredMethod("getFileCreator", new Class[] { File.class });
getFileType = mrjFileUtilsClass.getDeclaredMethod("getFileType", new Class[] { File.class });
} catch (ClassNotFoundException cnfe) {
errorMessage = cnfe.getMessage();
return false;
} catch (NoSuchFieldException nsfe) {
errorMessage = nsfe.getMessage();
return false;
} catch (NoSuchMethodException nsme) {
errorMessage = nsme.getMessage();
return false;
} catch (SecurityException se) {
errorMessage = se.getMessage();
return false;
} catch (IllegalAccessException iae) {
errorMessage = iae.getMessage();
return false;
}
break;
case MRJ_3_0:
try {
Class linker = Class.forName("com.apple.mrj.jdirect.Linker");
Constructor constructor = linker.getConstructor(new Class[]{ Class.class });
linkage = constructor.newInstance(new Object[] { BrowserLauncher.class });
} catch (ClassNotFoundException cnfe) {
errorMessage = cnfe.getMessage();
return false;
} catch (NoSuchMethodException nsme) {
errorMessage = nsme.getMessage();
return false;
} catch (InvocationTargetException ite) {
errorMessage = ite.getMessage();
return false;
} catch (InstantiationException ie) {
errorMessage = ie.getMessage();
return false;
} catch (IllegalAccessException iae) {
errorMessage = iae.getMessage();
return false;
}
break;
case MRJ_3_1:
try {
mrjFileUtilsClass = Class.forName("com.apple.mrj.MRJFileUtils");
openURL = mrjFileUtilsClass.getDeclaredMethod("openURL", new Class[] { String.class });
} catch (ClassNotFoundException cnfe) {
errorMessage = cnfe.getMessage();
return false;
} catch (NoSuchMethodException nsme) {
errorMessage = nsme.getMessage();
return false;
}
break;
default:
break;
}
return true;
}
private static Object locateBrowser() {
if (browser != null) {
return browser;
}
switch (jvm) {
case MRJ_2_0:
try {
Integer finderCreatorCode = (Integer) makeOSType.invoke(null, new Object[] { FINDER_CREATOR });
Object aeTarget = aeTargetConstructor.newInstance(new Object[] { finderCreatorCode });
Integer gurlType = (Integer) makeOSType.invoke(null, new Object[] { GURL_EVENT });
Object appleEvent = appleEventConstructor.newInstance(new Object[] { gurlType, gurlType, aeTarget, kAutoGenerateReturnID, kAnyTransactionID });
return appleEvent;
} catch (IllegalAccessException iae) {
browser = null;
errorMessage = iae.getMessage();
return browser;
} catch (InstantiationException ie) {
browser = null;
errorMessage = ie.getMessage();
return browser;
} catch (InvocationTargetException ite) {
browser = null;
errorMessage = ite.getMessage();
return browser;
}
case MRJ_2_1:
File systemFolder;
try {
systemFolder = (File) findFolder.invoke(null, new Object[] { kSystemFolderType });
} catch (IllegalArgumentException iare) {
browser = null;
errorMessage = iare.getMessage();
return browser;
} catch (IllegalAccessException iae) {
browser = null;
errorMessage = iae.getMessage();
return browser;
} catch (InvocationTargetException ite) {
browser = null;
errorMessage = ite.getTargetException().getClass() + ": " + ite.getTargetException().getMessage();
return browser;
}
String[] systemFolderFiles = systemFolder.list();
for(int i = 0; i < systemFolderFiles.length; i++) {
try {
File file = new File(systemFolder, systemFolderFiles[i]);
if (!file.isFile()) {
continue;
}
Object fileType = getFileType.invoke(null, new Object[] { file });
if (FINDER_TYPE.equals(fileType.toString())) {
Object fileCreator = getFileCreator.invoke(null, new Object[] { file });
if (FINDER_CREATOR.equals(fileCreator.toString())) {
browser = file.toString();
return browser;
}
}
} catch (IllegalArgumentException iare) {
errorMessage = iare.getMessage();
return null;
} catch (IllegalAccessException iae) {
browser = null;
errorMessage = iae.getMessage();
return browser;
} catch (InvocationTargetException ite) {
browser = null;
errorMessage = ite.getTargetException().getClass() + ": " + ite.getTargetException().getMessage();
return browser;
}
}
browser = null;
break;
case MRJ_3_0:
case MRJ_3_1:
browser = "";
break;
case WINDOWS_NT:
browser = "cmd.exe";
break;
case WINDOWS_9x:
browser = "command.com";
break;
case OTHER:
default:
browser = Configuration.getBrowser();
break;
}
return browser;
}
public static void openURL(String url) throws IOException {
if (!loadedWithoutErrors) {
throw new IOException("Exception in finding browser: " + errorMessage);
}
Object browser = locateBrowser();
if (browser == null) {
throw new IOException("Unable to locate browser: " + errorMessage);
}
switch (jvm) {
case MRJ_2_0:
Object aeDesc = null;
try {
aeDesc = aeDescConstructor.newInstance(new Object[] { url });
putParameter.invoke(browser, new Object[] { keyDirectObject, aeDesc });
sendNoReply.invoke(browser, new Object[] { });
} catch (InvocationTargetException ite) {
throw new IOException("InvocationTargetException while creating AEDesc: " + ite.getMessage());
} catch (IllegalAccessException iae) {
throw new IOException("IllegalAccessException while building AppleEvent: " + iae.getMessage());
} catch (InstantiationException ie) {
throw new IOException("InstantiationException while creating AEDesc: " + ie.getMessage());
} finally {
aeDesc = null;
browser = null;
}
break;
case MRJ_2_1:
Runtime.getRuntime().exec(new String[] { (String) browser, url } );
break;
case MRJ_3_0:
int[] instance = new int[1];
int result = ICStart(instance, 0);
if (result == 0) {
int[] selectionStart = new int[] { 0 };
byte[] urlBytes = url.getBytes();
int[] selectionEnd = new int[] { urlBytes.length };
result = ICLaunchURL(instance[0], new byte[] { 0 }, urlBytes,
urlBytes.length, selectionStart,
selectionEnd);
if (result == 0) {
ICStop(instance);
} else {
throw new IOException("Unable to launch URL: " + result);
}
} else {
throw new IOException("Unable to create an Internet Config instance: " + result);
}
break;
case MRJ_3_1:
try {
openURL.invoke(null, new Object[] { url });
} catch (InvocationTargetException ite) {
throw new IOException("InvocationTargetException while calling openURL: " + ite.getMessage());
} catch (IllegalAccessException iae) {
throw new IOException("IllegalAccessException while calling openURL: " + iae.getMessage());
}
break;
case WINDOWS_NT:
case WINDOWS_9x:
Process process = Runtime.getRuntime().exec(new String[] { (String) browser,
FIRST_WINDOWS_PARAMETER,
SECOND_WINDOWS_PARAMETER,
THIRD_WINDOWS_PARAMETER,
'"' + url + '"' });
try {
process.waitFor();
process.exitValue();
} catch (InterruptedException ie) {
throw new IOException("InterruptedException while launching browser: " + ie.getMessage());
}
break;
case OTHER:
process = Runtime.getRuntime().exec(new String[] { (String) browser,
NETSCAPE_REMOTE_PARAMETER,
NETSCAPE_OPEN_PARAMETER_START +
url +
NETSCAPE_OPEN_PARAMETER_END });
try {
int exitCode = process.waitFor();
if (exitCode != 0) {
Runtime.getRuntime().exec(new String[] { (String) browser, url });
}
} catch (InterruptedException ie) {
throw new IOException("InterruptedException while launching browser: " + ie.getMessage());
}
break;
default:
Runtime.getRuntime().exec(new String[] { (String) browser, url });
break;
}
}
private native static int ICStart(int[] instance, int signature);
private native static int ICStop(int[] instance);
private native static int ICLaunchURL(int instance, byte[] hint, byte[] data, int len,
int[] selectionStart, int[] selectionEnd);
}
package ca.bcgsc.sockeye.popup;
import homologeneload.HomologSource;
import java.awt.Color;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.io.File;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeSet;
import javax.swing.JFileChooser;
import javax.swing.JMenu;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableColumn;
import org.biojava.bio.program.gff.GFFTools;
import org.biojava.bio.seq.StrandedFeature.Strand;
import ca.bcgsc.genereg.gui.TFBSDialog;
import ca.bcgsc.sockeye.analysis.SequenceMatrix;
import ca.bcgsc.sockeye.analysis.scprofile.SCProfileList;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.config.Connection;
import ca.bcgsc.sockeye.config.Service;
import ca.bcgsc.sockeye.dataretrieval.CisREDDRU;
import ca.bcgsc.sockeye.dataretrieval.CisREDDataSource;
import ca.bcgsc.sockeye.dataretrieval.CohoUser;
import ca.bcgsc.sockeye.dataretrieval.DataSource;
import ca.bcgsc.sockeye.dataretrieval.EnsemblDataSource;
import ca.bcgsc.sockeye.dataretrieval.SemanticZoomManager;
import ca.bcgsc.sockeye.dataretrieval.chinook.AlignmentDataSource;
import ca.bcgsc.sockeye.dataretrieval.chinookfactory.ChinookDataSourceFactoryMaker;
import ca.bcgsc.sockeye.datastorage.ChromosomeInfo;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.datastorage.HitGeneInfo;
import ca.bcgsc.sockeye.datastorage.MultiDimTrackDistribution;
import ca.bcgsc.sockeye.datastorage.SockeyeTrackList;
import ca.bcgsc.sockeye.datastorage.Track;
import ca.bcgsc.sockeye.datastorage.TrackDistribution;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.datastorage.ensembl.CachedOrthologuesInfo;
import ca.bcgsc.sockeye.datastorage.events.StorageEvent;
import ca.bcgsc.sockeye.gui.AtomicMotifDialog;
import ca.bcgsc.sockeye.gui.DASAnnotationsDialog;
import ca.bcgsc.sockeye.gui.MainFrame;
import ca.bcgsc.sockeye.gui.MarkRegionDialog;
import ca.bcgsc.sockeye.gui.NCCScanDialog;
import ca.bcgsc.sockeye.gui.PrimerPredictionReportPanel;
import ca.bcgsc.sockeye.gui.SequencePanel;
import ca.bcgsc.sockeye.gui.Sockeye;
import ca.bcgsc.sockeye.gui.TrackReBinDialog;
import ca.bcgsc.sockeye.gui.alignment.SCProfileDialog;
import ca.bcgsc.sockeye.gui.alignment.SingleAlignmentDialog;
import ca.bcgsc.sockeye.gui.navigation.FeaturePanel;
import ca.bcgsc.sockeye.gui.navigation.MoveActionAdaptor;
import ca.bcgsc.sockeye.gui.optionsdialog.OptionsDialog;
import ca.bcgsc.sockeye.gui.util.SockeyeMenuCreator;
import ca.bcgsc.sockeye.gui.util.SockeyeThreadedMenuFiller;
import ca.bcgsc.sockeye.io.FASTAExporter;
import ca.bcgsc.sockeye.service.coexpression.common.CoexpressionService;
import ca.bcgsc.sockeye.service.coexpression.common.CoexpressionServiceException;
import ca.bcgsc.sockeye.service.coexpression.common.CoexpressionServiceFactory;
import ca.bcgsc.sockeye.service.featureloader.common.ConnectionManager;
import ca.bcgsc.sockeye.service.featureloader.common.DistributionContainer;
import ca.bcgsc.sockeye.service.featureloader.common.EnsemblDBListManager;
import ca.bcgsc.sockeye.service.featureloader.common.FeatureLoaderService;
import ca.bcgsc.sockeye.service.featureloader.common.FeatureLoaderServiceFactory;
import ca.bcgsc.sockeye.service.featureloader.common.RelationshipMapUtil;
import ca.bcgsc.sockeye.service.homolog.common.HomologService;
import ca.bcgsc.sockeye.service.homolog.common.HomologServiceFactory;
import ca.bcgsc.sockeye.trackmanager.AlignOperation;
import ca.bcgsc.sockeye.trackmanager.CoexpressedRelationship;
import ca.bcgsc.sockeye.trackmanager.CopyOperation;
import ca.bcgsc.sockeye.trackmanager.LoadCoexpressedOperation;
import ca.bcgsc.sockeye.trackmanager.LoadOrthologueOperation;
import ca.bcgsc.sockeye.trackmanager.Operation;
import ca.bcgsc.sockeye.trackmanager.OrthologousRelationship;
import ca.bcgsc.sockeye.trackmanager.TrackManagerFactory;
import ca.bcgsc.sockeye.trackmanager.TrackRelationshipException;
import ca.bcgsc.sockeye.trackmanager.TrackRelationshipOrderInterface;
import ca.bcgsc.sockeye.util.Log;
import ca.bcgsc.sockeye.util.StringUtils;
import ca.bcgsc.util.gui.NucleotideContentDialog;
import ca.bcgsc.util.gui.scomponents.SockeyeFileChooser;
import ca.bcgsc.util.gui.scomponents.SockeyePopup;
public class FeatureRightPopup extends SockeyePopup {
private static final String NCC_SCAN = "NCC Scan";
static SequencePanel sequence_panel;
private TrackFeature feature;
private ArrayList features;
private String feature_name, accession_id;
private int track_id;
private String track_name, _database, _species, _chromosome, sequence,
gff_file_name;
private int _bin_size;
private int _ensembl_version;
private String label = "", url = "";
private int baseClickedOnTrack = -1;
private static final int _POP_UP_COEXPRESSION_LIMIT = 15;
private static Map HOMOLOGUE_GENE_RELATIONSHIP_MAP = new HashMap();
static {
HOMOLOGUE_GENE_RELATIONSHIP_MAP.put(
FeatureLoaderService.HOMOLOGUE_GENE, null);
}
JMenu m_line_up = new JMenu();
JMenuItem m_align = new JMenuItem("Align");
JMenu m_alt_viewer = new JMenu("Alternative viewer");
JMenu m_description = new JMenu("Description");
JMenu m_transcripts = new JMenu("Transcripts");
JMenuItem m_delete = new JMenuItem("Delete");
JMenu m_gsc_homologues = new JMenu("Get orthologues");
JMenu m_coexpressedGenes = new JMenu("Get coexpressed genes");
JMenu[] m_transcr_id;
JMenuItem feature_tree = new JMenuItem("Select on feature tree");
JMenuItem m_centre_in_window = new JMenuItem("Centre in window");
JMenuItem m_mark_region = new JMenuItem("Mark region(s)...");
JMenuItem m_sequence = new JMenuItem("Show sequence...");
JMenuItem m_motif = new JMenuItem("Show motif sequences...");
JMenuItem m_atomic_motif = new JMenuItem("Show atomic motif...");
JMenuItem content = new JMenuItem("Show nucleotide content");
JMenuItem export_to_multi_fasta = new JMenuItem(
"Export sequences to multiFASTA");
JMenuItem delete = new JMenuItem("Delete region");
JMenuItem zoom_to_region = new JMenuItem("Zoom-in to region");
JMenuItem m_scan_TFBS = new JMenuItem("TFBS Scan");
JMenuItem mi_rename = new JMenuItem("Add/Change display string");
FindSequenceMenuItem m_findseq = new FindSequenceMenuItem();
JMenu m_gff_attributes = new JMenu("GFF Attributes");
JMenuItem mi_das_annotations = new JMenuItem("DAS Annotations");
PrimerPredictionMenuItem mi_pcrOutside = new PrimerPredictionMenuItem(
"Primers Outside Target");
PrimerPredictionMenuItem mi_pcrInside = new PrimerPredictionMenuItem(
"Primers Inside Target");
JMenu m_pcr = createPrimerPredictionMenu();
final static Map POPUP = Configuration.getPopupConfiguration();
final private static DecimalFormat score_format = new DecimalFormat(
Configuration.SCORE_FORMAT_PATTERN);
static Hashtable hit_info = new Hashtable();
AlignOperation align_op = null;
public FeatureRightPopup(int track_id, String gff_file_name) {
this.features = new ArrayList();
this.add(m_delete);
this.track_id = track_id;
this.gff_file_name = gff_file_name;
m_delete.addActionListener(new ActionListener() {
public void actionPerformed(java.awt.event.ActionEvent e) {
m_delete_actionPerformed(e);
}
});
}
public FeatureRightPopup(ArrayList features) {
this.features = new ArrayList();
TrackFeature f = (TrackFeature) features.get(0);
this.feature = DataStoreUser.getInstance().getSockeyeTrackList()
.getFeature(f.getTrackId(), f.getFeature(), f.getAccessionID());
if (feature == null)
feature = f;
for (Iterator i = features.iterator(); i.hasNext();) {
TrackFeature n = (TrackFeature) i.next();
TrackFeature nogap = DataStoreUser.getInstance()
.getSockeyeTrackList().getFeature(n.getTrackId(),
n.getFeature(), n.getAccessionID());
this.features.add(nogap == null ? n : nogap);
}
init();
}
public FeatureRightPopup(ArrayList features, int base) {
this.features = new ArrayList();
TrackFeature f = (TrackFeature) features.get(0);
this.feature = DataStoreUser.getInstance().getSockeyeTrackList()
.getFeature(f.getTrackId(), f.getFeature(), f.getAccessionID());
if (feature == null)
feature = f;
for (Iterator i = features.iterator(); i.hasNext();) {
TrackFeature n = (TrackFeature) i.next();
TrackFeature nogap = DataStoreUser.getInstance()
.getSockeyeTrackList().getFeature(n.getTrackId(),
n.getFeature(), n.getAccessionID());
this.features.add(nogap == null ? n : nogap);
}
setBaseClicked(base);
init();
}
public FeatureRightPopup(TrackFeature f) {
this.features = new ArrayList();
this.feature = DataStoreUser.getInstance().getSockeyeTrackList()
.getFeature(f.getTrackId(), f.getFeature(), f.getAccessionID());
if (feature == null)
feature = f;
this.features = new ArrayList();
this.features.add(this.feature);
init();
}
public void setBaseClicked(int base) {
baseClickedOnTrack = base;
}
private Connection getConnection() {
return DataStoreUser.getInstance().getDataSourceManager()
.getTrackEnsemblConnection(track_id);
}
private void init() {
feature_name = feature.getFeature();
accession_id = feature.getAccessionID();
if (accession_id.matches(".*_.*")) {
accession_id = accession_id.split("_")[0];
}
track_id = feature.getTrackId();
Operation oper = TrackManagerFactory.getInstance().getUpOperations(
track_id);
if (oper != null && oper.getType() == Operation.__ALIGN_OPERATION_TYPE) {
if (oper instanceof AlignOperation)
align_op = (AlignOperation) oper;
}
List databases = DataStoreUser.getInstance().getDataSourceManager()
.getTrackDatabases(track_id);
List species = DataStoreUser.getInstance().getDataSourceManager()
.getTrackSpecies(track_id);
List chromosomes = DataStoreUser.getInstance().getDataSourceManager()
.getTrackChromosomes(track_id);
if (databases.size() > 0)
_database = (String) databases.get(0);
if (species.size() > 0)
_species = (String) species.get(0);
if (chromosomes.size() > 0)
_chromosome = (String) chromosomes.get(0);
if (_database != null) {
_ensembl_version = ConnectionManager
.getEnsemblVersionForDatabase(_database);
}
_database = (_database == null ? "" : _database);
_species = (_species == null ? "" : _species);
_chromosome = (_chromosome == null ? "" : _chromosome);
if (feature instanceof TrackDistribution) {
if (feature instanceof MultiDimTrackDistribution) {
setMultiDistributionPopup();
} else {
setDistributionPopup();
}
return;
}
clearUp();
if (OptionsDialog.__showPopupIcons)
setPopupIcons();
if (DataStoreUser.getInstance().getDataSourceManager()
.getTrackDatabases(track_id).isEmpty()
&& !DataStoreUser.getInstance().getSockeyeTrackList()
.getTrackHasFeature(track_id, "sequence")) {
content.setEnabled(false);
m_sequence.setEnabled(false);
m_pcr.setEnabled(false);
m_findseq.setEnabled(false);
}
m_mark_region.addActionListener(new ActionListener() {
public void actionPerformed(java.awt.event.ActionEvent e) {
MarkRegionDialog.show(Sockeye.__frame, features, false);
}
});
m_motif.addActionListener(new ActionListener() {
public void actionPerformed(java.awt.event.ActionEvent e) {
List ids = DataStoreUser.getInstance().getSockeyeTrackList()
.getAllOrderedTrackIds();
for (int i = 0; i < ids.size(); i++) {
Collection cisRed = DataStoreUser.getInstance()
.getSockeyeTrackList().getFeatures(
Integer.parseInt(ids.get(i).toString()),
"cisRED");
if (cisRed != null) {
for (Iterator j = cisRed.iterator(); j.hasNext();) {
TrackFeature f = (TrackFeature) j.next();
if (f.getAccessionID().equals(
feature.getAccessionID())) {
System.out.println("Track " + i + ", cisRED "
+ f.getAccessionID());
MainFrame.getVis3D().highlightMultipleFeatures(
f);
}
}
}
}
}
});
m_atomic_motif.addActionListener(new ActionListener() {
public void actionPerformed(java.awt.event.ActionEvent e) {
AtomicMotifDialog.showDialog(Sockeye.__frame, feature
.getAccessionID());
}
});
m_sequence.addActionListener(new ActionListener() {
public void actionPerformed(java.awt.event.ActionEvent e) {
String sequence;
if (feature.getAttribute("pieces").equals("")) {
sequence = DataStoreUser.getInstance()
.getSockeyeTrackList().getFeatureSequence(feature);
} else {
int id_length = feature.getAccessionID().lastIndexOf('_');
String id = feature.getAccessionID()
.substring(0, id_length);
Collection all_features = DataStoreUser.getInstance()
.getSockeyeTrackList().getFeatures(track_id,
feature_name);
Iterator all_features_iterator = all_features.iterator();
Hashtable all_pieces = new Hashtable();
while (all_features_iterator.hasNext()) {
TrackFeature tf = (TrackFeature) all_features_iterator
.next();
String tf_id = tf.getAccessionID();
if (tf_id.startsWith(id)) {
String[] split = tf_id.split("_");
int index = 0;
if (split.length > 1)
index = Integer
.valueOf(split[split.length - 1])
.intValue();
all_pieces.put(new Integer(index), DataStoreUser
.getInstance().getSockeyeTrackList()
.getFeatureSequence(tf));
}
}
sequence = "";
for (int j = 1; j < all_pieces.size(); j++) {
sequence = sequence.concat((String) all_pieces
.get(new Integer(j)));
}
sequence = sequence.concat((String) all_pieces
.get(new Integer(0)));
}
String track_name = (String) DataStoreUser.getInstance()
.getSockeyeTrackList().getTrackAttribute(
feature.getTrackId(), "track_name");
if (sequence.length() == 0) {
JOptionPane.showMessageDialog(null,
"No sequence available for the track " + track_name
+ ".", "Warning",
JOptionPane.WARNING_MESSAGE);
return;
}
String reverseStrand = "";
Strand strand = feature.getStrand();
if (strand != null
&& strand.getValue() == -1
|| (feature.getFeature().equals("region") && DataStoreUser
.getInstance().getSockeyeTrackList()
.getTrackReverse(feature.getTrackId()))) {
reverseStrand = "(reversed complement)";
}
StringTokenizer strToken = new StringTokenizer(track_name, "=");
String datetime = "";
String species = "";
if (strToken.countTokens() == 2) {
StringTokenizer strToken2 = new StringTokenizer(strToken
.nextToken(), ":");
if (strToken2.countTokens() == 2) {
species = strToken2.nextToken() + ":";
}
datetime = "=" + strToken.nextToken();
}
int track_start = DataStoreUser.getInstance()
.getSockeyeTrackList().getTrackDataStart(
feature.getTrackId());
int track_end = DataStoreUser.getInstance()
.getSockeyeTrackList().getTrackDataEnd(
feature.getTrackId());
int feature_display_start = feature.getStart();
int feature_display_end = feature.getEnd();
if (track_start > feature.getStart()) {
feature_display_start = track_start;
}
if (track_end < feature.getEnd()) {
feature_display_end = track_end;
}
String length = " ("
+ (feature.getEnd() - feature.getStart() + 1) + "bp)";
if (feature.getAttribute("parent_name")
.equals("repeat_feature")) {
feature_name = "Repeat ("
+ feature.getAttribute("display_string") + ")";
}
String header = feature_name + ":" + accession_id + ": "
+ species + feature.getStart() + ".."
+ feature.getEnd() + length + reverseStrand;
sequence_panel = new SequencePanel(header, sequence,
Sockeye.__frame, feature_display_start,
feature_display_end, strand == null ? 1 : strand
.getValue());
sequence_panel.setFeature(feature);
sequence_panel
.setFeatureInformation(feature_name, accession_id);
if (track_start > feature.getStart()
|| track_end < feature.getEnd()) {
sequence_panel.warnFeatureCut();
}
}
});
if (features != null) {
if (features.size() > 1) {
this.addSelected(features.size());
for (int f = 0; f < features.size(); f++) {
TrackFeature tf = (TrackFeature) features.get(f);
String accession_id = tf.getAccessionID();
this.addTitle(tf.getFeature() + " " + accession_id);
this.addInfo(this.coordinates(tf));
}
this.addSeparator();
int size = features.size();
m_line_up.setText("Line up " + size + " features");
add(m_line_up);
JMenuItem m_start = new JMenuItem("5' to 5'");
m_start.setIcon(Configuration.align_left);
m_line_up.add(m_start);
m_start.addActionListener(new ActionListener() {
public void actionPerformed(java.awt.event.ActionEvent e) {
line_up(-1);
}
});
JMenuItem m_center = new JMenuItem("Centres");
m_line_up.add(m_center);
m_center.setIcon(Configuration.align_justify);
m_center.addActionListener(new ActionListener() {
public void actionPerformed(java.awt.event.ActionEvent e) {
line_up(0);
}
});
JMenuItem m_end = new JMenuItem("3' to 3'");
m_line_up.add(m_end);
m_end.setIcon(Configuration.align_right);
m_end.addActionListener(new ActionListener() {
public void actionPerformed(java.awt.event.ActionEvent e) {
line_up(1);
}
});
boolean regions_flag = true;
for (int i = 0; i < features.size(); i++) {
if (!((TrackFeature) features.get(i)).getFeature().equals(
"region")) {
regions_flag = false;
}
break;
}
if (regions_flag) {
add(m_align);
m_align.setText("Align " + features.size()
+ " selected regions");
if (OptionsDialog.__showPopupIcons)
m_align.setIcon(Configuration.popupAlign);
m_align.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
align(AlignmentDataSource.ALIGNMENT_APP_TYPE);
}
});
m_align = new JMenuItem();
add(m_align);
if (OptionsDialog.__showPopupIcons)
m_align.setIcon(Configuration.popupAlign);
m_align.setText("Align " + features.size()
+ " selected regions (rearrangements)");
m_align.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
align(AlignmentDataSource.R_ALIGNMENT_APP_TYPE);
}
});
MotifDiscoveryMenuItem mo_item = new MotifDiscoveryMenuItem(
feature, features);
add(mo_item);
if (OptionsDialog.__showPopupIcons)
mo_item.setIcon(Configuration.popupDiscover);
MCSMenuItem mcs_item = new MCSMenuItem(feature, features);
add(mcs_item);
if (OptionsDialog.__showPopupIcons)
mcs_item.setIcon(Configuration.popupMcs);
delete.setText("Delete regions");
add(delete);
delete.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
String message = "Do you want to delete selected regions?";
if (JOptionPane.showConfirmDialog(Sockeye.__frame,
message, "Confirmation",
JOptionPane.YES_NO_OPTION) == 0) {
for (int i = 0; i < features.size(); i++) {
TrackFeature f = (TrackFeature) features
.get(i);
DataStoreUser.getInstance()
.getSockeyeTrackList()
.removeFeature(f.getTrackId(),
"region",
f.getAccessionID());
}
}
}
});
m_findseq.setFeatureFeatures(feature, features);
add(m_findseq);
export_to_multi_fasta.setText("Export " + size
+ " sequences to multiFASTA");
add(export_to_multi_fasta);
export_to_multi_fasta
.addActionListener(new ActionListener() {
public void actionPerformed(
java.awt.event.ActionEvent e) {
String file_name = Configuration
.getUserPath()
+ "export.fasta";
SockeyeFileChooser export_toFASTA_dialog = SockeyeFileChooser
.getSockeyeFileChooser("FASTAExport");
export_toFASTA_dialog
.setDialogTitle("Save Sequences As...");
int result = export_toFASTA_dialog
.showSaveDialog(Sockeye.__frame,
"fasta",
new File(file_name));
try {
file_name = export_toFASTA_dialog
.getSelectedFile()
.getCanonicalPath();
} catch (java.io.IOException ex) {
Log.printStackTrace(ex);
System.out
.println("Cannot handle file!!!!!");
return;
}
if (result == JFileChooser.APPROVE_OPTION) {
FASTAExporter.exportToMultiFASTA(
features, file_name, 0);
}
}
});
return;
} else {
add(m_mark_region);
return;
}
}
}
if (feature_name.equals("gene")) {
setGenePopup(feature, true);
} else if (feature_name.equals("homologue")) {
} else if (feature_name.equals("exon")) {
setExonPopup(feature);
} else if (feature.getAttribute("parent_name").equals("repeat_feature")) {
setRepeatPopup();
} else if (feature_name.equals("EST")) {
setESTsPopup();
} else if (feature_name.equals("CpG")) {
setCpGPopup();
} else if (feature_name.equals("marker")) {
setMarkerPopup();
} else if (feature_name.equals("multitranscript")
&& DataStoreUser.getInstance().getSockeyeTrackList()
.getFeatures(track_id, "exon") != null) {
String szAccessionID = feature.getAccessionID();
String gene_id = szAccessionID.substring(0, szAccessionID
.indexOf('(') - 1);
SplicingDialog sp = new SplicingDialog(Sockeye.__frame,
(TrackFeature) DataStoreUser.getInstance()
.getSockeyeTrackList().getFeature(track_id, "gene",
gene_id));
sp.show();
return;
} else if (feature_name.equals("select")) {
setSelectPopup();
} else if (feature_name.equals("region")) {
setRegionPopup();
} else if (feature_name.endsWith("UTR")) {
setUTRPopup();
} else if (feature_name.equals("fragment_length_polymorphism")) {
setFragmentLengthPolymorphismPopup();
} else if (feature_name.startsWith("PWM_score")) {
setPWMScorePopup();
} else if (feature_name.startsWith("ncc_score")) {
setNCCScorePopup();
} else if (feature_name.startsWith("motif_discovery")) {
setMotifDiscoveryScorePopup();
} else if (feature_name.startsWith("mcs_calculation")) {
setMcsScorePopup();
} else if (feature_name.startsWith("amplicon")
|| feature_name.startsWith("forward_primer")
|| feature_name.startsWith("reverse_primer")) {
setPrimerPredictionPopup();
} else {
setGFFPopup();
}
Map attr = feature.getGroupAttributes();
ArrayList attr_names = new ArrayList();
ArrayList attr_values = new ArrayList();
for (Iterator it = attr.keySet().iterator(); it.hasNext();) {
String attr_name = (String) it.next();
if (!attr_name.equals("track_id") && !attr_name.equals("ID")
&& (attr.get(attr_name) instanceof ArrayList)) {
System.out.println(attr.get(attr_name));
ArrayList attr_value_list = (ArrayList) attr.get(attr_name);
if (attr_value_list != null && attr_value_list.size() > 0) {
attr_names.add(attr_name);
for (int index = 0; index < attr_value_list.size(); index++) {
if (index != 0) {
attr_names.add("");
}
attr_values.add(attr_value_list.get(index));
}
}
}
}
String source = feature.getSource();
if (source == null || source.toLowerCase().indexOf("gff") == -1) {
m_gff_attributes.setText("Attributes");
}
this.add(m_gff_attributes);
if (attr_values.size() > 0) {
JTable tab = new JTable(attr_values.size(), 2);
tab.setCellSelectionEnabled(false);
tab.setEnabled(false);
tab.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);
tab.setOpaque(false);
for (int row = 0; row < attr_values.size(); row++) {
tab.setValueAt(attr_names.get(row), row, 0);
tab.setValueAt(attr_values.get(row), row, 1);
}
TableColumn c = tab.getColumnModel().getColumn(1);
c.setPreferredWidth(160);
c.setMinWidth(5);
c = tab.getColumnModel().getColumn(0);
c.setPreferredWidth(105);
m_gff_attributes.setEnabled(true);
m_gff_attributes.add(tab);
}
else {
m_gff_attributes.setEnabled(false);
}
if (!feature_name.equals("select") && align_op == null) {
m_centre_in_window.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
centre_in_window();
}
});
add(m_centre_in_window);
}
if (!feature_name.equals("select") && !feature_name.equals("region")
&& !feature_name.endsWith("UTR") && !feature_name.equals("gap")) {
feature_tree.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
FeaturePanel.setSelectedFeature(feature_name);
}
});
add(feature_tree);
}
if (!feature.getFeature().equals("region")
&& !feature.getFeature().equals("select")) {
add(m_mark_region);
this.addSeparator();
}
if (m_alt_viewer.getItemCount() == 0)
m_alt_viewer.setEnabled(false);
add(m_alt_viewer);
addSeparator();
if (feature.getFeature().equals("cisRED")) {
add(m_motif);
add(m_atomic_motif);
addSeparator();
}
add(m_sequence);
add(content);
content.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
new NucleotideContentDialog(Sockeye.__frame, DataStoreUser
.getInstance().getSockeyeTrackList()
.getFeatureSequence(feature));
}
});
if (OptionsDialog.__showPopupIcons)
mi_rename.setIcon(Configuration.popupTrans_icon);
mi_rename.setEnabled(Configuration.getFeatureDisplay(feature_name,
feature.getScore() != GFFTools.NO_SCORE, false).isText());
mi_rename.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
String orig_name = feature.getAttribute("display_string");
String name = (String) JOptionPane.showInputDialog(
Sockeye.__frame, "Input new feature name", "Rename",
JOptionPane.OK_CANCEL_OPTION, null, null,
orig_name == null ? "" : orig_name);
feature.setAttribute("display_string", name);
if (!name.equals(orig_name)) {
DataStoreUser.getInstance().getSockeyeTrackList()
.setFeatureVisibility(track_id, feature_name,
feature.getAccessionID(), false);
DataStoreUser.getInstance().getSockeyeTrackList()
.setFeatureVisibility(track_id, feature_name,
feature.getAccessionID(), true);
}
}
});
add(mi_rename);
}
private void setGFFPopup() {
this.addTitle("Feature: " + feature.getFeature());
this.addInfo(coordinates(feature));
String raw_score_string = feature.getAttribute("raw_score");
if (feature.getScore() != GFFTools.NO_SCORE && raw_score_string != null
&& raw_score_string.length() > 0) {
double score = Double.valueOf(raw_score_string).doubleValue();
if (feature.getFeature().equals("cisRED"))
this.addInfo("Score (-log[p-value]): "
+ score_format.format(score));
else
this.addInfo("Score: " + score_format.format(score));
} else {
this.addInfo("Score: no score");
}
if (feature.getFeature().equals("cisRED"))
this.addInfo("Sequence : "
+ DataStoreUser.getInstance().getSockeyeTrackList()
.getFeatureSequence(feature));
else {
if (feature.getFrame() != GFFTools.NO_FRAME) {
this.addInfo("Frame: " + feature.getFrame());
} else {
this.addInfo("Frame: no frame");
}
}
if (feature.getFeature().equals(CisREDDRU.__CISRED_FEATURE_NAME)) {
JMenuItem mi_cisRED = new JMenuItem("cisRED view");
String id = feature.getAttribute(CisREDDRU.__FEATURE_ID);
String url = "http:
mi_cisRED.addActionListener(new PopupMenuURL(url));
m_alt_viewer.add(mi_cisRED);
m_alt_viewer.setEnabled(true);
}
}
private void setGenePopup(TrackFeature gene, boolean show_transcripts) {
String gene_accession_id = gene.getAccessionID();
this.addTitle("Gene: " + gene_accession_id);
this.addInfo(coordinates(gene));
final TrackFeature _gene = gene;
List description = gene.getGroupAttribute("display_string");
if (description != null) {
JMenuItem d = new JMenuItem((String) description.get(0));
d.setBackground(Color.WHITE);
m_description.add(d);
if (description.size() >= 2) {
JMenuItem s = new JMenuItem((String) description.get(1));
s.setBackground(Color.WHITE);
m_description.add(s);
}
add(m_description);
}
if (feature.getSource().equals("EnsEMBL")) {
this.addSeparator();
label = "GeneView";
JMenuItem m_gene_view = new JMenuItem(label + "...");
url = ((String) POPUP.get(label)).concat(gene_accession_id);
m_gene_view.addActionListener(new PopupMenuURL(url.replaceAll(
"SPECIES", _species)));
m_alt_viewer.add(m_gene_view);
label = "LocusLink";
if (!gene.getAttribute("locus_link").equals("")) {
JMenuItem m_locus_link = new JMenuItem(label.concat("..."));
url = ((String) POPUP.get(label)).concat(gene
.getAttribute("locus_link"));
m_locus_link.addActionListener(new PopupMenuURL(url));
m_alt_viewer.add(m_locus_link);
}
if (!feature_name.equals("select")) {
mi_pcrOutside.setFeatureFeatures(feature, features);
mi_pcrInside.setFeatureFeatures(feature, features);
add(m_pcr);
}
if (show_transcripts) {
setTranscriptPopup(gene);
}
add(m_gsc_homologues);
SockeyeMenuCreator.fillMenu(new GscHomologFiller(gene,
m_gsc_homologues));
add(m_coexpressedGenes);
this.addSeparator();
SockeyeMenuCreator.fillMenu(new CoexpressedFiller(gene,
m_coexpressedGenes));
}
}
private String[] getCoexpressedDatabaseForTrackDatabase(String trackDatabase) {
String[] db = new String[3];
db[0] = trackDatabase.replaceFirst("_core_", "_coexpression_reliable_");
db[1] = trackDatabase.replaceFirst("_core_", "_coexpression_tmm_");
db[2] = trackDatabase.replaceFirst("_core_",
"_coexpression_reliable_multiple_");
return db;
}
private Map getCoexpressed(String geneId, String[] database)
throws CoexpressionServiceException {
CoexpressionServiceFactory fac = CoexpressionServiceFactory
.getInstance();
Service service = Configuration
.getService(CoexpressionServiceFactory.COEXPRESSION_SERVICE);
String mode = null;
String remotehost = null;
if (service != null) {
mode = service.getMode();
remotehost = service.getRemotehost();
} else {
throw new CoexpressionServiceException(
"Coexpression service not set up properly.");
}
CoexpressionService coexpressionService = fac.getService(mode,
remotehost);
return coexpressionService.getCoexpressionScores(geneId, database);
}
private void setExonPopup(TrackFeature exon) {
this.addTitle("Exon: " + accession_id);
this.addInfo(coordinates(exon));
if (feature.getSource().equals("EnsEMBL")) {
this.addSeparator();
String gene_accession_id = exon.getAttribute("gene");
TrackFeature gene = DataStoreUser.getInstance()
.getSockeyeTrackList().getFeature(exon.getTrackId(),
"gene", gene_accession_id);
if (gene != null)
setGenePopup(gene, true);
}
}
private void setTranscriptPopup(TrackFeature gene) {
List transcripts = gene.getGroupAttribute("transcripts");
List proteins = gene.getGroupAttribute("proteins");
int n_transcripts = transcripts.size();
String selected_transcript_id = gene
.getAttribute("selected_transcript");
m_transcripts
.setText(new String("Transcripts (" + n_transcripts + ")"));
if (n_transcripts < 1
|| DataStoreUser.getInstance().getSockeyeTrackList()
.getFeatures(gene.getTrackId(), "exon") == null
|| !DataStoreUser.getInstance().getSockeyeTrackList()
.getFeatureVisibility("exon")) {
if (!DataStoreUser.getInstance().getSockeyeTrackList()
.getFeatureVisibility("exon"))
m_transcripts.setText(new String("Transcripts ("
+ n_transcripts + ")" + " (enable exons!)"));
m_transcripts.setEnabled(false);
}
add(m_transcripts);
m_transcr_id = new JMenu[n_transcripts];
for (int i = 0; i < n_transcripts; i++) {
String transcript_id = (String) transcripts.get(i);
m_transcr_id[i] = new JMenu();
m_transcr_id[i].setText(new String("Transcr: " + transcript_id
+ " "));
if (transcript_id.equals(selected_transcript_id)) {
m_transcr_id[i].setIcon(Configuration.check);
} else {
m_transcr_id[i].setIcon(Configuration.uncheck);
}
m_transcr_id[i].addMouseListener(new SelectedTranscript(gene,
m_transcr_id, i, transcript_id));
m_transcripts.add(m_transcr_id[i]);
label = "TransView";
JMenuItem m_trans_view = new JMenuItem(label.concat("..."));
url = ((String) POPUP.get(label)).concat(transcript_id);
m_trans_view.addActionListener(new PopupMenuURL(url.replaceAll(
"SPECIES", _species)));
m_transcr_id[i].add(m_trans_view);
JMenuItem m_cdna_export = new JMenuItem("Export cDNA...");
url = ((String) POPUP.get("ExportView"))
.replaceAll("FTYPE", "cdna").concat(transcript_id);
m_cdna_export.addActionListener(new PopupMenuURL(url.replaceAll(
"SPECIES", _species)));
m_transcr_id[i].add(m_cdna_export);
JMenuItem m_protein_export = new JMenuItem("Export peptide...");
m_protein_export.addActionListener(new PopupMenuURL(url.replaceAll(
"SPECIES", _species)));
m_transcr_id[i].add(m_protein_export);
}
}
private void setSNPPopup() {
this.addTitle("SNP: " + accession_id);
this.addInfo(coordinates(feature));
}
private void setMarkerPopup() {
this.addTitle("Marker: " + accession_id);
this.addInfo(coordinates(feature));
}
private void displayHit(HitTrackInfo hit_track_info) {
String hit_species = hit_track_info.getSpecies();
String hit_database = EnsemblDBListManager
.getCoreEnsemblDatabaseFromConnection(hit_track_info
.getVersion(), hit_species, getConnection());
String hit_chromosome = hit_track_info.getChromosome();
Track t = new Track(hit_track_info.getStart(), hit_track_info.getEnd());
String displayName = ConnectionManager
.convertEnsemblDatabaseToShortSpeciesName(hit_database)
+ " v"
+ ConnectionManager.getEnsemblVersionForDatabase(hit_database);
String trackName = "";
Date date = new Date();
try {
trackName = Track.computeTrackName(hit_track_info.getStart(),
hit_track_info.getEnd(), hit_track_info.getChromosome(),
date, displayName);
} catch (NullPointerException e) {
JOptionPane.showMessageDialog(null, "Sufficient data for gene "
+ hit_track_info._hgi.getGeneID() + " not found.",
"Unable to load gene",
javax.swing.JOptionPane.ERROR_MESSAGE);
Log.printStackTrace(e);
return;
}
t.setAttribute("track_name", trackName);
int max_track_length = ChromosomeInfo.getChromosomeLength(hit_database,
hit_chromosome);
t.setAttribute("track_max_length", new Integer(max_track_length));
int t_id = DataStoreUser.getInstance().getSockeyeTrackList()
.addTrack(t);
DataStoreUser.getInstance().getSockeyeTrackList().setTrackOffset(t_id,
hit_track_info.getOffset());
String databaseVersion = CisREDDataSource.getInfoFromDatabaseName(
hit_database, "version");
String databaseSpecies = CisREDDataSource.getInfoFromDatabaseName(
hit_database, "species");
List connectionList = ConnectionManager.getCisRedConnections();
if ((connectionList == null) || (connectionList.isEmpty())) {
System.err
.println("CisRED Connection is not set in user_config.xml or it's not supported for species "
+ databaseSpecies);
} else {
for (Iterator itr = connectionList.iterator(); itr.hasNext();) {
Connection cisREDconn = (Connection) itr.next();
String cisredVersion = CisREDDataSource
.getInfoFromDatabaseName(cisREDconn.getSubtype(),
"version");
if (cisredVersion.equals(databaseVersion)) {
CisREDDataSource cis_red_src = new CisREDDataSource(t_id,
hit_chromosome, cisREDconn, databaseSpecies);
DataStoreUser.getInstance().getSockeyeTrackList()
.addStorageListener(cis_red_src);
int cis_red_ds_id = DataStoreUser.getInstance()
.getDataSourceManager().addDataSource(cis_red_src);
DataStoreUser.getInstance().getSockeyeTrackList()
.addDataSourceId(t_id, cis_red_ds_id);
}
}
}
EnsemblDataSource src = new EnsemblDataSource(t_id, hit_database,
hit_chromosome);
src.setConnection(getConnection());
DataStoreUser.getInstance().getSockeyeTrackList().addStorageListener(
src);
int ds_id = DataStoreUser.getInstance().getDataSourceManager()
.addDataSource(src);
DataStoreUser.getInstance().getSockeyeTrackList().addDataSourceId(t_id,
ds_id);
int hit_gene_strand = hit_track_info._hgi.getHitGeneStrand();
boolean isCurrentReversed = DataStoreUser.getInstance()
.getSockeyeTrackList().getTrackReverse(track_id);
int x = feature.getStrand().getValue();
if (feature.getStrand().getValue() != hit_gene_strand
^ isCurrentReversed) {
DataStoreUser.getInstance().getSockeyeTrackList().setTrackReverse(
t_id, true);
}
String my_gene = feature.getAccessionID();
String hit_gene = hit_track_info._hgi.getGeneID();
HashMap trk_gene = new HashMap();
trk_gene.put(new Integer(this.track_id), my_gene);
trk_gene.put(new Integer(t_id), hit_gene);
TrackRelationshipOrderInterface relation = null;
try {
if (hit_track_info.getHitType()
.equals(HitTrackInfo.HOMOLOGOUS_TYPE)) {
OrthologousRelationship relation_h = null;
Operation[] dn_ops = TrackManagerFactory.getInstance()
.getDownOperations(this.track_id);
Operation up_op = TrackManagerFactory.getInstance()
.getUpOperations(this.track_id);
boolean up_track_rel = false;
boolean added_track = false;
for (int i = 0; i <= dn_ops.length; i++) {
Operation op = up_op;
if (i < dn_ops.length) {
op = dn_ops[i];
} else {
up_track_rel = true;
}
if (op.getType() == Operation.__LOAD_HOMOLOGUE_OPERATION_TYPE) {
relation_h = (OrthologousRelationship) op
.getTrackRelationship();
if (relation_h.getGene(this.track_id).equals(my_gene)) {
relation_h.addTrack(t_id, hit_gene, hit_track_info
.getSpecies());
}
if (i < dn_ops.length) {
TrackManagerFactory.getInstance()
.addTrack(op, t_id);
added_track = true;
break;
}
}
}
if (!added_track || up_track_rel || relation_h == null) {
HashMap trk_species = new HashMap();
trk_species.put(new Integer(this.track_id), this._species);
trk_species.put(new Integer(t_id), hit_track_info
.getSpecies());
relation_h = new OrthologousRelationship(trk_gene,
trk_species);
LoadOrthologueOperation hit_op = new LoadOrthologueOperation(
relation_h);
TrackManagerFactory.getInstance().addTrack(hit_op, t_id);
int[] parents = new int[1];
parents[0] = this.track_id;
TrackManagerFactory.getInstance().addOperation(hit_op,
parents);
}
relation = relation_h;
} else if (hit_track_info.getHitType().equals(
HitTrackInfo.COEXPRESSED_TYPE)) {
float pearson = ((Float) hit_track_info
.getAttribute("PearsonScore")).floatValue();
CoexpressedRelationship relation_c = null;
Operation[] ops = TrackManagerFactory.getInstance()
.getDownOperations(this.track_id);
for (int i = 0; i < ops.length; i++) {
if (ops[i].getType() == Operation.__LOAD_COEXPRESS_OPERATION_TYPE) {
relation_c = (CoexpressedRelationship) ops[i]
.getTrackRelationship();
if (relation_c.getGene(this.track_id).equals(my_gene)) {
relation_c.addTracks(this.track_id, my_gene, t_id,
hit_gene, pearson);
TrackManagerFactory.getInstance().addTrack(ops[i],
t_id);
break;
}
}
}
if (relation_c == null) {
relation_c = new CoexpressedRelationship();
relation_c.addTracks(this.track_id, my_gene, t_id,
hit_gene, pearson);
LoadCoexpressedOperation hit_op = new LoadCoexpressedOperation(
relation_c);
TrackManagerFactory.getInstance().addTrack(hit_op, t_id);
int[] parents = new int[1];
parents[0] = this.track_id;
TrackManagerFactory.getInstance().addOperation(hit_op,
parents);
}
relation = relation_c;
}
} catch (TrackRelationshipException e) {
e.printStackTrace();
Log.printStackTrace(e);
}
if (relation == null) {
TrackManagerFactory.getInstance().addTrackToRoot(t_id);
}
DataStoreUser.getInstance().getSockeyeTrackList().setFeatureVisibility(
FeaturePanel.getAllSelectedFeatures(), true);
}
class HitTrackInfo {
String _species, _chromosome, hit_type;
int _start, _end, _offset = 0, _version;
HitGeneInfo _hgi;
HashMap attributes = new HashMap();
public static final String COEXPRESSED_TYPE = "coexpressed";
public static final String HOMOLOGOUS_TYPE = "homologous";
protected HitTrackInfo(HitGeneInfo hgi, int track_start_offset,
int track_length, String type) {
_hgi = hgi;
TrackFeature gene = null;
if (feature.getFeature().equals("gene")) {
gene = feature;
} else {
String gene_id = feature.getAttribute("gene");
gene = DataStoreUser.getInstance().getSockeyeTrackList()
.getFeature(feature.getTrackId(), "gene", gene_id);
}
int hit_gene_strand = _hgi.getHitGeneStrand();
int gene_strand = gene.getStrand().getValue();
_offset = DataStoreUser.getInstance().getSockeyeTrackList()
.getTrackOffset(feature.getTrackId());
if (hit_gene_strand != -1 && gene_strand != -1) {
_start = _hgi.getHitGeneStart() - track_start_offset;
} else if (hit_gene_strand == -1 && gene_strand == -1) {
_start = _hgi.getHitGeneEnd()
- (track_start_offset + feature.getEnd()
- feature.getStart() + 1) + 1;
} else if (hit_gene_strand == -1 && gene_strand != -1) {
_start = _hgi.getHitGeneEnd()
- (track_length - track_start_offset) + 1;
} else if (hit_gene_strand != -1 && gene_strand == -1) {
_start = _hgi.getHitGeneStart()
- (track_length - track_start_offset - gene.getEnd() + gene
.getStart()) + 1;
}
int delta = 0;
if (_start < 1) {
delta = _offset + 1 - _start;
if (hit_gene_strand == gene_strand
|| DataStoreUser.getInstance().getSockeyeTrackList()
.getTrackReverse(feature.getTrackId()))
_offset = _offset + 1 - _start;
_start = 1;
}
_end = _start + track_length - 1 - delta;
hit_type = type;
}
protected int getStart() {
return _start;
}
protected int getEnd() {
return _end;
}
protected int getOffset() {
return _offset;
}
protected String getSpecies() {
return _hgi.getSpecies();
}
protected int getVersion() {
return _hgi.getVersion();
}
protected String getChromosome() {
return _hgi.getHitChrom();
}
protected String getDescription() {
return _hgi.getHitDescription();
}
protected String getHitType() {
return hit_type;
}
protected void setAttribute(String key, Object value) {
attributes.put(key, value);
}
protected Object getAttribute(String key) {
return attributes.get(key);
}
}
public void m_delete_actionPerformed(java.awt.event.ActionEvent e) {
if (JOptionPane.showConfirmDialog(Sockeye.__frame,
"Do you want to delete selected gff annotation from track?",
"Confirmation", JOptionPane.YES_NO_OPTION) == 0) {
}
}
private void setRepeatPopup() {
this.addTitle("Repeat (" + feature.getAttribute("display_string")
+ "), " + accession_id);
this.addInfo(coordinates(feature));
}
private void setUTRPopup() {
this.addTitle(feature.getFeature() + " Transcript: "
+ feature.getAttribute("transcript"));
this.addInfo(coordinates(feature));
}
private void setESTsPopup() {
this.addTitle("EST: " + accession_id);
this.addInfo(coordinates(feature));
if (feature.getSource().equals("EnsEMBL")) {
label = "Fetch EST";
JMenuItem m_fetch_est = new JMenuItem(label.concat("..."));
if (accession_id.indexOf(".") == -1) {
url = ((String) POPUP.get(label)).concat(accession_id);
} else {
url = ((String) POPUP.get(label)).concat(accession_id
.substring(0, accession_id.indexOf(".")));
}
m_fetch_est.addActionListener(new PopupMenuURL(url));
add(m_fetch_est);
}
}
private void setCpGPopup() {
this.addTitle("CpG data island: " + accession_id);
this.addInfo(coordinates(feature));
if (feature.getScore() != GFFTools.NO_SCORE) {
this.addInfo("Score: " + score_format.format(feature.getScore()));
} else {
this.addInfo("Score: no score");
}
}
private void setFragmentLengthPolymorphismPopup() {
this.addTitle("Fragment Length Polymorphism: " + accession_id);
this.addInfo(coordinates(feature));
this.addInfo("Minimum Allele Size:"
+ feature.getAttribute("min_allele_size"));
this.addInfo("Maximum Allele Size:"
+ feature.getAttribute("max_allele_size"));
this.addInfo("Analysis:"
+ feature.getAttribute("analysis_logical_name"));
this.addInfo("Synonyms:"
+ feature.getGroupAttribute("flp_synonyms").toString());
}
private void setPWMScorePopup() {
this.addTitle("PWM name: " + feature.getAttribute("display_name"));
this.addTitle("PWM ID: " + feature.getAttribute("accession_id"));
Operation operation = TrackManagerFactory.getInstance()
.getUpOperations(track_id);
String seq;
if (operation != null
&& operation.getType() != Operation.__IMPORT_GFF_OPERATION_TYPE) {
seq = DataStoreUser.getInstance().getSockeyeTrackList()
.getFeatureSequence(feature);
} else {
seq = feature.getAttribute("seq");
}
this.addInfo(coordinates(feature));
if (seq != null && seq.length() != 0) {
this.addInfo("Sequence: " + seq);
}
if (feature.getScore() != GFFTools.NO_SCORE) {
this.addInfo("Score: " + feature.getAttribute("score") + " ("
+ feature.getAttribute("percent_score") + ")");
this.addInfo("Threshold: " + feature.getAttribute("threshold"));
} else {
this.addInfo("Score: no score");
}
}
private void setNCCScorePopup() {
this.addTitle("NCC score");
String seq = DataStoreUser.getInstance().getSockeyeTrackList()
.getFeatureSequence(feature);
if (seq != null && seq.length() != 0) {
this.add(new JMenuItem(seq));
}
this.addInfo("Score: " + feature.getAttribute("score"));
this.addInfo("Threshold: " + feature.getAttribute("threshold"));
}
private void setMotifDiscoveryScorePopup() {
this.addTitle("Motif discovery score");
String seq = DataStoreUser.getInstance().getSockeyeTrackList()
.getFeatureSequence(feature);
String coord = feature.getAttribute("coordinates");
if (seq != null && seq.length() != 0) {
this.add(new JMenuItem(seq + " : " + coord));
}
this.addInfo("Score: " + feature.getAttribute("score"));
}
private void setMcsScorePopup() {
this.addTitle("MCS Score");
String coord = feature.getAttribute("coordinates");
this.add(new JMenuItem(coord));
this.addInfo("Score: " + feature.getAttribute("score"));
}
private void setPrimerPredictionPopup() {
this.addTitle(feature.getFeature());
this.addInfo(coordinates(feature));
this.addInfo("Primer pair quality: " + feature.getScore());
if (feature.getFeature().equals("forward_primer")
|| feature.getFeature().equals("reverse_primer")) {
String seq = DataStoreUser.getInstance().getSockeyeTrackList()
.getFeatureSequence(feature);
if (seq != null && seq.length() != 0) {
this.addInfo(seq);
}
}
JMenuItem ppReport = new JMenuItem("Primer Prediction Report");
ppReport.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
PrimerPredictionReportPanel ppReportPanel = new PrimerPredictionReportPanel(
Sockeye.__frame, "Primer Prediction Report", false,
feature);
}
});
this.addSeparator();
this.add(ppReport);
this.addSeparator();
}
private void setRegionPopup() {
this.addTitle("Region");
this.addInfo(coordinates(feature));
if (features.size() > 1) {
delete.setText("Delete regions");
}
add(delete);
delete.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
String message = "Do you want to delete selected region?";
if (features.size() > 1) {
message = "Do you want to delete selected regions?";
}
if (JOptionPane.showConfirmDialog(Sockeye.__frame, message,
"Confirmation", JOptionPane.YES_NO_OPTION) == 0) {
for (int i = 0; i < features.size(); i++) {
TrackFeature f = (TrackFeature) features.get(i);
DataStoreUser.getInstance().getSockeyeTrackList()
.removeFeature(f.getTrackId(), "region",
f.getAccessionID());
}
}
}
});
this.addSeparator();
if (align_op == null) {
JMenuItem part_track = createCopyToTrackMenuItem();
add(part_track);
}
add(zoom_to_region);
zoom_to_region.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
DataStoreUser.getInstance().getSockeyeTrackList()
.setTrackDataWindow(feature.getTrackId(),
feature.getStart(), feature.getEnd());
}
});
this.addSeparator();
mi_das_annotations
.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
String species = null;
List ds_list = DataStoreUser.getInstance()
.getSockeyeTrackList().getDataSources(track_id);
Iterator ds_it = ds_list.iterator();
EnsemblDataSource ensembl_ds = null;
while (ds_it.hasNext()) {
DataSource ds = DataStoreUser.getInstance()
.getDataSourceManager().getDataSource(
Integer.parseInt(ds_it.next()
.toString()));
if (ds instanceof EnsemblDataSource) {
ensembl_ds = (EnsemblDataSource) ds;
species = ensembl_ds.getSpecies();
break;
}
}
new DASAnnotationsDialog(Sockeye.__frame, feature
.getTrackId(), feature.getStart(), feature
.getEnd(), species);
}
});
if (align_op == null) {
m_scan_TFBS.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
CohoUser user = new CohoUser();
TFBSDialog dialog = new TFBSDialog(Sockeye.__frame,
track_id, feature.getStart(), feature.getEnd());
dialog.addCohoScanEventListener(user);
dialog.show();
}
});
add(m_scan_TFBS);
JMenuItem ncc_region = createNCCMenuItem();
add(ncc_region);
mi_pcrOutside.setFeatureFeatures(feature, features);
mi_pcrInside.setFeatureFeatures(feature, features);
add(m_pcr);
m_findseq.setFeatureFeatures(feature, features);
add(m_findseq);
MotifDiscoveryMenuItem mo_item = new MotifDiscoveryMenuItem(
feature, features);
add(mo_item);
if (OptionsDialog.__showPopupIcons)
mo_item.setIcon(Configuration.popupDiscover);
add(mi_das_annotations);
mi_das_annotations.setIcon(Configuration.das_icon);
JMenu m_export_to_FASTA = new JMenu("Export to FASTA");
if (OptionsDialog.__showPopupIcons) {
m_export_to_FASTA.setIcon(Configuration.popupExport);
}
this.add(m_export_to_FASTA);
JMenuItem m_export_sense = new JMenuItem(
"(+) positive strand sequence");
JMenuItem m_export_antisense = new JMenuItem(
"(-) negative strand sequence (reverse complement)");
m_export_to_FASTA.add(m_export_sense);
m_export_to_FASTA.add(m_export_antisense);
final List single_feature_list = new ArrayList();
single_feature_list.add(feature);
m_export_sense
.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
exportFASTA_actionPerformed(single_feature_list,
false);
}
});
m_export_antisense
.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
exportFASTA_actionPerformed(single_feature_list,
true);
}
});
}
}
private void setSelectPopup() {
int start = feature.getStart();
int end = feature.getEnd();
this.addTitle("Region (Transient)");
this.addInfo(coordinates(feature));
if (sequence != null) {
add(m_sequence);
}
if (align_op == null) {
JMenuItem part_track = createCopyToTrackMenuItem();
add(part_track);
}
JMenuItem mark_region = createStoreRegionMenuItem();
add(mark_region);
}
private JMenu createPrimerPredictionMenu() {
JMenu pp_menu = new JMenu("Primer Prediction");
if (OptionsDialog.__showPopupIcons)
pp_menu.setIcon(Configuration.popupPrimers);
pp_menu.add(mi_pcrOutside);
if (OptionsDialog.__showPopupIcons)
mi_pcrOutside.setIcon(Configuration.popupPrimersOutside);
pp_menu.add(mi_pcrInside);
if (OptionsDialog.__showPopupIcons)
mi_pcrInside.setIcon(Configuration.popupPrimersInside);
return pp_menu;
}
private JMenuItem createNCCMenuItem() {
JMenuItem ncc_region = new JMenuItem(NCC_SCAN);
if (OptionsDialog.__showPopupIcons) {
ncc_region.setIcon(Configuration.popupScan);
}
ncc_region.addActionListener(new ActionListener() {
public void actionPerformed(java.awt.event.ActionEvent e) {
for (Iterator fit = features.iterator(); fit.hasNext();) {
TrackFeature tf = (TrackFeature) fit.next();
if (tf.getEnd() - tf.getStart() + 1 > 6000) {
JOptionPane
.showMessageDialog(
null,
"This NCC scan can not be performed:\nAt least one of the selected regions exeeds the limit of 6kb, \nwhich would make this scan take a very long time!",
"Region too long",
javax.swing.JOptionPane.INFORMATION_MESSAGE);
return;
}
}
NCCScanDialog.show(Sockeye.__frame, features);
}
});
return ncc_region;
}
private JMenuItem createCopyToTrackMenuItem() {
JMenuItem part_track = new JMenuItem("Copy to new track");
if (OptionsDialog.__showPopupIcons) {
part_track.setIcon(Configuration.popupTrackCopy);
}
part_track.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
int t_id = feature.getTrackId();
int track_id = DataStoreUser.getInstance()
.getSockeyeTrackList().cloneTrack(t_id,
feature.getStart(), feature.getEnd());
try {
EnsemblDataSource src = new EnsemblDataSource(track_id,
_database, _chromosome);
src.setConnection(getConnection());
src.setSZBinLength(_bin_size, false);
DataStoreUser.getInstance().getSockeyeTrackList()
.addStorageListener(src);
int ds_id = DataStoreUser.getInstance()
.getDataSourceManager().addDataSource(src);
DataStoreUser.getInstance().getSockeyeTrackList()
.addDataSourceId(track_id, ds_id);
} catch (IllegalArgumentException f) {
}
DataStoreUser.getInstance().getSockeyeTrackList()
.setTrackDataWindow(track_id, feature.getStart(),
feature.getEnd());
DataStoreUser.getInstance().getSockeyeTrackList()
.changeTrackOffsetBy(
track_id,
feature.getStart()
- DataStoreUser.getInstance()
.getSockeyeTrackList()
.getTrackDataWindowStart(t_id));
DataStoreUser.getInstance().getSockeyeTrackList()
.setTrackVisibility(track_id, true);
CopyOperation copy_op = new CopyOperation();
TrackManagerFactory.getInstance().addTrack(copy_op, track_id);
int[] parents = new int[1];
parents[0] = t_id;
TrackManagerFactory.getInstance()
.addOperation(copy_op, parents);
}
});
return part_track;
}
private JMenuItem createStoreRegionMenuItem() {
JMenuItem mark_region = new JMenuItem("Mark this region");
if (OptionsDialog.__showPopupIcons) {
mark_region.setIcon(Configuration.popupFTreeSelect_icon);
}
mark_region.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
int start = feature.getStart();
int end = feature.getEnd();
String track_name = DataStoreUser.getInstance()
.getSockeyeTrackList().getTrackAttribute(track_id,
"track_name").toString();
String region_id = track_name.split(":")[0];
region_id = region_id.concat(new String(":" + start + ".."
+ end));
TrackFeature region = new TrackFeature(region_id, track_name,
"region", start, end, GFFTools.NO_SCORE, 0,
GFFTools.NO_FRAME);
region.setAccessionID(region_id);
region.setTrackId(track_id);
MainFrame.getVis3D().removeSelection();
DataStoreUser.getInstance().getSockeyeTrackList().addFeature(
track_id, "region", region);
DataStoreUser.getInstance().getSockeyeTrackList()
.setFeatureVisibility(track_id, "region", region_id,
true);
}
});
return mark_region;
}
private void align(String align_type) {
for (int i = 0; i < features.size(); i++) {
int region_id = ((TrackFeature) features.get(i)).getTrackId();
if (DataStoreUser.getInstance().getDataSourceManager()
.getTrackDatabases(region_id).isEmpty()
&& !DataStoreUser.getInstance().getSockeyeTrackList()
.getTrackHasFeature(region_id, "sequence")) {
String name = StringUtils.getShortNameForTrackID(region_id);
String msg = "The track " + name
+ " has no available nucleotide sequence data.";
JOptionPane.showMessageDialog(this, msg,
"Alignment not available", JOptionPane.ERROR_MESSAGE);
return;
}
}
DataSource ads;
if (align_type.equals(AlignmentDataSource.ALIGNMENT_APP_TYPE)) {
ads = ChinookDataSourceFactoryMaker.getFactory().getAlignmentDS(
features);
} else {
ads = ChinookDataSourceFactoryMaker.getFactory().getRAlignmentDS(
features);
}
if (ads == null) {
return;
}
DataStoreUser.getInstance().getDataSourceManager().addDataSource(ads);
DataStoreUser.getInstance().getSockeyeTrackList().addStorageListener(
ads);
List event_attrib = new ArrayList();
event_attrib.add(new Integer(ads.getTrack()));
event_attrib.add(new Integer(feature.getStart()));
event_attrib.add(new Integer(feature.getEnd()));
event_attrib.add(align_type);
((SockeyeTrackList) DataStoreUser.getInstance().getSockeyeTrackList())
.triggerEvent(StorageEvent.STORAGE_EVENT_TRACK_DATA_REQUEST,
event_attrib);
}
private void line_up(int where) {
for (int i = 0; i < features.size(); i++) {
TrackFeature f = (TrackFeature) features.get(i);
DataStoreUser.getInstance().getSockeyeTrackList().setToFeature(f,
(where == -1 || where == 0), (where == 1 || where == 0), 0);
}
for (int i = 1; i < features.size(); i++) {
TrackFeature f = (TrackFeature) features.get(i);
int delta = getLocation(feature, where) - getLocation(f, where);
DataStoreUser.getInstance().getSockeyeTrackList()
.changeTrackOffsetBy(f.getTrackId(), delta);
}
}
private void centre_in_window() {
int feature_centre = (feature.getStart() + feature.getEnd()) / 2;
int track_id = feature.getTrackId();
int t_start = DataStoreUser.getInstance().getSockeyeTrackList()
.getTrackDataWindowStart(track_id);
int t_end = DataStoreUser.getInstance().getSockeyeTrackList()
.getTrackDataWindowEnd(track_id);
int track_centre = (t_start + t_end) / 2;
int shift = track_centre - feature_centre;
MoveActionAdaptor.move(track_id, shift, false);
}
private int getLocation(TrackFeature feature, int where) {
int t_id = feature.getTrackId();
int t_start = DataStoreUser.getInstance().getSockeyeTrackList()
.getTrackDataWindowStart(t_id);
int f_start = feature.getStart();
int f_end = feature.getEnd();
int strand = feature.getStrand().getValue();
int loc5p, loc3p;
if (strand != -1) {
loc5p = f_start - t_start;
loc3p = f_end - t_start;
} else {
loc5p = f_end - t_start;
loc3p = f_start - t_start;
}
int loc;
if (where == -1) {
loc = loc5p;
} else if (where == 1) {
loc = loc3p;
} else {
loc = (loc3p + loc5p) / 2;
}
boolean rev = DataStoreUser.getInstance().getSockeyeTrackList()
.getTrackReverse(t_id);
if (rev) {
int t_length = DataStoreUser.getInstance().getSockeyeTrackList()
.getTrackDataWindowLength(t_id);
loc = t_length - loc;
}
loc += DataStoreUser.getInstance().getSockeyeTrackList()
.getTrackOffset(t_id);
return loc;
}
private void setMultiDistributionPopup() {
String title = (String) feature.getAttribute("display_string");
if (title == null || title.equals("")) {
title = "New Multi-Distribution Feature";
}
this.addTitle(title);
this.addSeparator();
final int trackID = feature.getTrackId();
final SCProfileList profiles = align_op.get3DSubalignment()
.getSCProfileList();
if (profiles != null) {
JMenu settings = new JMenu("Info...");
this.add(settings);
JTable tab = new JTable();
tab.setModel(new DefaultTableModel(6, 2) {
public boolean isCellEditable(int row, int column) {
return false;
}
});
tab.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
tab.setOpaque(false);
tab.setValueAt("Column Scoring Method: ", 0, 0);
tab.setValueAt(profiles.getColScoreMethod(), 0, 1);
tab.setValueAt("Match/Mismatch Matrix: ", 1, 0);
tab.setValueAt(profiles.getDMatrixName(), 1, 1);
tab.setValueAt("Sequence Relationship: ", 2, 0);
tab.setValueAt(profiles.getTrackRelationship().getType(), 2, 1);
tab.setValueAt("Window Smoothing: ", 3, 0);
tab.setValueAt(profiles.getSmoothingMethod(), 3, 1);
tab.setValueAt("Window Size: ", 4, 0);
tab.setValueAt(profiles.getWindowSize() + "bp", 4, 1);
tab.setValueAt("Max Bin Resolution: ", 5, 0);
tab.setValueAt("" + SCProfileList.__MAX_BIN_RESOLUTION, 5, 1);
TableColumn c = tab.getColumnModel().getColumn(1);
c.setPreferredWidth(20);
c.setMinWidth(130);
c = tab.getColumnModel().getColumn(0);
c.setPreferredWidth(5);
c.setMinWidth(160);
settings.add(tab);
}
this.addSeparator();
JMenuItem showAlign = new JMenuItem("Export/2D View...");
if (OptionsDialog.__showPopupIcons) {
showAlign.setIcon(Configuration.popupSeqExtr_icon);
}
this.add(showAlign);
showAlign.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
new SingleAlignmentDialog(Sockeye.__frame, align_op
.get3DSubalignment(), align_op.getAnchors(), trackID);
}
});
JMenuItem m_align_scprofile = new JMenuItem("Profile settings...");
this.add(m_align_scprofile);
m_align_scprofile.addActionListener(new ActionListener() {
public void actionPerformed(java.awt.event.ActionEvent e) {
try {
SCProfileDialog sc_dialog = new SCProfileDialog(align_op
.get3DSubalignment());
} catch (Exception ex) {
Log.printStackTrace(ex);
}
}
});
}
private void setDistributionPopup() {
TrackDistribution td = (TrackDistribution) feature;
this.setLightWeightPopupEnabled(false);
JTable tab = new JTable();
List dist = td.getDistributionInfo();
JScrollPane scrollPane = new JScrollPane(tab);
JMenuItem rebin = new JMenuItem("Re-bin this track");
JMenu distMenu = new JMenu("Show distribution values...");
JMenuItem opt = new JMenuItem("Options...");
int sum = 0;
double valActive = 0;
tab.setModel(new DefaultTableModel(new String[] { "Start", "End",
"Score" }, dist.size()) {
public boolean isCellEditable(int row, int column) {
return false;
}
});
for (int i = 0; i < dist.size(); i++) {
int start = ((DistributionContainer) dist.get(i)).getStart();
int end = ((DistributionContainer) dist.get(i)).getEnd() - 1;
double score = ((DistributionContainer) dist.get(i)).getScore();
tab.setValueAt(Integer.toString(start), i, 0);
tab.setValueAt(Integer.toString(end), i, 1);
tab.setValueAt(Double.toString(score), i, 2);
sum += score;
if (start <= baseClickedOnTrack && baseClickedOnTrack < end) {
valActive = score;
tab.changeSelection(i, 0, false, false);
tab.changeSelection(i, 2, false, true);
}
}
opt.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
OptionsDialog opt_dlg = new OptionsDialog(Sockeye.__frame, 2);
}
});
rebin.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
TrackReBinDialog reb_dlg = new TrackReBinDialog(
Sockeye.__frame, true);
List ds_list = DataStoreUser.getInstance()
.getSockeyeTrackList().getDataSources(track_id);
Iterator ds_it = ds_list.iterator();
EnsemblDataSource ensembl_ds = null;
while (ds_it.hasNext()) {
DataSource ds = DataStoreUser.getInstance()
.getDataSourceManager().getDataSource(
Integer.parseInt(ds_it.next().toString()));
if (ds instanceof EnsemblDataSource) {
ensembl_ds = (EnsemblDataSource) ds;
break;
}
}
if (ensembl_ds == null) {
return;
}
reb_dlg.setBinSizeMetricValues(SemanticZoomManager
.getBinSizeMetricNames(), 1);
reb_dlg.setBinSizeValue((int) (DataStoreUser.getInstance()
.getSockeyeTrackList().getTrackDataWindowLength(
track_id) / ensembl_ds.getSZBinLength()));
reb_dlg.setTrackLength(DataStoreUser.getInstance()
.getSockeyeTrackList().getTrackDataWindowLength(
track_id));
reb_dlg.show();
if (reb_dlg.getBinSizeValue() > 0) {
boolean do_rebin = true;
int confirm = JOptionPane.NO_OPTION;
if ((DataStoreUser.getInstance().getSockeyeTrackList()
.getTrackInternalStorageLength(track_id) / reb_dlg
.getBinSizeValue()) > 15000) {
if ((DataStoreUser.getInstance().getSockeyeTrackList()
.getTrackDataWindowLength(track_id) / reb_dlg
.getBinSizeValue()) > 5000) {
Object options[] = { "Cancel", "Proceed" };
confirm = JOptionPane
.showOptionDialog(
Sockeye.__frame,
"This rebin-operation will possibly lead to a memory overflow\n"
+ "unpredicted behaviour and long query times.\n"
+ "Proceeding is not recommended!\n",
"Good luck!",
JOptionPane.YES_NO_OPTION,
JOptionPane.QUESTION_MESSAGE, null,
options, options[0]);
switch (confirm) {
case JOptionPane.YES_OPTION:
do_rebin = false;
break;
case JOptionPane.CANCEL_OPTION:
break;
}
} else {
Object options[] = { "Crop the track", "Proceed",
"Cancel" };
confirm = JOptionPane
.showOptionDialog(
Sockeye.__frame,
"This rebin-operation will possibly lead to a memory overflow and long query times.\n"
+ "Proceeding is not recommended.\nThe best choice is to either crop the internal track buffer\n"
+ "to the current window size or to leave the bin size as it is!",
"Good luck!",
JOptionPane.YES_NO_CANCEL_OPTION,
JOptionPane.QUESTION_MESSAGE, null,
options, options[0]);
switch (confirm) {
case JOptionPane.YES_OPTION:
DataStoreUser.getInstance()
.getSockeyeTrackList().cropTrack(
track_id);
break;
case JOptionPane.NO_OPTION:
break;
case JOptionPane.CANCEL_OPTION:
do_rebin = false;
break;
}
}
}
if (do_rebin) {
ensembl_ds.setSZBinLength(reb_dlg.getBinSizeValue(),
confirm == JOptionPane.YES_OPTION);
}
}
}
});
tab
.setPreferredScrollableViewportSize(new java.awt.Dimension(200,
100));
distMenu.add(scrollPane);
this.addTitle("Distribution for feature: " + td.getFeature());
this.addSeparator();
this.addInfo("# of bins with score gt zero: " + dist.size());
this.addInfo("Sum of all bin scores: " + sum);
this.addInfo("Maximum score in this distribution: " + td.getMaxScore());
this.addInfo("Score at this position: " + valActive);
this.addSeparator();
this.add(rebin);
this.add(distMenu);
this.add(opt);
}
private void setPopupIcons() {
m_alt_viewer.setIcon(Configuration.popupAltView_icon);
m_transcripts.setIcon(Configuration.popupTrans_icon);
m_gsc_homologues.setIcon(Configuration.popupHomolog_icon);
m_sequence.setIcon(Configuration.popupSeqExtr_icon);
m_findseq.setIcon(Configuration.find_icon);
feature_tree.setIcon(Configuration.popupFTreeSelect_icon);
m_centre_in_window.setIcon(Configuration.popupCentre_icon);
m_coexpressedGenes.setIcon(Configuration.microArray);
content.setIcon(Configuration.popupNucContent);
m_mark_region.setIcon(Configuration.popupMarkRegion);
m_line_up.setIcon(Configuration.popupLineUp);
export_to_multi_fasta.setIcon(Configuration.popupExport);
export_to_multi_fasta.setIconTextGap(export_to_multi_fasta
.getIconTextGap() + 5);
m_align.setIcon(Configuration.popupAlign);
m_delete.setIcon(Configuration.popupDelete);
delete.setIcon(Configuration.popupDelete);
zoom_to_region.setIcon(Configuration.popupZoom);
zoom_to_region.setIconTextGap(zoom_to_region.getIconTextGap() + 4);
m_scan_TFBS.setIcon(Configuration.popupScan);
m_gff_attributes.setIcon(Configuration.info_icon);
}
private void clearUp() {
m_alt_viewer.removeAll();
m_description.removeAll();
m_transcripts.removeAll();
m_gsc_homologues.removeAll();
m_gff_attributes.removeAll();
m_sequence.removeAll();
m_mark_region.removeAll();
m_line_up.removeAll();
}
private static String abbreviate(String str) {
String abbr = new String(str);
return abbr;
}
private void exportFASTA_actionPerformed(List t_features, boolean reversed) {
String file_name = StringUtils.getShortNameForTrackID(track_id);
file_name = file_name.replaceAll("\\W", "_");
file_name = file_name.replaceAll("__", "_");
file_name = Configuration.getUserPath() + file_name + ".fasta";
SockeyeFileChooser export_toFASTA_dialog = SockeyeFileChooser
.getSockeyeFileChooser("FASTAExport");
export_toFASTA_dialog.setDialogTitle("Save Sequences As...");
int result = export_toFASTA_dialog.showSaveDialog(Sockeye.__frame,
"fasta", new File(file_name));
try {
file_name = export_toFASTA_dialog.getSelectedFile()
.getCanonicalPath();
} catch (java.io.IOException ex) {
Log.printStackTrace(ex);
System.out.println("Cannot handle file!!!!!");
return;
}
if (result == JFileChooser.APPROVE_OPTION) {
FASTAExporter.exportToMultiFASTA(t_features, file_name,
(reversed ? -1 : 1));
}
}
private class CoexpressedFiller extends SockeyeThreadedMenuFiller {
TrackFeature _gene;
CoexpressedFiller(TrackFeature gene, JMenu jm) {
super(jm);
_gene = gene;
}
public void fillMenu() {
final int gene_start = _gene.getStart();
int track_id = _gene.getTrackId();
int original_track_start = DataStoreUser.getInstance()
.getSockeyeTrackList().getTrackDataWindowStart(track_id);
final int original_track_length = DataStoreUser.getInstance()
.getSockeyeTrackList().getTrackDataWindowLength(track_id);
final int track_start_offset = gene_start - original_track_start;
String[] coexpressedDatabase = getCoexpressedDatabaseForTrackDatabase(_database);
Map lmCoexpressed = null;
try {
lmCoexpressed = getCoexpressed(_gene.getAccessionID(),
coexpressedDatabase);
} catch (CoexpressionServiceException e1) {
_menu_to_fill.setText("Co-expressed data not available");
_menu_to_fill.setEnabled(false);
return;
}
Iterator it = lmCoexpressed.keySet().iterator();
int n_coexpressedGenes = lmCoexpressed.size();
int count = 0;
int fracDigits = score_format.getMinimumFractionDigits();
score_format.setMinimumFractionDigits(3);
while (it.hasNext() && count++ < _POP_UP_COEXPRESSION_LIMIT) {
final String coexpressed_gene_id = (String) it.next();
final HitGeneInfo cgi = new HitGeneInfo(_database, _species,
coexpressed_gene_id, getConnection());
final Float score = (Float) lmCoexpressed
.get(coexpressed_gene_id);
JMenu m_coexpressed_gene_id = new JMenu(coexpressed_gene_id
+ " (" + score_format.format(score) + ")");
JMenuItem m_ce_title = new JMenuItem();
m_ce_title.setText("Gene: " + coexpressed_gene_id);
m_ce_title.setBackground(Color.white);
m_ce_title.setForeground(Color.blue);
m_coexpressed_gene_id.add(m_ce_title);
JMenuItem m_ce_loc = new JMenuItem();
m_ce_loc.setText(coordinates(cgi.getHitChrom(), cgi
.getHitGeneStart(), cgi.getHitGeneEnd(), cgi
.getHitGeneStrand()));
m_ce_loc.setBackground(Color.white);
m_coexpressed_gene_id.add(m_ce_loc);
m_coexpressed_gene_id.addSeparator();
JMenuItem m_get_coexpressed_gene = new JMenuItem(
"Get coexpressed gene");
m_coexpressed_gene_id.add(m_get_coexpressed_gene);
m_get_coexpressed_gene.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
HitTrackInfo info = new HitTrackInfo(cgi,
track_start_offset, original_track_length,
HitTrackInfo.COEXPRESSED_TYPE);
info.setAttribute("PearsonScore", score);
displayHit(info);
}
});
_menu_to_fill.add(m_coexpressed_gene_id);
}
score_format.setMinimumFractionDigits(fracDigits);
JMenu m_multiselect = null;
if (n_coexpressedGenes > 1) {
m_multiselect = new JMenu();
m_multiselect.setText("Get Multiple");
int idx = 2, inc = 1;
boolean gotLast = false;
while (idx <= n_coexpressedGenes) {
JMenuItem item = new JMenuItem("Top " + idx);
final Map geneList = lmCoexpressed;
final int idx_limit = idx;
item.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
Iterator it = geneList.keySet().iterator();
int num = 0;
while (it.hasNext() && num++ < idx_limit) {
String coexpressed_gene_id = (String) it.next();
final HitGeneInfo cgi = new HitGeneInfo(
_database, _species,
coexpressed_gene_id, getConnection());
Float score = (Float) geneList
.get(coexpressed_gene_id);
HitTrackInfo info = new HitTrackInfo(cgi,
track_start_offset,
original_track_length,
HitTrackInfo.COEXPRESSED_TYPE);
info.setAttribute("PearsonScore", score);
displayHit(info);
}
}
});
m_multiselect.add(item);
if (idx == n_coexpressedGenes) {
gotLast = true;
}
idx += inc;
if (idx > 100 && inc == 10) {
idx = 150;
inc = 50;
} else if (idx > 50 && inc == 5) {
idx = 60;
inc = 10;
} else if (idx > 10 && inc == 1) {
idx = 15;
inc = 5;
}
if (!gotLast && idx > n_coexpressedGenes) {
idx = n_coexpressedGenes;
}
}
}
if (m_multiselect != null) {
_menu_to_fill.add(m_multiselect);
}
_menu_to_fill.setText(new String("Co-expressed genes ("
+ n_coexpressedGenes + ")"));
if (n_coexpressedGenes == 0) {
_menu_to_fill.setEnabled(false);
}
}
}
static private FeatureLoaderService getFeatureLoaderService() {
FeatureLoaderServiceFactory fac = FeatureLoaderServiceFactory
.getInstance();
Service service = Configuration
.getService(FeatureLoaderServiceFactory.FEATURELOADER_SERVICES);
String mode = null;
String remotehost = null;
if (service != null) {
mode = service.getMode();
remotehost = service.getRemotehost();
} else {
throw new RuntimeException(
"Feature loader service not set up properly.");
}
FeatureLoaderService ser = fac.getService(mode, remotehost);
return ser;
}
private class GscHomologFiller extends SockeyeThreadedMenuFiller {
TrackFeature _gene;
Hashtable hit_track_info_table = new Hashtable();
int track_start_offset;
GscHomologFiller(TrackFeature gene, JMenu jm) {
super(jm);
_gene = gene;
}
private String getFullSpeciesName(String databaseName) {
String[] token = databaseName.split("_");
if (token.length == 5)
return (token[0] + " " + token[1]);
return null;
}
public void fillMenu() {
Connection connection = DataStoreUser.getInstance()
.getDataSourceManager().getTrackEnsemblConnection(
_gene.getTrackId());
if (connection == null)
connection = ConnectionManager.getCurrentConnection("Ensembl");
List supportedDb = HomologSource.getSupportedEnsemblDatabases();
boolean loadFromGscDb = false;
if (supportedDb != null) {
for (Iterator itr = supportedDb.iterator(); itr.hasNext();) {
String db = (String) itr.next();
String[] token = db.split("_");
if (token.length != 3) {
break;
}
String species = token[0] + "_" + token[1];
String version = token[2];
if ((_database.indexOf(species) != -1)
&& (_database.indexOf(version) != -1)) {
loadFromGscDb = true;
}
}
}
Map homologueMap = null;
if (loadFromGscDb) {
Service service = Configuration
.getService(HomologServiceFactory.HOMOLOG_SERVICE);
String mode = null;
String remotehost = null;
if (service != null) {
mode = service.getMode();
remotehost = service.getRemotehost();
HomologService ser = HomologServiceFactory.getInstance()
.getService(mode, remotehost);
homologueMap = ser.getHomologueGeneId(
getFullSpeciesName(_database), _gene
.getAccessionID());
} else {
System.err
.println("Homology Service definition error (is null)");
System.err.println("Try local mode...");
HomologService ser = HomologServiceFactory.getInstance()
.getService("local", "");
homologueMap = ser.getHomologueGeneId(
getFullSpeciesName(_database), _gene
.getAccessionID());
}
} else {
FeatureLoaderService ensemblSer = getFeatureLoaderService();
homologueMap = ensemblSer.getRelatedFeatureIDs(connection,
_database, _species, HOMOLOGUE_GENE_RELATIONSHIP_MAP,
_gene.getAccessionID());
}
if (homologueMap == null) {
homologueMap = new HashMap();
}
Iterator it = homologueMap.keySet().iterator();
while (it.hasNext()) {
String key = (String) it.next();
String subgroup = RelationshipMapUtil.extractSubGroup(key);
Object homologueIdList = homologueMap.get(key);
if (homologueIdList instanceof List) {
List homologList = (List) homologueMap.get(key);
if ((homologList != null) && (!homologList.isEmpty())) {
_gene.setAttribute(subgroup, homologList.subList(0, 1));
}
} else if (homologueIdList instanceof Map)
_gene.setAttribute(subgroup, RelationshipMapUtil
.getListFromMap((Map) homologueMap.get(key)));
}
final int gene_start = _gene.getStart();
int track_id = _gene.getTrackId();
int original_track_start = DataStoreUser.getInstance()
.getSockeyeTrackList().getTrackDataWindowStart(track_id);
int original_track_length = DataStoreUser.getInstance()
.getSockeyeTrackList().getTrackDataWindowLength(track_id);
track_start_offset = gene_start - original_track_start;
Object[] hit_species_array = EnsemblDBListManager
.getAllEnsemblSpeciesNames(_ensembl_version, connection)
.toArray();
Object[] hit_species_array_sorted;
try {
hit_species_array_sorted = SequenceMatrix
.getPhyloDistanceMatrix(SequenceMatrix.BTYPE2)
.getSpeciesRelation(hit_species_array, _species);
} catch (Exception e) {
Log.printStackTrace(e);
hit_species_array_sorted = new Object[0];
}
int n_homologues = 0;
final Hashtable h = new Hashtable();
for (int s = 0; s < hit_species_array_sorted.length; s++) {
String hit_species = hit_species_array_sorted[s].toString();
List homologues = _gene.getGroupAttribute(hit_species.replace(
' ', '_'));
if (homologues != null && !homologues.isEmpty()) {
h.put(hit_species, homologues);
JMenu m_species = new JMenu(hit_species);
_menu_to_fill.add(m_species);
for (int i = 0; i < homologues.size(); i++) {
final String hit_id = (String) homologues.get(i);
final HitGeneInfo hi = (CachedOrthologuesInfo
.getHitGeneInfo(hit_species, hit_id) != null) ? (HitGeneInfo) CachedOrthologuesInfo
.getHitGeneInfo(hit_species, hit_id)
: new HitGeneInfo(_database, hit_species,
hit_id, getConnection());
CachedOrthologuesInfo.putHitGeneInfo(hit_species,
hit_id, hi);
JMenu m_hit_id = new JMenu(hit_id);
JMenuItem m_hit_title = new JMenuItem();
m_hit_title.setText("Gene: " + hit_id);
m_hit_title.setBackground(Color.white);
m_hit_title.setForeground(Color.blue);
m_hit_id.add(m_hit_title);
JMenuItem m_hit_loc = new JMenuItem();
m_hit_loc.setText(coordinates(hi.getHitChrom(), hi
.getHitGeneStart(), hi.getHitGeneEnd(), hi
.getHitGeneStrand()));
m_hit_loc.setBackground(Color.white);
m_hit_id.add(m_hit_loc);
hit_track_info_table.put(hit_id, hi);
String description = hi.getHitDescription();
if (!description.equals("")) {
JMenuItem m_description = new JMenuItem();
m_description.setBackground(Color.WHITE);
m_hit_id.add(m_description);
m_description.setText(description);
JMenuItem m_source = new JMenuItem(hi
.getHitSource());
m_source.setBackground(Color.WHITE);
m_hit_id.add(m_source);
}
m_hit_id.addSeparator();
JMenuItem m_get_hit = new JMenuItem("Get orthologue");
m_hit_id.add(m_get_hit);
m_get_hit.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
m_get_hit_actionPerformed(hit_id, hi);
}
});
m_species.add(m_hit_id);
hit_info.put(hit_id, hi);
}
n_homologues += homologues.size();
}
}
JMenuItem m_all = new JMenuItem("Get all orthologues");
if (n_homologues != 0) {
this._menu_to_fill.addSeparator();
this._menu_to_fill.add(m_all);
}
m_all.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
Iterator hit = h.keySet().iterator();
while (hit.hasNext()) {
String hit_species = hit.next().toString();
List hit_ids = (List) h.get(hit_species);
for (int i = 0; i < hit_ids.size(); i++) {
String hit_id = (String) hit_ids.get(i);
HitTrackInfo hit_track_info = new HitTrackInfo(
(HitGeneInfo) hit_track_info_table
.get(hit_id), track_start_offset,
DataStoreUser.getInstance()
.getSockeyeTrackList()
.getTrackDataWindowLength(
_gene.getTrackId()),
HitTrackInfo.HOMOLOGOUS_TYPE);
displayHit(hit_track_info);
}
}
}
});
if (n_homologues == 0) {
this._menu_to_fill.setEnabled(false);
}
this._menu_to_fill.setText(new String("Get orthologues ("
+ n_homologues + ")"));
}
private void m_get_hit_actionPerformed(String hit_id, HitGeneInfo hi) {
HitTrackInfo hit_track_info = new HitTrackInfo(hi,
track_start_offset, DataStoreUser.getInstance()
.getSockeyeTrackList().getTrackDataWindowLength(
_gene.getTrackId()),
HitTrackInfo.HOMOLOGOUS_TYPE);
displayHit(hit_track_info);
}
}
private class HomologFiller extends SockeyeThreadedMenuFiller {
TrackFeature _gene;
Hashtable hit_track_info_table = new Hashtable();
int track_start_offset;
HomologFiller(TrackFeature gene, JMenu jm) {
super(jm);
_gene = gene;
}
public void fillMenu() {
FeatureLoaderService ser = getFeatureLoaderService();
Connection connection = DataStoreUser.getInstance()
.getDataSourceManager().getTrackEnsemblConnection(
_gene.getTrackId());
if (connection == null)
connection = ConnectionManager.getCurrentConnection("Ensembl");
Map homologueMap = ser.getRelatedFeatureIDs(connection, _database,
_species, HOMOLOGUE_GENE_RELATIONSHIP_MAP, _gene
.getAccessionID());
Iterator it = homologueMap.keySet().iterator();
while (it.hasNext()) {
String key = (String) it.next();
String subgroup = RelationshipMapUtil.extractSubGroup(key);
_gene.setAttribute(subgroup, RelationshipMapUtil
.getListFromMap((Map) homologueMap.get(key)));
}
final int gene_start = _gene.getStart();
int track_id = _gene.getTrackId();
int original_track_start = DataStoreUser.getInstance()
.getSockeyeTrackList().getTrackDataWindowStart(track_id);
int original_track_length = DataStoreUser.getInstance()
.getSockeyeTrackList().getTrackDataWindowLength(track_id);
track_start_offset = gene_start - original_track_start;
Object[] hit_species_array = EnsemblDBListManager
.getAllEnsemblSpeciesNames(_ensembl_version, connection)
.toArray();
Object[] hit_species_array_sorted;
try {
hit_species_array_sorted = SequenceMatrix
.getPhyloDistanceMatrix(SequenceMatrix.BTYPE2)
.getSpeciesRelation(hit_species_array, _species);
} catch (Exception e) {
Log.printStackTrace(e);
hit_species_array_sorted = new Object[0];
}
int n_homologues = 0;
final Hashtable h = new Hashtable();
for (int s = 0; s < hit_species_array_sorted.length; s++) {
String hit_species = hit_species_array_sorted[s].toString();
List homologues = _gene.getGroupAttribute(hit_species.replace(
' ', '_'));
if (homologues != null && !homologues.isEmpty()) {
h.put(hit_species, homologues);
JMenu m_species = new JMenu(hit_species);
_menu_to_fill.add(m_species);
for (int i = 0; i < homologues.size(); i++) {
final String hit_id = (String) homologues.get(i);
final HitGeneInfo hi = (CachedOrthologuesInfo
.getHitGeneInfo(hit_species, hit_id) != null) ? (HitGeneInfo) CachedOrthologuesInfo
.getHitGeneInfo(hit_species, hit_id)
: new HitGeneInfo(_database, hit_species,
hit_id, getConnection());
CachedOrthologuesInfo.putHitGeneInfo(hit_species,
hit_id, hi);
JMenu m_hit_id = new JMenu(hit_id);
JMenuItem m_hit_title = new JMenuItem();
m_hit_title.setText("Gene: " + hit_id);
m_hit_title.setBackground(Color.white);
m_hit_title.setForeground(Color.blue);
m_hit_id.add(m_hit_title);
JMenuItem m_hit_loc = new JMenuItem();
m_hit_loc.setText(coordinates(hi.getHitChrom(), hi
.getHitGeneStart(), hi.getHitGeneEnd(), hi
.getHitGeneStrand()));
m_hit_loc.setBackground(Color.white);
m_hit_id.add(m_hit_loc);
hit_track_info_table.put(hit_id, hi);
String description = hi.getHitDescription();
if (!description.equals("")) {
JMenuItem m_description = new JMenuItem();
m_description.setBackground(Color.WHITE);
m_hit_id.add(m_description);
m_description.setText(description);
JMenuItem m_source = new JMenuItem(hi
.getHitSource());
m_source.setBackground(Color.WHITE);
m_hit_id.add(m_source);
}
m_hit_id.addSeparator();
JMenuItem m_get_hit = new JMenuItem("Get orthologue");
m_hit_id.add(m_get_hit);
m_get_hit.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
m_get_hit_actionPerformed(hit_id, hi);
}
});
m_species.add(m_hit_id);
hit_info.put(hit_id, hi);
}
n_homologues += homologues.size();
}
}
JMenuItem m_all = new JMenuItem("Get all orthologues");
if (n_homologues != 0) {
this._menu_to_fill.addSeparator();
this._menu_to_fill.add(m_all);
}
m_all.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
Iterator hit = h.keySet().iterator();
while (hit.hasNext()) {
String hit_species = hit.next().toString();
ArrayList hit_ids = (ArrayList) h.get(hit_species);
for (int i = 0; i < hit_ids.size(); i++) {
String hit_id = (String) hit_ids.get(i);
HitTrackInfo hit_track_info = new HitTrackInfo(
(HitGeneInfo) hit_track_info_table
.get(hit_id), track_start_offset,
DataStoreUser.getInstance()
.getSockeyeTrackList()
.getTrackDataWindowLength(
_gene.getTrackId()),
HitTrackInfo.HOMOLOGOUS_TYPE);
displayHit(hit_track_info);
}
}
}
});
if (n_homologues == 0) {
this._menu_to_fill.setEnabled(false);
}
this._menu_to_fill.setText(new String("EnsEMBL orthologues ("
+ n_homologues + ")"));
}
private void m_get_hit_actionPerformed(String hit_id, HitGeneInfo hi) {
HitTrackInfo hit_track_info = new HitTrackInfo(hi,
track_start_offset, DataStoreUser.getInstance()
.getSockeyeTrackList().getTrackDataWindowLength(
_gene.getTrackId()),
HitTrackInfo.HOMOLOGOUS_TYPE);
displayHit(hit_track_info);
}
}
}
class SelectedTranscript implements MouseListener {
private String selected_transcript, was_selected_transcript;
int track_id;
TrackFeature gene;
JMenu[] jm;
int selected_index;
public SelectedTranscript(TrackFeature gene, JMenu[] jm,
int selected_index, String selected_transcript) {
this.selected_transcript = selected_transcript;
this.gene = gene;
this.jm = jm;
track_id = gene.getTrackId();
this.selected_index = selected_index;
}
public void mouseClicked(java.awt.event.MouseEvent e) {
was_selected_transcript = gene.getAttribute("selected_transcript");
if (was_selected_transcript.equals("")) {
jm[selected_index].setIcon(Configuration.check);
gene.setAttribute("selected_transcript", selected_transcript);
MainFrame.getVis3D().highlightTranscript(track_id,
getExons(selected_transcript),
getFivePrimeUTR(selected_transcript),
getThreePrimeUTR(selected_transcript));
} else if (was_selected_transcript.equals(selected_transcript)) {
jm[selected_index].setIcon(Configuration.uncheck);
gene.setAttribute("selected_transcript", "");
MainFrame.getVis3D().unHighlightTranscript(track_id,
getExons(selected_transcript),
getFivePrimeUTR(selected_transcript),
getThreePrimeUTR(selected_transcript));
} else {
for (int i = 0; i < jm.length; i++) {
jm[i].setIcon(Configuration.uncheck);
}
MainFrame.getVis3D().unHighlightTranscript(track_id,
getExons(was_selected_transcript),
getFivePrimeUTR(selected_transcript),
getThreePrimeUTR(selected_transcript));
jm[selected_index].setIcon(Configuration.check);
gene.setAttribute("selected_transcript", selected_transcript);
MainFrame.getVis3D().highlightTranscript(track_id,
getExons(selected_transcript),
getFivePrimeUTR(selected_transcript),
getThreePrimeUTR(selected_transcript));
}
}
ArrayList getExons(String transcript_id) {
List exons = gene.getGroupAttribute("exons");
Set exons_set = new TreeSet(exons);
exons = new ArrayList(exons_set);
ArrayList exons_for_transcript = new ArrayList();
for (int i = 0; i < exons.size(); i++) {
String exon_id = (String) exons.get(i);
TrackFeature exon = DataStoreUser.getInstance()
.getSockeyeTrackList()
.getFeature(track_id, "exon", exon_id);
if (exon.getGroupAttribute("transcripts").contains(transcript_id)) {
exons_for_transcript.add(exon_id);
}
}
return exons_for_transcript;
}
ArrayList getFivePrimeUTR(String transcript_id) {
ArrayList five_prime_UTR_for_transcript = new ArrayList();
Collection all_5_primes = DataStoreUser.getInstance()
.getSockeyeTrackList().getFeatures(track_id, "5'UTR");
if (all_5_primes == null || all_5_primes.isEmpty()) {
return five_prime_UTR_for_transcript;
}
Object[] fpUTRs = all_5_primes.toArray();
for (int i = 0; i < fpUTRs.length; i++) {
String t_id = ((TrackFeature) fpUTRs[i]).getAttribute("transcript");
if (t_id.equals(transcript_id)) {
five_prime_UTR_for_transcript.add((TrackFeature) fpUTRs[i]);
}
}
return five_prime_UTR_for_transcript;
}
ArrayList getThreePrimeUTR(String transcript_id) {
ArrayList three_prime_UTR_for_transcript = new ArrayList();
Collection all_3_primes = DataStoreUser.getInstance()
.getSockeyeTrackList().getFeatures(track_id, "3'UTR");
if (all_3_primes == null || all_3_primes.isEmpty()) {
return three_prime_UTR_for_transcript;
}
Object[] tpUTRs = all_3_primes.toArray();
for (int i = 0; i < tpUTRs.length; i++) {
String t_id = ((TrackFeature) tpUTRs[i]).getAttribute("transcript");
if (t_id.equals(transcript_id)) {
three_prime_UTR_for_transcript.add((TrackFeature) tpUTRs[i]);
}
}
return three_prime_UTR_for_transcript;
}
public void mouseEntered(MouseEvent e) {
}
public void mouseExited(MouseEvent e) {
}
public void mousePressed(MouseEvent e) {
}
public void mouseReleased(MouseEvent e) {
}
}/*------
package ca.bcgsc.sockeye.popup;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.JPopupMenu;
import javax.swing.JMenuItem;
import java.util.*;
import ca.bcgsc.sockeye.datastorage.*;
public class FeatureTreePopup extends JPopupMenu implements ActionListener {
public static final int SHOW_SUPERSETS = 0;
public static final int HIDE_SUPERSETS = 1;
public static final int HIGHLIGHT = 2;
public static final int NONE = -1;
private int _action = -1;
private String _my_feature;
private JMenuItem _mi_show_super = new JMenuItem("Show supersets");
private JMenuItem _mi_hide_super = new JMenuItem("Hide supersets");
private JMenuItem _mi_highlight = new JMenuItem("Highlight this set");
public FeatureTreePopup(String feature) {
super("Feature set options");
_my_feature = feature;
init();
pack();
}
public int getAction(){
return _action;
}
public void actionPerformed(ActionEvent e){
if (e.getSource() == _mi_show_super){
DataStoreUser.getInstance().getSockeyeTrackList().setFeatureVisibility(getFeatureNamesInSet(_my_feature), true);
return;
}
if (e.getSource() == _mi_hide_super){
DataStoreUser.getInstance().getSockeyeTrackList().setFeatureVisibility(getFeatureNamesInSet(_my_feature), false);
return;
}
if (e.getSource() == _mi_highlight){
return;
}
}
private Collection getFeatureNamesInSet(String set_name){
HashSet s = new HashSet();
Collection c = DataStoreUser.getInstance().getSockeyeTrackList().getFeatures(set_name);
for (Iterator fit = c.iterator(); fit.hasNext();)
s.add( ((TrackFeature)fit.next()).getFeature());
return s;
}
private void init(){
_mi_highlight.setEnabled(false);
_mi_show_super.addActionListener(this);
_mi_hide_super.addActionListener(this);
_mi_highlight.addActionListener(this);
this.add(_mi_show_super);
this.add(_mi_hide_super);
this.addSeparator();
this.add(_mi_highlight);
}
}
package ca.bcgsc.sockeye.popup;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.JMenuItem;
import java.util.ArrayList;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.gui.FindSequenceDialog;
public class FindSequenceMenuItem extends JMenuItem {
private TrackFeature feature = null;
private ArrayList features = null;
public FindSequenceMenuItem() {
super("Find Sequence");
this.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
findSequence_actionPerformed();
}
});
}
public void setFeatureFeatures(TrackFeature feature, ArrayList features) {
this.feature = feature;
this.features = features;
}
void findSequence_actionPerformed() {
FindSequenceDialog.show(this, feature, features);
}
}
package ca.bcgsc.sockeye.popup;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JMenuItem;
import ca.bcgsc.sockeye.dataretrieval.DataSource;
import ca.bcgsc.sockeye.dataretrieval.chinook.McsDataSource;
import ca
.bcgsc
.sockeye
.dataretrieval
.chinookfactory
.ChinookDataSourceFactoryMaker;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.datastorage.SockeyeTrackList;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.datastorage.events.StorageEvent;
public class MCSMenuItem extends JMenuItem {
TrackFeature feature;
ArrayList features;
public MCSMenuItem(TrackFeature feature, ArrayList features) {
super("Multi-species Conserved Sequences");
this.feature = feature;
this.features = features;
this.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
mcsCalculation_actionPerformed();
}
});
}
void mcsCalculation_actionPerformed() {
DataSource mcs_ds =
ChinookDataSourceFactoryMaker.getFactory().getMcsDS(features);
if (mcs_ds == null) {
System.out.println("Cannot create MCSDataSource!!!");
return;
}
DataStoreUser.getInstance().getDataSourceManager().addDataSource(mcs_ds);
DataStoreUser.getInstance().getDataSourceManager().setSingleShotSource(
mcs_ds.getId(),
true);
DataStoreUser.getInstance().getSockeyeTrackList().addStorageListener(
mcs_ds);
DataStoreUser.getInstance().getSockeyeTrackList().addDataSourceId(
mcs_ds.getTrack(),
mcs_ds.getId());
List event_attrib = new ArrayList();
event_attrib.add(new Integer(mcs_ds.getTrack()));
event_attrib.add(new Integer(feature.getStart()));
event_attrib.add(new Integer(feature.getEnd()));
event_attrib.add(McsDataSource.MCS_CALC);
(
(SockeyeTrackList) DataStoreUser
.getInstance()
.getSockeyeTrackList())
.triggerEvent(
StorageEvent.STORAGE_EVENT_TRACK_DATA_REQUEST,
event_attrib);
}
}
package ca.bcgsc.sockeye.popup;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JMenuItem;
import ca.bcgsc.sockeye.dataretrieval.DataSource;
import ca.bcgsc.sockeye.dataretrieval.chinookP2P.MotifDiscoveryP2PDataSource;
import ca.bcgsc.sockeye.dataretrieval.chinookfactory.ChinookDataSourceFactoryMaker;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.datastorage.SockeyeTrackList;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.datastorage.events.StorageEvent;
import ca.bcgsc.sockeye.util.Log;
public class MotifDiscoveryMenuItem
extends JMenuItem {
TrackFeature feature;
ArrayList features;
public MotifDiscoveryMenuItem(TrackFeature feature, ArrayList features) {
super("Discover motifs in regions");
this.feature = feature;
this.features = features;
this.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
discoverMotif_actionPerformed();
}
});
}
void discoverMotif_actionPerformed() {
DataSource motif_ds =
ChinookDataSourceFactoryMaker.getFactory().getMotifDiscoveryDS(features);
if (motif_ds == null){
Log.println("Cannot create MotifDiscoveryDataSource!!!");
return;
}
DataStoreUser.getInstance().getDataSourceManager().addDataSource(motif_ds);
DataStoreUser.getInstance().getDataSourceManager().setSingleShotSource(
motif_ds.getId(), true);
DataStoreUser.getInstance().getSockeyeTrackList().addStorageListener(
motif_ds);
DataStoreUser.getInstance().getSockeyeTrackList().addDataSourceId(
motif_ds.getTrack(), motif_ds.getId());
List event_attrib = new ArrayList();
event_attrib.add(new Integer(motif_ds.getTrack()));
event_attrib.add(new Integer(feature.getStart()));
event_attrib.add(new Integer(feature.getEnd()));
event_attrib.add(MotifDiscoveryP2PDataSource.MOTIF_DISCOVERY);
( (SockeyeTrackList) DataStoreUser.getInstance().getSockeyeTrackList()).
triggerEvent(
StorageEvent.STORAGE_EVENT_TRACK_DATA_REQUEST,
event_attrib);
}
}
package ca.bcgsc.sockeye.popup;
import javax.swing.JOptionPane;
import ca.bcgsc.sockeye.gui.Sockeye;
import ca.bcgsc.sockeye.util.Log;
public class PopupMenuURL implements java.awt.event.ActionListener {
private String url = null;
public PopupMenuURL (String url ) {
this.url = url;
}
public void actionPerformed(java.awt.event.ActionEvent e) {
try {
BrowserLauncher.openURL( url );
} catch (Exception ee) {
Log.printStackTrace(ee);
JOptionPane.showMessageDialog(Sockeye.__frame, "Cannot open Web Browser.",
"Warning", JOptionPane.WARNING_MESSAGE);
}
}
}
package ca.bcgsc.sockeye.popup;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.List;
import java.util.Iterator;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import ca.bcgsc.sockeye.dataretrieval.DataSource;
import ca
.bcgsc
.sockeye
.dataretrieval
.chinookfactory
.ChinookDataSourceFactoryMaker;
import ca.bcgsc.sockeye.dataretrieval.chinook.PrimerPredictionDataSource;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.datastorage.SockeyeTrackList;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.datastorage.events.StorageEvent;
public class PrimerPredictionMenuItem extends JMenuItem {
private TrackFeature feature = null;
private ArrayList features = null;
private String type = "";
public PrimerPredictionMenuItem(String type) {
super(type);
this.type = type;
this.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
primerPrediction_actionPerformed();
}
});
}
public void setFeatureFeatures(TrackFeature feature, ArrayList features) {
this.feature = feature;
this.features = features;
}
void primerPrediction_actionPerformed() {
for (Iterator fit = features.iterator(); fit.hasNext();) {
TrackFeature tf = (TrackFeature) fit.next();
if (tf.getEnd() - tf.getStart() + 1 > 20000) {
JOptionPane.showMessageDialog(
null,
"For primer prediction, please select a target sequence that is under 20 kb.",
"Primer Prediction region too long",
javax.swing.JOptionPane.INFORMATION_MESSAGE);
return;
}
}
DataSource pr_ds =
ChinookDataSourceFactoryMaker.getFactory().getPrimerPredictionDS(
features);
if (pr_ds == null)
return;
DataStoreUser.getInstance().getDataSourceManager().addDataSource(pr_ds);
DataStoreUser.getInstance().getDataSourceManager().setSingleShotSource(
pr_ds.getId(),
true);
DataStoreUser.getInstance().getSockeyeTrackList().addStorageListener(pr_ds);
DataStoreUser.getInstance().getSockeyeTrackList().addDataSourceId(
pr_ds.getTrack(),
pr_ds.getId());
List event_attrib = new ArrayList();
event_attrib.add(new Integer(pr_ds.getTrack()));
event_attrib.add(new Integer(feature.getStart()));
event_attrib.add(new Integer(feature.getEnd()));
event_attrib.add(PrimerPredictionDataSource.PRIMER_PREDICTION);
event_attrib.add(this.type);
(
(SockeyeTrackList) DataStoreUser
.getInstance()
.getSockeyeTrackList())
.triggerEvent(
StorageEvent.STORAGE_EVENT_TRACK_DATA_REQUEST,
event_attrib);
}
}
package ca.bcgsc.sockeye.popup;
import java.awt.Color;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Frame;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.font.FontRenderContext;
import java.awt.font.TextLayout;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import javax.swing.JDialog;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
public class SplicingDialog extends JDialog {
public SplicingDialog(Frame parent, TrackFeature gene) {
super(parent,
new String("Transcripts for " + gene.getAccessionID()),
false);
int length = 800;
SplicingPanel tp = new SplicingPanel(gene, length);
JScrollPane p_splicing = new JScrollPane((JPanel)tp);
Container content_pane = this.getContentPane();
content_pane.add(tp);
tp.repaint();
pack();
setLocationRelativeTo(parent);
setVisible(true);
}
}
class SplicingPanel
extends JPanel {
private static final Color _bg_color = Color.WHITE;
private static final Color _fg_color = Color.BLACK;
private static final Color _exon_color = Color.GREEN;
private static final Color _gene_color = Color.ORANGE;
private static final Color _5pUTR_color = Color.RED;
private static final Color _3pUTR_color = Color.BLUE;
private static final Font _font = new Font("San Serif", Font.PLAIN, 10);
private int _length;
private TrackFeature _gene;
private List _transcripts = new ArrayList();
private List _exons = new ArrayList();
private List _5pUTRs = new ArrayList();
private List _3pUTRs = new ArrayList();
private String[] exons;
public SplicingPanel(TrackFeature gene, int length) {
_gene = gene;
_length = length;
_transcripts = gene.getGroupAttribute("transcripts");
_exons = gene.getGroupAttribute("exons");
setPreferredSize(new Dimension(_length + 40,
35 + _transcripts.size() * 40));
}
public void paintComponent(Graphics g) {
Collection _5pUTRs = DataStoreUser
.getInstance()
.getSockeyeTrackList().getFeatures(_gene.getTrackId(), "5'UTR");
Collection _3pUTRs = DataStoreUser
.getInstance()
.getSockeyeTrackList().getFeatures(_gene.getTrackId(), "3'UTR");
Graphics2D g2;
g2 = (Graphics2D) g;
g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
RenderingHints.VALUE_ANTIALIAS_ON);
g2.setRenderingHint(RenderingHints.KEY_RENDERING,
RenderingHints.VALUE_RENDER_QUALITY);
g2.setColor(_bg_color);
Dimension panel_size = getSize();
g2.fillRect(0, 0, panel_size.width - 1, panel_size.height - 1);
FontRenderContext frc = g2.getFontRenderContext();
int gene_end = _gene.getEnd();
int gene_start = _gene.getStart();
int gene_length = gene_end - gene_start;
double alpha = (double) _length / gene_length;
int y = 25;
int track_id = _gene.getTrackId();
for (int t = 0; t < _transcripts.size(); t++) {
String transcript_id = (String) _transcripts.get(t);
TextLayout tl = new TextLayout(transcript_id, _font, frc);
g2.setColor(_fg_color);
tl.draw(g2, 10, y - 5);
int shift = 100;
g2.setColor(_gene_color);
g2.fillRect(10, y + 5, 800, 10);
for (int e = 0; e < _exons.size(); e++) {
TrackFeature exon = DataStoreUser.getInstance().getSockeyeTrackList().getFeature(track_id, "exon", (String) _exons.get(e));
if (exon.getGroupAttribute("transcripts").contains(transcript_id)) {
int exon_start = (int) ( (exon.getStart() - gene_start) * alpha);
int exon_end = (int) ( (exon.getEnd() - exon.getStart()) * alpha);
g2.setColor(_exon_color);
g2.fillRect(10 + exon_start, y, exon_end, 20);
}
}
if (_5pUTRs != null){
for( Iterator it = _5pUTRs.iterator(); it.hasNext(); ) {
TrackFeature tf = (TrackFeature)it.next();
if( tf.getAccessionID().equals(transcript_id) ) {
int start = (int) ( (tf.getStart() - gene_start) * alpha);
int end = (int) ( (tf.getEnd() - tf.getStart()) * alpha);
g2.setColor(_5pUTR_color);
g2.fillRect(10 + start, y, end, 20);
System.out.println( "5' >>>>> " + tf.getAccessionID() + " " + start + " " + end);
}
}
}
if (_3pUTRs != null){
for( Iterator it = _3pUTRs.iterator(); it.hasNext(); ) {
TrackFeature tf = (TrackFeature)it.next();
if( tf.getAccessionID().equals(transcript_id) ) {
int start = (int) ( (tf.getStart() - gene_start) * alpha);
int end = (int) ( (tf.getEnd() - tf.getStart()) * alpha);
g2.setColor(_3pUTR_color);
g2.fillRect(10 + start, y, end, 20);
System.out.println( "3' >>>>> " + tf.getAccessionID() + " " + start + " " + end);
}
}
}
y += 40;
}
}
}
package ca.bcgsc.sockeye.popup;
import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;
import java.text.Collator;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.StringTokenizer;
import java.util.TreeSet;
import javax.swing.ButtonGroup;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JFileChooser;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JSeparator;
import javax.swing.JTable;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableColumn;
import org.biojava.bio.program.gff.GFFTools;
import ca.bcgsc.genereg.gui.TFBSDialog;
import ca.bcgsc.sockeye.analysis.Alignment;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.dataretrieval.CohoUser;
import ca.bcgsc.sockeye.dataretrieval.DataSource;
import ca.bcgsc.sockeye.dataretrieval.EnsemblDataSource;
import ca.bcgsc.sockeye.dataretrieval.chinook.AlignmentDataSource;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.datastorage.SockeyeTrackList;
import ca.bcgsc.sockeye.datastorage.Track;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.gui.MainFrame;
import ca.bcgsc.sockeye.gui.SequencePanel;
import ca.bcgsc.sockeye.gui.Sockeye;
import ca.bcgsc.sockeye.gui.alignment.MultiAlignmentDialog;
import ca.bcgsc.sockeye.gui.alignment.SCProfileDialog;
import ca.bcgsc.sockeye.gui.alignment.SingleAlignmentDialog;
import ca.bcgsc.sockeye.gui.optionsdialog.OptionsDialog;
import ca.bcgsc.sockeye.io.FASTAExporter;
import ca.bcgsc.sockeye.io.GFFExporter;
import ca.bcgsc.sockeye.trackmanager.AlignOperation;
import ca.bcgsc.sockeye.trackmanager.CopyOperation;
import ca.bcgsc.sockeye.trackmanager.Operation;
import ca.bcgsc.sockeye.trackmanager.TrackManagerFactory;
import ca.bcgsc.sockeye.util.Log;
import ca.bcgsc.sockeye.util.StringUtils;
import ca.bcgsc.util.SequenceUtils;
import ca.bcgsc.util.gui.NucleotideContentDialog;
import ca.bcgsc.util.gui.scomponents.SockeyeFileChooser;
import ca.bcgsc.util.gui.scomponents.SockeyePopup;
public class TrackRightPopupNZ extends SockeyePopup {
SequencePanel sequence_panel;
JMenuItem m = new JMenuItem();
JMenuItem m_sequence = new JMenuItem("Show sequence...");
JMenuItem content = new JMenuItem("Show nucleotide content");
JMenuItem m_align = new JMenu("Alignment Options...");
AlignOperation align_oper = null;
JMenu m_extViewer = new JMenu("Alternative Viewer");
boolean extend;
ArrayList _tracks = new ArrayList();
String message = "track";
String _database, _species, _chromosome;
public TrackRightPopupNZ(int track_id) {
extend = false;
this._tracks.add(new Integer(track_id));
init();
}
public TrackRightPopupNZ(ArrayList tracks) {
extend = (tracks.size() > 1);
for (int i = 0; i < tracks.size(); i++) {
this._tracks.add(Integer.valueOf(tracks.get(i).toString()));
}
init();
}
private void init() {
JMenu m_track_info = new JMenu("Track details");
final int track_id = ((Integer) _tracks.get(0)).intValue();
if (DataStoreUser
.getInstance()
.getDataSourceManager()
.getTrackDatabases(track_id)
.isEmpty()
&& !DataStoreUser.getInstance().getSockeyeTrackList().getTrackHasFeature(
track_id,
"sequence")) {
content.setEnabled(false);
m_sequence.setEnabled(false);
}
Operation oper =
TrackManagerFactory.getInstance().getUpOperations(track_id);
if (oper != null && oper.getType() == Operation.__ALIGN_OPERATION_TYPE) {
if (oper instanceof AlignOperation)
align_oper = (AlignOperation) oper;
}
List ds_list =
DataStoreUser.getInstance().getSockeyeTrackList().getDataSources(
track_id);
Iterator ds_it = ds_list.iterator();
while (ds_it.hasNext()) {
DataSource ds =
DataStoreUser.getInstance().getDataSourceManager().getDataSource(
Integer.parseInt(ds_it.next().toString()));
if (ds instanceof EnsemblDataSource) {
_database = ((EnsemblDataSource) ds).getDatabase();
_species = ((EnsemblDataSource) ds).getSpecies();
_chromosome = ((EnsemblDataSource) ds).getChromosome();
}
}
if (!extend) {
String track_title =
"Track "
+ track_id
+ ": "
+ StringUtils.getShortNameForTrackID(track_id);
String ungapped_end_str =
(String) DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackAttribute(
track_id,
"ungapped_end");
int start =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackDataWindowStart(
track_id);
int end =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackDataWindowEnd(
track_id);
if (ungapped_end_str != null) {
end = Integer.parseInt(ungapped_end_str);
}
this.addTitle(
track_title
+ " (Offset: "
+ DataStoreUser.getInstance().getSockeyeTrackList().getTrackOffset(
track_id)
+ ")");
this.addInfo(coordinates(_chromosome, start, end, 0));
this.add(m_track_info);
this.addSeparator();
}
if (OptionsDialog.__showPopupIcons) {
m_extViewer.setIcon(Configuration.popupAltView_icon);
}
JMenuItem m_track_copy = new JMenuItem("Copy");
if (OptionsDialog.__showPopupIcons) {
m_track_copy.setIcon(Configuration.popupTrackCopy);
}
m_track_copy.setEnabled(align_oper == null);
m_track_copy.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
for (int i = 0; i < _tracks.size(); i++) {
int t_id = Integer.parseInt(_tracks.get(i).toString());
int new_track_id =
DataStoreUser.getInstance().getSockeyeTrackList().cloneTrack(t_id);
try {
EnsemblDataSource src =
new EnsemblDataSource(new_track_id, _database, _chromosome);
src.setConnection(
DataStoreUser
.getInstance()
.getDataSourceManager()
.getTrackEnsemblConnection(
t_id));
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.addStorageListener(
src);
int ds_id =
DataStoreUser.getInstance().getDataSourceManager().addDataSource(
src);
DataStoreUser.getInstance().getSockeyeTrackList().addDataSourceId(
new_track_id,
ds_id);
} catch (IllegalArgumentException ex) {
}
CopyOperation copy_op = new CopyOperation();
TrackManagerFactory.getInstance().addTrack(copy_op, new_track_id);
int[] parents = new int[1];
parents[0] = t_id;
TrackManagerFactory.getInstance().addOperation(copy_op, parents);
}
}
});
this.add(m_track_copy);
if (!extend) {
JMenuItem m_track_rename = new JMenuItem("Rename");
if (OptionsDialog.__showPopupIcons) {
m_track_rename.setIcon(Configuration.popupRename);
}
this.add(m_track_rename);
m_track_rename.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
Object orig_name = StringUtils.getShortNameForTrackID(track_id);
String name =
(String) JOptionPane.showInputDialog(
Sockeye.__frame,
"Input new track name",
"Rename ",
JOptionPane.OK_CANCEL_OPTION,
null,
null,
orig_name);
if (name != null && !name.equals(orig_name)) {
SockeyeTrackList tracks =
DataStoreUser.getInstance().getSockeyeTrackList();
boolean do_rename = true;
if (tracks.hasTrackAttributeValue("track_name", name)) {
Object[] options = { "OK", "CANCEL" };
do_rename =
JOptionPane.showOptionDialog(
Sockeye.__frame,
"This track name exists already.\n Are you sure you want two tracks with the same name?",
"Warning",
JOptionPane.DEFAULT_OPTION,
JOptionPane.WARNING_MESSAGE,
null,
options,
options[0])
== JOptionPane.OK_OPTION;
}
if (do_rename) {
tracks.setTrackAttribute(track_id, "track_name", name);
}
}
}
});
}
String reverse_lock =
(String) DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackAttribute(
track_id,
"reverse_locked");
JMenuItem m_track_reverse = new JMenuItem("Reverse");
if (OptionsDialog.__showPopupIcons) {
m_track_reverse.setIcon(Configuration.popupTrackReverse);
}
this.add(m_track_reverse);
if (reverse_lock == null) {
m_track_reverse.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
for (int i = 0; i < _tracks.size(); i++) {
DataStoreUser.getInstance().getSockeyeTrackList().setTrackReverse(
Integer.parseInt(_tracks.get(i).toString()),
!DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackReverse(
Integer.parseInt(_tracks.get(i).toString())));
}
}
});
} else
m_track_reverse.setEnabled(false);
JMenuItem m_track_delete = new JMenuItem("Delete");
if (OptionsDialog.__showPopupIcons) {
m_track_delete.setIcon(Configuration.popupDelete);
}
this.add(m_track_delete);
m_track_delete.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
HashSet align_operations = new HashSet();
HashSet tracks_to_delete = new HashSet();
ArrayList string_buffer = new ArrayList();
boolean has_rearrangement_aligments = false;
String warning_string =
"You are about to delete " + _tracks.size() + " tracks.\n";
String align_message =
"Additionally, all tracks created from the following alignments will be deleted:\n";
for (Iterator it = _tracks.iterator(); it.hasNext();) {
Integer tid_o = (Integer) it.next();
Operation oper =
TrackManagerFactory.getInstance().getUpOperations(tid_o.intValue());
if (oper != null
&& oper.getType() == Operation.__ALIGN_OPERATION_TYPE
&& oper instanceof AlignOperation) {
if (!((AlignOperation) oper).isComplete()) {
JOptionPane.showMessageDialog(
Sockeye.__frame,
"An alignment must be complete\nbefore it can be deleted.",
"Confirmation",
JOptionPane.ERROR_MESSAGE);
return;
}
String line =
((AlignOperation) oper).getAlignApplication()
+ "-"
+ ((AlignOperation) oper).getAlignID();
if (!string_buffer.contains(line)) {
align_message += (string_buffer.size() + 1) + ") " + line + "\n";
string_buffer.add(line);
}
align_operations.add(oper);
} else
tracks_to_delete.add(tid_o);
}
List r_align_opers = new ArrayList();
List opers = new ArrayList();
for (Iterator i = tracks_to_delete.iterator(); i.hasNext();) {
int trackId = ((Integer) i.next()).intValue();
Operation[] oparr =
TrackManagerFactory.getInstance().getDownOperations(trackId);
if (oparr != null)
opers.addAll(Arrays.asList(oparr));
}
for (int i = 0; i < opers.size(); i++) {
Operation op = (Operation) opers.get(i);
if (op != null && op.getType() == Operation.__ALIGN_OPERATION_TYPE) {
AlignOperation a_op = (AlignOperation) op;
if (a_op.getAlignType()
== AlignmentDataSource.R_ALIGNMENT_APP_TYPE)
r_align_opers.add(op);
}
}
if (r_align_opers.size() > 0)
warning_string
+= "Please note that among these tracks are parent tracks\n"
+ "for re-arrangement alignments. ALL child-tracks of these tracks will also be deleted\n";
if (align_operations.size() > 0)
warning_string += align_message;
if (JOptionPane
.showConfirmDialog(
Sockeye.__frame,
warning_string + "\nWould you like to continue with this deletion?",
"Confirm Alignment Deletion",
JOptionPane.YES_NO_OPTION)
!= JOptionPane.YES_OPTION)
return;
for (Iterator a_it = align_operations.iterator(); a_it.hasNext();) {
AlignOperation ao = (AlignOperation) a_it.next();
ao.cancel();
}
for (int i = 0; i < r_align_opers.size(); i++) {
((AlignOperation) r_align_opers.get(i)).cancel();
}
for (Iterator i = tracks_to_delete.iterator(); i.hasNext();) {
int trackId = ((Integer) i.next()).intValue();
DataStoreUser.getInstance().getSockeyeTrackList().removeTrack(
trackId);
TrackManagerFactory.getInstance().removeTrack(trackId);
}
DataStoreUser.getInstance().getSockeyeTrackList().refreshTrackOffsets();
}
});
JMenuItem m_track_mark = new JMenuItem("Mark as a region");
if (OptionsDialog.__showPopupIcons) {
m_track_mark.setIcon(Configuration.popupMarkRegion);
}
this.add(m_track_mark);
m_track_mark.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
int start =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackDataWindowStart(
track_id);
int end =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackDataWindowEnd(
track_id);
String track_name =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackAttribute(track_id, "track_name")
.toString();
String region_id = track_name.split(":")[0];
region_id = region_id.concat(new String(":" + start + ".." + end));
TrackFeature region =
new TrackFeature(
region_id,
track_name,
"region",
start,
end,
GFFTools.NO_SCORE,
0,
GFFTools.NO_FRAME);
region.setAccessionID(region_id);
region.setTrackId(track_id);
MainFrame.getVis3D().removeSelection();
DataStoreUser.getInstance().getSockeyeTrackList().addFeature(
track_id,
"region",
region);
DataStoreUser.getInstance().getSockeyeTrackList().setFeatureVisibility(
track_id,
"region",
region_id,
true);
}
});
this.addSeparator();
JMenuItem m_track_hide = new JMenuItem("Hide");
if (OptionsDialog.__showPopupIcons) {
m_track_hide.setIcon(Configuration.popupTrackHide);
}
this.add(m_track_hide);
m_track_hide.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
for (int i = 0; i < _tracks.size(); i++) {
DataStoreUser.getInstance().getSockeyeTrackList().setTrackVisibility(
Integer.parseInt(_tracks.get(i).toString()),
false);
}
}
});
JMenuItem m_track_show = new JMenuItem("Show");
if (OptionsDialog.__showPopupIcons) {
m_track_show.setIcon(Configuration.popupTrackShow);
}
this.add(m_track_show);
m_track_show.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
for (int i = 0; i < _tracks.size(); i++) {
DataStoreUser.getInstance().getSockeyeTrackList().setTrackVisibility(
Integer.parseInt(_tracks.get(i).toString()),
true);
}
}
});
JMenuItem m_scan_TFBS = new JMenuItem("TFBS Scan");
m_scan_TFBS.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
CohoUser cohoUser = new CohoUser();
int start =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackDataWindowStart(
track_id);
int end =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackDataWindowEnd(
track_id);
TFBSDialog dialog =
new TFBSDialog(
Sockeye.__frame,
track_id,
start,
end);
dialog.addCohoScanEventListener(cohoUser);
dialog.show();
}
});
m_scan_TFBS.setIcon(Configuration.popupScan);
add(m_scan_TFBS);
this.addSeparator();
m_track_show.setEnabled(false);
m_track_hide.setEnabled(false);
for (int i = 0; i < _tracks.size(); i++)
if (DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackVisibility(Integer.parseInt(_tracks.get(i).toString())))
m_track_hide.setEnabled(true);
else
m_track_show.setEnabled(true);
this.addSeparator();
JMenuItem m_track_EnsEMBL_contigView = new JMenuItem("EnsEMBL ContigView");
if (!extend) {
m_extViewer.add(m_track_EnsEMBL_contigView);
}
m_track_EnsEMBL_contigView
.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
String url =
(String) Configuration.getPopupConfiguration().get("ContigView");
List track_species_list =
DataStoreUser.getInstance().getDataSourceManager().getTrackSpecies(
track_id);
List track_chr_list =
DataStoreUser
.getInstance()
.getDataSourceManager()
.getTrackChromosomes(
track_id);
if (track_species_list.isEmpty() || track_chr_list.isEmpty())
return;
String species = track_species_list.get(0).toString();
String chromos = track_chr_list.get(0).toString();
int start =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackDataWindowStart(
track_id);
int end =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackDataWindowEnd(
track_id);
url =
url
.replaceAll("CHR", chromos)
.replaceAll("SPECIES", species)
.replaceAll("START", String.valueOf(start))
.replaceAll("END", String.valueOf(end));
try {
BrowserLauncher.openURL(url);
} catch (Exception ee) {
Log.printStackTrace(ee);
JOptionPane.showMessageDialog(
Sockeye.__frame,
"Cannot open Web Browser.",
"Warning",
JOptionPane.WARNING_MESSAGE);
}
}
});
JMenuItem m_track_NCBI_mapView = new JMenuItem("NCBI Map View");
if (!extend) {
m_extViewer.add(m_track_NCBI_mapView);
}
m_track_NCBI_mapView
.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
List track_species_list =
DataStoreUser.getInstance().getDataSourceManager().getTrackSpecies(
track_id);
List track_chr_list =
DataStoreUser
.getInstance()
.getDataSourceManager()
.getTrackChromosomes(
track_id);
if (track_species_list.isEmpty() || track_chr_list.isEmpty())
return;
String species = track_species_list.get(0).toString();
String chromos = track_chr_list.get(0).toString();
int start =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackDataWindowStart(
track_id);
int end =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackDataWindowEnd(
track_id);
String url =
(String) Configuration.getPopupConfiguration().get(
new String(species + "_MapView"));
if (url == null) {
JOptionPane.showMessageDialog(
Sockeye.__frame,
"An NCBI Map URL was not found for this species.",
"",
JOptionPane.INFORMATION_MESSAGE);
return;
}
url =
url
.replaceAll("chr", chromos)
.replaceAll("start", String.valueOf(start))
.replaceAll("end", String.valueOf(end));
try {
BrowserLauncher.openURL(url);
} catch (Exception ee) {
Log.printStackTrace(ee);
JOptionPane.showMessageDialog(
Sockeye.__frame,
"Cannot open Web Browser.",
"Warning",
JOptionPane.WARNING_MESSAGE);
}
}
});
if (_species != null && _species.matches(".*legans.*")) {
JMenuItem m_wormBase_DASView = new JMenuItem("WormBase DAS View");
m_extViewer.add(m_wormBase_DASView);
m_wormBase_DASView
.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
String url =
(String) Configuration.getPopupConfiguration().get(
"WormBaseDasView");
List track_species_list =
DataStoreUser.getInstance().getDataSourceManager().getTrackSpecies(
track_id);
List track_chr_list =
DataStoreUser
.getInstance()
.getDataSourceManager()
.getTrackChromosomes(
track_id);
if (track_species_list.isEmpty() || track_chr_list.isEmpty())
return;
String species = track_species_list.get(0).toString();
String chromos = track_chr_list.get(0).toString();
int start =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackDataWindowStart(
track_id);
int end =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackDataWindowEnd(
track_id);
url =
url
.replaceAll("CHR", chromos)
.replaceAll("START", String.valueOf(start))
.replaceAll("END", String.valueOf(end));
try {
BrowserLauncher.openURL(url);
} catch (Exception ee) {
Log.printStackTrace(ee);
JOptionPane.showMessageDialog(
Sockeye.__frame,
"Cannot open Web Browser.",
"Warning",
JOptionPane.WARNING_MESSAGE);
}
}
});
}
if (!extend) {
this.add(m_extViewer);
if (align_oper != null)
m_extViewer.setEnabled(false);
JMenuItem m_track_export_to_GFF = new JMenuItem("Export to GFF");
if (OptionsDialog.__showPopupIcons) {
m_track_export_to_GFF.setIcon(Configuration.popupExport);
}
this.add(m_track_export_to_GFF);
m_track_export_to_GFF
.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
String track_name =
(String) DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackAttribute(
track_id,
"track_name");
String file_name = track_name.split("=")[0];
file_name = file_name.replaceAll("\\W", "_");
file_name = file_name.replaceAll("__", "_");
file_name = Configuration.getUserPath() + file_name + ".gff";
SockeyeFileChooser export_toGFF_dialog =
SockeyeFileChooser.getSockeyeFileChooser("FASTAExport");
export_toGFF_dialog.setDialogTitle("Export Selected Track As...");
int result =
export_toGFF_dialog.showSaveDialog(
Sockeye.__frame,
"gff",
new File(file_name));
try {
file_name =
export_toGFF_dialog.getSelectedFile().getCanonicalPath();
} catch (java.io.IOException ex) {
Log.printStackTrace(ex);
System.out.println("Cannot handle file!!!!!");
return;
}
if (result == JFileChooser.APPROVE_OPTION) {
GFFExporter.exportEnsemblTrackToGFF(track_id, file_name);
}
}
});
}
JMenu m_track_export_to_FASTA = new JMenu("Export to FASTA");
if (OptionsDialog.__showPopupIcons) {
m_track_export_to_FASTA.setIcon(Configuration.popupExport);
}
this.add(m_track_export_to_FASTA);
JMenuItem m_export_sense = new JMenuItem("(+) positive strand sequence");
JMenuItem m_export_antisense =
new JMenuItem("(-) negative strand sequence (reverse complement)");
m_track_export_to_FASTA.add(m_export_sense);
m_track_export_to_FASTA.add(m_export_antisense);
m_export_sense.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
for (int i = 0; i < _tracks.size(); i++) {
final int t_id = Integer.parseInt(_tracks.get(i).toString());
exportFASTA_actionPerformed(t_id, 1);
}
}
});
m_export_antisense.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(ActionEvent e) {
for (int i = 0; i < _tracks.size(); i++) {
final int t_id = Integer.parseInt(_tracks.get(i).toString());
exportFASTA_actionPerformed(t_id, -1);
}
}
});
this.addSeparator();
if (OptionsDialog.__showPopupIcons) {
m_sequence.setIcon(Configuration.popupSeqExtr_icon);
}
add(m_sequence);
m_sequence.addActionListener(new ActionListener() {
public void actionPerformed(java.awt.event.ActionEvent e) {
try {
for (int i = 0; i < _tracks.size(); i++) {
int track_id = Integer.parseInt(_tracks.get(i).toString());
int window_start =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackDataWindowStart(
track_id);
int window_end =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackDataWindowEnd(
track_id);
String length = " (" + (window_end - window_start + 1) + "bp)";
String track_name =
(String) DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackAttribute(
track_id,
"track_name");
StringTokenizer strToken = new StringTokenizer(track_name, "=");
String datetime = "";
String species = "";
if (strToken.countTokens() == 2) {
species = strToken.nextToken();
datetime = "=" + strToken.nextToken();
}
boolean reverse =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackReverse(
track_id);
String rev = "";
if (reverse)
rev = "(reverse complement)";
sequence_panel =
new SequencePanel(
species + length + rev,
"",
Sockeye.__frame,
window_start,
window_end,
1);
sequence_panel.setTrack(track_id);
sequence_panel.setDataStorageManager(
DataStoreUser.getInstance().getSockeyeTrackList());
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.addStorageListener(
sequence_panel);
String seq =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackSequence(
track_id);
if (reverse) {
seq = SequenceUtils.reverseComplementSequence(seq);
}
sequence_panel.setSequence(seq);
sequence_panel.show();
}
} catch (java.lang.Exception ee) {
ee.printStackTrace();
}
}
});
if (!extend) {
if (OptionsDialog.__showPopupIcons)
content.setIcon(Configuration.popupNucContent);
add(content);
content.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
new NucleotideContentDialog(
Sockeye.__frame,
DataStoreUser.getInstance().getSockeyeTrackList().getTrackSequence(
track_id));
}
});
}
JMenu rm_menu = new JMenu("Repeat Masking");
JCheckBoxMenuItem mi_unmasked = new JCheckBoxMenuItem("Unmasked");
JCheckBoxMenuItem mi_softmasked = new JCheckBoxMenuItem("Softmasked");
JCheckBoxMenuItem mi_hardmasked = new JCheckBoxMenuItem("Hardmasked");
ButtonGroup rm_cb_group = new ButtonGroup();
rm_cb_group.add(mi_unmasked);
rm_cb_group.add(mi_softmasked);
rm_cb_group.add(mi_hardmasked);
rm_menu.add(mi_unmasked);
rm_menu.add(mi_softmasked);
rm_menu.add(mi_hardmasked);
add(rm_menu);
if (OptionsDialog.__showPopupIcons)
rm_menu.setIcon(Configuration.popupSequenceMask);
int t_id = Integer.parseInt(_tracks.get(0).toString());
boolean ensembl_track =
!DataStoreUser
.getInstance()
.getDataSourceManager()
.getTrackDatabases(t_id)
.isEmpty();
if (extend)
rm_menu.setEnabled(false);
else {
int mode = -1;
if (!ensembl_track) {
mi_unmasked.setEnabled(false);
mi_softmasked.setEnabled(false);
mi_hardmasked.setEnabled(false);
} else {
mode =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackSequenceMode(
t_id);
}
switch (mode) {
case Track.SEQ_HARD_MASKED :
mi_hardmasked.setSelected(true);
break;
case Track.SEQ_SOFT_MASKED :
mi_softmasked.setSelected(true);
break;
case Track.SEQ_UNMASKED :
mi_unmasked.setSelected(true);
break;
}
}
mi_unmasked.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
int t_id = Integer.parseInt(_tracks.get(0).toString());
DataStoreUser.getInstance().getSockeyeTrackList().setTrackSequenceMode(
t_id,
Track.SEQ_UNMASKED);
}
});
mi_softmasked.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
int t_id = Integer.parseInt(_tracks.get(0).toString());
DataStoreUser.getInstance().getSockeyeTrackList().setTrackSequenceMode(
t_id,
Track.SEQ_SOFT_MASKED);
}
});
mi_hardmasked.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
int t_id = Integer.parseInt(_tracks.get(0).toString());
DataStoreUser.getInstance().getSockeyeTrackList().setTrackSequenceMode(
t_id,
Track.SEQ_HARD_MASKED);
}
});
if (OptionsDialog.__showPopupIcons) {
m_track_info.setIcon(Configuration.info_icon);
}
if (!extend) {
String headlines[] =
(
(String) DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackAttribute(
track_id,
"track_name")).split(
"=");
int row = 0;
Collator collator = Collator.getInstance();
collator.setStrength(Collator.PRIMARY);
TreeSet sortedKeys = new TreeSet(collator);
sortedKeys.addAll(
DataStoreUser.getInstance().getSockeyeTrackList().getFeatureNames(
track_id));
sortedKeys.remove("Sequence");
for (int i = 0; i < headlines.length; i++) {
JLabel head = new JLabel(headlines[i], JLabel.LEFT);
m_track_info.add(head);
}
JTable tab = new JTable();
tab.setModel(new DefaultTableModel(sortedKeys.size(), 2) {
public boolean isCellEditable(int row, int column) {
return false;
}
});
tab.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
tab.setOpaque(false);
tab.setPreferredSize(new Dimension(200, sortedKeys.size() * 16));
for (Iterator it = sortedKeys.iterator(); it.hasNext();) {
String feature_name = (String) it.next();
String feature_value =
Integer.toString(
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getDataWindowFeatureCount(
track_id,
feature_name));
feature_value += " / "
+ Integer.toString(
DataStoreUser.getInstance().getSockeyeTrackList().getFeatureCount(
track_id,
feature_name));
tab.setValueAt(feature_name, row, 0);
tab.setValueAt(feature_value, row, 1);
row++;
}
if (row > 0) {
TableColumn c = tab.getColumnModel().getColumn(1);
c.setPreferredWidth(20);
c.setMinWidth(5);
c = tab.getColumnModel().getColumn(0);
c.setPreferredWidth(5);
m_track_info.add(tab);
}
if (align_oper != null && align_oper.isComplete()) {
boolean rearrange_mode =
align_oper.getAlignType().equals(
AlignmentDataSource.R_ALIGNMENT_APP_TYPE);
addSeparator();
add(m_align);
m_align.setText(rearrange_mode ? "Sub-alignment..." : "Alignment...");
if (rearrange_mode) {
JMenuItem m_align_rearr = new JMenuItem("Other sub-alignments...");
m_align.add(m_align_rearr);
m_align.add(new JSeparator());
m_align_rearr.addActionListener(new ActionListener() {
public void actionPerformed(java.awt.event.ActionEvent e) {
try {
MultiAlignmentDialog dialog =
new MultiAlignmentDialog(align_oper);
} catch (Exception ex) {
Log.printStackTrace(ex);
}
}
});
}
final int tid = align_oper.getReferenceTrack();
final Alignment alignment = align_oper.get3DSubalignment();
JMenuItem showAlign = new JMenuItem("Export/2D View...");
m_align.add(showAlign);
showAlign.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
int trackStart =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackDataStart(
tid);
int trackEnd =
DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackDataEnd(
tid);
new SingleAlignmentDialog(
Sockeye.__frame,
alignment,
align_oper.getAnchors(),
tid);
}
});
JMenuItem m_align_scprofile =
new JMenuItem("Sequence Conservation Profiles...");
m_align.add(m_align_scprofile);
m_align_scprofile.addActionListener(new ActionListener() {
public void actionPerformed(java.awt.event.ActionEvent e) {
try {
SCProfileDialog sc_dialog = new SCProfileDialog(alignment);
} catch (Exception ex) {
Log.printStackTrace(ex);
}
}
});
}
}
}
private void exportFASTA_actionPerformed(int track_id, int strand) {
String track_name =
(String) DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackAttribute(
track_id,
"track_name");
String file_name = track_name.split("=")[0];
file_name = file_name.replaceAll("\\W", "_");
file_name = file_name.replaceAll("__", "_");
file_name = Configuration.getUserPath() + file_name + ".fasta";
SockeyeFileChooser export_toFASTA_dialog =
SockeyeFileChooser.getSockeyeFileChooser("FASTAExport");
export_toFASTA_dialog.setDialogTitle("Save Sequences As...");
int result =
export_toFASTA_dialog.showSaveDialog(
Sockeye.__frame,
"fasta",
new File(file_name));
try {
file_name = export_toFASTA_dialog.getSelectedFile().getCanonicalPath();
} catch (java.io.IOException ex) {
Log.printStackTrace(ex);
System.out.println("Cannot handle file!!!!!");
return;
}
if (result == JFileChooser.APPROVE_OPTION) {
FASTAExporter.exportToMultiFASTA(track_id, strand, file_name);
}
}
}
package ca.bcgsc.sockeye.service.chinookplusplus.common;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Random;
import ca.bcgsc.sockeye.service.chinookplusplus.common.ChinookPlusPlusService;
import ca.bcgsc.sockeye.service.chinookplusplus.common.ChinookPlusPlusServiceException;
public class ChinookPlusPlusLocal implements ChinookPlusPlusService {
static private String FILE_PREFIX = "/tmp/chinookplusplus.tmp.";
static {
if (System.getProperty("os.name").startsWith("Windows")) {
FILE_PREFIX = "c:" + FILE_PREFIX;
}
}
static public ChinookPlusPlusLocal getInstance() {
return new ChinookPlusPlusLocal();
}
public String uploadFile(byte[] bytes) throws ChinookPlusPlusServiceException {
Random rr = new Random(System.currentTimeMillis());
String fileId = String.valueOf(rr.nextInt());
FileOutputStream os = null;
try {
os = new FileOutputStream(FILE_PREFIX + fileId);
os.write(bytes);
} catch (IOException e) {
e.printStackTrace();
throw new ChinookPlusPlusServiceException(e.getMessage());
} finally {
if (os != null) {
try {
os.close();
} catch (IOException e1) {
}
}
}
return fileId;
}
}
package ca.bcgsc.sockeye.service.chinookplusplus.common;
import java.rmi.RemoteException;
import javax.xml.rpc.ServiceException;
import ca.bcgsc.sockeye.service.chinookplusplus.common.ChinookPlusPlusService;
import ca.bcgsc.sockeye.service.chinookplusplus.common.ChinookPlusPlusServiceException;
import ca.bcgsc.sockeye.service.chinookplusplus.remote.genstubs.ChinookPlusPlusLocalServiceLocator;
import ca.bcgsc.sockeye.service.chinookplusplus.remote.genstubs.ChinookPlusPlusSoapBindingStub;
import ca.bcgsc.sockeye.util.Log;
public class ChinookPlusPlusRemote implements ChinookPlusPlusService {
private String remoteConnectionStr = null;
public ChinookPlusPlusRemote(String remoteConnectionStr) {
this.remoteConnectionStr = remoteConnectionStr;
}
public String uploadFile(byte[] bytes) throws ChinookPlusPlusServiceException {
ChinookPlusPlusLocalServiceLocator loc =
new ChinookPlusPlusLocalServiceLocator(remoteConnectionStr);
String fileId = null;
try {
ChinookPlusPlusSoapBindingStub stub =
(ChinookPlusPlusSoapBindingStub) loc.getChinookPlusPlus();
fileId = stub.uploadFile(bytes);
} catch (ServiceException e) {
Log.printStackTrace(e);
throw new ChinookPlusPlusServiceException(e.getMessage());
} catch (RemoteException re) {
Log.printStackTrace(re);
throw new ChinookPlusPlusServiceException(re.getMessage());
}
return fileId;
}
}
package ca.bcgsc.sockeye.service.chinookplusplus.common;
public interface ChinookPlusPlusService {
public String uploadFile(byte[] bytes) throws ChinookPlusPlusServiceException;
}
package ca.bcgsc.sockeye.service.chinookplusplus.common;
public class ChinookPlusPlusServiceException extends Exception {
public ChinookPlusPlusServiceException(String message) {
super(message);
}
}
package ca.bcgsc.sockeye.service.chinookplusplus.common;
public class ChinookPlusPlusServiceFactory {
public static String CHINOOKPLUSPLUS_SERVICES = "ChinookPlusPlus";
static private ChinookPlusPlusServiceFactory instance = new ChinookPlusPlusServiceFactory();
static public ChinookPlusPlusServiceFactory getInstance() {
return instance;
}
public ChinookPlusPlusService getService(String serviceType, String remotehost) {
if("remote".equals(serviceType)) {
return new ChinookPlusPlusRemote(remotehost);
} else {
return ChinookPlusPlusLocal.getInstance();
}
}
}
package ca.bcgsc.sockeye.service.chinookplusplus.junit;
import ca.bcgsc.sockeye.service.chinookplusplus.common.ChinookPlusPlusService;
import ca.bcgsc.sockeye.service.chinookplusplus.common.ChinookPlusPlusServiceException;
import ca.bcgsc.sockeye.service.chinookplusplus.common.ChinookPlusPlusServiceFactory;
import junit.framework.TestCase;
import junit.framework.TestSuite;
public class ChinookPlusPlusUnitTest extends TestCase {
public ChinookPlusPlusUnitTest(String name) {
super(name);
}
public static void main(String[] args) {
junit.textui.TestRunner.run(ChinookPlusPlusUnitTest.suite());
}
protected void setUp() {
}
protected void tearDown() {
}
public static TestSuite suite() {
TestSuite testSuite = new TestSuite();
testSuite.addTest(new ChinookPlusPlusUnitTest("testRemote"));
return testSuite;
}
public void testRemote() throws ChinookPlusPlusServiceException {
ChinookPlusPlusService service =
ChinookPlusPlusServiceFactory.getInstance().getService(
"remote",
"island.bcgsc.ca:8080");
String fileId = service.uploadFile("1234567".getBytes());
System.out.println(fileId);
int i = Integer.parseInt(fileId);
}
}
package ca.bcgsc.sockeye.service.chinookplusplus.remote.genstubs;
public interface ChinookPlusPlusLocal extends java.rmi.Remote {
public java.lang.String uploadFile(byte[] bytes) throws java.rmi.RemoteException, ca.bcgsc.sockeye.service.chinookplusplus.remote.genstubs.ChinookPlusPlusServiceException;
}
package ca.bcgsc.sockeye.service.chinookplusplus.remote.genstubs;
public interface ChinookPlusPlusLocalService extends javax.xml.rpc.Service {
public java.lang.String getChinookPlusPlusAddress();
public ca.bcgsc.sockeye.service.chinookplusplus.remote.genstubs.ChinookPlusPlusLocal getChinookPlusPlus() throws javax.xml.rpc.ServiceException;
public ca.bcgsc.sockeye.service.chinookplusplus.remote.genstubs.ChinookPlusPlusLocal getChinookPlusPlus(java.net.URL portAddress) throws javax.xml.rpc.ServiceException;
}
package ca.bcgsc.sockeye.service.chinookplusplus.remote.genstubs;
public class ChinookPlusPlusLocalServiceLocator extends org.apache.axis.client.Service implements ca.bcgsc.sockeye.service.chinookplusplus.remote.genstubs.ChinookPlusPlusLocalService {
private java.lang.String ChinookPlusPlus_address = "http:
public ChinookPlusPlusLocalServiceLocator(String remoteConnStr) {
ChinookPlusPlus_address = "http:
}
public java.lang.String getChinookPlusPlusAddress() {
return ChinookPlusPlus_address;
}
private java.lang.String ChinookPlusPlusWSDDServiceName = "ChinookPlusPlus";
public java.lang.String getChinookPlusPlusWSDDServiceName() {
return ChinookPlusPlusWSDDServiceName;
}
public void setChinookPlusPlusWSDDServiceName(java.lang.String name) {
ChinookPlusPlusWSDDServiceName = name;
}
public ca.bcgsc.sockeye.service.chinookplusplus.remote.genstubs.ChinookPlusPlusLocal getChinookPlusPlus() throws javax.xml.rpc.ServiceException {
java.net.URL endpoint;
try {
endpoint = new java.net.URL(ChinookPlusPlus_address);
}
catch (java.net.MalformedURLException e) {
throw new javax.xml.rpc.ServiceException(e);
}
return getChinookPlusPlus(endpoint);
}
public ca.bcgsc.sockeye.service.chinookplusplus.remote.genstubs.ChinookPlusPlusLocal getChinookPlusPlus(java.net.URL portAddress) throws javax.xml.rpc.ServiceException {
try {
ca.bcgsc.sockeye.service.chinookplusplus.remote.genstubs.ChinookPlusPlusSoapBindingStub _stub = new ca.bcgsc.sockeye.service.chinookplusplus.remote.genstubs.ChinookPlusPlusSoapBindingStub(portAddress, this);
_stub.setPortName(getChinookPlusPlusWSDDServiceName());
return _stub;
}
catch (org.apache.axis.AxisFault e) {
return null;
}
}
public java.rmi.Remote getPort(Class serviceEndpointInterface) throws javax.xml.rpc.ServiceException {
try {
if (ca.bcgsc.sockeye.service.chinookplusplus.remote.genstubs.ChinookPlusPlusLocal.class.isAssignableFrom(serviceEndpointInterface)) {
ca.bcgsc.sockeye.service.chinookplusplus.remote.genstubs.ChinookPlusPlusSoapBindingStub _stub = new ca.bcgsc.sockeye.service.chinookplusplus.remote.genstubs.ChinookPlusPlusSoapBindingStub(new java.net.URL(ChinookPlusPlus_address), this);
_stub.setPortName(getChinookPlusPlusWSDDServiceName());
return _stub;
}
}
catch (java.lang.Throwable t) {
throw new javax.xml.rpc.ServiceException(t);
}
throw new javax.xml.rpc.ServiceException("There is no stub implementation for the interface: " + (serviceEndpointInterface == null ? "null" : serviceEndpointInterface.getName()));
}
public java.rmi.Remote getPort(javax.xml.namespace.QName portName, Class serviceEndpointInterface) throws javax.xml.rpc.ServiceException {
if (portName == null) {
return getPort(serviceEndpointInterface);
}
String inputPortName = portName.getLocalPart();
if ("ChinookPlusPlus".equals(inputPortName)) {
return getChinookPlusPlus();
}
else {
java.rmi.Remote _stub = getPort(serviceEndpointInterface);
((org.apache.axis.client.Stub) _stub).setPortName(portName);
return _stub;
}
}
public javax.xml.namespace.QName getServiceName() {
return new javax.xml.namespace.QName("http:
}
private java.util.HashSet ports = null;
public java.util.Iterator getPorts() {
if (ports == null) {
ports = new java.util.HashSet();
ports.add(new javax.xml.namespace.QName("ChinookPlusPlus"));
}
return ports.iterator();
}
}
package ca.bcgsc.sockeye.service.chinookplusplus.remote.genstubs;
public class ChinookPlusPlusServiceException extends org.apache.axis.AxisFault implements java.io.Serializable {
public ChinookPlusPlusServiceException() {
}
private java.lang.Object __equalsCalc = null;
public synchronized boolean equals(java.lang.Object obj) {
if (!(obj instanceof ChinookPlusPlusServiceException)) return false;
ChinookPlusPlusServiceException other = (ChinookPlusPlusServiceException) obj;
if (obj == null) return false;
if (this == obj) return true;
if (__equalsCalc != null) {
return (__equalsCalc == obj);
}
__equalsCalc = obj;
boolean _equals;
_equals = true;
__equalsCalc = null;
return _equals;
}
private boolean __hashCodeCalc = false;
public synchronized int hashCode() {
if (__hashCodeCalc) {
return 0;
}
__hashCodeCalc = true;
int _hashCode = 1;
__hashCodeCalc = false;
return _hashCode;
}
private static org.apache.axis.description.TypeDesc typeDesc =
new org.apache.axis.description.TypeDesc(ChinookPlusPlusServiceException.class);
static {
typeDesc.setXmlType(new javax.xml.namespace.QName("http:
}
public static org.apache.axis.description.TypeDesc getTypeDesc() {
return typeDesc;
}
public static org.apache.axis.encoding.Serializer getSerializer(
java.lang.String mechType,
java.lang.Class _javaType,
javax.xml.namespace.QName _xmlType) {
return
new org.apache.axis.encoding.ser.BeanSerializer(
_javaType, _xmlType, typeDesc);
}
public static org.apache.axis.encoding.Deserializer getDeserializer(
java.lang.String mechType,
java.lang.Class _javaType,
javax.xml.namespace.QName _xmlType) {
return
new org.apache.axis.encoding.ser.BeanDeserializer(
_javaType, _xmlType, typeDesc);
}
public void writeDetails(javax.xml.namespace.QName qname, org.apache.axis.encoding.SerializationContext context) throws java.io.IOException {
context.serialize(qname, null, this);
}
}
package ca.bcgsc.sockeye.service.chinookplusplus.remote.genstubs;
public class ChinookPlusPlusSoapBindingStub extends org.apache.axis.client.Stub implements ca.bcgsc.sockeye.service.chinookplusplus.remote.genstubs.ChinookPlusPlusLocal {
private java.util.Vector cachedSerClasses = new java.util.Vector();
private java.util.Vector cachedSerQNames = new java.util.Vector();
private java.util.Vector cachedSerFactories = new java.util.Vector();
private java.util.Vector cachedDeserFactories = new java.util.Vector();
static org.apache.axis.description.OperationDesc [] _operations;
static {
_operations = new org.apache.axis.description.OperationDesc[1];
org.apache.axis.description.OperationDesc oper;
oper = new org.apache.axis.description.OperationDesc();
oper.setName("uploadFile");
oper.addParameter(new javax.xml.namespace.QName("", "bytes"), new javax.xml.namespace.QName("http:
oper.setReturnType(new javax.xml.namespace.QName("http:
oper.setReturnClass(java.lang.String.class);
oper.setReturnQName(new javax.xml.namespace.QName("", "uploadFileReturn"));
oper.setStyle(org.apache.axis.enum.Style.RPC);
oper.setUse(org.apache.axis.enum.Use.ENCODED);
oper.addFault(new org.apache.axis.description.FaultDesc(
new javax.xml.namespace.QName("http:
"ca.bcgsc.sockeye.service.chinookplusplus.remote.genstubs.ChinookPlusPlusServiceException",
new javax.xml.namespace.QName("http:
true
));
_operations[0] = oper;
}
public ChinookPlusPlusSoapBindingStub() throws org.apache.axis.AxisFault {
this(null);
}
public ChinookPlusPlusSoapBindingStub(java.net.URL endpointURL, javax.xml.rpc.Service service) throws org.apache.axis.AxisFault {
this(service);
super.cachedEndpoint = endpointURL;
}
public ChinookPlusPlusSoapBindingStub(javax.xml.rpc.Service service) throws org.apache.axis.AxisFault {
if (service == null) {
super.service = new org.apache.axis.client.Service();
} else {
super.service = service;
}
java.lang.Class cls;
javax.xml.namespace.QName qName;
java.lang.Class beansf = org.apache.axis.encoding.ser.BeanSerializerFactory.class;
java.lang.Class beandf = org.apache.axis.encoding.ser.BeanDeserializerFactory.class;
java.lang.Class enumsf = org.apache.axis.encoding.ser.EnumSerializerFactory.class;
java.lang.Class enumdf = org.apache.axis.encoding.ser.EnumDeserializerFactory.class;
java.lang.Class arraysf = org.apache.axis.encoding.ser.ArraySerializerFactory.class;
java.lang.Class arraydf = org.apache.axis.encoding.ser.ArrayDeserializerFactory.class;
java.lang.Class simplesf = org.apache.axis.encoding.ser.SimpleSerializerFactory.class;
java.lang.Class simpledf = org.apache.axis.encoding.ser.SimpleDeserializerFactory.class;
qName = new javax.xml.namespace.QName("http:
cachedSerQNames.add(qName);
cls = ca.bcgsc.sockeye.service.chinookplusplus.remote.genstubs.ChinookPlusPlusServiceException.class;
cachedSerClasses.add(cls);
cachedSerFactories.add(beansf);
cachedDeserFactories.add(beandf);
}
private org.apache.axis.client.Call createCall() throws java.rmi.RemoteException {
try {
org.apache.axis.client.Call _call =
(org.apache.axis.client.Call) super.service.createCall();
if (super.maintainSessionSet) {
_call.setMaintainSession(super.maintainSession);
}
if (super.cachedUsername != null) {
_call.setUsername(super.cachedUsername);
}
if (super.cachedPassword != null) {
_call.setPassword(super.cachedPassword);
}
if (super.cachedEndpoint != null) {
_call.setTargetEndpointAddress(super.cachedEndpoint);
}
if (super.cachedTimeout != null) {
_call.setTimeout(super.cachedTimeout);
}
if (super.cachedPortName != null) {
_call.setPortName(super.cachedPortName);
}
java.util.Enumeration keys = super.cachedProperties.keys();
while (keys.hasMoreElements()) {
java.lang.String key = (java.lang.String) keys.nextElement();
_call.setProperty(key, super.cachedProperties.get(key));
}
synchronized (this) {
if (firstCall()) {
_call.setSOAPVersion(org.apache.axis.soap.SOAPConstants.SOAP11_CONSTANTS);
_call.setEncodingStyle(org.apache.axis.Constants.URI_SOAP11_ENC);
for (int i = 0; i < cachedSerFactories.size(); ++i) {
java.lang.Class cls = (java.lang.Class) cachedSerClasses.get(i);
javax.xml.namespace.QName qName =
(javax.xml.namespace.QName) cachedSerQNames.get(i);
java.lang.Class sf = (java.lang.Class)
cachedSerFactories.get(i);
java.lang.Class df = (java.lang.Class)
cachedDeserFactories.get(i);
_call.registerTypeMapping(cls, qName, sf, df, false);
}
}
}
return _call;
}
catch (java.lang.Throwable t) {
throw new org.apache.axis.AxisFault("Failure trying to get the Call object", t);
}
}
public java.lang.String uploadFile(byte[] bytes) throws java.rmi.RemoteException, ca.bcgsc.sockeye.service.chinookplusplus.remote.genstubs.ChinookPlusPlusServiceException {
if (super.cachedEndpoint == null) {
throw new org.apache.axis.NoEndPointException();
}
org.apache.axis.client.Call _call = createCall();
_call.setOperation(_operations[0]);
_call.setUseSOAPAction(true);
_call.setSOAPActionURI("");
_call.setSOAPVersion(org.apache.axis.soap.SOAPConstants.SOAP11_CONSTANTS);
_call.setOperationName(new javax.xml.namespace.QName("http:
setRequestHeaders(_call);
setAttachments(_call);
java.lang.Object _resp = _call.invoke(new java.lang.Object[] {bytes});
if (_resp instanceof java.rmi.RemoteException) {
throw (java.rmi.RemoteException)_resp;
}
else {
extractAttachments(_call);
try {
return (java.lang.String) _resp;
} catch (java.lang.Exception _exception) {
return (java.lang.String) org.apache.axis.utils.JavaUtils.convert(_resp, java.lang.String.class);
}
}
}
}
package ca.bcgsc.sockeye.service.coexpression.common;
import java.util.Map;
public interface CoexpressionService {
public Map getCoexpressionScores(String geneId, String[] database) throws CoexpressionServiceException;
}
package ca.bcgsc.sockeye.service.coexpression.common;
public class CoexpressionServiceException extends Exception {
public CoexpressionServiceException(String message) {
super(message);
}
}
package ca.bcgsc.sockeye.service.coexpression.common;
import ca.bcgsc.sockeye.service.coexpression.directdao.CoexpressionDAO;
import ca.bcgsc.sockeye.service.coexpression.remote.CoexpressionRemote;
public class CoexpressionServiceFactory {
public static String COEXPRESSION_SERVICE = "Coexpression";
static private CoexpressionServiceFactory instance = new CoexpressionServiceFactory();
static public CoexpressionServiceFactory getInstance() {
return instance;
}
public CoexpressionService getService(String serviceType, String remotehost) {
if("remote".equals(serviceType)) {
return new CoexpressionRemote(remotehost);
} else {
return CoexpressionDAO.getInstance();
}
}
}
package ca.bcgsc.sockeye.service.coexpression.directdao;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.config.Service;
import ca.bcgsc.sockeye.service.coexpression.common.CoexpressionService;
import ca.bcgsc.sockeye.service.coexpression.common.CoexpressionServiceException;
import ca.bcgsc.sockeye.service.featureloader.common.FeatureLoaderLocal;
import ca.bcgsc.sockeye.util.Log;
public class CoexpressionDAO implements CoexpressionService {
static public CoexpressionDAO getInstance() {
return new CoexpressionDAO();
}
static {
try {
Class.forName("com.mysql.jdbc.Driver");
} catch (ClassNotFoundException e) {
e.printStackTrace();
}
}
static private final String SQL_GET_COEXPRESSED_GENES = "select coexpressed_gene from coexpression where gene_name = ? order by pearson_correl desc limit 400";
static private final String SQL_GET_COEXPRESSED_GENES_SCORES = "select coexpressed_gene, pearson_correl from coexpression where gene_name = ? order by pearson_correl desc limit 400";
static private final String SQL_GET_COEXPRESSED_TMM_GENES_SCORES = "select coexpressed_gene, tmm_score from coexpression where gene_name = ? order by tmm_score desc limit 400";
static private final String SQL_GET_COEXPRESSED_MULTIPLE_GENES_SCORES = "select coexpressed_gene, score from coexpression_reliable where gene_name = ? order by score desc limit 400";
private String username = null;
private String password = null;
private String server = null;
private int port = -1;
private Connection conn = null;
private ca.bcgsc.sockeye.config.Connection configConn = null;
public CoexpressionDAO() {
Service service = Configuration.getService("Coexpression");
String dbServer = service.getConnection();
ca.bcgsc.sockeye.config.Connection[] conns = Configuration
.getConnections();
int i;
boolean bMatch = false;
for (i = 0; i < conns.length; i++) {
if (dbServer.equals(conns[i].getName())) {
bMatch = true;
configConn = conns[i];
break;
}
}
if (bMatch == false) {
throw new RuntimeException(
"No defined db connections match the one specified: "
+ dbServer);
}
server = conns[i].getHost();
port = Integer.parseInt(conns[i].getPort());
username = conns[i].getUser();
password = conns[i].getPass();
}
private void connect(String database) throws CoexpressionServiceException {
if (conn == null) {
try {
conn = DriverManager.getConnection("jdbc:mysql:
+ ":" + port + "/" + database,
username, password);
} catch (SQLException e) {
Log.printStackTrace(e);
try {
String alternatedb = getAlternateDb(database);
if (alternatedb != null) {
conn = DriverManager.getConnection("jdbc:mysql:
+ server + ":" + port + "/" + alternatedb,
username, password);
}
} catch (SQLException e1) {
Log.printStackTrace(e1);
}
}
}
}
private String getAlternateDb(String database) {
List dbList = FeatureLoaderLocal.getInstance().getDatabaseList(
configConn, "coexpression");
String prefix = database.substring(0, database.lastIndexOf('_'));
for (int i = 0; i < dbList.size(); i++) {
if (((String) dbList.get(i)).startsWith(prefix)) {
return (String) dbList.get(i);
}
}
return null;
}
private void disconnect() {
if (conn != null) {
try {
conn.close();
} catch (SQLException e) {
}
conn = null;
}
}
public void finalize() {
if (conn != null) {
System.out.println("Connection leak detected!!!!");
disconnect();
}
}
public Map getCoexpressionScores(String geneId, String[] database)
throws CoexpressionServiceException {
LinkedHashMap map = new LinkedHashMap();
boolean connected = false;
for (int i = 0; i < database.length; i++) {
connect(database[i]);
if (conn == null) {
System.out.println("No coexpression database found");
continue;
}
PreparedStatement ps = null;
ResultSet rs = null;
try {
if (database[i].indexOf("_tmm_") != -1) {
ps = conn
.prepareStatement(SQL_GET_COEXPRESSED_TMM_GENES_SCORES);
ps.setString(1, geneId);
rs = ps.executeQuery();
while (rs.next()) {
map.put(rs.getString("coexpressed_gene"), new Float(rs
.getFloat("tmm_score")));
}
} else if (database[i].indexOf("_reliable_multiple_") != -1) {
ps = conn
.prepareStatement(SQL_GET_COEXPRESSED_MULTIPLE_GENES_SCORES);
ps.setString(1, geneId);
rs = ps.executeQuery();
while (rs.next()) {
map.put(rs.getString("coexpressed_gene"), new Float(rs
.getFloat("score")));
}
} else if (database[i].indexOf("_reliable_") != -1) {
ps = conn
.prepareStatement(SQL_GET_COEXPRESSED_GENES_SCORES);
ps.setString(1, geneId);
rs = ps.executeQuery();
while (rs.next()) {
map.put(rs.getString("coexpressed_gene"), new Float(rs
.getFloat("pearson_correl")));
}
}
} catch (Exception e) {
System.out.println(database[i]);
e.printStackTrace();
throw new CoexpressionServiceException(e.getMessage());
} finally {
cleanup(ps, rs);
disconnect();
}
}
return map;
}
private void cleanup(PreparedStatement ps, ResultSet rs) {
if (rs != null) {
try {
rs.close();
} catch (SQLException e) {
}
}
if (ps != null) {
try {
ps.close();
} catch (SQLException e) {
}
}
}
public String getPassword() {
return password;
}
public int getPort() {
return port;
}
public String getServer() {
return server;
}
public String getUsername() {
return username;
}
public Connection getConn() {
return conn;
}
public void setConn(Connection connection) {
conn = connection;
}
public void setPassword(String string) {
password = string;
}
public void setPort(int i) {
port = i;
}
public void setServer(String string) {
server = string;
}
public void setUsername(String string) {
username = string;
}
}/*------
package ca.bcgsc.sockeye.service.coexpression.remote;
import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.Map;
import javax.xml.rpc.ServiceException;
import ca.bcgsc.sockeye.service.coexpression.common.CoexpressionService;
import ca.bcgsc.sockeye.service.coexpression.common.CoexpressionServiceException;
import ca.bcgsc.sockeye.service.coexpression.remote.genstubs.CoexpressionDAOServiceLocator;
import ca.bcgsc.sockeye.service.coexpression.remote.genstubs.CoexpressionSoapBindingStub;
import ca.bcgsc.sockeye.util.Log;
public class CoexpressionRemote implements CoexpressionService {
private String remoteConnectionStr = null;
public CoexpressionRemote(String remoteConnectionStr) {
this.remoteConnectionStr = remoteConnectionStr;
}
public Map getCoexpressionScores(String geneId, String database)
throws CoexpressionServiceException {
CoexpressionDAOServiceLocator loc = new CoexpressionDAOServiceLocator(
remoteConnectionStr);
Map map = null;
try {
CoexpressionSoapBindingStub stub = (CoexpressionSoapBindingStub) loc
.getCoexpression();
map = stub.getCoexpressionScores(geneId, database);
map = sort(map);
} catch (ServiceException e) {
e.printStackTrace();
Log.printStackTrace(e);
throw new CoexpressionServiceException(e.getMessage());
} catch (RemoteException re) {
Log.printStackTrace(re);
re.printStackTrace();
throw new CoexpressionServiceException(re.getMessage());
}
return map;
}
public Map getCoexpressionScores(String geneId, String[] database)
throws CoexpressionServiceException {
return null;
}
private Map sort(Map map) {
Map sortedMap = new LinkedHashMap();
ArrayList list = new ArrayList(map.entrySet());
Collections.sort(list, new Comparator() {
public boolean equals(Object obj) {
return (this == obj);
}
public int compare(Object o1, Object o2) {
Map.Entry e1 = (Map.Entry) o1;
Map.Entry e2 = (Map.Entry) o2;
float f1 = ((Float) e1.getValue()).floatValue();
float f2 = ((Float) e2.getValue()).floatValue();
return f1 == f2 ? 0 : (f1 > f2 ? -1 : 1);
}
});
for (int i = 0; i < list.size(); i++) {
Map.Entry e = (Map.Entry) list.get(i);
sortedMap.put(e.getKey(), e.getValue());
}
return sortedMap;
}
}/*------
package ca.bcgsc.sockeye.service.coexpression.remote.genstubs;
public interface CoexpressionDAO extends java.rmi.Remote {
public java.util.HashMap getCoexpressionScores(java.lang.String geneId, java.lang.String database) throws java.rmi.RemoteException, ca.bcgsc.sockeye.service.coexpression.remote.genstubs.CoexpressionServiceException;
}
package ca.bcgsc.sockeye.service.coexpression.remote.genstubs;
public interface CoexpressionDAOService extends javax.xml.rpc.Service {
public java.lang.String getCoexpressionAddress();
public ca.bcgsc.sockeye.service.coexpression.remote.genstubs.CoexpressionDAO getCoexpression() throws javax.xml.rpc.ServiceException;
public ca.bcgsc.sockeye.service.coexpression.remote.genstubs.CoexpressionDAO getCoexpression(java.net.URL portAddress) throws javax.xml.rpc.ServiceException;
}
package ca.bcgsc.sockeye.service.coexpression.remote.genstubs;
public class CoexpressionDAOServiceLocator extends org.apache.axis.client.Service implements ca.bcgsc.sockeye.service.coexpression.remote.genstubs.CoexpressionDAOService {
private java.lang.String Coexpression_address = "http:
public CoexpressionDAOServiceLocator(String remoteConnStr) {
Coexpression_address = "http:
}
public java.lang.String getCoexpressionAddress() {
return Coexpression_address;
}
private java.lang.String CoexpressionWSDDServiceName = "Coexpression";
public java.lang.String getCoexpressionWSDDServiceName() {
return CoexpressionWSDDServiceName;
}
public void setCoexpressionWSDDServiceName(java.lang.String name) {
CoexpressionWSDDServiceName = name;
}
public ca.bcgsc.sockeye.service.coexpression.remote.genstubs.CoexpressionDAO getCoexpression() throws javax.xml.rpc.ServiceException {
java.net.URL endpoint;
try {
endpoint = new java.net.URL(Coexpression_address);
}
catch (java.net.MalformedURLException e) {
throw new javax.xml.rpc.ServiceException(e);
}
return getCoexpression(endpoint);
}
public ca.bcgsc.sockeye.service.coexpression.remote.genstubs.CoexpressionDAO getCoexpression(java.net.URL portAddress) throws javax.xml.rpc.ServiceException {
try {
ca.bcgsc.sockeye.service.coexpression.remote.genstubs.CoexpressionSoapBindingStub _stub = new ca.bcgsc.sockeye.service.coexpression.remote.genstubs.CoexpressionSoapBindingStub(portAddress, this);
_stub.setPortName(getCoexpressionWSDDServiceName());
return _stub;
}
catch (org.apache.axis.AxisFault e) {
return null;
}
}
public java.rmi.Remote getPort(Class serviceEndpointInterface) throws javax.xml.rpc.ServiceException {
try {
if (ca.bcgsc.sockeye.service.coexpression.remote.genstubs.CoexpressionDAO.class.isAssignableFrom(serviceEndpointInterface)) {
ca.bcgsc.sockeye.service.coexpression.remote.genstubs.CoexpressionSoapBindingStub _stub = new ca.bcgsc.sockeye.service.coexpression.remote.genstubs.CoexpressionSoapBindingStub(new java.net.URL(Coexpression_address), this);
_stub.setPortName(getCoexpressionWSDDServiceName());
return _stub;
}
}
catch (java.lang.Throwable t) {
throw new javax.xml.rpc.ServiceException(t);
}
throw new javax.xml.rpc.ServiceException("There is no stub implementation for the interface: " + (serviceEndpointInterface == null ? "null" : serviceEndpointInterface.getName()));
}
public java.rmi.Remote getPort(javax.xml.namespace.QName portName, Class serviceEndpointInterface) throws javax.xml.rpc.ServiceException {
if (portName == null) {
return getPort(serviceEndpointInterface);
}
String inputPortName = portName.getLocalPart();
if ("Coexpression".equals(inputPortName)) {
return getCoexpression();
}
else {
java.rmi.Remote _stub = getPort(serviceEndpointInterface);
((org.apache.axis.client.Stub) _stub).setPortName(portName);
return _stub;
}
}
public javax.xml.namespace.QName getServiceName() {
return new javax.xml.namespace.QName("http:
}
private java.util.HashSet ports = null;
public java.util.Iterator getPorts() {
if (ports == null) {
ports = new java.util.HashSet();
ports.add(new javax.xml.namespace.QName("Coexpression"));
}
return ports.iterator();
}
}
package ca.bcgsc.sockeye.service.coexpression.remote.genstubs;
public class CoexpressionServiceException extends org.apache.axis.AxisFault implements java.io.Serializable {
public CoexpressionServiceException() {
}
private java.lang.Object __equalsCalc = null;
public synchronized boolean equals(java.lang.Object obj) {
if (!(obj instanceof CoexpressionServiceException)) return false;
CoexpressionServiceException other = (CoexpressionServiceException) obj;
if (obj == null) return false;
if (this == obj) return true;
if (__equalsCalc != null) {
return (__equalsCalc == obj);
}
__equalsCalc = obj;
boolean _equals;
_equals = true;
__equalsCalc = null;
return _equals;
}
private boolean __hashCodeCalc = false;
public synchronized int hashCode() {
if (__hashCodeCalc) {
return 0;
}
__hashCodeCalc = true;
int _hashCode = 1;
__hashCodeCalc = false;
return _hashCode;
}
private static org.apache.axis.description.TypeDesc typeDesc =
new org.apache.axis.description.TypeDesc(CoexpressionServiceException.class);
static {
typeDesc.setXmlType(new javax.xml.namespace.QName("http:
}
public static org.apache.axis.description.TypeDesc getTypeDesc() {
return typeDesc;
}
public static org.apache.axis.encoding.Serializer getSerializer(
java.lang.String mechType,
java.lang.Class _javaType,
javax.xml.namespace.QName _xmlType) {
return
new org.apache.axis.encoding.ser.BeanSerializer(
_javaType, _xmlType, typeDesc);
}
public static org.apache.axis.encoding.Deserializer getDeserializer(
java.lang.String mechType,
java.lang.Class _javaType,
javax.xml.namespace.QName _xmlType) {
return
new org.apache.axis.encoding.ser.BeanDeserializer(
_javaType, _xmlType, typeDesc);
}
public void writeDetails(javax.xml.namespace.QName qname, org.apache.axis.encoding.SerializationContext context) throws java.io.IOException {
context.serialize(qname, null, this);
}
}
package ca.bcgsc.sockeye.service.coexpression.remote.genstubs;
public class CoexpressionSoapBindingStub extends org.apache.axis.client.Stub implements ca.bcgsc.sockeye.service.coexpression.remote.genstubs.CoexpressionDAO {
private java.util.Vector cachedSerClasses = new java.util.Vector();
private java.util.Vector cachedSerQNames = new java.util.Vector();
private java.util.Vector cachedSerFactories = new java.util.Vector();
private java.util.Vector cachedDeserFactories = new java.util.Vector();
static org.apache.axis.description.OperationDesc [] _operations;
static {
_operations = new org.apache.axis.description.OperationDesc[1];
org.apache.axis.description.OperationDesc oper;
oper = new org.apache.axis.description.OperationDesc();
oper.setName("getCoexpressionScores");
oper.addParameter(new javax.xml.namespace.QName("", "geneId"), new javax.xml.namespace.QName("http:
oper.addParameter(new javax.xml.namespace.QName("", "database"), new javax.xml.namespace.QName("http:
oper.setReturnType(new javax.xml.namespace.QName("http:
oper.setReturnClass(java.util.HashMap.class);
oper.setReturnQName(new javax.xml.namespace.QName("", "getCoexpressionScoresReturn"));
oper.setStyle(org.apache.axis.enum.Style.RPC);
oper.setUse(org.apache.axis.enum.Use.ENCODED);
oper.addFault(new org.apache.axis.description.FaultDesc(
new javax.xml.namespace.QName("http:
"ca.bcgsc.sockeye.service.coexpression.remote.genstubs.CoexpressionServiceException",
new javax.xml.namespace.QName("http:
true
));
_operations[0] = oper;
}
public CoexpressionSoapBindingStub() throws org.apache.axis.AxisFault {
this(null);
}
public CoexpressionSoapBindingStub(java.net.URL endpointURL, javax.xml.rpc.Service service) throws org.apache.axis.AxisFault {
this(service);
super.cachedEndpoint = endpointURL;
}
public CoexpressionSoapBindingStub(javax.xml.rpc.Service service) throws org.apache.axis.AxisFault {
if (service == null) {
super.service = new org.apache.axis.client.Service();
} else {
super.service = service;
}
java.lang.Class cls;
javax.xml.namespace.QName qName;
java.lang.Class beansf = org.apache.axis.encoding.ser.BeanSerializerFactory.class;
java.lang.Class beandf = org.apache.axis.encoding.ser.BeanDeserializerFactory.class;
java.lang.Class enumsf = org.apache.axis.encoding.ser.EnumSerializerFactory.class;
java.lang.Class enumdf = org.apache.axis.encoding.ser.EnumDeserializerFactory.class;
java.lang.Class arraysf = org.apache.axis.encoding.ser.ArraySerializerFactory.class;
java.lang.Class arraydf = org.apache.axis.encoding.ser.ArrayDeserializerFactory.class;
java.lang.Class simplesf = org.apache.axis.encoding.ser.SimpleSerializerFactory.class;
java.lang.Class simpledf = org.apache.axis.encoding.ser.SimpleDeserializerFactory.class;
qName = new javax.xml.namespace.QName("http:
cachedSerQNames.add(qName);
cls = ca.bcgsc.sockeye.service.coexpression.remote.genstubs.CoexpressionServiceException.class;
cachedSerClasses.add(cls);
cachedSerFactories.add(beansf);
cachedDeserFactories.add(beandf);
}
private org.apache.axis.client.Call createCall() throws java.rmi.RemoteException {
try {
org.apache.axis.client.Call _call =
(org.apache.axis.client.Call) super.service.createCall();
if (super.maintainSessionSet) {
_call.setMaintainSession(super.maintainSession);
}
if (super.cachedUsername != null) {
_call.setUsername(super.cachedUsername);
}
if (super.cachedPassword != null) {
_call.setPassword(super.cachedPassword);
}
if (super.cachedEndpoint != null) {
_call.setTargetEndpointAddress(super.cachedEndpoint);
}
if (super.cachedTimeout != null) {
_call.setTimeout(super.cachedTimeout);
}
if (super.cachedPortName != null) {
_call.setPortName(super.cachedPortName);
}
java.util.Enumeration keys = super.cachedProperties.keys();
while (keys.hasMoreElements()) {
java.lang.String key = (java.lang.String) keys.nextElement();
_call.setProperty(key, super.cachedProperties.get(key));
}
synchronized (this) {
if (firstCall()) {
_call.setSOAPVersion(org.apache.axis.soap.SOAPConstants.SOAP11_CONSTANTS);
_call.setEncodingStyle(org.apache.axis.Constants.URI_SOAP11_ENC);
for (int i = 0; i < cachedSerFactories.size(); ++i) {
java.lang.Class cls = (java.lang.Class) cachedSerClasses.get(i);
javax.xml.namespace.QName qName =
(javax.xml.namespace.QName) cachedSerQNames.get(i);
java.lang.Class sf = (java.lang.Class)
cachedSerFactories.get(i);
java.lang.Class df = (java.lang.Class)
cachedDeserFactories.get(i);
_call.registerTypeMapping(cls, qName, sf, df, false);
}
}
}
return _call;
}
catch (java.lang.Throwable t) {
throw new org.apache.axis.AxisFault("Failure trying to get the Call object", t);
}
}
public java.util.HashMap getCoexpressionScores(java.lang.String geneId, java.lang.String database) throws java.rmi.RemoteException, ca.bcgsc.sockeye.service.coexpression.remote.genstubs.CoexpressionServiceException {
if (super.cachedEndpoint == null) {
throw new org.apache.axis.NoEndPointException();
}
org.apache.axis.client.Call _call = createCall();
_call.setOperation(_operations[0]);
_call.setUseSOAPAction(true);
_call.setSOAPActionURI("");
_call.setSOAPVersion(org.apache.axis.soap.SOAPConstants.SOAP11_CONSTANTS);
_call.setOperationName(new javax.xml.namespace.QName("http:
setRequestHeaders(_call);
setAttachments(_call);
java.lang.Object _resp = _call.invoke(new java.lang.Object[] {geneId, database});
if (_resp instanceof java.rmi.RemoteException) {
throw (java.rmi.RemoteException)_resp;
}
else {
extractAttachments(_call);
try {
return (java.util.HashMap) _resp;
} catch (java.lang.Exception _exception) {
return (java.util.HashMap) org.apache.axis.utils.JavaUtils.convert(_resp, java.util.HashMap.class);
}
}
}
}
package ca.bcgsc.sockeye.service.featureloader.common;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import ca.bcgsc.chinook.server.comobj.SerializableSimpleGFFRecord;
public class AttributeUtil {
private AttributeUtil() {
super();
}
public static void setAttribute(
String key,
Object value,
SerializableSimpleGFFRecord unseq) {
Map map = unseq.getGroupAttributes();
if(value instanceof List) {
map.put(key, value);
return;
}
if (map == null) {
map = new HashMap();
unseq.setGroupAttributes(map);
}
ArrayList temp = new ArrayList();
temp.add(value);
map.put(key, temp);
}
public static String getAttribute(
String key,
SerializableSimpleGFFRecord unseq) {
Map map = unseq.getGroupAttributes();
if (map == null) {
return null;
}
ArrayList tn = (ArrayList)(map.get(key));
if( tn == null || tn.isEmpty())
return "";
else
return (String)tn.get(0);
}
}
package ca.bcgsc.sockeye.service.featureloader.common;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Properties;
import java.util.Set;
import java.util.StringTokenizer;
import org.ensembl.driver.DriverManager;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.config.Connection;
import ca.bcgsc.sockeye.config.Service;
import ca.bcgsc.sockeye.dataretrieval.CisREDDRU;
import ca.bcgsc.sockeye.dataretrieval.CisREDDataSource;
import ca.bcgsc.sockeye.util.StringUtils;
public class ConnectionManager {
public static final String __ENSEMBL = "Ensembl";
static HashMap _short_long_names = new HashMap();
private static ArrayList _conn = new ArrayList();
private static HashMap _current_connections = new HashMap();
private static HashMap _current_databases = new HashMap();
private static final int MINIMUM_ENSEMBL_VERSION_SUPPORTED = 11;
private static HashMap _ensembl_driver_map = new HashMap();
public static void initialize() {
_conn.clear();
_current_databases.clear();
_current_connections.clear();
Connection[] conn = Configuration.getConnections();
for (int i = 0; i < conn.length; i++) {
if (containsConnection(conn[i]) || conn[i] == null) {
continue;
}
_conn.add(conn[i]);
if (getCurrentConnection(conn[i].getType()) == null) {
setCurrentConnectionByConnection(conn[i]);
}
}
if (_conn.size() == 0) {
javax.swing.JOptionPane.showMessageDialog(null,
"No connections available, check Internet connection",
"Sockeye can't connect",
javax.swing.JOptionPane.INFORMATION_MESSAGE);
}
}
public static Connection getCurrentConnection(String type) {
return (Connection) _current_connections.get(type);
}
public static void setCurrentConnectionByConnection(Connection connection) {
_current_connections.put(new String(connection.getType()), connection);
}
public static void setCurrentConnectionByName(String name) {
Connection connection = getConnectionForName(name);
setCurrentConnectionByConnection(connection);
}
public static void setCurrentConnectionByIndex(int index) {
List conn = getConnectionList(__ENSEMBL);
setCurrentConnectionByConnection((Connection) conn.get(index));
System.out.println(conn.get(index));
}
public static boolean addConnection(Connection connection) {
if (containsConnection(connection)) {
return false;
}
boolean sameNameExists = false;
Connection conn_same = null;
for (Iterator i = _conn.iterator(); i.hasNext();) {
Connection conn = (Connection) i.next();
if (conn.getName().equals(connection.getName())) {
sameNameExists = true;
conn_same = conn;
break;
}
}
if (sameNameExists) {
removeConnection(conn_same);
}
_conn.add(connection);
if (_current_connections.containsKey(new String(connection.getType()))) {
} else {
_current_connections.put(new String(connection.getType()),
connection);
}
return true;
}
public static boolean removeConnection(Connection connection) {
for (Iterator i = _conn.iterator(); i.hasNext();) {
Connection temp = (Connection) i.next();
if (temp.getHost().equals(connection.getHost())
&& temp.getName().equals(connection.getName())
&& temp.getPass().equals(connection.getPass())
&& temp.getPort().equals(connection.getPort())
&& temp.getType().equals(connection.getType())
&& temp.getUser().equals(connection.getUser())) {
i.remove();
if (_current_connections.containsValue(connection)) {
_current_connections.remove(connection);
}
return true;
}
}
return false;
}
private static boolean containsConnection(Connection connection) {
for (Iterator i = _conn.iterator(); i.hasNext();) {
Connection temp = (Connection) i.next();
if (temp.getHost().equals(connection.getHost())
&& temp.getName().equals(connection.getName())
&& temp.getPass().equals(connection.getPass())
&& temp.getPort().equals(connection.getPort())
&& temp.getType().equals(connection.getType())
&& temp.getUser().equals(connection.getUser())) {
return true;
}
}
return false;
}
public static ArrayList getConnectionList(String type) {
ArrayList conn_list = new ArrayList();
Service service = Configuration
.getService(FeatureLoaderServiceFactory.FEATURELOADER_SERVICES);
String mode = null;
if (service != null) {
mode = service.getMode();
} else {
throw new RuntimeException(
"Feature loader service not set up properly.");
}
for (Iterator i = _conn.iterator(); i.hasNext();) {
Connection connection = (Connection) i.next();
if (connection.getType().equals(type)
&& ("remote".equals(mode) || ("new".equals(connection
.getSubtype()))
&& !("lite".equals(connection.getSubtype())))) {
conn_list.add(connection);
}
}
return conn_list;
}
public static ArrayList getConnectionNames(String type) {
ArrayList names_list = new ArrayList();
ArrayList conn_list = getConnectionList(type);
for (Iterator i = conn_list.iterator(); i.hasNext();) {
Connection connection = (Connection) i.next();
names_list.add(connection.getName());
}
return names_list;
}
public static Connection getConnectionForName(String name) {
for (Iterator i = _conn.iterator(); i.hasNext();) {
Connection connection = (Connection) i.next();
if (connection.getName().equals(name)) {
return connection;
}
}
return null;
}
public static Connection getConnectionBySubtypeSpecies(String subtype) {
for (Iterator i = _conn.iterator(); i.hasNext();) {
Connection connection = (Connection) i.next();
String[] subtype_arr = connection.getSubtype().split(",");
for (int j = 0; j < subtype_arr.length; j++) {
if (subtype_arr[j].replaceAll(" ", "").startsWith(subtype)) {
return connection;
}
}
}
return null;
}
public static Connection getConnectionByType(String type) {
for (Iterator i = _conn.iterator(); i.hasNext();) {
Connection connection = (Connection) i.next();
if (connection != null) {
String t = connection.getType();
if (t != null && t.equals(type))
return connection;
}
}
return null;
}
public static Connection getCisRedConnection(String species) {
if (species == null)
throw new IllegalArgumentException("Species is NULL");
for (Iterator i = _conn.iterator(); i.hasNext();) {
Connection connection = (Connection) i.next();
if (connection != null) {
String t = connection.getType();
if (t != null && t.equals(CisREDDRU.__CISRED_FEATURE_NAME)) {
String cisredSpecies = CisREDDataSource
.getInfoFromDatabaseName(connection.getSubtype(),
"species");
if (species.equals(cisredSpecies))
return connection;
}
}
}
return null;
}
public static List getCisRedConnections() {
List connections = new ArrayList();
for (Iterator i = _conn.iterator(); i.hasNext();) {
Connection connection = (Connection) i.next();
if (connection != null) {
String t = connection.getType();
if (t != null && t.equals(CisREDDRU.__CISRED_FEATURE_NAME)) {
connections.add(connection);
}
}
}
return connections;
}
public static List getAllConnectionTypes() {
ArrayList types = new ArrayList();
Set available_types = _current_connections.keySet();
for (Iterator i = available_types.iterator(); i.hasNext();) {
types.add(i.next().toString());
}
return types;
}
public static void setCurrentDatabase(String type, String db_name) {
try {
if (db_name == null) {
throw new Exception("no current database defined for " + type);
}
_current_databases.put(type, db_name);
} catch (Exception e) {
e.printStackTrace();
}
}
public static String getCurrentDatabaseByType(String type) {
return (String) _current_databases.get(type);
}
public static String getCurrentDatabaseByName(String name) {
Connection connection = getConnectionForName(name);
return getCurrentDatabaseByType(connection.getType());
}
public static Properties createEnsemblDriverConfig(Connection connection) {
if (connection != null && connection.getType().equals(__ENSEMBL)) {
Properties allConfigProps = new Properties();
allConfigProps.put("jdbc_driver", "com.mysql.jdbc.Driver");
allConfigProps.put("host", connection.getHost());
allConfigProps.put("port", connection.getPort());
allConfigProps.put("user", connection.getUser());
allConfigProps.put("password", connection.getPass());
allConfigProps.put("connection_pool_size", "50");
return allConfigProps;
} else {
return null;
}
}
public static org.ensembl.driver.Driver createCurrentEnsemblDriver() {
try {
Connection curr_conn = (Connection) _current_connections
.get(__ENSEMBL);
if (_ensembl_driver_map.containsKey(getKeyForCurrDB(curr_conn))) {
org.ensembl.driver.Driver driver = (org.ensembl.driver.Driver) _ensembl_driver_map
.get(getKeyForCurrDB(curr_conn));
String database_dd = (String) driver.getConfiguration().get(
"database");
if (database_dd.equals(getCurrentDatabaseByType(__ENSEMBL))
&& driver.isConnected()) {
return driver;
}
}
Properties driver_properties = createEnsemblDriverConfig(curr_conn);
String database_name = getCurrentDatabaseByType(__ENSEMBL);
if (database_name == null) {
throw new Exception("no selected database for driver in "
+ _current_databases.toString());
}
driver_properties.put(new String("ensembl_driver"), new String(
"org.ensembl.driver.plugin.standard.MySQLDriver"));
driver_properties.put(new String("database"), database_name);
try {
org.ensembl.driver.Driver ensembl_driver = DriverManager
.load(driver_properties);
if (ensembl_driver == null) {
throw new Exception("unsupported_db");
}
_ensembl_driver_map.put(getKeyForCurrDB(curr_conn),
ensembl_driver);
return ensembl_driver;
} catch (Exception e) {
e.printStackTrace();
throw new Exception("unsupported_db");
}
} catch (Exception e) {
e.printStackTrace();
return null;
}
}
private static Object getKeyForCurrDB(Connection curr_conn) {
return new ConnectionSpeciesdbKey(curr_conn,
(String) _current_databases.get(__ENSEMBL));
}
private static Object getKeyForDB(Connection curr_conn, String database_name) {
return new ConnectionSpeciesdbKey(curr_conn, database_name);
}
public static org.ensembl.driver.Driver createEnsemblDriverForDatabase(
String ensembl_type, String a_database_name, Connection a_conn) {
String database_name = a_database_name;
String alternate_db = null;
if (ensembl_type.equals("COMPARA")) {
if (!database_name.matches("ensembl_compara_*")) {
alternate_db = EnsemblDBListManager
.getEnsemblDatabaseForCoreDatabaseName(database_name,
"COMPARA", a_conn);
}
}
if (ensembl_type.equals("EST")) {
if (!database_name.matches(".*_est_.*")) {
alternate_db = EnsemblDBListManager
.getEnsemblDatabaseForCoreDatabaseName(database_name,
"EST", a_conn);
}
}
if (ensembl_type.equals("SNP")) {
if (!database_name.matches(".*_snp_.*")) {
alternate_db = EnsemblDBListManager
.getEnsemblDatabaseForCoreDatabaseName(database_name,
"SNP", a_conn);
}
}
try {
if (alternate_db != null) {
database_name = alternate_db;
}
if (_ensembl_driver_map.containsKey(getKeyForDB(a_conn,
database_name))) {
org.ensembl.driver.Driver driver = (org.ensembl.driver.Driver) _ensembl_driver_map
.get(getKeyForDB(a_conn, database_name));
String database_dd = (String) driver.getConfiguration().get(
"database");
if (database_dd.equals(database_name) && driver.isConnected()
&& ensembl_type.equals("CORE")) {
return driver;
}
if (database_dd.equals(alternate_db) && /* driver.isConnected() && */
ensembl_type.equals("COMPARA")) {
return driver;
}
if (database_dd.equals(alternate_db) && driver.isConnected()
&& ensembl_type.equals("EST")) {
return driver;
}
if (database_dd.equals(alternate_db) && driver.isConnected()
&& ensembl_type.equals("SNP")) {
return driver;
}
if (driver.isConnected()) {
return driver;
}
}
Properties driver_properties = createEnsemblDriverConfig(a_conn);
if (database_name == null) {
throw new Exception("no selected database for driver in "
+ _current_databases.toString());
}
if (ensembl_type.equals("CORE")) {
driver_properties.put(new String("ensembl_driver"), new String(
"org.ensembl.driver.plugin.standard.MySQLDriver"));
driver_properties.put(new String("database"), database_name);
org.ensembl.driver.Driver ensembl_driver = DriverManager
.load(driver_properties);
if (ensembl_driver == null) {
throw new Exception("unsupported_db");
}
_ensembl_driver_map.put(getKeyForDB(a_conn, database_name),
ensembl_driver);
return ensembl_driver;
} else if (ensembl_type.equals("COMPARA")) {
driver_properties
.put(
new String("ensembl_driver"),
new String(
"org.ensembl.driver.plugin.compara.ComparaMySQLDriver"));
if (alternate_db == null) {
throw new Exception("no selected database for driver in "
+ _current_databases.toString());
}
driver_properties.put(new String("database"), alternate_db);
driver_properties
.put(new String("path"), new String("current"));
org.ensembl.driver.Driver ensembl_driver = DriverManager
.load(driver_properties);
if (ensembl_driver == null) {
throw new Exception("unsupported_db");
}
_ensembl_driver_map.put(getKeyForDB(a_conn, database_name),
ensembl_driver);
return ensembl_driver;
} else if (ensembl_type.equals("EST")) {
driver_properties.put(new String("ensembl_driver"), new String(
"org.ensembl.driver.plugin.standard.MySQLDriver"));
if (alternate_db == null) {
return null;
}
driver_properties.put(new String("database"), alternate_db);
org.ensembl.driver.Driver ensembl_driver = DriverManager
.load(driver_properties);
if (ensembl_driver == null) {
throw new Exception("unsupported_db");
}
_ensembl_driver_map.put(getKeyForDB(a_conn, database_name),
ensembl_driver);
return ensembl_driver;
} else if (ensembl_type.equals("SNP")) {
driver_properties.put(new String("ensembl_driver"), new String(
"org.ensembl.driver.plugin.standard.MySQLDriver"));
if (alternate_db == null) {
throw new Exception("no selected database for driver in "
+ _current_databases.toString());
}
driver_properties.put(new String("database"), alternate_db);
org.ensembl.driver.Driver ensembl_driver = DriverManager
.load(driver_properties);
if (ensembl_driver == null) {
throw new Exception("unsupported_db");
}
_ensembl_driver_map.put(getKeyForDB(a_conn, database_name),
ensembl_driver);
return ensembl_driver;
} else {
throw new Exception("Invalid ensembl_type has been set");
}
} catch (Exception e) {
e.printStackTrace();
return null;
}
}
private static boolean isHigherThanMinimumEnsemblVersionSupported(
String database_name) {
int version = getEnsemblVersionForDatabase(database_name);
if (MINIMUM_ENSEMBL_VERSION_SUPPORTED <= version) {
return true;
}
return false;
}
public static String convertEnsemblDatabaseNameToSpeciesName(String db_name) {
StringTokenizer st = new StringTokenizer(db_name, "_");
String species = st.nextToken() + "_" + st.nextToken();
char[] firstletter = new char[1];
firstletter[0] = species.charAt(0);
String fl = new String(firstletter);
fl = fl.toUpperCase();
species = species.substring(1);
species = fl + species;
return species;
}
public static String convertEnsemblDatabaseToShortSpeciesName(String db_name) {
String species = convertEnsemblDatabaseNameToSpeciesName(db_name);
String shortname = StringUtils.getShortSpeciesName(species);
_short_long_names.put(shortname, species);
return shortname;
}
public static String getLongSpeciesName(String shortname) {
Object longname = _short_long_names.get(shortname);
if (longname != null) {
return longname.toString();
} else {
return "";
}
}
public static int getEnsemblVersionForDatabase(String db_name) {
String[] db_name_pieces = db_name.split("_");
String ens_vers_str = db_name_pieces[db_name_pieces.length - 2];
return Integer.valueOf(ens_vers_str).intValue();
}
public static boolean testEnsemblForConnection(Connection conn) {
try {
Properties driver_config = createEnsemblDriverConfig(conn);
if (driver_config == null) {
throw new Exception("driver_conf is null");
}
org.ensembl.driver.Driver driver = DriverManager
.load(driver_config);
String[] databases = driver.fetchDatabaseNames();
if (databases == null || databases.length == 0) {
throw new Exception();
}
return true;
} catch (Exception e) {
return false;
}
}
}/*------
package ca.bcgsc.sockeye.service.featureloader.common;
import ca.bcgsc.sockeye.config.Connection;
public final class ConnectionSpeciesdbKey {
private Connection conn;
private String speciesdb;
ConnectionSpeciesdbKey(Connection conn, String speciesdb) {
this.conn = conn;
this.speciesdb = speciesdb;
}
public boolean equals(Object obj) {
if(!(obj instanceof ConnectionSpeciesdbKey)) {
return false;
}
ConnectionSpeciesdbKey key = (ConnectionSpeciesdbKey) obj;
if (getConn().equals(key.getConn()) &&
getSpeciesdb().equals(key.getSpeciesdb())) {
return true;
}
return false;
}
public int hashCode() {
return conn.hashCode() ^ speciesdb.hashCode();
}
public Connection getConn() {
return conn;
}
public String getSpeciesdb() {
return speciesdb;
}
}
package ca.bcgsc.sockeye.service.featureloader.common;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import ca.bcgsc.sockeye.config.Connection;
public class CustomEnsEMBLQuery {
static {
try {
Class.forName("com.mysql.jdbc.Driver");
} catch (ClassNotFoundException e) {
e.printStackTrace();
}
}
public static CustomEnsEMBLQuery getInstance(Connection connection) {
return new CustomEnsEMBLQuery(connection);
}
private Connection connection;
private Statement stmt;
private java.sql.Connection conn;
private ResultSet rset;
private CustomEnsEMBLQuery(Connection connection) {
this.connection = connection;
}
public java.sql.Connection getConnection(String db) {
String server = connection.getHost();
String port = connection.getPort();
if (port != null || port != "") {
server = server.concat(":").concat(port);
}
String user = connection.getUser();
String passwd = connection.getPass();
String url = new String("jdbc:mysql:
try {
conn = DriverManager.getConnection(url, user, passwd);
return conn;
}
catch (SQLException e) {
System.out.println("CustomEnsEMBLQuery: Can't connect to DB: " + e.getMessage());
return null;
}
}
public ResultSet doQuery(String db, String query_string) {
return doQuery(db, "lite", query_string);
}
public ResultSet doQuery(String db, String db_type, String query_string) {
getConnection(db.replaceAll("core", db_type));
try {
stmt = conn.createStatement();
}
catch (SQLException e) {
System.out.println("CustomEnsEMBLQuery: Can't create statement: " + e.toString());
try {
conn.close();
}
catch (SQLException s) {
System.out.println("Can't close connection: " + e.toString());
}
return null;
}
try {
rset = stmt.executeQuery(query_string);
}
catch (SQLException e) {
System.out.println("CustomEnsEMBLQuery: Error while executing query: " + e.toString());
return null;
}
return rset;
}
public void close() {
try {
if(rset != null) rset.close();
}
catch (SQLException e) {
System.out.println("CustomEnsEMBLQuery Can't close result set: " + e.toString());
}
try {
if(stmt != null) stmt.close();
}
catch (SQLException e) {
System.out.println("CustomEnsEMBLQuery Can't close statement: " + e.toString());
}
try {
if(conn != null) conn.close();
}
catch (SQLException e) {
System.out.println("CustomEnsEMBLQuery Can't close connection: " + e.toString());
}
}
}
package ca.bcgsc.sockeye.service.featureloader.common;
import java.io.Serializable;
public class DistributionContainer implements Serializable{
private int _start;
private int _end;
private double _score;
public DistributionContainer(){
}
public DistributionContainer(int start, int end, double score) {
this._start = start;
this._end = end;
this._score = score;
}
public boolean isInRange(int position) {
if (position >= this._start && position <= this._end) {
return true;
}
else {
return false;
}
}
public int getClosestDistance(int position) {
if ((this._start - position) > (position - this._end)) {
return (this._start - position);
}
else {
return (position - this._end);
}
}
public double getScore() {
return this._score;
}
public int getStart() {
return this._start;
}
public void setStart(int start) {
this._start = start;
}
public int getEnd() {
return this._end;
}
public void setEnd(int end) {
this._end = end;
}
public String toString() {
return "(" + this._start + ", " + this._end + ")->" + this._score;
}
}
package ca.bcgsc.sockeye.service.featureloader.common;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Properties;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeSet;
import org.ensembl.driver.ConfigurationException;
import org.ensembl.driver.Driver;
import org.ensembl.driver.DriverManager;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.config.Connection;
import ca.bcgsc.sockeye.config.Service;
public class EnsemblDBListManager {
public EnsemblDBListManager() {
super();
}
static private HashMap _list_driver_map = new HashMap();
public static Driver getListingDriver(
Connection connection) {
Driver driver = null;
try {
synchronized (_list_driver_map) {
if (_list_driver_map.containsKey(connection)) {
driver =
(org.ensembl.driver.Driver) _list_driver_map.get(connection);
} else {
Properties driver_config = ConnectionManager.createEnsemblDriverConfig(connection);
driver = DriverManager.load(driver_config);
_list_driver_map.put(
connection,
driver);
}
}
} catch (ConfigurationException e) {
e.printStackTrace();
}
return driver;
}
public static List getAllEnsemblSpeciesNames(int version, Connection connection) {
FeatureLoaderService ser = getFeatureLoaderService();
Object[] db_core = ser.getDatabaseList(
connection, "CORE").toArray();
Set all_ensembl_species_names = new TreeSet();
int index = 0;
for (int j = 0; j < db_core.length; j++) {
String db_name = (String) db_core[j];
String[] db_name_pieces = db_name.split("_");
if( Integer.valueOf(db_name_pieces[3]).intValue() == version ) {
all_ensembl_species_names.add(ConnectionManager.convertEnsemblDatabaseNameToSpeciesName(db_name)) ;
}
}
return new ArrayList(all_ensembl_species_names);
}
public static String getCoreEnsemblDatabaseFromConnection (int version, String species, Connection conn ) {
FeatureLoaderService ser = getFeatureLoaderService();
List databases = ser.getDatabaseList(
conn, "CORE");
for(Iterator it = databases.iterator(); it.hasNext(); ) {
String database = (String)it.next();
if( database.startsWith( species.toLowerCase().concat("_core_" + version ) ) ) return database;
}
return null;
}
private static FeatureLoaderService getFeatureLoaderService() {
FeatureLoaderServiceFactory fac = FeatureLoaderServiceFactory.getInstance();
Service service =
Configuration.getService(FeatureLoaderServiceFactory.FEATURELOADER_SERVICES);
String mode = null;
String remotehost = null;
if (service != null) {
mode = service.getMode();
remotehost = service.getRemotehost();
} else {
throw new RuntimeException("Feature loader service not set up properly.");
}
FeatureLoaderService ser = fac.getService(mode, remotehost);
return ser;
}
private static String getEnsemblDatabaseForVersionAndDatabase(int
version_number, String start_db_name, String dbType, Connection a_conn) {
FeatureLoaderService ser = getFeatureLoaderService();
List snp_list = ser.getDatabaseList(a_conn, dbType);
String version_string = String.valueOf(version_number);
for (Iterator i = snp_list.iterator(); i.hasNext(); ) {
String snp_db = (String) i.next();
StringTokenizer st = new StringTokenizer(snp_db, "_");
String start_curr_db = st.nextToken();
st.nextToken();
st.nextToken();
if (version_string.equals( (String) st.nextToken()) &&
start_db_name.equals(start_curr_db)) {
return snp_db;
}
}
return null;
}
private static String getEnsemblComparaDatabaseForVersion(int version_number,
Connection a_conn) {
FeatureLoaderService ser = getFeatureLoaderService();
List compara_list = ser.getDatabaseList(a_conn, "COMPARA");
String version_string = String.valueOf(version_number);
for (Iterator i = compara_list.iterator(); i.hasNext(); ) {
String compara_db = (String) i.next();
StringTokenizer st = new StringTokenizer(compara_db, "_");
st.nextToken();
st.nextToken();
if (version_string.equals( (String) st.nextToken())) {
return compara_db;
}
}
return null;
}
public static String getEnsemblDatabaseForCoreDatabaseName(
String database_name, String dbType, Connection a_conn) {
StringTokenizer st = new StringTokenizer(database_name, "_");
String db_start = st.nextToken();
st.nextToken();
st.nextToken();
String ensembl_version = st.nextToken();
int version = Integer.valueOf(ensembl_version).intValue();
if("COMPARA".equals(dbType)) {
return getEnsemblComparaDatabaseForVersion(version, a_conn);
} else {
return getEnsemblDatabaseForVersionAndDatabase(version, db_start, dbType,
a_conn);
}
}
}
package ca.bcgsc.sockeye.service.featureloader.common;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
public class FeatureDistributionLoaderResult implements Serializable {
private Map featureDistributions = new HashMap();
private List warningFeatureTypes = new ArrayList();
public FeatureDistributionLoaderResult() {
super();
}
public void put(String type, Map rawDistribution) {
featureDistributions.put(type, rawDistribution);
}
public Map get(String type) {
Map l = (Map)featureDistributions.get(type);
if (l == null) {
return null;
}
return (Map)(featureDistributions.get(type));
}
public void addWarningFeatureType(String type) {
warningFeatureTypes.add(type);
}
public Map getFeatureDistributions() {
return featureDistributions;
}
public List getWarningFeatureTypes() {
return Collections.unmodifiableList(warningFeatureTypes);
}
public void setFeatureDistributions(Map featureDistributions) {
this.featureDistributions = featureDistributions;
}
public void setWarningFeatureTypes(List warningFeatureTypes) {
this.warningFeatureTypes = warningFeatureTypes;
}
}
package ca.bcgsc.sockeye.service.featureloader.common;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import org.biojava.bio.program.gff.GFFTools;
import ca.bcgsc.chinook.server.comobj.SerializableSimpleGFFRecord;
import ca.bcgsc.sockeye.config.Connection;
import ca.bcgsc.sockeye.util.Log;
class FeatureLoaderLiteLocal {
private Connection _conn;
private String _database;
private String _species;
private String _chromosome;
private int _query_start;
private int _query_end;
private List _featureTypes;
private FeatureLoaderResult _result;
FeatureLoaderLiteLocal(Connection conn, String database, String species,
String chromosome, int query_start, int query_end, List featureTypes,
FeatureLoaderResult result) {
super();
_conn = conn;
_database = database.replaceAll("core", "lite");
_species = species;
_chromosome = chromosome;
_query_start = query_start;
_query_end = query_end;
_featureTypes = featureTypes;
_result = result;
}
public void load() {
String queryGene = "select gene_name, chr_start, chr_end, chr_strand, " +
"description, external_db from gene where db = 'core' and chr_name = ? " +
"and ( chr_start between ? and ? or " +
"chr_end between ? and ? )";
CustomEnsEMBLQuery cq = CustomEnsEMBLQuery.getInstance(_conn);
java.sql.Connection jconn = cq.getConnection(_database);
PreparedStatement ps = null;
ResultSet rs = null;
List genes_returned = (List) _result.get("gene");
if (genes_returned == null) {
genes_returned = new ArrayList();
_result.put("gene", genes_returned);
}
List multitrans_returned = (List) _result.get("multitranscript");
if (multitrans_returned == null) {
multitrans_returned = new ArrayList();
_result.put("multitranscript", multitrans_returned);
}
List exons_returned = (List) _result.get("exon");
if (exons_returned == null) {
exons_returned = new ArrayList();
_result.put("exon", exons_returned);
}
List fputr_returned = (List) _result.get("5'UTR");
if (fputr_returned == null) {
fputr_returned = new ArrayList();
_result.put("5'UTR", fputr_returned);
}
List tputr_returned = (List) _result.get("3'UTR");
if (tputr_returned == null) {
tputr_returned = new ArrayList();
_result.put("3'UTR", tputr_returned);
}
Map geneNameToGFFRecordMap = new HashMap();
try {
ps = jconn.prepareStatement(queryGene);
ps.setString(1, _chromosome);
ps.setInt(2, _query_start);
ps.setInt(3, _query_end);
ps.setInt(4, _query_start);
ps.setInt(5, _query_end);
rs = ps.executeQuery();
boolean bGeneFound = false;
int iMin = Integer.MAX_VALUE;
int iMax = Integer.MIN_VALUE;
while (rs.next()) {
bGeneFound = true;
int start = rs.getInt("chr_start");
int end = rs.getInt("chr_end");
if (start < iMin) {
iMin = start;
}
if (end > iMax) {
iMax = end;
}
SerializableSimpleGFFRecord gene = new SerializableSimpleGFFRecord();
String name = rs.getString("gene_name");
gene.setSeqName(_chromosome);
gene.setSource("EnsEMBL");
gene.setFeature("gene");
gene.setStart(start);
gene.setEnd(end);
gene.setScore(GFFTools.NO_SCORE);
gene.setStrand(rs.getInt("chr_strand"));
gene.setFrame(GFFTools.NO_FRAME);
AttributeUtil.setAttribute("ID", name, gene);
String d = rs.getString("description");
ArrayList description = new ArrayList();
try {
d = d.replace('[', '=').replace(']', ' ');
String d1 = d.split("=")[0].replace('.', ' ');
String d2 = d.split("=")[1].replace('.', ' ').replace(';', ' ');
description.add(d1);
description.add(d2);
AttributeUtil.setAttribute("display_string", description, gene);
} catch (Throwable e) {
Log.println(
e + " Error in parsing EnsEMBL description string: " + d);
}
geneNameToGFFRecordMap.put(name, gene);
genes_returned.add(gene);
}
closePS(ps, rs);
if (!bGeneFound) {
return;
}
String inClause = buildCommaSeparatedNameList(
geneNameToGFFRecordMap.keySet());
String transcriptQuery = "select transcript_name, exon_ids, gene_name " +
"from transcript where db = 'core' and gene_name in (" +
inClause +
")";
ResultSet rsTranscript = cq.doQuery(_database, "lite", transcriptQuery);
Properties exonsToGeneTranscriptProps = new Properties();
ArrayList transcription_names = new ArrayList();
while (rsTranscript.next()) {
String transcript_id = rsTranscript.getString("transcript_name");
String gene_name = rsTranscript.getString("gene_name");
addTranscriptIdToGene(gene_name, transcript_id,
geneNameToGFFRecordMap);
String exon_ids = rsTranscript.getString("exon_ids");
exonsToGeneTranscriptProps.put(
":" + exon_ids + ":" ,
gene_name + ":" + transcript_id
);
transcription_names.add(transcript_id);
}
rsTranscript.close();
Map transcriptToExonListsMap = new HashMap();
String exonQuery = "select exon_name, exon_id, chr_start, chr_end, " +
"chr_strand from exon where db = 'core' and chr_name = ? and " +
"( chr_start between ? and ? or " +
"chr_end between ? and ? ) order by chr_start";
ps = jconn.prepareStatement(exonQuery);
ps.setString(1, _chromosome);
ps.setInt(2, iMin);
ps.setInt(3, iMax);
ps.setInt(4, iMin);
ps.setInt(5, iMax);
rs = ps.executeQuery();
while (rs.next()) {
SerializableSimpleGFFRecord exon = new SerializableSimpleGFFRecord();
String name = rs.getString("exon_name");
exon.setSeqName(_chromosome);
exon.setSource("EnsEMBL");
exon.setFeature("exon");
exon.setStart(rs.getInt("chr_start"));
exon.setEnd(rs.getInt("chr_end"));
exon.setScore(GFFTools.NO_SCORE);
exon.setStrand(rs.getInt("chr_strand"));
exon.setFrame(GFFTools.NO_FRAME);
AttributeUtil.setAttribute("ID", name, exon);
String exon_id = rs.getString("exon_id");
if (setGeneTranscriptInfo(exon, exon_id, exonsToGeneTranscriptProps,
geneNameToGFFRecordMap, transcriptToExonListsMap)) {
exons_returned.add(exon);
}
}
closePS(ps, rs);
inClause = buildCommaSeparatedNameList(transcription_names);
String tranlationQuery =
"SELECT "
+ " t.seq_start, "
+ " t.seq_end, "
+ " tsi.stable_id "
+ " FROM "
+ " translation t,"
+ " transcript_stable_id tsi, "
+ " transcript tc "
+ " WHERE "
+ " tsi.transcript_id = tc.transcript_id"
+ " AND "
+ " tsi.stable_id in ( " + inClause + " )"
+ " AND "
+ " tc.translation_id = t.translation_id "
;
ResultSet rsTranslation = cq.doQuery(_database.replaceAll("lite", "core"), "core", tranlationQuery);
while (rsTranslation.next()) {
int seq_start = rsTranslation.getInt("seq_start");
int seq_end = rsTranslation.getInt("seq_end");
String transcriptName = rsTranslation.getString("stable_id");
List exonNames = (List)transcriptToExonListsMap.get(transcriptName);
boolean codingExon = false;
boolean threePrimeUTRExon = false;
for(int e = 0; e < exonNames.size(); e++) {
SerializableSimpleGFFRecord exon = getExon((String)exonNames.get(e),
exons_returned);
if (e == 0) codingExon = true;
if ( e == exonNames.size() - 1 ) threePrimeUTRExon = true;
if ( codingExon ) {
if ( e == 0 ) {
final int crop = seq_start - 1;
if ( crop!=0 ) {
SerializableSimpleGFFRecord five_prime_UTR =
create5UTR(transcriptName, exon, crop);
fputr_returned.add(five_prime_UTR);
}
}
if ( e == exonNames.size() - 1 ) {
final int crop = seq_end - (exon.getEnd() - exon.getStart() + 1);
if ( crop!=0 ) {
SerializableSimpleGFFRecord three_prime_UTR =
create3UTR(transcriptName, exon, crop);
tputr_returned.add(three_prime_UTR);
}
}
if ( e == exonNames.size() - 1 ) codingExon = false;
}
else {
if ( threePrimeUTRExon ) {
SerializableSimpleGFFRecord three_prime_UTR =
createUTR(transcriptName, exon, "3'UTR");
tputr_returned.add(three_prime_UTR);
} else {
SerializableSimpleGFFRecord five_prime_UTR =
createUTR(transcriptName, exon, "5'UTR");
fputr_returned.add(five_prime_UTR);
}
}
}
}
rsTranslation.close();
fixUTRPieces(fputr_returned);
fixUTRPieces(tputr_returned);
} catch (SQLException e) {
e.printStackTrace();
_result.addWarningFeatureType("gene");
} finally {
closePS(ps, rs);
cq.close();
}
}
private void fixUTRPieces(List utrs) {
HashMap map = new HashMap();
Iterator it = utrs.iterator();
while (it.hasNext()) {
SerializableSimpleGFFRecord utr = (SerializableSimpleGFFRecord) it.next();
String tr_name = (String) map.get(utr.getGroupAttributes().get("transcript"));
if(tr_name != null) {
int pieces = ((Integer)map.get(tr_name)).intValue();
map.put(tr_name, new Integer( pieces + 1) );
utr.getGroupAttributes().put("pieces", String.valueOf(pieces + 1));
} else {
map.put(tr_name, new Integer(1));
}
}
}
private SerializableSimpleGFFRecord createUTR(String transcriptName,
SerializableSimpleGFFRecord exon,
String featureType) {
SerializableSimpleGFFRecord utr =
new SerializableSimpleGFFRecord();
utr.setSeqName(_chromosome);
utr.setSource("EnsEMBL");
utr.setFeature(featureType);
utr.setStart(exon.getStart());
utr.setEnd(exon.getEnd());
utr.setScore(GFFTools.NO_SCORE);
utr.setStrand(exon.getStrand());
utr.setFrame(GFFTools.NO_FRAME);
AttributeUtil.setAttribute("ID", transcriptName, utr);
AttributeUtil.setAttribute(
"transcript",
transcriptName,
utr);
return utr;
}
private SerializableSimpleGFFRecord create3UTR(
String transcriptName,
SerializableSimpleGFFRecord exon,
final int crop) {
SerializableSimpleGFFRecord three_prime_UTR =
new SerializableSimpleGFFRecord();
three_prime_UTR.setSeqName(_chromosome);
three_prime_UTR.setSource("EnsEMBL");
three_prime_UTR.setFeature("3'UTR");
if (exon.getStrand() == 1) {
three_prime_UTR.setStart(exon.getEnd() + crop + 1);
three_prime_UTR.setEnd(exon.getEnd());
} else {
three_prime_UTR.setStart(exon.getStart());
three_prime_UTR.setEnd(exon.getStart() - crop - 1);
}
three_prime_UTR.setScore(GFFTools.NO_SCORE);
three_prime_UTR.setStrand(exon.getStrand());
three_prime_UTR.setFrame(GFFTools.NO_FRAME);
AttributeUtil.setAttribute("ID", transcriptName, three_prime_UTR);
AttributeUtil.setAttribute(
"transcript",
transcriptName,
three_prime_UTR);
return three_prime_UTR;
}
private SerializableSimpleGFFRecord create5UTR(
String transcriptName,
SerializableSimpleGFFRecord exon,
final int crop) {
SerializableSimpleGFFRecord five_prime_UTR =
new SerializableSimpleGFFRecord();
five_prime_UTR.setSeqName(_chromosome);
five_prime_UTR.setSource("EnsEMBL");
five_prime_UTR.setFeature("5'UTR");
if (exon.getStrand() == 1) {
five_prime_UTR.setStart(exon.getStart());
five_prime_UTR.setEnd(exon.getStart() + crop - 1);
} else {
five_prime_UTR.setStart(exon.getEnd() - crop + 1);
five_prime_UTR.setEnd(exon.getEnd());
}
five_prime_UTR.setScore(GFFTools.NO_SCORE);
five_prime_UTR.setStrand(exon.getStrand());
five_prime_UTR.setFrame(GFFTools.NO_FRAME);
AttributeUtil.setAttribute("ID", transcriptName, five_prime_UTR);
AttributeUtil.setAttribute(
"transcript",
transcriptName,
five_prime_UTR);
return five_prime_UTR;
}
private SerializableSimpleGFFRecord getExon(String exonName, List exons_returned) {
for (int i = 0; i < exons_returned.size(); i++) {
SerializableSimpleGFFRecord exon =
(SerializableSimpleGFFRecord) exons_returned.get(i);
if(AttributeUtil.getAttribute("ID", exon).equals(exonName)) {
return exon;
}
}
throw new RuntimeException();
}
private boolean setGeneTranscriptInfo(SerializableSimpleGFFRecord exon,
String exon_id, Properties exonsToGeneTranscriptProps,
Map geneNameToGFFRecordMap,
Map transcriptToExonListsMap) {
ArrayList transcript_ids = new ArrayList();
String gene_name = null;
Iterator it = exonsToGeneTranscriptProps.keySet().iterator();
while(it.hasNext()){
String key = (String) it.next();
if(key.indexOf(":" + exon_id + ":") != -1) {
String gt = exonsToGeneTranscriptProps.getProperty(key);
gene_name = gt.substring(0, gt.indexOf(":"));
String transcript_id = gt.substring(gt.indexOf(":") + 1);
transcript_ids.add(transcript_id);
addExonTotranscriptToExonListsMap(transcript_id, exon,
transcriptToExonListsMap);
addExonIdToGene(AttributeUtil.getAttribute("ID", exon), gene_name, geneNameToGFFRecordMap);
}
}
if(gene_name == null) {
return false;
}
AttributeUtil.setAttribute("gene", gene_name, exon);
AttributeUtil.setAttribute("transcripts", transcript_ids, exon);
return true;
}
private void addExonTotranscriptToExonListsMap(String transcript_id,
SerializableSimpleGFFRecord exon,
Map transcriptToExonListsMap) {
List exonNames = (List)transcriptToExonListsMap.get(transcript_id);
if(exonNames == null) {
exonNames = new ArrayList();
transcriptToExonListsMap.put(transcript_id, exonNames);
}
if (exon.getStrand() == 1) {
exonNames.add(AttributeUtil.getAttribute("ID", exon));
} else {
exonNames.add(0, AttributeUtil.getAttribute("ID", exon));
}
}
private void addExonIdToGene(String exon_id, String gene_name,
Map geneNameToGFFRecordMap) {
SerializableSimpleGFFRecord gene =
(SerializableSimpleGFFRecord) geneNameToGFFRecordMap.get(gene_name);
List exon_ids = (List)gene.getGroupAttributes().get("exons");
if(exon_ids == null) {
exon_ids = new ArrayList();
gene.getGroupAttributes().put("exons", exon_ids);
}
exon_ids.add(exon_id);
}
private void addTranscriptIdToGene(String gene_name,
String transcript_id,
Map geneNameToGFFRecordMap) {
SerializableSimpleGFFRecord gene =
(SerializableSimpleGFFRecord) geneNameToGFFRecordMap.get(gene_name);
List transcript_ids = (List)gene.getGroupAttributes().get("transcripts");
if(transcript_ids == null) {
transcript_ids = new ArrayList();
gene.getGroupAttributes().put("transcripts", transcript_ids);
}
transcript_ids.add(transcript_id);
if(transcript_ids.size() > 1) {
if(transcript_ids.size() == 2) {
String mt_accession_id =
AttributeUtil.getAttribute("ID", gene) + " (" + transcript_ids.size() + ")";
SerializableSimpleGFFRecord multitranscript = new SerializableSimpleGFFRecord();
multitranscript.setSeqName(_chromosome);
multitranscript.setSource("EnsEMBL");
multitranscript.setFeature("multitranscript");
multitranscript.setStart(gene.getStart());
multitranscript.setEnd(gene.getEnd());
multitranscript.setScore(GFFTools.NO_SCORE);
multitranscript.setStrand(gene.getStrand());
multitranscript.setFrame(GFFTools.NO_FRAME);
AttributeUtil.setAttribute("ID", mt_accession_id, multitranscript);
if (gene.getStrand() > 0) {
multitranscript.setEnd(gene.getStart());
} else {
multitranscript.setStart(gene.getEnd());
}
((List) _result.get("multitranscript")).add(multitranscript);
} else {
SerializableSimpleGFFRecord multitranscript = findMultitranscript(AttributeUtil.getAttribute("ID", gene));
String mt_accession_id =
AttributeUtil.getAttribute("ID", gene) + " (" + transcript_ids.size() + ")";
AttributeUtil.setAttribute("ID", mt_accession_id, multitranscript);
}
}
AttributeUtil.setAttribute("transcripts", transcript_ids, gene);
AttributeUtil.setAttribute("selected_transcript", "", gene);
}
private SerializableSimpleGFFRecord findMultitranscript(String geneName) {
List list = (List) _result.get("multitranscript");
for (int i = 0; i < list.size(); i++) {
SerializableSimpleGFFRecord record = (SerializableSimpleGFFRecord)list.get(i);
if(AttributeUtil.getAttribute("ID", record).startsWith(geneName + " (")){
return record;
}
}
return null;
}
private String buildCommaSeparatedNameList(Collection names) {
StringBuffer sb = new StringBuffer();
boolean bStart = true;
Iterator it = names.iterator();
while(it.hasNext()){
if(!bStart){
sb.append(',');
} else {
bStart = false;
}
sb.append("'");
sb.append((String) it.next());
sb.append("'");
}
return sb.toString();
}
private void closePS(PreparedStatement ps, ResultSet rs) {
try {
if(rs != null) rs.close();
} catch (SQLException e1) {
}
try {
if(ps != null) ps.close();
} catch (SQLException e1) {
}
}
}
package ca.bcgsc.sockeye.service.featureloader.common;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.TreeMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.biojava.bio.program.gff.GFFTools;
import org.ensembl.datamodel.Analysis;
import org.ensembl.datamodel.CoordinateSystem;
import org.ensembl.datamodel.DnaDnaAlignment;
import org.ensembl.datamodel.Exon;
import org.ensembl.datamodel.Gene;
import org.ensembl.datamodel.Location;
import org.ensembl.datamodel.Marker;
import org.ensembl.datamodel.RepeatFeature;
import org.ensembl.datamodel.SimpleFeature;
import org.ensembl.datamodel.Transcript;
import org.ensembl.driver.AdaptorException;
import org.ensembl.driver.AnalysisAdaptor;
import org.ensembl.driver.DnaDnaAlignmentAdaptor;
import org.ensembl.driver.Driver;
import org.ensembl.driver.GeneAdaptor;
import org.ensembl.driver.MarkerAdaptor;
import org.ensembl.driver.QueryAdaptor;
import org.ensembl.driver.RepeatFeatureAdaptor;
import org.ensembl.driver.SequenceAdaptor;
import org.ensembl.driver.SimpleFeatureAdaptor;
import org.ensembl.driver.plugin.standard.MySQLDriver;
import ca.bcgsc.chinook.server.comobj.SerializableSimpleGFFRecord;
import ca.bcgsc.sockeye.config.Connection;
import ca.bcgsc.sockeye.util.Log;
public class FeatureLoaderLocal implements FeatureLoaderService {
private List _featureTypes;
private FeatureLoaderResult _result;
private int _query_start;
private int _query_end;
private String _chromosome;
private String _species;
private String _database;
private Connection _conn;
public static FeatureLoaderService getInstance() {
return new FeatureLoaderLocal();
}
public FeatureLoaderLocal() {
super();
}
public FeatureLoaderResult getFeatures(Connection conn, String database,
String species, String chromosome, int query_start, int query_end,
List featureTypes) {
_conn = conn;
_database = database;
_species = species;
_chromosome = chromosome;
_query_start = query_start;
_query_end = query_end;
_featureTypes = featureTypes;
_result = new FeatureLoaderResult();
if (featureTypes.contains("gene")
|| featureTypes.contains("multitranscript")) {
if (addGenes(featureTypes.contains("exon")) < 0) {
_result.addWarningFeatureType("genes");
}
}
if (featureTypes.contains("exon") && !featureTypes.contains("genes")) {
if (addExons() < 0) {
_result.addWarningFeatureType("exons");
}
}
if (featureTypes.contains("CpG Ensembl")) {
if (addCpG() < 0) {
_result.addWarningFeatureType("CpG islands (Ensembl)");
}
}
if (featureTypes.contains("Eponine")) {
if (addEponine() < 0) {
_result.addWarningFeatureType("Eponine");
}
}
if (featureTypes.contains("repeats")) {
if (addRepeats() < 0) {
_result.addWarningFeatureType("Repeats");
}
}
if (featureTypes.contains("EST")) {
if (addESTs() < 0) {
_result.addWarningFeatureType("ESTs");
}
}
if (featureTypes.contains("marker")) {
if (addMarkers() < 0) {
_result.addWarningFeatureType("markers");
}
}
if (featureTypes.contains("SNP")) {
if (addSNPs() < 0) {
_result.addWarningFeatureType("SNP");
}
}
if (featureTypes.contains("fragment_length_polymorphism")) {
if (addFragmentLengthPolymorphisms() < 0) {
_result.addWarningFeatureType("fragment_length_polymorphism");
}
}
if (featureTypes.contains("sequence")
|| featureTypes.contains("masked_sequence")) {
if (addSequence() < 0) {
_result.addWarningFeatureType("Sequence");
}
}
if (featureTypes.contains("undefined_sequence")) {
addUndefinedSequenceRegions();
}
return _result;
}
public FeatureDistributionLoaderResult getFeatureDistributions(
Connection conn, String database, String species,
String chromosome, int query_start, int query_end,
List featureTypes, int binSize) {
FeatureDistributionLoaderResult result = null;
result = new FeatureDistributionLoaderResult();
Iterator it = featureTypes.iterator();
while (it.hasNext()) {
String feature = (String) it.next();
Map distribution = queryAndAddFeatureDistribution(feature, binSize,
query_start, query_end, chromosome, conn, database);
result.put(feature, distribution);
}
return result;
}
public Map getRelatedFeatureIDs(Connection conn, String database,
String species, Map relationshipHierarchy, String featureID) {
_conn = conn;
_database = database;
_species = species;
if (relationshipHierarchy.containsKey(HOMOLOGUE_GENE)) {
return loadHomologues(featureID);
} else {
throw new RuntimeException("Relationship not supported");
}
}
private Map loadHomologues(String geneID) {
Date d = new Date();
String species = _species.replaceAll("_", " ");
String query = "select "
+ "member1.member_id, "
+ "member1.chr_start, member1.chr_end, member1.chr_name, member1.stable_id, "
+ "member2.chr_start, member2.chr_end, member2.chr_name, member2.stable_id, genome_db2.name "
+ "from "
+ " member member1, "
+ " homology_member homology_member1, "
+ " homology_member homology_member2, "
+ " member member2, "
+ " genome_db genome_db2 "
+ "where "
+ " member1.member_id = homology_member1.member_id and "
+ " homology_member1.homology_id = homology_member2.homology_id and "
+ " homology_member2.member_id = member2.member_id and "
+ " member2.member_id != member1.member_id and "
+ " member2.genome_db_id = genome_db2.genome_db_id and "
+ " member1.stable_id = ? " + "group by "
+ " member2.member_id";
Map map = new HashMap();
QueryAdaptor qa = null;
PreparedStatement ps = null;
ResultSet rset = null;
java.sql.Connection connection = null;
boolean get_homologue = true;
try {
if (getVersion(_database) >= 30) {
connection = CustomEnsEMBLQuery.getInstance(_conn)
.getConnection(
"ensembl_compara_" + getVersion(_database));
} else {
connection = CustomEnsEMBLQuery.getInstance(_conn)
.getConnection(
"ensembl_compara_" + getVersion(_database)
+ "_1");
}
ps = connection.prepareStatement(query);
ps.setString(1, geneID);
rset = ps.executeQuery();
while (rset.next()) {
String hit_accession_id = (String) rset
.getString("member2.stable_id");
String hit_species = (String) rset.getString("genome_db2.name");
String species_key = RelationshipMapUtil.createSubGroupKey(
HOMOLOGUE_GENE, hit_species.replace(' ', '_'));
Map homologues = (Map) map.get(species_key);
if (homologues == null) {
homologues = new HashMap();
}
homologues.put(hit_accession_id, null);
map.put(species_key, homologues);
System.out
.println(">>> FOUND HOMOLOGUE: "
+ hit_species.replace(' ', '_')
+ homologues.toString());
}
} catch (SQLException e) {
System.out.println("CustomEnsEMBLQuery: Can't create statement: "
+ e.toString());
closePS(ps, rset);
return null;
} finally {
closePS(ps, rset);
}
Date d2 = new Date();
System.out.println("Time taken for loadHomologues: "
+ (d2.getTime() - d.getTime()) / 1000 + "s");
return map;
}
public GeneInfo getGeneInfo(Connection conn, String database, String geneID) {
GeneInfo gInfo = new GeneInfo();
org.ensembl.driver.plugin.standard.MySQLDriver driver = null;
driver = (MySQLDriver) ConnectionManager
.createEnsemblDriverForDatabase("CORE", database, conn);
Date date = new Date();
GeneAdaptor geneAdaptor;
try {
geneAdaptor = driver.getGeneAdaptor();
Gene gene = geneAdaptor.fetch(geneID);
String accession_id = gene.getAccessionID();
int start = gene.getLocation().getStart();
int end = gene.getLocation().getEnd();
int strand = gene.getLocation().getStrand();
String desc = gene.getDescription();
String display_name = gene.getDisplayName();
String chromosome = gene.getLocation().getSeqRegionName();
gInfo.setStart(start);
gInfo.setEnd(end);
gInfo.setStrand(strand);
gInfo.setDescription(desc);
gInfo.setChromosome(chromosome);
} catch (AdaptorException e) {
Log.printStackTrace(e);
}
Date date2 = new Date();
System.out.println("Getting GeneInfo takes: "
+ ((date2.getTime() - date.getTime()) / 1000) + "s");
return gInfo;
}
public Map getChromosomeInfo(Connection conn, String database) {
Map map = new LinkedHashMap();
String query = "SELECT seq_region.name AS chr_name, length "
+ "FROM seq_region, coord_system "
+ "WHERE seq_region.coord_system_id = coord_system.coord_system_id "
+ " and coord_system.rank = 1 "
+ "ORDER BY seq_region.name";
org.ensembl.driver.plugin.standard.MySQLDriver driver = null;
ResultSet rs = null;
try {
driver = (org.ensembl.driver.plugin.standard.MySQLDriver) ConnectionManager
.createEnsemblDriverForDatabase("CORE", database, conn);
QueryAdaptor qa = (QueryAdaptor) driver.getAdaptor("query");
rs = (ResultSet) qa.execute(query);
while (rs.next()) {
String name = rs.getString("chr_name");
int length = rs.getInt("length");
map.put(name, new Integer(length));
}
rs.close();
} catch (Exception e) {
e.printStackTrace();
Log.printStackTrace(e);
} finally {
try {
if (rs != null) {
rs.close();
}
} catch (Throwable e) {
}
}
return map;
}
private static Properties patterns = new Properties();
static {
patterns.put("CORE", ".*_.*_.*core.*");
patterns.put("COMPARA", ".*compara.*");
patterns.put("EST", ".*_est_.*");
patterns.put("SNP", ".*_snp_.*");
patterns.put("coexpression", ".*_coexpression_.*");
}
public List getDatabaseList(Connection connection, String dbType) {
List core_list = new ArrayList();
try {
org.ensembl.driver.Driver driver = EnsemblDBListManager
.getListingDriver(connection);
String[] databases = driver.fetchDatabaseNames();
for (int i = 0; i < databases.length; i++) {
if (databases[i].matches(patterns.getProperty(dbType))) {
core_list.add(databases[i]);
}
}
} catch (Throwable e) {
e.printStackTrace();
}
return core_list;
}
private static List filter(List old_list, Connection connection) {
LinkedHashMap map = new LinkedHashMap();
List new_list = new ArrayList();
for (int i = 0; i < old_list.size(); i++) {
String name = (String) old_list.get(i);
int lastUnderScoreIndex = name.lastIndexOf('_');
if (lastUnderScoreIndex == -1) {
continue;
}
String key = name.substring(0, lastUnderScoreIndex + 1);
int j = key.substring(0, key.length() - 1).lastIndexOf('_') + 1;
int version = Integer.parseInt(key.substring(j, key.length() - 1));
if ((version <= 14 || version >= 20)
&& connection.getSubtype().equals("lite")) {
continue;
}
if (version >= 20 && "old".equals(connection.getSubtype())) {
continue;
}
if (version < 20
&& !("old".equals(connection.getSubtype()) || "lite"
.equals(connection.getSubtype()))) {
continue;
}
String value = name.substring(lastUnderScoreIndex + 1);
if (map.containsKey(key)) {
String oldValue = (String) map.get(key);
int iIsNewValueBetter = isNewValueBetter(oldValue, value);
if (iIsNewValueBetter == 1) {
map.put(key, value);
} else if (iIsNewValueBetter == 2) {
new_list.add(name);
}
} else {
map.put(key, value);
}
}
Iterator it = map.keySet().iterator();
while (it.hasNext()) {
String key = (String) it.next();
new_list.add(key + map.get(key));
}
return new_list;
}
private static int isNewValueBetter(String oldValue, String newValue) {
int oldIndex = getFirstNonNumericIndex(oldValue);
int newIndex = getFirstNonNumericIndex(newValue);
if (oldIndex == 0 || newIndex == 0) {
return 2;
}
int newInt = Integer.parseInt(newValue.substring(0, newIndex));
int oldInt = Integer.parseInt(oldValue.substring(0, oldIndex));
if (newInt > oldInt) {
return 1;
} else if (newInt < oldInt) {
return 0;
} else {
String newSz = newValue.substring(newIndex);
String oldSz = oldValue.substring(oldIndex);
return oldSz.compareTo(newSz) < 0 ? 1 : 0;
}
}
private static int getFirstNonNumericIndex(String sz) {
int index = 0;
for (index = 0; index < sz.length(); index++) {
if (Character.isDigit(sz.charAt(index))) {
continue;
}
break;
}
return index;
}
private int addGenes(boolean want_exons) {
org.ensembl.driver.plugin.standard.MySQLDriver driver = null;
driver = (org.ensembl.driver.plugin.standard.MySQLDriver) ConnectionManager
.createEnsemblDriverForDatabase("CORE", _database, _conn);
GeneAdaptor geneAdaptor;
try {
CoordinateSystem cs = null;
if (isDanioSuperContig()) {
cs = new CoordinateSystem("supercontig");
} else {
cs = driver.getDefaultCoordinateSystem();
}
geneAdaptor = driver.getGeneAdaptor();
Location location = new Location(cs, _chromosome, _query_start,
_query_end);
Iterator gene_iterator = geneAdaptor.fetch(location).iterator();
List genes_returned = (List) _result.get("gene");
if (genes_returned == null) {
genes_returned = new ArrayList();
_result.put("gene", genes_returned);
}
List multitrans_returned = (List) _result.get("multitranscript");
if (multitrans_returned == null) {
multitrans_returned = new ArrayList();
_result.put("multitranscript", multitrans_returned);
}
List exons_returned = (List) _result.get("exon");
if (exons_returned == null) {
exons_returned = new ArrayList();
if (want_exons) {
_result.put("exon", exons_returned);
}
}
List fputr_returned = (List) _result.get("5'UTR");
if (fputr_returned == null) {
fputr_returned = new ArrayList();
if (want_exons) {
_result.put("5'UTR", fputr_returned);
}
}
List tputr_returned = (List) _result.get("3'UTR");
if (tputr_returned == null) {
tputr_returned = new ArrayList();
if (want_exons) {
_result.put("3'UTR", tputr_returned);
}
}
while (gene_iterator.hasNext()) {
Gene ensembl_gene = (Gene) gene_iterator.next();
String accession_id = ensembl_gene.getAccessionID();
int start = ensembl_gene.getLocation().getStart();
int end = ensembl_gene.getLocation().getEnd();
int strand = ensembl_gene.getLocation().getStrand();
String description = ensembl_gene.getDescription();
int i = 0;
SerializableSimpleGFFRecord gene = new SerializableSimpleGFFRecord();
gene.setSeqName(_chromosome);
gene.setSource("EnsEMBL");
gene.setFeature("gene");
gene.setStart(start);
gene.setEnd(end);
gene.setScore(GFFTools.NO_SCORE);
gene.setStrand(strand);
gene.setFrame(GFFTools.NO_FRAME);
AttributeUtil.setAttribute("ID", accession_id, gene);
ArrayList descriptions = new ArrayList();
try {
description = description.replace('[', '=').replace(']',
' ');
String d1 = description.split("=")[0].replace('.', ' ');
String d2 = description.split("=")[1].replace('.', ' ')
.replace(';', ' ');
descriptions.add(d1);
descriptions.add(d2);
AttributeUtil.setAttribute("display_string", description,
gene);
} catch (Throwable e) {
Log.println(e
+ " Error in parsing EnsEMBL description string: "
+ description);
}
getLocusLinkIDforGene(accession_id, gene);
ArrayList transcript_ids = new ArrayList();
ArrayList protein_ids = new ArrayList();
for (Iterator t = ensembl_gene.getTranscripts().iterator(); t
.hasNext();) {
Transcript transcript = (Transcript) t.next();
if (want_exons) {
setFivePrimeUTR(transcript, accession_id,
fputr_returned);
setThreePrimeUTR(transcript, accession_id,
tputr_returned);
}
transcript_ids.add(transcript.getAccessionID());
}
AttributeUtil.setAttribute("transcripts", transcript_ids, gene);
AttributeUtil.setAttribute("proteins", protein_ids, gene);
AttributeUtil.setAttribute("selected_transcript", "", gene);
genes_returned.add(gene);
int number_of_transcripts = ensembl_gene.getTranscripts()
.size();
if (number_of_transcripts > 1) {
String mt_accession_id = accession_id + " ("
+ String.valueOf(number_of_transcripts) + ")";
SerializableSimpleGFFRecord multitranscript = new SerializableSimpleGFFRecord();
multitranscript.setSeqName(_chromosome);
multitranscript.setSource("EnsEMBL");
multitranscript.setFeature("multitranscript");
multitranscript.setStart(start);
multitranscript.setEnd(end);
multitranscript.setScore(GFFTools.NO_SCORE);
multitranscript.setStrand(strand);
multitranscript.setFrame(GFFTools.NO_FRAME);
AttributeUtil.setAttribute("ID", mt_accession_id,
multitranscript);
if (strand > 0) {
multitranscript.setEnd(start);
} else {
multitranscript.setStart(end);
}
multitrans_returned.add(multitranscript);
}
Object[] exons = ensembl_gene.getExons().toArray();
ArrayList exon_id = new ArrayList();
for (int e = 0; e < exons.length; e++) {
Exon ensembl_exon = (Exon) exons[e];
accession_id = ensembl_exon.getAccessionID();
if (want_exons) {
start = ensembl_exon.getLocation().getStart();
end = ensembl_exon.getLocation().getEnd();
strand = ensembl_exon.getLocation().getStrand();
SerializableSimpleGFFRecord exon = new SerializableSimpleGFFRecord();
exon.setSeqName(_chromosome);
exon.setSource("EnsEMBL");
exon.setFeature("exon");
exon.setStart(start);
exon.setEnd(end);
exon.setScore(GFFTools.NO_SCORE);
exon.setStrand(strand);
exon.setFrame(GFFTools.NO_FRAME);
AttributeUtil.setAttribute("ID", accession_id, exon);
ArrayList exon_transcript_id = new ArrayList();
for (Iterator t = ensembl_exon.getTranscripts()
.iterator(); t.hasNext();) {
Transcript transcript = (Transcript) t.next();
exon_transcript_id.add(transcript.getAccessionID());
}
AttributeUtil.setAttribute("gene", AttributeUtil
.getAttribute("ID", gene), exon);
AttributeUtil.setAttribute("transcripts",
exon_transcript_id, exon);
exons_returned.add(exon);
}
exon_id.add(accession_id);
}
AttributeUtil.setAttribute("exons", exon_id, gene);
}
_result.put("gene", genes_returned);
return 0;
} catch (AdaptorException e) {
e.printStackTrace();
return -1;
}
}
protected void setFivePrimeUTR(Transcript transcript,
String gene_accession_id, List fpUTR_list) {
String t_id = transcript.getAccessionID();
List utr5p = transcript.getFivePrimeUTR();
if (utr5p != null) {
Iterator utr5p_iterator = utr5p.iterator();
int label5 = 1;
int pieces = utr5p.size();
while (utr5p_iterator.hasNext()) {
Location l = (Location) utr5p_iterator.next();
String five_prime_UTR_id;
if (pieces > 1) {
five_prime_UTR_id = t_id.concat("_" + label5++);
} else {
five_prime_UTR_id = t_id;
}
SerializableSimpleGFFRecord five_prime_UTR = new SerializableSimpleGFFRecord();
five_prime_UTR.setSeqName(_chromosome);
five_prime_UTR.setSource("EnsEMBL");
five_prime_UTR.setFeature("5'UTR");
five_prime_UTR.setStart(l.getStart());
five_prime_UTR.setEnd(l.getEnd());
five_prime_UTR.setScore(GFFTools.NO_SCORE);
five_prime_UTR.setStrand(l.getStrand());
five_prime_UTR.setFrame(GFFTools.NO_FRAME);
AttributeUtil.setAttribute("ID", five_prime_UTR_id,
five_prime_UTR);
if (pieces > 1) {
AttributeUtil.setAttribute("pieces", String.valueOf(utr5p
.size()), five_prime_UTR);
}
AttributeUtil.setAttribute("transcript", t_id, five_prime_UTR);
fpUTR_list.add(five_prime_UTR);
}
}
}
protected void setThreePrimeUTR(Transcript transcript,
String gene_accession_id, List tpUTR_list) {
String t_id = transcript.getAccessionID();
List utr3p = transcript.getThreePrimeUTR();
if (utr3p != null) {
Iterator utr3p_iterator = utr3p.iterator();
int label3 = 1;
int pieces = utr3p.size();
while (utr3p_iterator.hasNext()) {
Location l = (Location) utr3p_iterator.next();
String three_prime_UTR_id;
if (pieces > 1) {
three_prime_UTR_id = t_id.concat("_" + label3++);
} else {
three_prime_UTR_id = t_id;
}
SerializableSimpleGFFRecord three_prime_UTR = new SerializableSimpleGFFRecord();
three_prime_UTR.setSeqName(_chromosome);
three_prime_UTR.setSource("EnsEMBL");
three_prime_UTR.setFeature("3'UTR");
three_prime_UTR.setStart(l.getStart());
three_prime_UTR.setEnd(l.getEnd());
three_prime_UTR.setScore(GFFTools.NO_SCORE);
three_prime_UTR.setStrand(l.getStrand());
three_prime_UTR.setFrame(GFFTools.NO_FRAME);
AttributeUtil.setAttribute("ID", three_prime_UTR_id,
three_prime_UTR);
if (pieces > 1) {
AttributeUtil.setAttribute("pieces",
String.valueOf(pieces), three_prime_UTR);
}
AttributeUtil.setAttribute("transcript", t_id, three_prime_UTR);
tpUTR_list.add(three_prime_UTR);
}
}
}
private int addExons() {
org.ensembl.driver.plugin.standard.MySQLDriver driver = null;
driver = (org.ensembl.driver.plugin.standard.MySQLDriver) ConnectionManager
.createEnsemblDriverForDatabase("CORE", _database, _conn);
GeneAdaptor geneAdaptor;
try {
CoordinateSystem cs = null;
if (isDanioSuperContig()) {
cs = new CoordinateSystem("supercontig");
} else {
cs = driver.getDefaultCoordinateSystem();
}
geneAdaptor = driver.getGeneAdaptor();
GeneAdaptor ga = (GeneAdaptor) ConnectionManager
.createEnsemblDriverForDatabase("CORE", _database, _conn)
.getAdaptor("gene");
Location location = new Location(cs, _chromosome, _query_start,
_query_end);
Iterator gene_iterator = geneAdaptor.fetch(location).iterator();
List exons_returned = (List) _result.get("exon");
if (exons_returned == null) {
exons_returned = new ArrayList();
_result.put("exon", exons_returned);
}
List fputr_returned = (List) _result.get("5'UTR");
if (fputr_returned == null) {
fputr_returned = new ArrayList();
_result.put("5'UTR", fputr_returned);
}
List tputr_returned = (List) _result.get("3'UTR");
if (tputr_returned == null) {
tputr_returned = new ArrayList();
_result.put("3'UTR", tputr_returned);
}
while (gene_iterator.hasNext()) {
Gene ensembl_gene = (Gene) gene_iterator.next();
String gene_accession_id = ensembl_gene.getAccessionID();
Object[] exons = ensembl_gene.getExons().toArray();
for (int e = 0; e < exons.length; e++) {
Exon ensembl_exon = (Exon) exons[e];
String accession_id = ensembl_exon.getAccessionID();
int start = ensembl_exon.getLocation().getStart();
int end = ensembl_exon.getLocation().getEnd();
int strand = ensembl_exon.getLocation().getStrand();
SerializableSimpleGFFRecord exon = new SerializableSimpleGFFRecord();
exon.setSeqName(_chromosome);
exon.setSource("EnsEMBL");
exon.setFeature("exon");
exon.setStart(start);
exon.setEnd(end);
exon.setScore(GFFTools.NO_SCORE);
exon.setStrand(strand);
exon.setFrame(GFFTools.NO_FRAME);
AttributeUtil.setAttribute("ID", accession_id, exon);
ArrayList exon_transcript_id = new ArrayList();
for (Iterator t = ensembl_exon.getTranscripts().iterator(); t
.hasNext();) {
Transcript transcript = (Transcript) t.next();
exon_transcript_id.add(transcript.getAccessionID());
}
AttributeUtil.setAttribute("gene", gene_accession_id, exon);
AttributeUtil.setAttribute("transcripts",
exon_transcript_id, exon);
exons_returned.add(exon);
}
for (Iterator t = ensembl_gene.getTranscripts().iterator(); t
.hasNext();) {
Transcript transcript = (Transcript) t.next();
if (transcript != null) {
setFivePrimeUTR(transcript, gene_accession_id,
fputr_returned);
setThreePrimeUTR(transcript, gene_accession_id,
tputr_returned);
}
}
}
return 0;
} catch (Exception e) {
Log.printStackTrace(e);
return -1;
}
}
private int addCpG() {
try {
AnalysisAdaptor aa = (AnalysisAdaptor) ConnectionManager
.createEnsemblDriverForDatabase("CORE", _database, _conn)
.getAdaptor("analysis");
Analysis a = aa.fetchByLogicalName("CpG");
SimpleFeatureAdaptor sa = (SimpleFeatureAdaptor) ConnectionManager
.createEnsemblDriverForDatabase("CORE", _database, _conn)
.getAdaptor("simple_feature");
CoordinateSystem cs = null;
if (isDanioSuperContig()) {
cs = new CoordinateSystem("supercontig");
} else {
cs = ConnectionManager.createEnsemblDriverForDatabase("CORE",
_database, _conn).getCoordinateSystemAdaptor()
.fetchTopLevel();
}
Location location = new Location(cs, _chromosome, _query_start,
_query_end);
Iterator sa_iterator = sa.fetch(location, a).iterator();
List feature_list = new ArrayList();
while (sa_iterator.hasNext()) {
SimpleFeature feature = (SimpleFeature) sa_iterator.next();
String accession_id = String.valueOf(feature.getInternalID());
int start = feature.getLocation().getStart();
int end = feature.getLocation().getEnd();
int strand = feature.getLocation().getStrand();
double score = feature.getScore();
SerializableSimpleGFFRecord cpg = new SerializableSimpleGFFRecord();
cpg.setSeqName(_chromosome);
cpg.setSource("EnsEMBL");
cpg.setFeature("CpG Ensembl");
cpg.setStart(start);
cpg.setEnd(end);
cpg.setScore(score);
cpg.setStrand(strand);
cpg.setFrame(GFFTools.NO_FRAME);
AttributeUtil.setAttribute("ID", accession_id, cpg);
feature_list.add(cpg);
}
_result.put("CpG Ensembl", feature_list);
return 0;
} catch (Exception e) {
_result.put("CpG Ensembl", null);
return -1;
}
}
private int addEponine() {
try {
AnalysisAdaptor aa = (AnalysisAdaptor) ConnectionManager
.createEnsemblDriverForDatabase("CORE", _database, _conn)
.getAdaptor("analysis");
Analysis a = aa.fetchByLogicalName("Eponine");
SimpleFeatureAdaptor sa = (SimpleFeatureAdaptor) ConnectionManager
.createEnsemblDriverForDatabase("CORE", _database, _conn)
.getAdaptor("simple_feature");
CoordinateSystem cs = null;
if (isDanioSuperContig()) {
cs = new CoordinateSystem("supercontig");
} else {
cs = ConnectionManager.createEnsemblDriverForDatabase("CORE",
_database, _conn).getCoordinateSystemAdaptor()
.fetchTopLevel();
}
Location location = new Location(cs, _chromosome, _query_start,
_query_end);
Iterator sa_iterator = sa.fetch(location, a).iterator();
List feature_list = new ArrayList();
while (sa_iterator.hasNext()) {
SimpleFeature feature = (SimpleFeature) sa_iterator.next();
String accession_id = String.valueOf(feature.getInternalID());
int start = feature.getLocation().getStart();
int end = feature.getLocation().getEnd();
int strand = feature.getLocation().getStrand();
double score = feature.getScore();
SerializableSimpleGFFRecord eponine = new SerializableSimpleGFFRecord();
eponine.setSeqName(_chromosome);
eponine.setSource("EnsEMBL");
eponine.setFeature("Eponine");
eponine.setStart(start);
eponine.setEnd(end);
eponine.setScore(score);
eponine.setStrand(strand);
eponine.setFrame(GFFTools.NO_FRAME);
AttributeUtil
.setAttribute("ID", String.valueOf(start), eponine);
feature_list.add(eponine);
System.out.println(accession_id + " " + feature.getAnalysisID()
+ " " + start + " " + end + " " + strand + " " + score);
}
_result.put("Eponine", feature_list);
return 0;
} catch (Exception e) {
_result.put("Eponine", null);
return -1;
}
}
private int addSNPs() {
String driver_name = "com.mysql.jdbc.Driver";
try {
Class.forName(driver_name);
} catch (ClassNotFoundException e) {
System.out.println("Driver " + driver_name + " not found");
}
String server_name = _conn.getHost();
if (_conn.getPort() != null) {
server_name = server_name.concat(":" + _conn.getPort());
}
String url = "jdbc:mysql:
+ this._database.replaceAll("core", "lite");
String username = _conn.getUser();
String password = _conn.getPass();
java.sql.Connection conn = null;
try {
conn = java.sql.DriverManager
.getConnection(url, username, password);
} catch (SQLException e) {
System.out.println("Can't connect to DB");
_result.put("SNP", null);
return -1;
}
Statement stmt = null;
String query = "select id_refsnp, chr_start, chr_end, chr_strand from snp where snpclass='snp' and chr_name='"
+ _chromosome
+ "' and chr_start>="
+ _query_start
+ " and chr_end<=" + _query_end + " limit 10";
ResultSet rset = null;
try {
stmt = conn.createStatement();
rset = stmt.executeQuery(query);
List snps_returned = new ArrayList();
while (rset.next()) {
String id_refsnp = rset.getString("id_refsnp");
int start = Integer.valueOf(rset.getString("chr_start"))
.intValue();
int end = Integer.valueOf(rset.getString("chr_end")).intValue();
int strand = Integer.valueOf(rset.getString("chr_strand"))
.intValue();
SerializableSimpleGFFRecord snp = new SerializableSimpleGFFRecord();
snp.setSeqName(_chromosome);
snp.setSource("EnsEMBL");
snp.setFeature("SNP");
snp.setStart(start);
snp.setEnd(end);
snp.setScore(GFFTools.NO_SCORE);
snp.setStrand(strand);
snp.setFrame(GFFTools.NO_FRAME);
AttributeUtil.setAttribute("ID", id_refsnp, snp);
snps_returned.add(snp);
_result.put("SNP", snps_returned);
}
return 0;
} catch (SQLException e) {
_result.put("SNP", null);
return -1;
} finally {
try {
if (rset != null) {
rset.close();
}
} catch (SQLException e1) {
}
try {
if (stmt != null) {
stmt.close();
}
} catch (SQLException e2) {
}
try {
if (conn != null) {
conn.close();
}
} catch (SQLException e3) {
}
}
}
private int addMarkers() {
try {
CoordinateSystem cs = null;
if (isDanioSuperContig()) {
cs = new CoordinateSystem("supercontig");
} else {
cs = ConnectionManager.createEnsemblDriverForDatabase("CORE",
_database, _conn).getDefaultCoordinateSystem();
}
MarkerAdaptor ma = (MarkerAdaptor) ConnectionManager
.createEnsemblDriverForDatabase("CORE", _database, _conn)
.getAdaptor("marker");
Iterator ma_iterator = ma.fetch(
new Location(cs, _chromosome, _query_start, _query_end, 0))
.iterator();
List marker_list = new ArrayList();
while (ma_iterator.hasNext()) {
Marker feature = (Marker) ma_iterator.next();
String accession_id = String.valueOf(feature.getInternalID());
int start = feature.getLocation().getStart();
int end = feature.getLocation().getEnd();
int strand = feature.getLocation().getStrand();
SerializableSimpleGFFRecord marker = new SerializableSimpleGFFRecord();
marker.setSeqName(_chromosome);
marker.setSource("EnsEMBL");
marker.setFeature("marker");
marker.setStart(start);
marker.setEnd(end);
marker.setScore(GFFTools.NO_SCORE);
marker.setStrand(strand);
marker.setFrame(GFFTools.NO_FRAME);
AttributeUtil.setAttribute("ID", accession_id, marker);
marker_list.add(marker);
}
_result.put("marker", marker_list);
return 0;
} catch (Exception e) {
_result.put("marker", null);
e.printStackTrace();
return -1;
}
}
private int addESTs() {
org.ensembl.driver.plugin.standard.MySQLDriver driver = null;
try {
driver = (org.ensembl.driver.plugin.standard.MySQLDriver) ConnectionManager
.createEnsemblDriverForDatabase("EST", _database, _conn);
DnaDnaAlignmentAdaptor da = (DnaDnaAlignmentAdaptor) driver
.getAdaptor("dna_dna_alignment");
CoordinateSystem cs = null;
if (isDanioSuperContig()) {
cs = new CoordinateSystem("supercontig");
} else {
cs = driver.getDefaultCoordinateSystem();
}
Iterator da_iterator = da.fetch(
new Location(cs, _chromosome, _query_start, _query_end, 0))
.iterator();
List est_return = new ArrayList();
while (da_iterator.hasNext()) {
DnaDnaAlignment feature = (DnaDnaAlignment) da_iterator.next();
String accession_id = feature.getHitAccession();
int start = feature.getLocation().getStart();
int end = feature.getLocation().getEnd();
int strand = feature.getLocation().getStrand();
SerializableSimpleGFFRecord est = new SerializableSimpleGFFRecord();
est.setSeqName(_chromosome);
est.setSource("EnsEMBL");
est.setFeature("EST");
est.setStart(start);
est.setEnd(end);
est.setScore(GFFTools.NO_SCORE);
est.setStrand(strand);
est.setFrame(GFFTools.NO_FRAME);
AttributeUtil.setAttribute("ID", accession_id, est);
est_return.add(est);
}
_result.put("EST", est_return);
return 0;
} catch (Exception e) {
_result.put("EST", null);
return -1;
}
}
private int addRepeats() {
try {
RepeatFeatureAdaptor rfa = (RepeatFeatureAdaptor) ConnectionManager
.createEnsemblDriverForDatabase("CORE", _database, _conn)
.getAdaptor("repeat_feature");
CoordinateSystem cs = null;
if (isDanioSuperContig()) {
cs = new CoordinateSystem("supercontig");
} else {
cs = ConnectionManager.createEnsemblDriverForDatabase("CORE",
_database, _conn).getDefaultCoordinateSystem();
}
List repeat_list = rfa.fetch(new Location(cs, _chromosome,
_query_start, _query_end, 0));
System.out.println(" # of repeats found: " + repeat_list.size());
Iterator rfa_iterator = repeat_list.iterator();
while (rfa_iterator.hasNext()) {
RepeatFeature feature = (RepeatFeature) rfa_iterator.next();
String type = "repeats";
String accession_id = "rep"
+ String.valueOf(new Long(feature.getInternalID()));
List features_returned = (List) _result.get(type);
if (features_returned == null) {
features_returned = new ArrayList();
_result.put(type, features_returned);
}
int start = feature.getLocation().getStart();
int end = feature.getLocation().getEnd();
int strand = feature.getLocation().getStrand();
SerializableSimpleGFFRecord repeat = new SerializableSimpleGFFRecord();
repeat.setSeqName(_chromosome);
repeat.setSource("EnsEMBL");
repeat.setFeature(type);
repeat.setStart(start);
repeat.setEnd(end);
repeat.setScore(GFFTools.NO_SCORE);
repeat.setStrand(strand);
repeat.setFrame(GFFTools.NO_FRAME);
AttributeUtil.setAttribute("ID", accession_id, repeat);
AttributeUtil.setAttribute("display_string", feature
.getRepeatConsensus().getType(), repeat);
AttributeUtil.setAttribute("parent_name", "repeat_feature",
repeat);
features_returned.add(repeat);
}
return 0;
} catch (Exception e) {
_result.put("Repeats", null);
return -1;
}
}
private int addFragmentLengthPolymorphisms() {
try {
Driver driver = ConnectionManager.createEnsemblDriverForDatabase(
"CORE", _database, _conn);
MarkerAdaptor ma = (MarkerAdaptor) driver.getAdaptor("marker");
CoordinateSystem cs = null;
if (isDanioSuperContig()) {
cs = new CoordinateSystem("supercontig");
} else {
cs = driver.getDefaultCoordinateSystem();
}
Iterator ma_iterator = ma.fetch(
new Location(cs, _chromosome, _query_start, _query_end, 0))
.iterator();
List flp_list = new ArrayList();
while (ma_iterator.hasNext()) {
Marker feature = (Marker) ma_iterator.next();
String accession_id = String.valueOf(feature.getInternalID());
int start = feature.getLocation().getStart();
int end = feature.getLocation().getEnd();
int strand = feature.getLocation().getStrand();
if (feature.getMinPrimerDistance() != feature
.getMaxPrimerDistance()) {
int variable_number_of_nucleotides = feature
.getMaxPrimerDistance()
- feature.getMinPrimerDistance();
SerializableSimpleGFFRecord marker = new SerializableSimpleGFFRecord();
marker.setSeqName(_chromosome);
marker.setSource("EnsEMBL");
marker.setFeature("fragment_length_polymorphism");
marker.setStart(start);
marker.setEnd(end);
marker.setScore(variable_number_of_nucleotides);
marker.setStrand(strand);
marker.setFrame(GFFTools.NO_FRAME);
AttributeUtil.setAttribute("ID", accession_id, marker);
AttributeUtil.setAttribute("flp_synonyms",
(ArrayList) feature.getSynonyms(), marker);
AttributeUtil.setAttribute("min_allele_size", String
.valueOf(feature.getMinPrimerDistance()), marker);
AttributeUtil.setAttribute("analysis_logical_name", feature
.getAnalysis().getGFFSource(), marker);
AttributeUtil.setAttribute("max_allele_size", String
.valueOf(feature.getMaxPrimerDistance()), marker);
flp_list.add(marker);
}
_result.put("fragment_length_polymorphism", flp_list);
}
return 0;
} catch (Exception e) {
_result.put("fragment_length_polymorphism", null);
return -1;
}
}
private int addSequence() {
String sequence = this.retrieveSequence();
List l = new ArrayList();
if (sequence == null || sequence.length() == 0) {
_result.put("sequence", null);
return -1;
}
SerializableSimpleGFFRecord sequence_f = new SerializableSimpleGFFRecord();
sequence_f.setSeqName(_chromosome);
sequence_f.setSource("EnsEMBL");
sequence_f.setFeature("sequence");
sequence_f.setStart(_query_start);
sequence_f.setEnd(_query_end);
sequence_f.setScore(0);
sequence_f.setStrand(0);
sequence_f.setFrame(0);
AttributeUtil.setAttribute("ID", "sequence", sequence_f);
AttributeUtil.setAttribute("sequence", sequence, sequence_f);
l.add(sequence_f);
_result.put("sequence", l);
ArrayList masked_features = new ArrayList();
Pattern p = Pattern.compile("[a-z]+");
Matcher m = p.matcher(sequence);
while (m.find()) {
String accession_id = new String("maskedseq-" + m.start() + ":"
+ m.end());
SerializableSimpleGFFRecord mseq_f = new SerializableSimpleGFFRecord();
mseq_f.setSeqName(_chromosome);
mseq_f.setSource("EnsEMBL");
mseq_f.setFeature("masked_sequence");
mseq_f.setStart(_query_start + m.start());
mseq_f.setEnd(_query_start + m.end());
mseq_f.setScore(GFFTools.NO_SCORE);
mseq_f.setStrand(0);
mseq_f.setFrame(GFFTools.NO_FRAME);
AttributeUtil.setAttribute("ID", accession_id, mseq_f);
masked_features.add(mseq_f);
}
if (!masked_features.isEmpty())
_result.put("masked_sequence", masked_features);
return 0;
}
private String retrieveSequence() {
String sequence = new String();
StringBuffer seq_buff;
try {
CoordinateSystem cs = null;
if (isDanioSuperContig()) {
cs = new CoordinateSystem("supercontig");
} else {
cs = ConnectionManager.createEnsemblDriverForDatabase("CORE",
_database, _conn).getCoordinateSystemAdaptor()
.fetchTopLevel();
}
Location location = new Location(cs, _chromosome, _query_start,
_query_end, 1);
SequenceAdaptor sa = (SequenceAdaptor) ConnectionManager
.createEnsemblDriverForDatabase("CORE", _database, _conn)
.getAdaptor("sequence");
if (sa == null)
return null;
sequence = sa.fetch(location).getString();
seq_buff = new StringBuffer(sequence);
System.out.println("Start Sequence length is:" + sequence.length());
RepeatFeatureAdaptor rfa = (RepeatFeatureAdaptor) ConnectionManager
.createEnsemblDriverForDatabase("CORE", _database, _conn)
.getAdaptor("repeat_feature");
if (rfa == null) {
System.out
.println("ENSEMBL Problem: Cannot create repeat adaptor ehen rertrieving sequence!!!!");
return sequence;
}
List repeat_list = rfa.fetch(new Location(cs, _chromosome,
_query_start, _query_end, 0));
System.out.println(" # found for softmasking: "
+ repeat_list.size());
Iterator rfa_iterator = repeat_list.iterator();
while (rfa_iterator.hasNext()) {
RepeatFeature feature = (RepeatFeature) rfa_iterator.next();
int r_start = Math.max(feature.getLocation().getStart()
- _query_start, 0);
int r_end = Math.min(feature.getLocation().getEnd()
- _query_start, sequence.length());
if (r_start > r_end) {
System.err.println(feature.getLocation().getStrand()
+ " end: " + feature.getLocation().getEnd() + " "
+ r_start + " " + r_end);
} else {
String sub = sequence.substring(r_start, r_end)
.toLowerCase();
seq_buff.replace(r_start, r_end, sub);
}
}
} catch (AdaptorException e) {
e.printStackTrace();
Log.printStackTrace(e);
return sequence;
}
return seq_buff.toString();
}
private void addUndefinedSequenceRegions() {
List feature_list = new ArrayList();
String sequence = retrieveSequence();
int start = sequence.indexOf("N");
int end = start;
int index = start;
while (index != -1) {
while (sequence.charAt(index++) == 'N') {
end++;
if (index == sequence.length()) {
break;
}
}
String accession_id = String.valueOf(feature_list.size());
SerializableSimpleGFFRecord unseq = new SerializableSimpleGFFRecord();
unseq.setSeqName(_chromosome);
unseq.setSource("EnsEMBL");
unseq.setFeature("undefined_sequence");
unseq.setStart(_query_start + start);
unseq.setEnd(_query_start + end - 1);
unseq.setScore(GFFTools.NO_SCORE);
unseq.setStrand(0);
unseq.setFrame(GFFTools.NO_FRAME);
AttributeUtil.setAttribute("ID", accession_id, unseq);
feature_list.add(unseq);
start = sequence.indexOf("N", end + 1);
end = start;
index = start;
}
_result.put("undefined_sequence", feature_list);
}
private void getLocusLinkIDforGene(String accession_id,
SerializableSimpleGFFRecord gene) {
StringBuffer query = new StringBuffer();
java.sql.ResultSet rs = null;
query
.append("SELECT x.dbprimary_acc "
+ "FROM gene_stable_id g, xref x, object_xref o, external_db e, transcript t, translation tr "
+ "WHERE e.db_name='LocusLink' "
+ "AND e.external_db_id=x.external_db_id "
+ "AND x.xref_id=o.xref_id "
+ "AND o.ensembl_id=tr.translation_id "
+ "AND tr.transcript_id=t.transcript_id "
+ "AND t.gene_id=g.gene_id " + "AND g.stable_id='"
+ accession_id + "'");
try {
QueryAdaptor qa = (QueryAdaptor) ConnectionManager
.createEnsemblDriverForDatabase("CORE", _database, _conn)
.getAdaptor("query");
rs = (java.sql.ResultSet) qa.execute(query.toString());
while (rs.next()) {
String locus_link = new String(rs.getString("dbprimary_acc"));
AttributeUtil.setAttribute("locus_link", locus_link, gene);
}
} catch (AdaptorException e) {
Log.printStackTrace(e);
} catch (SQLException e) {
Log.printStackTrace(e);
} finally {
try {
if (rs != null) {
rs.close();
}
} catch (SQLException e) {
}
}
}
private Map queryAndAddFeatureDistribution(String feature, int binSize,
int chr_start, int chr_end, String chromosome, Connection conn,
String database) {
if (chromosome.length() == 0)
return null;
if (chr_start < 0 || chr_end < 0 || chr_start >= chr_end)
return null;
if (!(feature.equalsIgnoreCase("gene") || feature
.equalsIgnoreCase("exon")
)) {
System.out.println("SZ - DEBUG: Unknown feature " + feature);
return null;
}
String query = "SELECT INTERVAL(seq_region_start";
for (int i = chr_start + binSize; i < chr_end + binSize; i += binSize)
query += ", " + Integer.toString(i);
query += ") AS bin, COUNT(*) AS fcount " + "FROM " + feature
+ " g, seq_region s " + "WHERE s.name = '" + chromosome + "'"
+ " AND g.seq_region_start >= " + Integer.toString(chr_start)
+ " AND g.seq_region_end < " + Integer.toString(chr_end)
+ " group by bin ;";
ResultSet rset = null;
TreeMap results = new TreeMap();
Driver driver = (org.ensembl.driver.plugin.standard.MySQLDriver) ConnectionManager
.createEnsemblDriverForDatabase("CORE", database, conn);
try {
QueryAdaptor qa = (QueryAdaptor) driver.getAdaptor("query");
rset = (ResultSet) qa.execute(query);
while (rset.next()) {
results.put(new Integer(chr_start + binSize * rset.getInt(1)),
rset.getObject(2));
}
} catch (SQLException e) {
Log.printStackTrace(e);
e.printStackTrace();
} catch (AdaptorException e) {
Log.printStackTrace(e);
e.printStackTrace();
} finally {
try {
if (rset != null) {
rset.close();
}
} catch (SQLException e) {
e.printStackTrace();
}
}
return results;
}
private void closePS(PreparedStatement ps, ResultSet rs) {
try {
if (rs != null)
rs.close();
} catch (SQLException e1) {
}
try {
if (ps != null)
ps.close();
} catch (SQLException e1) {
}
}
private static int getVersion(String database) {
String[] tokens = database.split("_");
if (tokens.length == 5) {
return Integer.parseInt(tokens[3]);
}
return 0;
}
private static String getSpecies(String database) {
String[] tokens = database.split("_");
if (tokens.length == 5) {
return tokens[0];
}
return null;
}
private synchronized boolean isDanioSuperContig() {
return ("danio".equals(getSpecies(_database).toLowerCase()) && (_chromosome
.startsWith("ctg") || _chromosome.startsWith("NA")));
}
}/*------
package ca.bcgsc.sockeye.service.featureloader.common;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import ca.bcgsc.chinook.server.comobj.SerializableSimpleGFFRecord;
import ca.bcgsc.sockeye.config.Connection;
import ca.bcgsc.sockeye.service.featureloader.remote.genstubs.FeatureLoaderLocalServiceLocator;
import ca.bcgsc.sockeye.service.featureloader.remote.genstubs.FeatureLoaderSoapBindingStub;
public class FeatureLoaderRemote implements FeatureLoaderService {
private String remoteConnectionStr = null;
public FeatureLoaderRemote(String remoteConnectionStr) {
this.remoteConnectionStr = remoteConnectionStr;
}
public FeatureLoaderResult getFeatures(
Connection conn,
String database,
String species,
String chromosome,
int query_start,
int query_end,
List featureTypes) {
FeatureLoaderLocalServiceLocator loc =
new FeatureLoaderLocalServiceLocator(remoteConnectionStr,getServiceName(conn));
FeatureLoaderResult result = null;
try {
FeatureLoaderSoapBindingStub stub =
(FeatureLoaderSoapBindingStub) loc.getFeatureLoader();
result =
convert(stub.getFeatures(
convert(conn),
database,
species,
chromosome,
query_start,
query_end,
featureTypes.toArray()));
} catch (Throwable e) {
e.printStackTrace();
System.out.println("Trying again with local mode...");
result =
FeatureLoaderLocal.getInstance().getFeatures(
conn,
database,
species,
chromosome,
query_start,
query_end,
featureTypes);
}
return result;
}
private FeatureLoaderResult convert(ca.bcgsc.sockeye.service.featureloader.remote.genstubs.FeatureLoaderResult result) {
FeatureLoaderResult finalResult = new FeatureLoaderResult();
finalResult.setWarningFeatureTypes(convertObjArrayToList(result.getWarningFeatureTypes()));
Map map = result.getFeatures();
Iterator iter = map.keySet().iterator();
while (iter.hasNext()) {
String key = (String)iter.next();
Object value = map.get(key);
if(value instanceof Object[]){
value = convertObjArrayToList((Object[])value);
}
finalResult.put(key, (List) value);
}
return finalResult;
}
private List convertObjArrayToList(Object[] objects) {
if (objects == null) {
return null;
}
ArrayList list = new ArrayList();
for (int i = 0; i < objects.length; i++) {
if(objects[i] instanceof SerializableSimpleGFFRecord) {
list.add(convert((SerializableSimpleGFFRecord)objects[i]));
} else {
list.add(objects[i]);
}
}
return list;
}
private SerializableSimpleGFFRecord convert(SerializableSimpleGFFRecord recordWithArray) {
SerializableSimpleGFFRecord record = new SerializableSimpleGFFRecord();
record.setComment(recordWithArray.getComment());
record.setEnd(recordWithArray.getEnd());
record.setFeature(recordWithArray.getFeature());
record.setFrame(recordWithArray.getFrame());
record.setScore(recordWithArray.getScore());
record.setSeqName(recordWithArray.getSeqName());
record.setSource(recordWithArray.getSource());
record.setStart(recordWithArray.getStart());
record.setStrand(recordWithArray.getStrand());
Map newMap = new HashMap();
Map map = recordWithArray.getGroupAttributes();
Iterator iter = map.keySet().iterator();
while (iter.hasNext()) {
String key = (String)iter.next();
Object value = map.get(key);
if(value instanceof Object[]){
value = convertObjArrayToList((Object[])value);
}
newMap.put(key, (List) value);
}
record.setGroupAttributes(newMap);
return record;
}
private FeatureDistributionLoaderResult convert(ca.bcgsc.sockeye.service.featureloader.remote.genstubs.FeatureDistributionLoaderResult result) {
FeatureDistributionLoaderResult finalResult = new FeatureDistributionLoaderResult();
finalResult.setWarningFeatureTypes(convertObjArrayToList(result.getWarningFeatureTypes()));
Map map = result.getFeatureDistributions();
finalResult.setFeatureDistributions(map);
return finalResult;
}
private ca.bcgsc.sockeye.service.featureloader.remote.genstubs.Connection convert(Connection conn) {
ca.bcgsc.sockeye.service.featureloader.remote.genstubs.Connection connStub =
new ca.bcgsc.sockeye.service.featureloader.remote.genstubs.Connection();
connStub.setHost(conn.getHost());
connStub.setName(conn.getName());
connStub.setPass(conn.getPass());
connStub.setPort(conn.getPort());
connStub.setType(conn.getType());
connStub.setSubtype(conn.getSubtype());
connStub.setUser(conn.getUser());
return connStub;
}
public FeatureDistributionLoaderResult getFeatureDistributions(
Connection conn,
String database,
String species,
String chromosome,
int query_start,
int query_end,
List featureTypes,
int binSize) {
FeatureLoaderLocalServiceLocator loc =
new FeatureLoaderLocalServiceLocator(remoteConnectionStr,getServiceName(conn));
FeatureDistributionLoaderResult result = null;
try {
FeatureLoaderSoapBindingStub stub =
(FeatureLoaderSoapBindingStub) loc.getFeatureLoader();
result =
convert(stub.getFeatureDistributions(
convert(conn),
database,
species,
chromosome,
query_start,
query_end,
featureTypes.toArray(),
binSize));
} catch (Throwable e) {
e.printStackTrace();
System.out.println("Trying again with local mode...");
result =
FeatureLoaderLocal.getInstance().getFeatureDistributions(
conn,
database,
species,
chromosome,
query_start,
query_end,
featureTypes,
binSize);
}
return result;
}
public GeneInfo getGeneInfo(
Connection conn,
String database,
String geneID) {
FeatureLoaderLocalServiceLocator loc =
new FeatureLoaderLocalServiceLocator(remoteConnectionStr,getServiceName(conn));
GeneInfo result = null;
try {
FeatureLoaderSoapBindingStub stub =
(FeatureLoaderSoapBindingStub) loc.getFeatureLoader();
result = convert(stub.getGeneInfo(
convert(conn),
database,
geneID));
} catch (Throwable e) {
e.printStackTrace();
System.out.println("Trying again with local mode...");
result =
FeatureLoaderLocal.getInstance().getGeneInfo(
conn,
database,
geneID);
}
return result;
}
private GeneInfo convert(ca.bcgsc.sockeye.service.featureloader.remote.genstubs.GeneInfo info) {
GeneInfo ginfo = new GeneInfo();
ginfo.setChromosome(info.getChromosome());
ginfo.setDescription(info.getDescription());
ginfo.setEnd(info.getEnd());
ginfo.setStart(info.getStart());
ginfo.setStrand(info.getStrand());
return ginfo;
}
public Map getChromosomeInfo(
Connection conn,
String database) {
FeatureLoaderLocalServiceLocator loc =
new FeatureLoaderLocalServiceLocator(remoteConnectionStr,getServiceName(conn));
Map result = null;
try {
FeatureLoaderSoapBindingStub stub =
(FeatureLoaderSoapBindingStub) loc.getFeatureLoader();
result = stub.getChromosomeInfo(
convert(conn),
database);
} catch (Throwable e) {
e.printStackTrace();
System.out.println("Trying again with local mode...");
result =
FeatureLoaderLocal.getInstance().getChromosomeInfo(
conn,
database);
}
return result;
}
public List getDatabaseList(Connection conn, String dbType) {
FeatureLoaderLocalServiceLocator loc =
new FeatureLoaderLocalServiceLocator(remoteConnectionStr,getServiceName(conn));
List result = null;
try {
FeatureLoaderSoapBindingStub stub =
(FeatureLoaderSoapBindingStub) loc.getFeatureLoader();
result = convert(stub.getDatabaseList(
convert(conn),
dbType));
} catch (Throwable e) {
e.printStackTrace();
System.out.println("Trying again with local mode...");
result =
FeatureLoaderLocal.getInstance().getDatabaseList(
conn,
dbType);
}
return result;
}
private List convert(Object[] objects) {
ArrayList list = new ArrayList();
for(int i = 0; i < objects.length; i++){
list.add(objects[i]);
}
return list;
}
public Map getRelatedFeatureIDs(
Connection conn,
String database,
String species,
Map relationshipHierarchy,
String featureID) {
FeatureLoaderLocalServiceLocator loc =
new FeatureLoaderLocalServiceLocator(remoteConnectionStr, getServiceName(conn));
Map result = null;
try {
FeatureLoaderSoapBindingStub stub =
(FeatureLoaderSoapBindingStub) loc.getFeatureLoader();
result = stub.getRelatedFeatureIDs(
convert(conn),
database,
species,
(HashMap) relationshipHierarchy,
featureID);
} catch (Throwable e) {
e.printStackTrace();
System.out.println("Trying again with local mode...");
result =
FeatureLoaderLocal.getInstance().getRelatedFeatureIDs(
conn,
database,
species,
relationshipHierarchy,
featureID);
}
return result;
}
private static String getServiceName(Connection conn) {
if ("new".equals(conn.getSubtype().toLowerCase())) {
return "axis-new";
} else {
return "axis";
}
}
}
package ca.bcgsc.sockeye.service.featureloader.common;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
public class FeatureLoaderResult implements Serializable {
private Map features = new HashMap();
private List warningFeatureTypes = new ArrayList();
public FeatureLoaderResult() {
}
public void put(String type, List typedFeatures) {
features.put(type, typedFeatures);
}
public List get(String type) {
List l = (List)features.get(type);
if (l == null) {
return null;
}
return (List)(features.get(type));
}
public void addWarningFeatureType(String type) {
warningFeatureTypes.add(type);
}
public Map getFeatures() {
return features;
}
public List getWarningFeatureTypes() {
return Collections.unmodifiableList(warningFeatureTypes);
}
public void setFeatures(Map features) {
this.features = features;
}
public void setWarningFeatureTypes(List warningFeatureTypes) {
this.warningFeatureTypes = warningFeatureTypes;
}
}
package ca.bcgsc.sockeye.service.featureloader.common;
import java.util.List;
import java.util.Map;
import ca.bcgsc.sockeye.config.Connection;
public interface FeatureLoaderService {
public static String HOMOLOGUE_GENE = "HOMOLOGUE_GENE";
public static String GENE_TRANSCRIPT = "GENE_TRANSCRIPT";
public static String TRANSCRIPT_EXON = "TRANSCRIPT_EXON";
abstract public FeatureLoaderResult getFeatures(
Connection conn,
String database,
String species,
String chromosome,
int query_start,
int query_end,
List featureTypes);
abstract public FeatureDistributionLoaderResult getFeatureDistributions(
Connection conn,
String database,
String species,
String chromosome,
int query_start,
int query_end,
List featureTypes,
int binSize);
abstract public Map getRelatedFeatureIDs(
Connection conn,
String database,
String species,
Map relationshipHierarchy,
String featureID);
abstract public GeneInfo getGeneInfo(
Connection conn,
String database,
String geneID);
abstract public Map getChromosomeInfo(
Connection conn,
String database);
abstract public List getDatabaseList(Connection connection, String dbType);
}
package ca.bcgsc.sockeye.service.featureloader.common;
public class FeatureLoaderServiceFactory {
public static String FEATURELOADER_SERVICES = "FeatureLoader";
static private FeatureLoaderServiceFactory instance = new FeatureLoaderServiceFactory();
static public FeatureLoaderServiceFactory getInstance() {
return instance;
}
public FeatureLoaderService getService(String serviceType, String remotehost) {
if("remote".equals(serviceType)) {
return new FeatureLoaderRemote(remotehost);
} else {
return FeatureLoaderLocal.getInstance();
}
}
}
package ca.bcgsc.sockeye.service.featureloader.common;
public class GeneInfo {
private String chromosome;
private int start;
private int end;
private int strand;
private String description;
public GeneInfo() {
super();
}
public String getChromosome() {
return chromosome;
}
public void setChromosome(String chromosome) {
this.chromosome = chromosome;
}
public String getDescription() {
return description;
}
public void setDescription(String description) {
this.description = description;
}
public int getEnd() {
return end;
}
public void setEnd(int end) {
this.end = end;
}
public int getStart() {
return start;
}
public void setStart(int start) {
this.start = start;
}
public int getStrand() {
return strand;
}
public void setStrand(int strand) {
this.strand = strand;
}
}
package ca.bcgsc.sockeye.service.featureloader.common;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
public class RelationshipMapUtil {
private static final char SUBGROUP_SEPARATOR = ':';
private RelationshipMapUtil() {
super();
}
public static String createSubGroupKey(String relationshipKey, String subGroup) {
StringBuffer sb = new StringBuffer(relationshipKey);
sb.append(SUBGROUP_SEPARATOR);
sb.append(subGroup);
return sb.toString();
}
public static String extractSubGroup(String key) {
int i = key.indexOf(SUBGROUP_SEPARATOR);
if(i == -1){
throw new RuntimeException("Key is not valid.");
}
return key.substring(i + 1);
}
public static List getListFromMap(Map map) {
ArrayList list = new ArrayList();
Set set = map.keySet();
Iterator it = set.iterator();
while (it.hasNext()) {
list.add(it.next());
}
return list;
}
}
package ca.bcgsc.sockeye.service.featureloader.common;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Map;
import java.util.TreeMap;
public class RemoteFeatureCountAdapter {
public RemoteFeatureCountAdapter() {
}
public RemoteFeatureCountAdapter(String host, String user, String pass, String database){
setConnectionParameters(host, user, pass);
setCoreDatabase(database) ;
}
public RemoteFeatureCountAdapter(String host, String user, String pass){
setConnectionParameters(host, user, pass);
}
public void setConnectionParameters (String host, String user, String pass, String database){
setConnectionParameters(host, user, pass);
setCoreDatabase(database) ;
}
public void setConnectionParameters (String host, String user, String pass){
_dbServer = host;
_dbUser = user;
_dbPass = pass;
try {
Class.forName("com.mysql.jdbc.Driver");
} catch (ClassNotFoundException e) {
System.out.println("SZ - Driver not found: " + e.getMessage());
}
}
public void setCoreDatabase (String database){
_dbCore = database;
}
public Map getFeatureHistogram (String featureName,
String chromosome, int chr_start, int chr_end,
int intervalLength){
String query;
TreeMap histogram;
if (chromosome.length() == 0)
return null;
if (chr_start < 0 || chr_end < 0 || chr_start >= chr_end)
return null;
if (!(featureName.equalsIgnoreCase("gene") ||
featureName.equalsIgnoreCase("exon") ||
featureName.equalsIgnoreCase("snp") ||
featureName.equalsIgnoreCase("repeat"))){
System.out.println("SZ - DEBUG: Unknown feature " + featureName);
return null;
}
query = getHistogramQueryString(featureName.toLowerCase(), chromosome, chr_start, chr_end, intervalLength);
return doHistogramQuery(query, chr_start, intervalLength);
}
protected String getHistogramQueryString (String featureName, String chromosome,
int chr_start, int chr_end, int intervalLength){
String liteQuery = new String ("SELECT INTERVAL(chr_start" );
String miscAdd = new String();
if ( featureName.equalsIgnoreCase("GENE") )
miscAdd = " AND db='core' ";
for (int i=chr_start+intervalLength; i<chr_end+intervalLength; i+=intervalLength)
liteQuery += ", " + Integer.toString(i);
liteQuery += ") AS bin, COUNT(*) AS fcount FROM " + featureName + " ";
liteQuery += "WHERE chr_name = '" + chromosome + "'"
+ " AND chr_start >= " + Integer.toString(chr_start)
+ " AND chr_end < " + Integer.toString(chr_end)
+ miscAdd
+ " group by bin ;";
return liteQuery;
}
protected TreeMap doHistogramQuery(String queryString, int startOffset, int intervalLength){
String url = new String("jdbc:mysql:
TreeMap results = new TreeMap();
Connection conn;
Statement stmt;
ResultSet rset;
try {
conn = DriverManager.getConnection (url , _dbUser, _dbPass);
}
catch (SQLException e) {
System.out.println("SZ: Can't connect to DB: " + e.getMessage());
return null;
}
try {
stmt = conn.createStatement();
}
catch (SQLException e) {
System.out.println("SZ: Can't create statement: " + e.toString());
try{
conn.close();
}
catch (SQLException s){
System.out.println("Can't close connection: " + e.toString());
}
return null;
}
try {
rset = stmt.executeQuery(queryString);
}
catch (SQLException e) {
System.out.println("SZ: Error while executing query: " + e.toString());
return null;
}
try {
while (rset.next()){
results.put(new Integer(startOffset+ intervalLength * rset.getInt(1)), rset.getObject(2));
}
}
catch (SQLException e) {
System.out.println("SZ Error while reading result set: " + e.toString());
return null;
}
try{
stmt.close();
}
catch(SQLException e){
System.out.println("SZ Can't close statement: " + e.toString());
}
try{
conn.close();
}
catch(SQLException e){
System.out.println("SZ Can't close connection: " + e.toString());
}
return results;
}
protected String _dbServer;
protected String _dbUser;
protected String _dbPass;
protected String _dbCore;
public String getDatabase() {
return _dbCore;
}
public String getPass() {
return _dbPass;
}
public String getUser() {
return _dbUser;
}
}
package ca.bcgsc.sockeye.service.featureloader.junit;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import junit.framework.TestCase;
import junit.framework.TestSuite;
import ca.bcgsc.chinook.server.comobj.SerializableSimpleGFFRecord;
import ca.bcgsc.sockeye.service.featureloader.common.AttributeUtil;
import ca.bcgsc.sockeye.service.featureloader.common.ConnectionManager;
import ca.bcgsc.sockeye.service.featureloader.common.DistributionContainer;
import ca.bcgsc.sockeye.service.featureloader.common.FeatureDistributionLoaderResult;
import ca.bcgsc.sockeye.service.featureloader.common.FeatureLoaderResult;
import ca.bcgsc.sockeye.service.featureloader.common.FeatureLoaderService;
import ca.bcgsc.sockeye.service.featureloader.common.FeatureLoaderServiceFactory;
import ca.bcgsc.sockeye.service.featureloader.common.GeneInfo;
import ca.bcgsc.sockeye.service.featureloader.common.RelationshipMapUtil;
public class FeatureLoaderUnitTest extends TestCase {
public FeatureLoaderUnitTest(String name) {
super(name);
}
public static void main(String[] args) {
junit.textui.TestRunner.run(FeatureLoaderUnitTest.suite());
}
protected void setUp() {
ConnectionManager.initialize();
}
protected void tearDown() {
}
public static TestSuite suite() {
TestSuite testSuite = new TestSuite();
testSuite.addTest(new FeatureLoaderUnitTest("testEnsembl16CEle"));
testSuite.addTest(new FeatureLoaderUnitTest("testEnsembl16CEleDistribution"));
testSuite.addTest(new FeatureLoaderUnitTest("testEnsembl16CEleGeneInfo"));
testSuite.addTest(new FeatureLoaderUnitTest("testEnsembl16CEleChromosomeInfo"));
testSuite.addTest(new FeatureLoaderUnitTest("testEnsembl16DatabaseList"));
testSuite.addTest(new FeatureLoaderUnitTest("testEnsembl16Orthologues"));
testSuite.addTest(new FeatureLoaderUnitTest("testEnsembl16Transcripts"));
return testSuite;
}
public void testEnsembl16CEle() {
FeatureLoaderService service =
FeatureLoaderServiceFactory.getInstance().getService(
"remote",
"island.bcgsc.ca:8080");
String[] featureTypes =
{
"gene",
"sequence conservation profile set",
"Conserved Region",
"generic_scored",
"User defined feature sets"
};
List list = new ArrayList();
for(int i = 0; i < featureTypes.length; i++) {
list.add(featureTypes[i]);
}
FeatureLoaderResult result = service.getFeatures(
ConnectionManager.getCurrentConnection("Ensembl"),
"caenorhabditis_elegans_core_16_102",
"Caenorhabditis_elegans",
"I",
1,
10000,
list
);
Map features = result.getFeatures();
Set keys = features.keySet();
assertEquals(true, keys.contains("gene"));
Iterator it = keys.iterator();
while (it.hasNext()) {
String key = (String) it.next();
List l = (List)features.get(key);
System.out.println(key + "\t" + (l == null ? "null" : "" + l.size()) );
}
List l = (List)features.get("gene");
SerializableSimpleGFFRecord gff = (SerializableSimpleGFFRecord)l.get(0);
assertEquals("Y74C9A.3", AttributeUtil.getAttribute("ID", gff));
assertEquals(-1, gff.getStrand());
assertEquals(4181, gff.getStart());
assertEquals(10232, gff.getEnd());
}
public void testEnsembl16CEleDistribution() {
FeatureLoaderService service =
FeatureLoaderServiceFactory.getInstance().getService(
"remote",
"island.bcgsc.ca:8080");
List list = new ArrayList();
list.add("gene");
FeatureDistributionLoaderResult result = service.getFeatureDistributions(
ConnectionManager.getCurrentConnection("Ensembl"),
"caenorhabditis_elegans_core_16_102",
"Caenorhabditis_elegans",
"I",
1,
1000000,
list,
6666
);
Map map = (Map) result.getFeatureDistributions().get("gene");
List dcList = translateDistributionToContainer(map, 6666);
assertEquals(1.0, ((DistributionContainer)dcList.get(0)).getScore(), 0);
assertEquals(2.0, ((DistributionContainer)dcList.get(69)).getScore(), 0);
}
private List translateDistributionToContainer(
Map distribution,
int binSize) {
ArrayList dcList = new ArrayList();
List bins = new ArrayList(distribution.keySet());
Iterator it = bins.iterator();
while (it.hasNext()) {
Integer bin = new Integer(it.next().toString());
int start = bin.intValue();
int end = start + binSize;
int score = Integer.parseInt(distribution.get(bin).toString());
dcList.add(new DistributionContainer(start, end, score));
}
return dcList;
}
public void testEnsembl16CEleGeneInfo() {
FeatureLoaderService service =
FeatureLoaderServiceFactory.getInstance().getService(
"remote",
"island.bcgsc.ca:8080");
GeneInfo geneInfo = service.getGeneInfo(
ConnectionManager.getCurrentConnection("Ensembl"),
"caenorhabditis_elegans_core_16_102",
"T18D3.4"
);
assertEquals(12467981, geneInfo.getStart());
assertEquals(12475261, geneInfo.getEnd());
assertEquals(1, geneInfo.getStrand());
assertEquals("X", geneInfo.getChromosome());
}
public void testEnsembl16CEleChromosomeInfo() {
FeatureLoaderService service =
FeatureLoaderServiceFactory.getInstance().getService(
"remote",
"island.bcgsc.ca:8080");
Map cInfo = service.getChromosomeInfo(
ConnectionManager.getCurrentConnection("Ensembl"),
"caenorhabditis_elegans_core_16_102"
);
Iterator it = cInfo.keySet().iterator();
assertEquals("I", (String) it.next());
assertEquals(6, cInfo.size());
}
public void testEnsembl16DatabaseList() {
FeatureLoaderService service =
FeatureLoaderServiceFactory.getInstance().getService(
"remote",
"island.bcgsc.ca:8080");
List dbs = service.getDatabaseList(
ConnectionManager.getCurrentConnection("Ensembl"),
"CORE"
);
assertTrue(dbs.size() > 0);
}
private static Map HOMOLOGUE_GENE_RELATIONSHIP_MAP = new HashMap();
private static Map GENE_TRANSCRIPT_EXON_RELATIONSHIP_MAP = new HashMap();
private static Map TRANSCRIPT_EXON_RELATIONSHIP_MAP = new HashMap();
static {
HOMOLOGUE_GENE_RELATIONSHIP_MAP.put(
FeatureLoaderService.HOMOLOGUE_GENE,
null);
TRANSCRIPT_EXON_RELATIONSHIP_MAP.put(FeatureLoaderService.TRANSCRIPT_EXON, null);
GENE_TRANSCRIPT_EXON_RELATIONSHIP_MAP.put(
FeatureLoaderService.GENE_TRANSCRIPT,
TRANSCRIPT_EXON_RELATIONSHIP_MAP);
}
public void testEnsembl16Orthologues() {
FeatureLoaderService service =
FeatureLoaderServiceFactory.getInstance().getService(
"remote",
"island.bcgsc.ca:8080");
Map map = service.getRelatedFeatureIDs(
ConnectionManager.getCurrentConnection("Ensembl"),
"caenorhabditis_elegans_core_16_102",
"caenorhabditis_elegans",
HOMOLOGUE_GENE_RELATIONSHIP_MAP,
"Y74C9A.3"
);
Map homologues =
(Map) map.get(
RelationshipMapUtil.createSubGroupKey(
FeatureLoaderService.HOMOLOGUE_GENE,
"Caenorhabditis_briggsae"));
assertTrue(homologues.containsKey("ENSCBRG00000008160"));
assertTrue(map.size() > 0);
}
public void testEnsembl16Transcripts() {
FeatureLoaderService service =
FeatureLoaderServiceFactory.getInstance().getService(
"remote",
"island.bcgsc.ca:8080");
Map map = service.getRelatedFeatureIDs(
ConnectionManager.getCurrentConnection("Ensembl"),
"caenorhabditis_elegans_core_16_102",
"caenorhabditis_elegans",
GENE_TRANSCRIPT_EXON_RELATIONSHIP_MAP,
"Y48G1C.2"
);
Map transcriptIdsMap =
(Map) map.get(FeatureLoaderService.GENE_TRANSCRIPT);
assertTrue(transcriptIdsMap.size() > 0);
}
}
package ca.bcgsc.sockeye.service.featureloader.remote.genstubs;
public class Connection implements java.io.Serializable {
private java.lang.String host;
private java.lang.String name;
private java.lang.String pass;
private java.lang.String port;
private java.lang.String subtype;
private java.lang.String type;
private java.lang.String user;
public Connection() {
}
public java.lang.String getHost() {
return host;
}
public void setHost(java.lang.String host) {
this.host = host;
}
public java.lang.String getName() {
return name;
}
public void setName(java.lang.String name) {
this.name = name;
}
public java.lang.String getPass() {
return pass;
}
public void setPass(java.lang.String pass) {
this.pass = pass;
}
public java.lang.String getPort() {
return port;
}
public void setPort(java.lang.String port) {
this.port = port;
}
public java.lang.String getSubtype() {
return subtype;
}
public void setSubtype(java.lang.String subtype) {
this.subtype = subtype;
}
public java.lang.String getType() {
return type;
}
public void setType(java.lang.String type) {
this.type = type;
}
public java.lang.String getUser() {
return user;
}
public void setUser(java.lang.String user) {
this.user = user;
}
private java.lang.Object __equalsCalc = null;
public synchronized boolean equals(java.lang.Object obj) {
if (!(obj instanceof Connection)) return false;
Connection other = (Connection) obj;
if (obj == null) return false;
if (this == obj) return true;
if (__equalsCalc != null) {
return (__equalsCalc == obj);
}
__equalsCalc = obj;
boolean _equals;
_equals = true &&
((this.host==null && other.getHost()==null) ||
(this.host!=null &&
this.host.equals(other.getHost()))) &&
((this.name==null && other.getName()==null) ||
(this.name!=null &&
this.name.equals(other.getName()))) &&
((this.pass==null && other.getPass()==null) ||
(this.pass!=null &&
this.pass.equals(other.getPass()))) &&
((this.port==null && other.getPort()==null) ||
(this.port!=null &&
this.port.equals(other.getPort()))) &&
((this.subtype==null && other.getSubtype()==null) ||
(this.subtype!=null &&
this.subtype.equals(other.getSubtype()))) &&
((this.type==null && other.getType()==null) ||
(this.type!=null &&
this.type.equals(other.getType()))) &&
((this.user==null && other.getUser()==null) ||
(this.user!=null &&
this.user.equals(other.getUser())));
__equalsCalc = null;
return _equals;
}
private boolean __hashCodeCalc = false;
public synchronized int hashCode() {
if (__hashCodeCalc) {
return 0;
}
__hashCodeCalc = true;
int _hashCode = 1;
if (getHost() != null) {
_hashCode += getHost().hashCode();
}
if (getName() != null) {
_hashCode += getName().hashCode();
}
if (getPass() != null) {
_hashCode += getPass().hashCode();
}
if (getPort() != null) {
_hashCode += getPort().hashCode();
}
if (getSubtype() != null) {
_hashCode += getSubtype().hashCode();
}
if (getType() != null) {
_hashCode += getType().hashCode();
}
if (getUser() != null) {
_hashCode += getUser().hashCode();
}
__hashCodeCalc = false;
return _hashCode;
}
private static org.apache.axis.description.TypeDesc typeDesc =
new org.apache.axis.description.TypeDesc(Connection.class);
static {
typeDesc.setXmlType(new javax.xml.namespace.QName("FeatureLoader", "Connection"));
org.apache.axis.description.ElementDesc elemField = new org.apache.axis.description.ElementDesc();
elemField.setFieldName("host");
elemField.setXmlName(new javax.xml.namespace.QName("", "host"));
elemField.setXmlType(new javax.xml.namespace.QName("http:
typeDesc.addFieldDesc(elemField);
elemField = new org.apache.axis.description.ElementDesc();
elemField.setFieldName("name");
elemField.setXmlName(new javax.xml.namespace.QName("", "name"));
elemField.setXmlType(new javax.xml.namespace.QName("http:
typeDesc.addFieldDesc(elemField);
elemField = new org.apache.axis.description.ElementDesc();
elemField.setFieldName("pass");
elemField.setXmlName(new javax.xml.namespace.QName("", "pass"));
elemField.setXmlType(new javax.xml.namespace.QName("http:
typeDesc.addFieldDesc(elemField);
elemField = new org.apache.axis.description.ElementDesc();
elemField.setFieldName("port");
elemField.setXmlName(new javax.xml.namespace.QName("", "port"));
elemField.setXmlType(new javax.xml.namespace.QName("http:
typeDesc.addFieldDesc(elemField);
elemField = new org.apache.axis.description.ElementDesc();
elemField.setFieldName("subtype");
elemField.setXmlName(new javax.xml.namespace.QName("", "subtype"));
elemField.setXmlType(new javax.xml.namespace.QName("http:
typeDesc.addFieldDesc(elemField);
elemField = new org.apache.axis.description.ElementDesc();
elemField.setFieldName("type");
elemField.setXmlName(new javax.xml.namespace.QName("", "type"));
elemField.setXmlType(new javax.xml.namespace.QName("http:
typeDesc.addFieldDesc(elemField);
elemField = new org.apache.axis.description.ElementDesc();
elemField.setFieldName("user");
elemField.setXmlName(new javax.xml.namespace.QName("", "user"));
elemField.setXmlType(new javax.xml.namespace.QName("http:
typeDesc.addFieldDesc(elemField);
}
public static org.apache.axis.description.TypeDesc getTypeDesc() {
return typeDesc;
}
public static org.apache.axis.encoding.Serializer getSerializer(
java.lang.String mechType,
java.lang.Class _javaType,
javax.xml.namespace.QName _xmlType) {
return
new org.apache.axis.encoding.ser.BeanSerializer(
_javaType, _xmlType, typeDesc);
}
public static org.apache.axis.encoding.Deserializer getDeserializer(
java.lang.String mechType,
java.lang.Class _javaType,
javax.xml.namespace.QName _xmlType) {
return
new org.apache.axis.encoding.ser.BeanDeserializer(
_javaType, _xmlType, typeDesc);
}
}
package ca.bcgsc.sockeye.service.featureloader.remote.genstubs;
public class FeatureDistributionLoaderResult implements java.io.Serializable {
private java.util.HashMap featureDistributions;
private java.lang.Object[] warningFeatureTypes;
public FeatureDistributionLoaderResult() {
}
public java.util.HashMap getFeatureDistributions() {
return featureDistributions;
}
public void setFeatureDistributions(java.util.HashMap featureDistributions) {
this.featureDistributions = featureDistributions;
}
public java.lang.Object[] getWarningFeatureTypes() {
return warningFeatureTypes;
}
public void setWarningFeatureTypes(java.lang.Object[] warningFeatureTypes) {
this.warningFeatureTypes = warningFeatureTypes;
}
private java.lang.Object __equalsCalc = null;
public synchronized boolean equals(java.lang.Object obj) {
if (!(obj instanceof FeatureDistributionLoaderResult)) return false;
FeatureDistributionLoaderResult other = (FeatureDistributionLoaderResult) obj;
if (obj == null) return false;
if (this == obj) return true;
if (__equalsCalc != null) {
return (__equalsCalc == obj);
}
__equalsCalc = obj;
boolean _equals;
_equals = true &&
((this.featureDistributions==null && other.getFeatureDistributions()==null) ||
(this.featureDistributions!=null &&
this.featureDistributions.equals(other.getFeatureDistributions()))) &&
((this.warningFeatureTypes==null && other.getWarningFeatureTypes()==null) ||
(this.warningFeatureTypes!=null &&
java.util.Arrays.equals(this.warningFeatureTypes, other.getWarningFeatureTypes())));
__equalsCalc = null;
return _equals;
}
private boolean __hashCodeCalc = false;
public synchronized int hashCode() {
if (__hashCodeCalc) {
return 0;
}
__hashCodeCalc = true;
int _hashCode = 1;
if (getFeatureDistributions() != null) {
_hashCode += getFeatureDistributions().hashCode();
}
if (getWarningFeatureTypes() != null) {
for (int i=0;
i<java.lang.reflect.Array.getLength(getWarningFeatureTypes());
i++) {
java.lang.Object obj = java.lang.reflect.Array.get(getWarningFeatureTypes(), i);
if (obj != null &&
!obj.getClass().isArray()) {
_hashCode += obj.hashCode();
}
}
}
__hashCodeCalc = false;
return _hashCode;
}
private static org.apache.axis.description.TypeDesc typeDesc =
new org.apache.axis.description.TypeDesc(FeatureDistributionLoaderResult.class);
static {
typeDesc.setXmlType(new javax.xml.namespace.QName("FeatureLoader", "FeatureDistributionLoaderResult"));
org.apache.axis.description.ElementDesc elemField = new org.apache.axis.description.ElementDesc();
elemField.setFieldName("featureDistributions");
elemField.setXmlName(new javax.xml.namespace.QName("", "featureDistributions"));
elemField.setXmlType(new javax.xml.namespace.QName("http:
typeDesc.addFieldDesc(elemField);
elemField = new org.apache.axis.description.ElementDesc();
elemField.setFieldName("warningFeatureTypes");
elemField.setXmlName(new javax.xml.namespace.QName("", "warningFeatureTypes"));
elemField.setXmlType(new javax.xml.namespace.QName("http:
typeDesc.addFieldDesc(elemField);
}
public static org.apache.axis.description.TypeDesc getTypeDesc() {
return typeDesc;
}
public static org.apache.axis.encoding.Serializer getSerializer(
java.lang.String mechType,
java.lang.Class _javaType,
javax.xml.namespace.QName _xmlType) {
return
new org.apache.axis.encoding.ser.BeanSerializer(
_javaType, _xmlType, typeDesc);
}
public static org.apache.axis.encoding.Deserializer getDeserializer(
java.lang.String mechType,
java.lang.Class _javaType,
javax.xml.namespace.QName _xmlType) {
return
new org.apache.axis.encoding.ser.BeanDeserializer(
_javaType, _xmlType, typeDesc);
}
}
package ca.bcgsc.sockeye.service.featureloader.remote.genstubs;
public interface FeatureLoaderLocal extends java.rmi.Remote {
public ca.bcgsc.sockeye.service.featureloader.remote.genstubs.FeatureLoaderResult getFeatures(ca.bcgsc.sockeye.service.featureloader.remote.genstubs.Connection conn, java.lang.String database, java.lang.String species, java.lang.String chromosome, int query_start, int query_end, java.lang.Object[] featureTypes) throws java.rmi.RemoteException;
public ca.bcgsc.sockeye.service.featureloader.remote.genstubs.FeatureDistributionLoaderResult getFeatureDistributions(ca.bcgsc.sockeye.service.featureloader.remote.genstubs.Connection conn, java.lang.String database, java.lang.String species, java.lang.String chromosome, int query_start, int query_end, java.lang.Object[] featureTypes, int binSize) throws java.rmi.RemoteException;
public ca.bcgsc.sockeye.service.featureloader.remote.genstubs.GeneInfo getGeneInfo(ca.bcgsc.sockeye.service.featureloader.remote.genstubs.Connection conn, java.lang.String database, java.lang.String geneID) throws java.rmi.RemoteException;
public java.util.HashMap getChromosomeInfo(ca.bcgsc.sockeye.service.featureloader.remote.genstubs.Connection conn, java.lang.String database) throws java.rmi.RemoteException;
public java.lang.Object[] getDatabaseList(ca.bcgsc.sockeye.service.featureloader.remote.genstubs.Connection connection, java.lang.String dbType) throws java.rmi.RemoteException;
public java.util.HashMap getRelatedFeatureIDs(ca.bcgsc.sockeye.service.featureloader.remote.genstubs.Connection conn, java.lang.String database, java.lang.String species, java.util.HashMap relationshipHierarchy, java.lang.String featureID) throws java.rmi.RemoteException;
}
package ca.bcgsc.sockeye.service.featureloader.remote.genstubs;
public interface FeatureLoaderLocalService extends javax.xml.rpc.Service {
public java.lang.String getFeatureLoaderAddress();
public ca.bcgsc.sockeye.service.featureloader.remote.genstubs.FeatureLoaderLocal getFeatureLoader() throws javax.xml.rpc.ServiceException;
public ca.bcgsc.sockeye.service.featureloader.remote.genstubs.FeatureLoaderLocal getFeatureLoader(java.net.URL portAddress) throws javax.xml.rpc.ServiceException;
}
package ca.bcgsc.sockeye.service.featureloader.remote.genstubs;
public class FeatureLoaderLocalServiceLocator extends org.apache.axis.client.Service implements ca.bcgsc.sockeye.service.featureloader.remote.genstubs.FeatureLoaderLocalService {
private java.lang.String FeatureLoader_address = "http:
private final static String defaultDir = "axis-new";
public FeatureLoaderLocalServiceLocator(String remoteConnStr) {
this(remoteConnStr, defaultDir);
}
public FeatureLoaderLocalServiceLocator(String remoteConnStr, String dir) {
FeatureLoader_address = "http:
}
public java.lang.String getFeatureLoaderAddress() {
return FeatureLoader_address;
}
private java.lang.String FeatureLoaderWSDDServiceName = "FeatureLoader";
public java.lang.String getFeatureLoaderWSDDServiceName() {
return FeatureLoaderWSDDServiceName;
}
public void setFeatureLoaderWSDDServiceName(java.lang.String name) {
FeatureLoaderWSDDServiceName = name;
}
public ca.bcgsc.sockeye.service.featureloader.remote.genstubs.FeatureLoaderLocal getFeatureLoader() throws javax.xml.rpc.ServiceException {
java.net.URL endpoint;
try {
endpoint = new java.net.URL(FeatureLoader_address);
}
catch (java.net.MalformedURLException e) {
throw new javax.xml.rpc.ServiceException(e);
}
return getFeatureLoader(endpoint);
}
public ca.bcgsc.sockeye.service.featureloader.remote.genstubs.FeatureLoaderLocal getFeatureLoader(java.net.URL portAddress) throws javax.xml.rpc.ServiceException {
try {
ca.bcgsc.sockeye.service.featureloader.remote.genstubs.FeatureLoaderSoapBindingStub _stub = new ca.bcgsc.sockeye.service.featureloader.remote.genstubs.FeatureLoaderSoapBindingStub(portAddress, this);
_stub.setPortName(getFeatureLoaderWSDDServiceName());
return _stub;
}
catch (org.apache.axis.AxisFault e) {
return null;
}
}
public java.rmi.Remote getPort(Class serviceEndpointInterface) throws javax.xml.rpc.ServiceException {
try {
if (ca.bcgsc.sockeye.service.featureloader.remote.genstubs.FeatureLoaderLocal.class.isAssignableFrom(serviceEndpointInterface)) {
ca.bcgsc.sockeye.service.featureloader.remote.genstubs.FeatureLoaderSoapBindingStub _stub = new ca.bcgsc.sockeye.service.featureloader.remote.genstubs.FeatureLoaderSoapBindingStub(new java.net.URL(FeatureLoader_address), this);
_stub.setPortName(getFeatureLoaderWSDDServiceName());
return _stub;
}
}
catch (java.lang.Throwable t) {
throw new javax.xml.rpc.ServiceException(t);
}
throw new javax.xml.rpc.ServiceException("There is no stub implementation for the interface: " + (serviceEndpointInterface == null ? "null" : serviceEndpointInterface.getName()));
}
public java.rmi.Remote getPort(javax.xml.namespace.QName portName, Class serviceEndpointInterface) throws javax.xml.rpc.ServiceException {
if (portName == null) {
return getPort(serviceEndpointInterface);
}
String inputPortName = portName.getLocalPart();
if ("FeatureLoader".equals(inputPortName)) {
return getFeatureLoader();
}
else {
java.rmi.Remote _stub = getPort(serviceEndpointInterface);
((org.apache.axis.client.Stub) _stub).setPortName(portName);
return _stub;
}
}
public javax.xml.namespace.QName getServiceName() {
return new javax.xml.namespace.QName("http:
}
private java.util.HashSet ports = null;
public java.util.Iterator getPorts() {
if (ports == null) {
ports = new java.util.HashSet();
ports.add(new javax.xml.namespace.QName("FeatureLoader"));
}
return ports.iterator();
}
}
package ca.bcgsc.sockeye.service.featureloader.remote.genstubs;
public class FeatureLoaderResult implements java.io.Serializable {
private java.util.HashMap features;
private java.lang.Object[] warningFeatureTypes;
public FeatureLoaderResult() {
}
public java.util.HashMap getFeatures() {
return features;
}
public void setFeatures(java.util.HashMap features) {
this.features = features;
}
public java.lang.Object[] getWarningFeatureTypes() {
return warningFeatureTypes;
}
public void setWarningFeatureTypes(java.lang.Object[] warningFeatureTypes) {
this.warningFeatureTypes = warningFeatureTypes;
}
private java.lang.Object __equalsCalc = null;
public synchronized boolean equals(java.lang.Object obj) {
if (!(obj instanceof FeatureLoaderResult)) return false;
FeatureLoaderResult other = (FeatureLoaderResult) obj;
if (obj == null) return false;
if (this == obj) return true;
if (__equalsCalc != null) {
return (__equalsCalc == obj);
}
__equalsCalc = obj;
boolean _equals;
_equals = true &&
((this.features==null && other.getFeatures()==null) ||
(this.features!=null &&
this.features.equals(other.getFeatures()))) &&
((this.warningFeatureTypes==null && other.getWarningFeatureTypes()==null) ||
(this.warningFeatureTypes!=null &&
java.util.Arrays.equals(this.warningFeatureTypes, other.getWarningFeatureTypes())));
__equalsCalc = null;
return _equals;
}
private boolean __hashCodeCalc = false;
public synchronized int hashCode() {
if (__hashCodeCalc) {
return 0;
}
__hashCodeCalc = true;
int _hashCode = 1;
if (getFeatures() != null) {
_hashCode += getFeatures().hashCode();
}
if (getWarningFeatureTypes() != null) {
for (int i=0;
i<java.lang.reflect.Array.getLength(getWarningFeatureTypes());
i++) {
java.lang.Object obj = java.lang.reflect.Array.get(getWarningFeatureTypes(), i);
if (obj != null &&
!obj.getClass().isArray()) {
_hashCode += obj.hashCode();
}
}
}
__hashCodeCalc = false;
return _hashCode;
}
private static org.apache.axis.description.TypeDesc typeDesc =
new org.apache.axis.description.TypeDesc(FeatureLoaderResult.class);
static {
typeDesc.setXmlType(new javax.xml.namespace.QName("FeatureLoader", "FeatureLoaderResult"));
org.apache.axis.description.ElementDesc elemField = new org.apache.axis.description.ElementDesc();
elemField.setFieldName("features");
elemField.setXmlName(new javax.xml.namespace.QName("", "features"));
elemField.setXmlType(new javax.xml.namespace.QName("http:
typeDesc.addFieldDesc(elemField);
elemField = new org.apache.axis.description.ElementDesc();
elemField.setFieldName("warningFeatureTypes");
elemField.setXmlName(new javax.xml.namespace.QName("", "warningFeatureTypes"));
elemField.setXmlType(new javax.xml.namespace.QName("http:
typeDesc.addFieldDesc(elemField);
}
public static org.apache.axis.description.TypeDesc getTypeDesc() {
return typeDesc;
}
public static org.apache.axis.encoding.Serializer getSerializer(
java.lang.String mechType,
java.lang.Class _javaType,
javax.xml.namespace.QName _xmlType) {
return
new org.apache.axis.encoding.ser.BeanSerializer(
_javaType, _xmlType, typeDesc);
}
public static org.apache.axis.encoding.Deserializer getDeserializer(
java.lang.String mechType,
java.lang.Class _javaType,
javax.xml.namespace.QName _xmlType) {
return
new org.apache.axis.encoding.ser.BeanDeserializer(
_javaType, _xmlType, typeDesc);
}
}
package ca.bcgsc.sockeye.service.featureloader.remote.genstubs;
import ca.bcgsc.chinook.server.comobj.SerializableSimpleGFFRecord;
public class FeatureLoaderSoapBindingStub extends org.apache.axis.client.Stub implements ca.bcgsc.sockeye.service.featureloader.remote.genstubs.FeatureLoaderLocal {
private java.util.Vector cachedSerClasses = new java.util.Vector();
private java.util.Vector cachedSerQNames = new java.util.Vector();
private java.util.Vector cachedSerFactories = new java.util.Vector();
private java.util.Vector cachedDeserFactories = new java.util.Vector();
static org.apache.axis.description.OperationDesc [] _operations;
static {
_operations = new org.apache.axis.description.OperationDesc[6];
org.apache.axis.description.OperationDesc oper;
oper = new org.apache.axis.description.OperationDesc();
oper.setName("getFeatures");
oper.addParameter(new javax.xml.namespace.QName("", "conn"), new javax.xml.namespace.QName("FeatureLoader", "Connection"), ca.bcgsc.sockeye.service.featureloader.remote.genstubs.Connection.class, org.apache.axis.description.ParameterDesc.IN, false, false);
oper.addParameter(new javax.xml.namespace.QName("", "database"), new javax.xml.namespace.QName("http:
oper.addParameter(new javax.xml.namespace.QName("", "species"), new javax.xml.namespace.QName("http:
oper.addParameter(new javax.xml.namespace.QName("", "chromosome"), new javax.xml.namespace.QName("http:
oper.addParameter(new javax.xml.namespace.QName("", "query_start"), new javax.xml.namespace.QName("http:
oper.addParameter(new javax.xml.namespace.QName("", "query_end"), new javax.xml.namespace.QName("http:
oper.addParameter(new javax.xml.namespace.QName("", "featureTypes"), new javax.xml.namespace.QName("http:
oper.setReturnType(new javax.xml.namespace.QName("FeatureLoader", "FeatureLoaderResult"));
oper.setReturnClass(ca.bcgsc.sockeye.service.featureloader.remote.genstubs.FeatureLoaderResult.class);
oper.setReturnQName(new javax.xml.namespace.QName("", "getFeaturesReturn"));
oper.setStyle(org.apache.axis.enum.Style.RPC);
oper.setUse(org.apache.axis.enum.Use.ENCODED);
_operations[0] = oper;
oper = new org.apache.axis.description.OperationDesc();
oper.setName("getFeatureDistributions");
oper.addParameter(new javax.xml.namespace.QName("", "conn"), new javax.xml.namespace.QName("FeatureLoader", "Connection"), ca.bcgsc.sockeye.service.featureloader.remote.genstubs.Connection.class, org.apache.axis.description.ParameterDesc.IN, false, false);
oper.addParameter(new javax.xml.namespace.QName("", "database"), new javax.xml.namespace.QName("http:
oper.addParameter(new javax.xml.namespace.QName("", "species"), new javax.xml.namespace.QName("http:
oper.addParameter(new javax.xml.namespace.QName("", "chromosome"), new javax.xml.namespace.QName("http:
oper.addParameter(new javax.xml.namespace.QName("", "query_start"), new javax.xml.namespace.QName("http:
oper.addParameter(new javax.xml.namespace.QName("", "query_end"), new javax.xml.namespace.QName("http:
oper.addParameter(new javax.xml.namespace.QName("", "featureTypes"), new javax.xml.namespace.QName("http:
oper.addParameter(new javax.xml.namespace.QName("", "binSize"), new javax.xml.namespace.QName("http:
oper.setReturnType(new javax.xml.namespace.QName("FeatureLoader", "FeatureDistributionLoaderResult"));
oper.setReturnClass(ca.bcgsc.sockeye.service.featureloader.remote.genstubs.FeatureDistributionLoaderResult.class);
oper.setReturnQName(new javax.xml.namespace.QName("", "getFeatureDistributionsReturn"));
oper.setStyle(org.apache.axis.enum.Style.RPC);
oper.setUse(org.apache.axis.enum.Use.ENCODED);
_operations[1] = oper;
oper = new org.apache.axis.description.OperationDesc();
oper.setName("getGeneInfo");
oper.addParameter(new javax.xml.namespace.QName("", "conn"), new javax.xml.namespace.QName("FeatureLoader", "Connection"), ca.bcgsc.sockeye.service.featureloader.remote.genstubs.Connection.class, org.apache.axis.description.ParameterDesc.IN, false, false);
oper.addParameter(new javax.xml.namespace.QName("", "database"), new javax.xml.namespace.QName("http:
oper.addParameter(new javax.xml.namespace.QName("", "geneID"), new javax.xml.namespace.QName("http:
oper.setReturnType(new javax.xml.namespace.QName("FeatureLoader", "GeneInfo"));
oper.setReturnClass(ca.bcgsc.sockeye.service.featureloader.remote.genstubs.GeneInfo.class);
oper.setReturnQName(new javax.xml.namespace.QName("", "getGeneInfoReturn"));
oper.setStyle(org.apache.axis.enum.Style.RPC);
oper.setUse(org.apache.axis.enum.Use.ENCODED);
_operations[2] = oper;
oper = new org.apache.axis.description.OperationDesc();
oper.setName("getChromosomeInfo");
oper.addParameter(new javax.xml.namespace.QName("", "conn"), new javax.xml.namespace.QName("FeatureLoader", "Connection"), ca.bcgsc.sockeye.service.featureloader.remote.genstubs.Connection.class, org.apache.axis.description.ParameterDesc.IN, false, false);
oper.addParameter(new javax.xml.namespace.QName("", "database"), new javax.xml.namespace.QName("http:
oper.setReturnType(new javax.xml.namespace.QName("http:
oper.setReturnClass(java.util.HashMap.class);
oper.setReturnQName(new javax.xml.namespace.QName("", "getChromosomeInfoReturn"));
oper.setStyle(org.apache.axis.enum.Style.RPC);
oper.setUse(org.apache.axis.enum.Use.ENCODED);
_operations[3] = oper;
oper = new org.apache.axis.description.OperationDesc();
oper.setName("getDatabaseList");
oper.addParameter(new javax.xml.namespace.QName("", "connection"), new javax.xml.namespace.QName("FeatureLoader", "Connection"), ca.bcgsc.sockeye.service.featureloader.remote.genstubs.Connection.class, org.apache.axis.description.ParameterDesc.IN, false, false);
oper.addParameter(new javax.xml.namespace.QName("", "dbType"), new javax.xml.namespace.QName("http:
oper.setReturnType(new javax.xml.namespace.QName("http:
oper.setReturnClass(java.lang.Object[].class);
oper.setReturnQName(new javax.xml.namespace.QName("", "getDatabaseListReturn"));
oper.setStyle(org.apache.axis.enum.Style.RPC);
oper.setUse(org.apache.axis.enum.Use.ENCODED);
_operations[4] = oper;
oper = new org.apache.axis.description.OperationDesc();
oper.setName("getRelatedFeatureIDs");
oper.addParameter(new javax.xml.namespace.QName("", "conn"), new javax.xml.namespace.QName("FeatureLoader", "Connection"), ca.bcgsc.sockeye.service.featureloader.remote.genstubs.Connection.class, org.apache.axis.description.ParameterDesc.IN, false, false);
oper.addParameter(new javax.xml.namespace.QName("", "database"), new javax.xml.namespace.QName("http:
oper.addParameter(new javax.xml.namespace.QName("", "species"), new javax.xml.namespace.QName("http:
oper.addParameter(new javax.xml.namespace.QName("", "relationshipHierarchy"), new javax.xml.namespace.QName("http:
oper.addParameter(new javax.xml.namespace.QName("", "featureID"), new javax.xml.namespace.QName("http:
oper.setReturnType(new javax.xml.namespace.QName("http:
oper.setReturnClass(java.util.HashMap.class);
oper.setReturnQName(new javax.xml.namespace.QName("", "getRelatedFeatureIDsReturn"));
oper.setStyle(org.apache.axis.enum.Style.RPC);
oper.setUse(org.apache.axis.enum.Use.ENCODED);
_operations[5] = oper;
}
public FeatureLoaderSoapBindingStub() throws org.apache.axis.AxisFault {
this(null);
}
public FeatureLoaderSoapBindingStub(java.net.URL endpointURL, javax.xml.rpc.Service service) throws org.apache.axis.AxisFault {
this(service);
super.cachedEndpoint = endpointURL;
}
public FeatureLoaderSoapBindingStub(javax.xml.rpc.Service service) throws org.apache.axis.AxisFault {
if (service == null) {
super.service = new org.apache.axis.client.Service();
} else {
super.service = service;
}
java.lang.Class cls;
javax.xml.namespace.QName qName;
java.lang.Class beansf = org.apache.axis.encoding.ser.BeanSerializerFactory.class;
java.lang.Class beandf = org.apache.axis.encoding.ser.BeanDeserializerFactory.class;
java.lang.Class enumsf = org.apache.axis.encoding.ser.EnumSerializerFactory.class;
java.lang.Class enumdf = org.apache.axis.encoding.ser.EnumDeserializerFactory.class;
java.lang.Class arraysf = org.apache.axis.encoding.ser.ArraySerializerFactory.class;
java.lang.Class arraydf = org.apache.axis.encoding.ser.ArrayDeserializerFactory.class;
java.lang.Class simplesf = org.apache.axis.encoding.ser.SimpleSerializerFactory.class;
java.lang.Class simpledf = org.apache.axis.encoding.ser.SimpleDeserializerFactory.class;
qName = new javax.xml.namespace.QName("FeatureLoader", "FeatureDistributionLoaderResult");
cachedSerQNames.add(qName);
cls = ca.bcgsc.sockeye.service.featureloader.remote.genstubs.FeatureDistributionLoaderResult.class;
cachedSerClasses.add(cls);
cachedSerFactories.add(beansf);
cachedDeserFactories.add(beandf);
qName = new javax.xml.namespace.QName("FeatureLoader", "FeatureLoaderResult");
cachedSerQNames.add(qName);
cls = ca.bcgsc.sockeye.service.featureloader.remote.genstubs.FeatureLoaderResult.class;
cachedSerClasses.add(cls);
cachedSerFactories.add(beansf);
cachedDeserFactories.add(beandf);
qName = new javax.xml.namespace.QName("FeatureLoader", "Connection");
cachedSerQNames.add(qName);
cls = ca.bcgsc.sockeye.service.featureloader.remote.genstubs.Connection.class;
cachedSerClasses.add(cls);
cachedSerFactories.add(beansf);
cachedDeserFactories.add(beandf);
qName = new javax.xml.namespace.QName("FeatureLoader", "GeneInfo");
cachedSerQNames.add(qName);
cls = ca.bcgsc.sockeye.service.featureloader.remote.genstubs.GeneInfo.class;
cachedSerClasses.add(cls);
cachedSerFactories.add(beansf);
cachedDeserFactories.add(beandf);
qName = new javax.xml.namespace.QName("FeatureLoader", "SerializableSimpleGFFRecord");
cachedSerQNames.add(qName);
cls = SerializableSimpleGFFRecord.class;
cachedSerClasses.add(cls);
cachedSerFactories.add(beansf);
cachedDeserFactories.add(beandf);
}
private org.apache.axis.client.Call createCall() throws java.rmi.RemoteException {
try {
org.apache.axis.client.Call _call =
(org.apache.axis.client.Call) super.service.createCall();
if (super.maintainSessionSet) {
_call.setMaintainSession(super.maintainSession);
}
if (super.cachedUsername != null) {
_call.setUsername(super.cachedUsername);
}
if (super.cachedPassword != null) {
_call.setPassword(super.cachedPassword);
}
if (super.cachedEndpoint != null) {
_call.setTargetEndpointAddress(super.cachedEndpoint);
}
if (super.cachedTimeout != null) {
_call.setTimeout(super.cachedTimeout);
}
if (super.cachedPortName != null) {
_call.setPortName(super.cachedPortName);
}
java.util.Enumeration keys = super.cachedProperties.keys();
while (keys.hasMoreElements()) {
java.lang.String key = (java.lang.String) keys.nextElement();
_call.setProperty(key, super.cachedProperties.get(key));
}
synchronized (this) {
if (firstCall()) {
_call.setSOAPVersion(org.apache.axis.soap.SOAPConstants.SOAP11_CONSTANTS);
_call.setEncodingStyle(org.apache.axis.Constants.URI_SOAP11_ENC);
for (int i = 0; i < cachedSerFactories.size(); ++i) {
java.lang.Class cls = (java.lang.Class) cachedSerClasses.get(i);
javax.xml.namespace.QName qName =
(javax.xml.namespace.QName) cachedSerQNames.get(i);
java.lang.Class sf = (java.lang.Class)
cachedSerFactories.get(i);
java.lang.Class df = (java.lang.Class)
cachedDeserFactories.get(i);
_call.registerTypeMapping(cls, qName, sf, df, false);
}
}
}
return _call;
}
catch (java.lang.Throwable t) {
throw new org.apache.axis.AxisFault("Failure trying to get the Call object", t);
}
}
public ca.bcgsc.sockeye.service.featureloader.remote.genstubs.FeatureLoaderResult getFeatures(ca.bcgsc.sockeye.service.featureloader.remote.genstubs.Connection conn, java.lang.String database, java.lang.String species, java.lang.String chromosome, int query_start, int query_end, java.lang.Object[] featureTypes) throws java.rmi.RemoteException {
if (super.cachedEndpoint == null) {
throw new org.apache.axis.NoEndPointException();
}
org.apache.axis.client.Call _call = createCall();
_call.setOperation(_operations[0]);
_call.setUseSOAPAction(true);
_call.setSOAPActionURI("");
_call.setSOAPVersion(org.apache.axis.soap.SOAPConstants.SOAP11_CONSTANTS);
_call.setOperationName(new javax.xml.namespace.QName("http:
setRequestHeaders(_call);
setAttachments(_call);
java.lang.Object _resp = _call.invoke(new java.lang.Object[] {conn, database, species, chromosome, new java.lang.Integer(query_start), new java.lang.Integer(query_end), featureTypes});
if (_resp instanceof java.rmi.RemoteException) {
throw (java.rmi.RemoteException)_resp;
}
else {
extractAttachments(_call);
try {
return (ca.bcgsc.sockeye.service.featureloader.remote.genstubs.FeatureLoaderResult) _resp;
} catch (java.lang.Exception _exception) {
return (ca.bcgsc.sockeye.service.featureloader.remote.genstubs.FeatureLoaderResult) org.apache.axis.utils.JavaUtils.convert(_resp, ca.bcgsc.sockeye.service.featureloader.remote.genstubs.FeatureLoaderResult.class);
}
}
}
public ca.bcgsc.sockeye.service.featureloader.remote.genstubs.FeatureDistributionLoaderResult getFeatureDistributions(ca.bcgsc.sockeye.service.featureloader.remote.genstubs.Connection conn, java.lang.String database, java.lang.String species, java.lang.String chromosome, int query_start, int query_end, java.lang.Object[] featureTypes, int binSize) throws java.rmi.RemoteException {
if (super.cachedEndpoint == null) {
throw new org.apache.axis.NoEndPointException();
}
org.apache.axis.client.Call _call = createCall();
_call.setOperation(_operations[1]);
_call.setUseSOAPAction(true);
_call.setSOAPActionURI("");
_call.setSOAPVersion(org.apache.axis.soap.SOAPConstants.SOAP11_CONSTANTS);
_call.setOperationName(new javax.xml.namespace.QName("http:
setRequestHeaders(_call);
setAttachments(_call);
java.lang.Object _resp = _call.invoke(new java.lang.Object[] {conn, database, species, chromosome, new java.lang.Integer(query_start), new java.lang.Integer(query_end), featureTypes, new java.lang.Integer(binSize)});
if (_resp instanceof java.rmi.RemoteException) {
throw (java.rmi.RemoteException)_resp;
}
else {
extractAttachments(_call);
try {
return (ca.bcgsc.sockeye.service.featureloader.remote.genstubs.FeatureDistributionLoaderResult) _resp;
} catch (java.lang.Exception _exception) {
return (ca.bcgsc.sockeye.service.featureloader.remote.genstubs.FeatureDistributionLoaderResult) org.apache.axis.utils.JavaUtils.convert(_resp, ca.bcgsc.sockeye.service.featureloader.remote.genstubs.FeatureDistributionLoaderResult.class);
}
}
}
public ca.bcgsc.sockeye.service.featureloader.remote.genstubs.GeneInfo getGeneInfo(ca.bcgsc.sockeye.service.featureloader.remote.genstubs.Connection conn, java.lang.String database, java.lang.String geneID) throws java.rmi.RemoteException {
if (super.cachedEndpoint == null) {
throw new org.apache.axis.NoEndPointException();
}
org.apache.axis.client.Call _call = createCall();
_call.setOperation(_operations[2]);
_call.setUseSOAPAction(true);
_call.setSOAPActionURI("");
_call.setSOAPVersion(org.apache.axis.soap.SOAPConstants.SOAP11_CONSTANTS);
_call.setOperationName(new javax.xml.namespace.QName("http:
setRequestHeaders(_call);
setAttachments(_call);
java.lang.Object _resp = _call.invoke(new java.lang.Object[] {conn, database, geneID});
if (_resp instanceof java.rmi.RemoteException) {
throw (java.rmi.RemoteException)_resp;
}
else {
extractAttachments(_call);
try {
return (ca.bcgsc.sockeye.service.featureloader.remote.genstubs.GeneInfo) _resp;
} catch (java.lang.Exception _exception) {
return (ca.bcgsc.sockeye.service.featureloader.remote.genstubs.GeneInfo) org.apache.axis.utils.JavaUtils.convert(_resp, ca.bcgsc.sockeye.service.featureloader.remote.genstubs.GeneInfo.class);
}
}
}
public java.util.HashMap getChromosomeInfo(ca.bcgsc.sockeye.service.featureloader.remote.genstubs.Connection conn, java.lang.String database) throws java.rmi.RemoteException {
if (super.cachedEndpoint == null) {
throw new org.apache.axis.NoEndPointException();
}
org.apache.axis.client.Call _call = createCall();
_call.setOperation(_operations[3]);
_call.setUseSOAPAction(true);
_call.setSOAPActionURI("");
_call.setSOAPVersion(org.apache.axis.soap.SOAPConstants.SOAP11_CONSTANTS);
_call.setOperationName(new javax.xml.namespace.QName("http:
setRequestHeaders(_call);
setAttachments(_call);
java.lang.Object _resp = _call.invoke(new java.lang.Object[] {conn, database});
if (_resp instanceof java.rmi.RemoteException) {
throw (java.rmi.RemoteException)_resp;
}
else {
extractAttachments(_call);
try {
return (java.util.HashMap) _resp;
} catch (java.lang.Exception _exception) {
return (java.util.HashMap) org.apache.axis.utils.JavaUtils.convert(_resp, java.util.HashMap.class);
}
}
}
public java.lang.Object[] getDatabaseList(ca.bcgsc.sockeye.service.featureloader.remote.genstubs.Connection connection, java.lang.String dbType) throws java.rmi.RemoteException {
if (super.cachedEndpoint == null) {
throw new org.apache.axis.NoEndPointException();
}
org.apache.axis.client.Call _call = createCall();
_call.setOperation(_operations[4]);
_call.setUseSOAPAction(true);
_call.setSOAPActionURI("");
_call.setSOAPVersion(org.apache.axis.soap.SOAPConstants.SOAP11_CONSTANTS);
_call.setOperationName(new javax.xml.namespace.QName("http:
setRequestHeaders(_call);
setAttachments(_call);
java.lang.Object _resp = _call.invoke(new java.lang.Object[] {connection, dbType});
if (_resp instanceof java.rmi.RemoteException) {
throw (java.rmi.RemoteException)_resp;
}
else {
extractAttachments(_call);
try {
return (java.lang.Object[]) _resp;
} catch (java.lang.Exception _exception) {
return (java.lang.Object[]) org.apache.axis.utils.JavaUtils.convert(_resp, java.lang.Object[].class);
}
}
}
public java.util.HashMap getRelatedFeatureIDs(ca.bcgsc.sockeye.service.featureloader.remote.genstubs.Connection conn, java.lang.String database, java.lang.String species, java.util.HashMap relationshipHierarchy, java.lang.String featureID) throws java.rmi.RemoteException {
if (super.cachedEndpoint == null) {
throw new org.apache.axis.NoEndPointException();
}
org.apache.axis.client.Call _call = createCall();
_call.setOperation(_operations[5]);
_call.setUseSOAPAction(true);
_call.setSOAPActionURI("");
_call.setSOAPVersion(org.apache.axis.soap.SOAPConstants.SOAP11_CONSTANTS);
_call.setOperationName(new javax.xml.namespace.QName("http:
setRequestHeaders(_call);
setAttachments(_call);
java.lang.Object _resp = _call.invoke(new java.lang.Object[] {conn, database, species, relationshipHierarchy, featureID});
if (_resp instanceof java.rmi.RemoteException) {
throw (java.rmi.RemoteException)_resp;
}
else {
extractAttachments(_call);
try {
return (java.util.HashMap) _resp;
} catch (java.lang.Exception _exception) {
return (java.util.HashMap) org.apache.axis.utils.JavaUtils.convert(_resp, java.util.HashMap.class);
}
}
}
}
package ca.bcgsc.sockeye.service.featureloader.remote.genstubs;
public class GeneInfo implements java.io.Serializable {
private java.lang.String chromosome;
private java.lang.String description;
private int end;
private int start;
private int strand;
public GeneInfo() {
}
public java.lang.String getChromosome() {
return chromosome;
}
public void setChromosome(java.lang.String chromosome) {
this.chromosome = chromosome;
}
public java.lang.String getDescription() {
return description;
}
public void setDescription(java.lang.String description) {
this.description = description;
}
public int getEnd() {
return end;
}
public void setEnd(int end) {
this.end = end;
}
public int getStart() {
return start;
}
public void setStart(int start) {
this.start = start;
}
public int getStrand() {
return strand;
}
public void setStrand(int strand) {
this.strand = strand;
}
private java.lang.Object __equalsCalc = null;
public synchronized boolean equals(java.lang.Object obj) {
if (!(obj instanceof GeneInfo)) return false;
GeneInfo other = (GeneInfo) obj;
if (obj == null) return false;
if (this == obj) return true;
if (__equalsCalc != null) {
return (__equalsCalc == obj);
}
__equalsCalc = obj;
boolean _equals;
_equals = true &&
((this.chromosome==null && other.getChromosome()==null) ||
(this.chromosome!=null &&
this.chromosome.equals(other.getChromosome()))) &&
((this.description==null && other.getDescription()==null) ||
(this.description!=null &&
this.description.equals(other.getDescription()))) &&
this.end == other.getEnd() &&
this.start == other.getStart() &&
this.strand == other.getStrand();
__equalsCalc = null;
return _equals;
}
private boolean __hashCodeCalc = false;
public synchronized int hashCode() {
if (__hashCodeCalc) {
return 0;
}
__hashCodeCalc = true;
int _hashCode = 1;
if (getChromosome() != null) {
_hashCode += getChromosome().hashCode();
}
if (getDescription() != null) {
_hashCode += getDescription().hashCode();
}
_hashCode += getEnd();
_hashCode += getStart();
_hashCode += getStrand();
__hashCodeCalc = false;
return _hashCode;
}
private static org.apache.axis.description.TypeDesc typeDesc =
new org.apache.axis.description.TypeDesc(GeneInfo.class);
static {
typeDesc.setXmlType(new javax.xml.namespace.QName("FeatureLoader", "GeneInfo"));
org.apache.axis.description.ElementDesc elemField = new org.apache.axis.description.ElementDesc();
elemField.setFieldName("chromosome");
elemField.setXmlName(new javax.xml.namespace.QName("", "chromosome"));
elemField.setXmlType(new javax.xml.namespace.QName("http:
typeDesc.addFieldDesc(elemField);
elemField = new org.apache.axis.description.ElementDesc();
elemField.setFieldName("description");
elemField.setXmlName(new javax.xml.namespace.QName("", "description"));
elemField.setXmlType(new javax.xml.namespace.QName("http:
typeDesc.addFieldDesc(elemField);
elemField = new org.apache.axis.description.ElementDesc();
elemField.setFieldName("end");
elemField.setXmlName(new javax.xml.namespace.QName("", "end"));
elemField.setXmlType(new javax.xml.namespace.QName("http:
typeDesc.addFieldDesc(elemField);
elemField = new org.apache.axis.description.ElementDesc();
elemField.setFieldName("start");
elemField.setXmlName(new javax.xml.namespace.QName("", "start"));
elemField.setXmlType(new javax.xml.namespace.QName("http:
typeDesc.addFieldDesc(elemField);
elemField = new org.apache.axis.description.ElementDesc();
elemField.setFieldName("strand");
elemField.setXmlName(new javax.xml.namespace.QName("", "strand"));
elemField.setXmlType(new javax.xml.namespace.QName("http:
typeDesc.addFieldDesc(elemField);
}
public static org.apache.axis.description.TypeDesc getTypeDesc() {
return typeDesc;
}
public static org.apache.axis.encoding.Serializer getSerializer(
java.lang.String mechType,
java.lang.Class _javaType,
javax.xml.namespace.QName _xmlType) {
return
new org.apache.axis.encoding.ser.BeanSerializer(
_javaType, _xmlType, typeDesc);
}
public static org.apache.axis.encoding.Deserializer getDeserializer(
java.lang.String mechType,
java.lang.Class _javaType,
javax.xml.namespace.QName _xmlType) {
return
new org.apache.axis.encoding.ser.BeanDeserializer(
_javaType, _xmlType, typeDesc);
}
}
package ca.bcgsc.sockeye.service.featureloader.remote.log;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.Date;
import org.apache.axis.AxisFault;
import org.apache.axis.Constants;
import org.apache.axis.Handler;
import org.apache.axis.MessageContext;
import org.apache.axis.handlers.BasicHandler;
public class WebServiceLogHandler extends BasicHandler {
static {
try {
Class.forName("com.mysql.jdbc.Driver");
} catch (ClassNotFoundException e) {
e.printStackTrace();
}
}
public void invoke(MessageContext msgContext) throws AxisFault {
try {
Handler serviceHandler = msgContext.getService();
String remoteIP = msgContext.getStrProp(Constants.MC_REMOTE_ADDR);
String operation = msgContext.getOperation().getName();
DatabaseLogger logger = new DatabaseLogger(operation, remoteIP);
logger.start();
} catch (Exception e) {
AxisFault.makeFault(e);
}
}
class DatabaseLogger extends Thread {
String ip;
String operation;
public DatabaseLogger(String op, String ip) {
this.operation = op;
this.ip = ip;
}
public void run() {
Connection conn = null;
PreparedStatement ps = null;
try {
conn = getConnection();
String SQL_INSERT_ENTRY = "INSERT INTO sockeye_usage "
+ "(ip_address, time, operation) " + "VALUES(?, ?, ?)";
ps = conn.prepareStatement(SQL_INSERT_ENTRY);
ps.setString(1, ip);
ps.setTimestamp(2, new Timestamp(new Date().getTime()));
ps.setString(3, operation);
ps.execute();
} catch (SQLException e) {
e.printStackTrace();
} finally {
disconnect(conn, ps);
}
}
private Connection getConnection() throws SQLException {
Connection conn = DriverManager.getConnection(
"jdbc:mysql:
return conn;
}
private void disconnect(Connection conn, PreparedStatement ps) {
if (ps != null) {
try {
ps.close();
} catch (SQLException e) {
}
}
if (conn != null) {
try {
conn.close();
} catch (SQLException e) {
}
}
}
}
}
package ca.bcgsc.sockeye.service.homolog.common;
import java.util.Map;
public interface HomologService {
String HOMOLOG = "HOMOLOGUE_GENE:";
public Map getHomologueGeneId(String source, String geneId);
}package ca.bcgsc.sockeye.service.homolog.common;
public class HomologServiceException extends Exception {
public HomologServiceException(String message) {
super(message);
}
}
package ca.bcgsc.sockeye.service.homolog.common;
import ca.bcgsc.sockeye.service.homolog.remote.HomologServiceRemote;
public class HomologServiceFactory {
public static String HOMOLOG_SERVICE = "Homology";
public static HomologServiceFactory instance = new HomologServiceFactory();
public static HomologServiceFactory getInstance() {
return instance;
}
public HomologService getService(String serviceType, String remotehost) {
if ("remote".equals(serviceType)) {
return new HomologServiceRemote(remotehost);
} else {
return HomologServiceLocal.getInstance();
}
}
}package ca.bcgsc.sockeye.service.homolog.common;
import homologeneload.HomologSource;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
public class HomologServiceLocal implements HomologService {
public static HomologServiceLocal getInstance() {
return new HomologServiceLocal();
}
public Map getHomologueGeneId(String source, String geneId) {
System.out.println("Get Homolog for Gene id " + geneId);
Map homologueList = new HashMap();
HomologSource hs = new HomologSource(source.replaceAll("_", " "));
Map sm = hs.getOrthologsByGene(geneId, false);
if (sm == null)
return null;
for (Iterator itr = sm.keySet().iterator(); itr.hasNext();) {
String species = (String) itr.next();
List geneIds = (List) sm.get(species);
String newKey = HOMOLOG + species.replaceAll(" ", "_");
homologueList.put(newKey, geneIds);
}
return homologueList;
}
}package ca.bcgsc.sockeye.service.homolog.remote;
import java.rmi.RemoteException;
import java.util.Map;
import javax.xml.rpc.ServiceException;
import ca.bcgsc.sockeye.service.coexpression.common.CoexpressionServiceException;
import ca.bcgsc.sockeye.service.homolog.common.HomologService;
import ca.bcgsc.sockeye.service.homolog.remote.genstubs.HomologServiceLocalServiceLocator;
import ca.bcgsc.sockeye.service.homolog.remote.genstubs.HomologySoapBindingStub;
import ca.bcgsc.sockeye.util.Log;
public class HomologServiceRemote implements HomologService {
private String remoteConnectionStr = null;
public HomologServiceRemote(String remoteConnectionStr) {
this.remoteConnectionStr = remoteConnectionStr;
}
public Map getHomologueGeneId(String source, String geneId) {
HomologServiceLocalServiceLocator loc = new HomologServiceLocalServiceLocator(
remoteConnectionStr);
Map map = null;
try {
HomologySoapBindingStub stub = (HomologySoapBindingStub) loc
.getHomology();
map = stub.getHomologueGeneId(source, geneId);
} catch (ServiceException e) {
e.printStackTrace();
Log.printStackTrace(e);
} catch (RemoteException re) {
Log.printStackTrace(re);
re.printStackTrace();
}
return map;
}
}/**
package ca.bcgsc.sockeye.service.homolog.remote.genstubs;
public interface HomologServiceLocal extends java.rmi.Remote {
public java.util.HashMap getHomologueGeneId(java.lang.String source,
java.lang.String geneId) throws java.rmi.RemoteException;
}
package ca.bcgsc.sockeye.service.homolog.remote.genstubs;
public interface HomologServiceLocalService extends javax.xml.rpc.Service {
public java.lang.String getHomologyAddress();
public ca.bcgsc.sockeye.service.homolog.remote.genstubs.HomologServiceLocal getHomology() throws javax.xml.rpc.ServiceException;
public ca.bcgsc.sockeye.service.homolog.remote.genstubs.HomologServiceLocal getHomology(java.net.URL portAddress) throws javax.xml.rpc.ServiceException;
}
package ca.bcgsc.sockeye.service.homolog.remote.genstubs;
public class HomologServiceLocalServiceLocator extends
org.apache.axis.client.Service
implements
ca.bcgsc.sockeye.service.homolog.remote.genstubs.HomologServiceLocalService {
private java.lang.String Homology_address = "http:
public HomologServiceLocalServiceLocator(java.lang.String server) {
Homology_address = "http:
}
public java.lang.String getHomologyAddress() {
return Homology_address;
}
private java.lang.String HomologyWSDDServiceName = "Homology";
public java.lang.String getHomologyWSDDServiceName() {
return HomologyWSDDServiceName;
}
public void setHomologyWSDDServiceName(java.lang.String name) {
HomologyWSDDServiceName = name;
}
public ca.bcgsc.sockeye.service.homolog.remote.genstubs.HomologServiceLocal getHomology()
throws javax.xml.rpc.ServiceException {
java.net.URL endpoint;
try {
endpoint = new java.net.URL(Homology_address);
} catch (java.net.MalformedURLException e) {
throw new javax.xml.rpc.ServiceException(e);
}
return getHomology(endpoint);
}
public ca.bcgsc.sockeye.service.homolog.remote.genstubs.HomologServiceLocal getHomology(
java.net.URL portAddress) throws javax.xml.rpc.ServiceException {
try {
ca.bcgsc.sockeye.service.homolog.remote.genstubs.HomologySoapBindingStub _stub = new ca.bcgsc.sockeye.service.homolog.remote.genstubs.HomologySoapBindingStub(
portAddress, this);
_stub.setPortName(getHomologyWSDDServiceName());
return _stub;
} catch (org.apache.axis.AxisFault e) {
return null;
}
}
public java.rmi.Remote getPort(Class serviceEndpointInterface)
throws javax.xml.rpc.ServiceException {
try {
if (ca.bcgsc.sockeye.service.homolog.remote.genstubs.HomologServiceLocal.class
.isAssignableFrom(serviceEndpointInterface)) {
ca.bcgsc.sockeye.service.homolog.remote.genstubs.HomologySoapBindingStub _stub = new ca.bcgsc.sockeye.service.homolog.remote.genstubs.HomologySoapBindingStub(
new java.net.URL(Homology_address), this);
_stub.setPortName(getHomologyWSDDServiceName());
return _stub;
}
} catch (java.lang.Throwable t) {
throw new javax.xml.rpc.ServiceException(t);
}
throw new javax.xml.rpc.ServiceException(
"There is no stub implementation for the interface: "
+ (serviceEndpointInterface == null ? "null"
: serviceEndpointInterface.getName()));
}
public java.rmi.Remote getPort(javax.xml.namespace.QName portName,
Class serviceEndpointInterface)
throws javax.xml.rpc.ServiceException {
if (portName == null) {
return getPort(serviceEndpointInterface);
}
String inputPortName = portName.getLocalPart();
if ("Homology".equals(inputPortName)) {
return getHomology();
} else {
java.rmi.Remote _stub = getPort(serviceEndpointInterface);
((org.apache.axis.client.Stub) _stub).setPortName(portName);
return _stub;
}
}
public javax.xml.namespace.QName getServiceName() {
return new javax.xml.namespace.QName(
"http:
"HomologServiceLocalService");
}
private java.util.HashSet ports = null;
public java.util.Iterator getPorts() {
if (ports == null) {
ports = new java.util.HashSet();
ports.add(new javax.xml.namespace.QName("Homology"));
}
return ports.iterator();
}
}/**
package ca.bcgsc.sockeye.service.homolog.remote.genstubs;
public class HomologySoapBindingStub extends org.apache.axis.client.Stub implements ca.bcgsc.sockeye.service.homolog.remote.genstubs.HomologServiceLocal {
private java.util.Vector cachedSerClasses = new java.util.Vector();
private java.util.Vector cachedSerQNames = new java.util.Vector();
private java.util.Vector cachedSerFactories = new java.util.Vector();
private java.util.Vector cachedDeserFactories = new java.util.Vector();
static org.apache.axis.description.OperationDesc [] _operations;
static {
_operations = new org.apache.axis.description.OperationDesc[2];
org.apache.axis.description.OperationDesc oper;
oper = new org.apache.axis.description.OperationDesc();
oper.setName("getInstance");
oper.setReturnType(new javax.xml.namespace.QName("http:
oper.setReturnClass(ca.bcgsc.sockeye.service.homolog.remote.genstubs.HomologServiceLocal.class);
oper.setReturnQName(new javax.xml.namespace.QName("", "getInstanceReturn"));
oper.setStyle(org.apache.axis.enum.Style.RPC);
oper.setUse(org.apache.axis.enum.Use.ENCODED);
_operations[0] = oper;
oper = new org.apache.axis.description.OperationDesc();
oper.setName("getHomologueGeneId");
oper.addParameter(new javax.xml.namespace.QName("", "source"), new javax.xml.namespace.QName("http:
oper.addParameter(new javax.xml.namespace.QName("", "geneId"), new javax.xml.namespace.QName("http:
oper.setReturnType(new javax.xml.namespace.QName("http:
oper.setReturnClass(java.util.HashMap.class);
oper.setReturnQName(new javax.xml.namespace.QName("", "getHomologueGeneIdReturn"));
oper.setStyle(org.apache.axis.enum.Style.RPC);
oper.setUse(org.apache.axis.enum.Use.ENCODED);
_operations[1] = oper;
}
public HomologySoapBindingStub() throws org.apache.axis.AxisFault {
this(null);
}
public HomologySoapBindingStub(java.net.URL endpointURL, javax.xml.rpc.Service service) throws org.apache.axis.AxisFault {
this(service);
super.cachedEndpoint = endpointURL;
}
public HomologySoapBindingStub(javax.xml.rpc.Service service) throws org.apache.axis.AxisFault {
if (service == null) {
super.service = new org.apache.axis.client.Service();
} else {
super.service = service;
}
java.lang.Class cls;
javax.xml.namespace.QName qName;
java.lang.Class beansf = org.apache.axis.encoding.ser.BeanSerializerFactory.class;
java.lang.Class beandf = org.apache.axis.encoding.ser.BeanDeserializerFactory.class;
java.lang.Class enumsf = org.apache.axis.encoding.ser.EnumSerializerFactory.class;
java.lang.Class enumdf = org.apache.axis.encoding.ser.EnumDeserializerFactory.class;
java.lang.Class arraysf = org.apache.axis.encoding.ser.ArraySerializerFactory.class;
java.lang.Class arraydf = org.apache.axis.encoding.ser.ArrayDeserializerFactory.class;
java.lang.Class simplesf = org.apache.axis.encoding.ser.SimpleSerializerFactory.class;
java.lang.Class simpledf = org.apache.axis.encoding.ser.SimpleDeserializerFactory.class;
qName = new javax.xml.namespace.QName("http:
cachedSerQNames.add(qName);
cls = ca.bcgsc.sockeye.service.homolog.remote.genstubs.HomologServiceLocal.class;
cachedSerClasses.add(cls);
cachedSerFactories.add(beansf);
cachedDeserFactories.add(beandf);
}
private org.apache.axis.client.Call createCall() throws java.rmi.RemoteException {
try {
org.apache.axis.client.Call _call =
(org.apache.axis.client.Call) super.service.createCall();
if (super.maintainSessionSet) {
_call.setMaintainSession(super.maintainSession);
}
if (super.cachedUsername != null) {
_call.setUsername(super.cachedUsername);
}
if (super.cachedPassword != null) {
_call.setPassword(super.cachedPassword);
}
if (super.cachedEndpoint != null) {
_call.setTargetEndpointAddress(super.cachedEndpoint);
}
if (super.cachedTimeout != null) {
_call.setTimeout(super.cachedTimeout);
}
if (super.cachedPortName != null) {
_call.setPortName(super.cachedPortName);
}
java.util.Enumeration keys = super.cachedProperties.keys();
while (keys.hasMoreElements()) {
java.lang.String key = (java.lang.String) keys.nextElement();
_call.setProperty(key, super.cachedProperties.get(key));
}
synchronized (this) {
if (firstCall()) {
_call.setSOAPVersion(org.apache.axis.soap.SOAPConstants.SOAP11_CONSTANTS);
_call.setEncodingStyle(org.apache.axis.Constants.URI_SOAP11_ENC);
for (int i = 0; i < cachedSerFactories.size(); ++i) {
java.lang.Class cls = (java.lang.Class) cachedSerClasses.get(i);
javax.xml.namespace.QName qName =
(javax.xml.namespace.QName) cachedSerQNames.get(i);
java.lang.Class sf = (java.lang.Class)
cachedSerFactories.get(i);
java.lang.Class df = (java.lang.Class)
cachedDeserFactories.get(i);
_call.registerTypeMapping(cls, qName, sf, df, false);
}
}
}
return _call;
}
catch (java.lang.Throwable t) {
throw new org.apache.axis.AxisFault("Failure trying to get the Call object", t);
}
}
public ca.bcgsc.sockeye.service.homolog.remote.genstubs.HomologServiceLocal getInstance() throws java.rmi.RemoteException {
if (super.cachedEndpoint == null) {
throw new org.apache.axis.NoEndPointException();
}
org.apache.axis.client.Call _call = createCall();
_call.setOperation(_operations[0]);
_call.setUseSOAPAction(true);
_call.setSOAPActionURI("");
_call.setSOAPVersion(org.apache.axis.soap.SOAPConstants.SOAP11_CONSTANTS);
_call.setOperationName(new javax.xml.namespace.QName("http:
setRequestHeaders(_call);
setAttachments(_call);
java.lang.Object _resp = _call.invoke(new java.lang.Object[] {});
if (_resp instanceof java.rmi.RemoteException) {
throw (java.rmi.RemoteException)_resp;
}
else {
extractAttachments(_call);
try {
return (ca.bcgsc.sockeye.service.homolog.remote.genstubs.HomologServiceLocal) _resp;
} catch (java.lang.Exception _exception) {
return (ca.bcgsc.sockeye.service.homolog.remote.genstubs.HomologServiceLocal) org.apache.axis.utils.JavaUtils.convert(_resp, ca.bcgsc.sockeye.service.homolog.remote.genstubs.HomologServiceLocal.class);
}
}
}
public java.util.HashMap getHomologueGeneId(java.lang.String source, java.lang.String geneId) throws java.rmi.RemoteException {
if (super.cachedEndpoint == null) {
throw new org.apache.axis.NoEndPointException();
}
org.apache.axis.client.Call _call = createCall();
_call.setOperation(_operations[1]);
_call.setUseSOAPAction(true);
_call.setSOAPActionURI("");
_call.setSOAPVersion(org.apache.axis.soap.SOAPConstants.SOAP11_CONSTANTS);
_call.setOperationName(new javax.xml.namespace.QName("http:
setRequestHeaders(_call);
setAttachments(_call);
java.lang.Object _resp = _call.invoke(new java.lang.Object[] {source, geneId});
if (_resp instanceof java.rmi.RemoteException) {
throw (java.rmi.RemoteException)_resp;
}
else {
extractAttachments(_call);
try {
return (java.util.HashMap) _resp;
} catch (java.lang.Exception _exception) {
return (java.util.HashMap) org.apache.axis.utils.JavaUtils.convert(_resp, java.util.HashMap.class);
}
}
}
}
package ca.bcgsc.sockeye.service.ncc.common;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import ca.bcgsc.sockeye.config.Configuration;
import ca.bcgsc.sockeye.config.Connection;
import ca.bcgsc.sockeye.config.Service;
import ca.bcgsc.util.SequenceUtils;
public class NCCLocal implements NCCService {
private static final String[] NCC_TABLES =
{ "sixmers", "sevenmers", "eightmers", "ninemers", "tenmers" };
static {
try {
Class.forName("com.mysql.jdbc.Driver");
} catch (ClassNotFoundException e) {
e.printStackTrace();
}
}
private String username = null;
private String password = null;
private String server = null;
private int port = -1;
private Connection conn = null;
static public NCCLocal getInstance() {
return new NCCLocal();
}
public NCCLocal() {
Service service = Configuration.getService("NCC");
String dbServer = service.getConnection();
ca.bcgsc.sockeye.config.Connection[] conns = Configuration.getConnections();
int i;
boolean bMatch = false;
for (i = 0; i < conns.length; i++) {
if (dbServer.equals(conns[i].getName())) {
bMatch = true;
break;
}
}
if (bMatch == false) {
throw new RuntimeException(
"No defined db connections match the one specified: " + dbServer);
}
server = conns[i].getHost();
port = Integer.parseInt(conns[i].getPort());
username = conns[i].getUser();
password = conns[i].getPass();
}
public double[] scanNCC(
String database,
String seq,
int motif_size,
boolean ncc2)
throws NCCServiceException {
PreparedStatement stmt = null;
java.sql.Connection conn = null;
ResultSet rset = null;
String url = new String("jdbc:mysql:
try {
conn = DriverManager.getConnection(url, username, password);
String query =
"select * from " + NCC_TABLES[motif_size - 6] + " where motif= ? ";
stmt = conn.prepareStatement(query);
double[] ncc_scores = new double[seq.length() - motif_size + 1];
int i = 0;
while (i + motif_size < seq.length()) {
String motif = seq.substring(i, i + motif_size).toUpperCase();
i++;
if (!SequenceUtils.dnaMatches(motif)) {
continue;
}
stmt.setString(1, motif);
rset = stmt.executeQuery();
if( rset == null ) continue;
rset.next();
double ncc_score = 0.;
if (ncc2) {
ncc_score = Double.parseDouble(rset.getString("ncc2_score"));
} else {
ncc_score = Double.parseDouble(rset.getString("ncc_score"));
}
ncc_scores[i] = ncc_score;
}
return ncc_scores;
} catch (SQLException sqle) {
sqle.printStackTrace();
throw new NCCServiceException(sqle.getMessage());
} finally {
try {
if (rset != null)
rset.close();
} catch (SQLException e) {
System.out.println("Can't close result set: " + e.toString());
}
try {
if (stmt != null)
stmt.close();
} catch (SQLException e) {
System.out.println("Can't close statement: " + e.toString());
}
try {
if (conn != null)
conn.close();
} catch (SQLException e) {
System.out.println("Can't close connection: " + e.toString());
}
}
}
public static String[] _CPermutedMotifs(
String motif,
int non_permute_index) {
String[] permuted_motifs;
if (non_permute_index > -1) {
permuted_motifs = new String[motif.length() - 1];
} else {
permuted_motifs = new String[motif.length()];
}
int index = 0;
for (int i = 0; i < motif.length(); i++) {
if (i == non_permute_index) {
continue;
}
permuted_motifs[index++] =
motif.subSequence(0, i)
+ new String("" + _CPermute(motif.charAt(i)))
+ motif.subSequence(i + 1, motif.length());
}
return permuted_motifs;
}
public static String[] _NCPermutedMotifs(
String motif,
int non_permute_index) {
String[] permuted_motifs;
if (non_permute_index > -1) {
permuted_motifs = new String[motif.length() - 1];
} else {
permuted_motifs = new String[motif.length()];
}
int index = 0;
for (int i = 0; i < motif.length(); i++) {
if (i == non_permute_index) {
continue;
}
permuted_motifs[index++] =
motif.subSequence(0, i)
+ new String("" + _NCPermute(motif.charAt(i)))
+ motif.subSequence(i + 1, motif.length());
}
return permuted_motifs;
}
private static char _CPermute(char c) {
if (c == 'A') {
return 'G';
} else if (c == 'C') {
return 'T';
} else if (c == 'G') {
return 'A';
} else if (c == 'T') {
return 'C';
} else {
return c;
}
}
private static char _NCPermute(char c) {
if (c == 'A') {
return 'C';
} else if (c == 'C') {
return 'A';
} else if (c == 'G') {
return 'T';
} else if (c == 'T') {
return 'G';
} else {
return c;
}
}
}
package ca.bcgsc.sockeye.service.ncc.common;
import java.rmi.RemoteException;
import javax.xml.rpc.ServiceException;
import ca.bcgsc.sockeye.service.ncc.remote.genstubs.NCCLocalServiceLocator;
import ca.bcgsc.sockeye.service.ncc.remote.genstubs.NCCSoapBindingStub;
import ca.bcgsc.sockeye.util.Log;
public class NCCRemote implements NCCService {
private String remoteConnectionStr = null;
public NCCRemote(String remoteConnectionStr) {
this.remoteConnectionStr = remoteConnectionStr;
}
public double[] scanNCC(String database, String seq, int motif_size, boolean ncc2) throws NCCServiceException {
NCCLocalServiceLocator loc =
new NCCLocalServiceLocator(remoteConnectionStr);
double[] da = null;
try {
NCCSoapBindingStub stub =
(NCCSoapBindingStub) loc.getNCC();
da = stub.scanNCC(database, seq, motif_size, ncc2);
} catch (ServiceException e) {
Log.printStackTrace(e);
throw new NCCServiceException(e.getMessage());
} catch (RemoteException re) {
Log.printStackTrace(re);
throw new NCCServiceException(re.getMessage());
}
return da;
}
}
package ca.bcgsc.sockeye.service.ncc.common;
public interface NCCService {
public double[] scanNCC(String database, String seq, int motif_size, boolean ncc2) throws NCCServiceException;
}
package ca.bcgsc.sockeye.service.ncc.common;
public class NCCServiceException extends Exception {
public NCCServiceException(String message) {
super(message);
}
}
package ca.bcgsc.sockeye.service.ncc.common;
public class NCCServiceFactory {
public static String NCC_SERVICE = "NCC";
static private NCCServiceFactory instance = new NCCServiceFactory();
static public NCCServiceFactory getInstance() {
return instance;
}
public NCCService getService(String serviceType, String remotehost) {
if("remote".equals(serviceType)) {
return new NCCRemote(remotehost);
} else {
return NCCLocal.getInstance();
}
}
}
package ca.bcgsc.sockeye.service.ncc.junit;
import junit.framework.TestCase;
import junit.framework.TestSuite;
import ca.bcgsc.sockeye.service.ncc.common.NCCService;
import ca.bcgsc.sockeye.service.ncc.common.NCCServiceException;
import ca.bcgsc.sockeye.service.ncc.common.NCCServiceFactory;
public class NCCUnitTest extends TestCase {
public NCCUnitTest(String name) {
super(name);
}
public static void main(String[] args) {
junit.textui.TestRunner.run(NCCUnitTest.suite());
}
protected void setUp() {
}
protected void tearDown() {
}
public static TestSuite suite() {
TestSuite testSuite = new TestSuite();
testSuite.addTest(new NCCUnitTest("testRemote"));
return testSuite;
}
public void testRemote() throws NCCServiceException {
NCCService service =
NCCServiceFactory.getInstance().getService(
"remote",
"island.bcgsc.ca:8080");
double[] da = service.scanNCC("caenorhabditis_elegans_ncc", "AAAAAAAAAAAAATTTTTTTTTT", 8, true);
assertEquals(0, da[0], 0);
}
}
package ca.bcgsc.sockeye.service.ncc.remote.genstubs;
public interface NCCLocal extends java.rmi.Remote {
public double[] scanNCC(java.lang.String database, java.lang.String seq, int motif_size, boolean ncc2) throws java.rmi.RemoteException, ca.bcgsc.sockeye.service.ncc.remote.genstubs.NCCServiceException;
}
package ca.bcgsc.sockeye.service.ncc.remote.genstubs;
public interface NCCLocalService extends javax.xml.rpc.Service {
public java.lang.String getNCCAddress();
public ca.bcgsc.sockeye.service.ncc.remote.genstubs.NCCLocal getNCC() throws javax.xml.rpc.ServiceException;
public ca.bcgsc.sockeye.service.ncc.remote.genstubs.NCCLocal getNCC(java.net.URL portAddress) throws javax.xml.rpc.ServiceException;
}
package ca.bcgsc.sockeye.service.ncc.remote.genstubs;
public class NCCLocalServiceLocator extends org.apache.axis.client.Service implements ca.bcgsc.sockeye.service.ncc.remote.genstubs.NCCLocalService {
private java.lang.String NCC_address = "http:
public NCCLocalServiceLocator(String remoteConnStr) {
NCC_address = "http:
}
public java.lang.String getNCCAddress() {
return NCC_address;
}
private java.lang.String NCCWSDDServiceName = "NCC";
public java.lang.String getNCCWSDDServiceName() {
return NCCWSDDServiceName;
}
public void setNCCWSDDServiceName(java.lang.String name) {
NCCWSDDServiceName = name;
}
public ca.bcgsc.sockeye.service.ncc.remote.genstubs.NCCLocal getNCC() throws javax.xml.rpc.ServiceException {
java.net.URL endpoint;
try {
endpoint = new java.net.URL(NCC_address);
}
catch (java.net.MalformedURLException e) {
throw new javax.xml.rpc.ServiceException(e);
}
return getNCC(endpoint);
}
public ca.bcgsc.sockeye.service.ncc.remote.genstubs.NCCLocal getNCC(java.net.URL portAddress) throws javax.xml.rpc.ServiceException {
try {
ca.bcgsc.sockeye.service.ncc.remote.genstubs.NCCSoapBindingStub _stub = new ca.bcgsc.sockeye.service.ncc.remote.genstubs.NCCSoapBindingStub(portAddress, this);
_stub.setPortName(getNCCWSDDServiceName());
return _stub;
}
catch (org.apache.axis.AxisFault e) {
return null;
}
}
public java.rmi.Remote getPort(Class serviceEndpointInterface) throws javax.xml.rpc.ServiceException {
try {
if (ca.bcgsc.sockeye.service.ncc.remote.genstubs.NCCLocal.class.isAssignableFrom(serviceEndpointInterface)) {
ca.bcgsc.sockeye.service.ncc.remote.genstubs.NCCSoapBindingStub _stub = new ca.bcgsc.sockeye.service.ncc.remote.genstubs.NCCSoapBindingStub(new java.net.URL(NCC_address), this);
_stub.setPortName(getNCCWSDDServiceName());
return _stub;
}
}
catch (java.lang.Throwable t) {
throw new javax.xml.rpc.ServiceException(t);
}
throw new javax.xml.rpc.ServiceException("There is no stub implementation for the interface: " + (serviceEndpointInterface == null ? "null" : serviceEndpointInterface.getName()));
}
public java.rmi.Remote getPort(javax.xml.namespace.QName portName, Class serviceEndpointInterface) throws javax.xml.rpc.ServiceException {
if (portName == null) {
return getPort(serviceEndpointInterface);
}
String inputPortName = portName.getLocalPart();
if ("NCC".equals(inputPortName)) {
return getNCC();
}
else {
java.rmi.Remote _stub = getPort(serviceEndpointInterface);
((org.apache.axis.client.Stub) _stub).setPortName(portName);
return _stub;
}
}
public javax.xml.namespace.QName getServiceName() {
return new javax.xml.namespace.QName("http:
}
private java.util.HashSet ports = null;
public java.util.Iterator getPorts() {
if (ports == null) {
ports = new java.util.HashSet();
ports.add(new javax.xml.namespace.QName("NCC"));
}
return ports.iterator();
}
}
package ca.bcgsc.sockeye.service.ncc.remote.genstubs;
public class NCCServiceException extends org.apache.axis.AxisFault implements java.io.Serializable {
public NCCServiceException() {
}
private java.lang.Object __equalsCalc = null;
public synchronized boolean equals(java.lang.Object obj) {
if (!(obj instanceof NCCServiceException)) return false;
NCCServiceException other = (NCCServiceException) obj;
if (obj == null) return false;
if (this == obj) return true;
if (__equalsCalc != null) {
return (__equalsCalc == obj);
}
__equalsCalc = obj;
boolean _equals;
_equals = true;
__equalsCalc = null;
return _equals;
}
private boolean __hashCodeCalc = false;
public synchronized int hashCode() {
if (__hashCodeCalc) {
return 0;
}
__hashCodeCalc = true;
int _hashCode = 1;
__hashCodeCalc = false;
return _hashCode;
}
private static org.apache.axis.description.TypeDesc typeDesc =
new org.apache.axis.description.TypeDesc(NCCServiceException.class);
static {
typeDesc.setXmlType(new javax.xml.namespace.QName("http:
}
public static org.apache.axis.description.TypeDesc getTypeDesc() {
return typeDesc;
}
public static org.apache.axis.encoding.Serializer getSerializer(
java.lang.String mechType,
java.lang.Class _javaType,
javax.xml.namespace.QName _xmlType) {
return
new org.apache.axis.encoding.ser.BeanSerializer(
_javaType, _xmlType, typeDesc);
}
public static org.apache.axis.encoding.Deserializer getDeserializer(
java.lang.String mechType,
java.lang.Class _javaType,
javax.xml.namespace.QName _xmlType) {
return
new org.apache.axis.encoding.ser.BeanDeserializer(
_javaType, _xmlType, typeDesc);
}
public void writeDetails(javax.xml.namespace.QName qname, org.apache.axis.encoding.SerializationContext context) throws java.io.IOException {
context.serialize(qname, null, this);
}
}
package ca.bcgsc.sockeye.service.ncc.remote.genstubs;
public class NCCSoapBindingStub extends org.apache.axis.client.Stub implements ca.bcgsc.sockeye.service.ncc.remote.genstubs.NCCLocal {
private java.util.Vector cachedSerClasses = new java.util.Vector();
private java.util.Vector cachedSerQNames = new java.util.Vector();
private java.util.Vector cachedSerFactories = new java.util.Vector();
private java.util.Vector cachedDeserFactories = new java.util.Vector();
static org.apache.axis.description.OperationDesc [] _operations;
static {
_operations = new org.apache.axis.description.OperationDesc[1];
org.apache.axis.description.OperationDesc oper;
oper = new org.apache.axis.description.OperationDesc();
oper.setName("scanNCC");
oper.addParameter(new javax.xml.namespace.QName("", "database"), new javax.xml.namespace.QName("http:
oper.addParameter(new javax.xml.namespace.QName("", "seq"), new javax.xml.namespace.QName("http:
oper.addParameter(new javax.xml.namespace.QName("", "motif_size"), new javax.xml.namespace.QName("http:
oper.addParameter(new javax.xml.namespace.QName("", "ncc2"), new javax.xml.namespace.QName("http:
oper.setReturnType(new javax.xml.namespace.QName("http:
oper.setReturnClass(double[].class);
oper.setReturnQName(new javax.xml.namespace.QName("", "scanNCCReturn"));
oper.setStyle(org.apache.axis.enum.Style.RPC);
oper.setUse(org.apache.axis.enum.Use.ENCODED);
oper.addFault(new org.apache.axis.description.FaultDesc(
new javax.xml.namespace.QName("http:
"ca.bcgsc.sockeye.service.ncc.remote.genstubs.NCCServiceException",
new javax.xml.namespace.QName("http:
true
));
_operations[0] = oper;
}
public NCCSoapBindingStub() throws org.apache.axis.AxisFault {
this(null);
}
public NCCSoapBindingStub(java.net.URL endpointURL, javax.xml.rpc.Service service) throws org.apache.axis.AxisFault {
this(service);
super.cachedEndpoint = endpointURL;
}
public NCCSoapBindingStub(javax.xml.rpc.Service service) throws org.apache.axis.AxisFault {
if (service == null) {
super.service = new org.apache.axis.client.Service();
} else {
super.service = service;
}
java.lang.Class cls;
javax.xml.namespace.QName qName;
java.lang.Class beansf = org.apache.axis.encoding.ser.BeanSerializerFactory.class;
java.lang.Class beandf = org.apache.axis.encoding.ser.BeanDeserializerFactory.class;
java.lang.Class enumsf = org.apache.axis.encoding.ser.EnumSerializerFactory.class;
java.lang.Class enumdf = org.apache.axis.encoding.ser.EnumDeserializerFactory.class;
java.lang.Class arraysf = org.apache.axis.encoding.ser.ArraySerializerFactory.class;
java.lang.Class arraydf = org.apache.axis.encoding.ser.ArrayDeserializerFactory.class;
java.lang.Class simplesf = org.apache.axis.encoding.ser.SimpleSerializerFactory.class;
java.lang.Class simpledf = org.apache.axis.encoding.ser.SimpleDeserializerFactory.class;
qName = new javax.xml.namespace.QName("http:
cachedSerQNames.add(qName);
cls = ca.bcgsc.sockeye.service.ncc.remote.genstubs.NCCServiceException.class;
cachedSerClasses.add(cls);
cachedSerFactories.add(beansf);
cachedDeserFactories.add(beandf);
qName = new javax.xml.namespace.QName("http:
cachedSerQNames.add(qName);
cls = double[].class;
cachedSerClasses.add(cls);
cachedSerFactories.add(arraysf);
cachedDeserFactories.add(arraydf);
}
private org.apache.axis.client.Call createCall() throws java.rmi.RemoteException {
try {
org.apache.axis.client.Call _call =
(org.apache.axis.client.Call) super.service.createCall();
if (super.maintainSessionSet) {
_call.setMaintainSession(super.maintainSession);
}
if (super.cachedUsername != null) {
_call.setUsername(super.cachedUsername);
}
if (super.cachedPassword != null) {
_call.setPassword(super.cachedPassword);
}
if (super.cachedEndpoint != null) {
_call.setTargetEndpointAddress(super.cachedEndpoint);
}
if (super.cachedTimeout != null) {
_call.setTimeout(super.cachedTimeout);
}
if (super.cachedPortName != null) {
_call.setPortName(super.cachedPortName);
}
java.util.Enumeration keys = super.cachedProperties.keys();
while (keys.hasMoreElements()) {
java.lang.String key = (java.lang.String) keys.nextElement();
_call.setProperty(key, super.cachedProperties.get(key));
}
synchronized (this) {
if (firstCall()) {
_call.setSOAPVersion(org.apache.axis.soap.SOAPConstants.SOAP11_CONSTANTS);
_call.setEncodingStyle(org.apache.axis.Constants.URI_SOAP11_ENC);
for (int i = 0; i < cachedSerFactories.size(); ++i) {
java.lang.Class cls = (java.lang.Class) cachedSerClasses.get(i);
javax.xml.namespace.QName qName =
(javax.xml.namespace.QName) cachedSerQNames.get(i);
java.lang.Class sf = (java.lang.Class)
cachedSerFactories.get(i);
java.lang.Class df = (java.lang.Class)
cachedDeserFactories.get(i);
_call.registerTypeMapping(cls, qName, sf, df, false);
}
}
}
return _call;
}
catch (java.lang.Throwable t) {
throw new org.apache.axis.AxisFault("Failure trying to get the Call object", t);
}
}
public double[] scanNCC(java.lang.String database, java.lang.String seq, int motif_size, boolean ncc2) throws java.rmi.RemoteException, ca.bcgsc.sockeye.service.ncc.remote.genstubs.NCCServiceException {
if (super.cachedEndpoint == null) {
throw new org.apache.axis.NoEndPointException();
}
org.apache.axis.client.Call _call = createCall();
_call.setOperation(_operations[0]);
_call.setUseSOAPAction(true);
_call.setSOAPActionURI("");
_call.setSOAPVersion(org.apache.axis.soap.SOAPConstants.SOAP11_CONSTANTS);
_call.setOperationName(new javax.xml.namespace.QName("http:
setRequestHeaders(_call);
setAttachments(_call);
java.lang.Object _resp = _call.invoke(new java.lang.Object[] {database, seq, new java.lang.Integer(motif_size), new java.lang.Boolean(ncc2)});
if (_resp instanceof java.rmi.RemoteException) {
throw (java.rmi.RemoteException)_resp;
}
else {
extractAttachments(_call);
try {
return (double[]) _resp;
} catch (java.lang.Exception _exception) {
return (double[]) org.apache.axis.utils.JavaUtils.convert(_resp, double[].class);
}
}
}
}
package ca.bcgsc.sockeye.trackmanager;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import org.biojava.bio.program.gff.GFFTools;
import ca.bcgsc.sockeye.analysis.Alignment;
import ca.bcgsc.sockeye.analysis.AlignmentException;
import ca.bcgsc.sockeye.dataretrieval.DataSourceManager;
import ca.bcgsc.sockeye.dataretrieval.SCProfileDataSource;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.datastorage.SockeyeTrackList;
import ca.bcgsc.sockeye.datastorage.Track;
import ca.bcgsc.sockeye.datastorage.TrackFeature;
import ca.bcgsc.sockeye.gui.alignment.MultiAlignmentDialog;
import ca.bcgsc.sockeye.gui.alignment.SCProfileDialog;
import ca.bcgsc.sockeye.gui.alignment.SingleAlignmentDialog;
import ca.bcgsc.sockeye.service.featureloader.common.DistributionContainer;
import ca.bcgsc.sockeye.util.Log;
public class AlignOperation
extends Operation {
private boolean completed = false;
private ArrayList relationships = new ArrayList();
private HashMap uptrk_dntrk = new HashMap();
private String align_app = null;
private String align_type = null;
private int ref_track = -1;
private List src_regions = null;
private List src_trks = new ArrayList();
private int alignment_3d = 0;
private List subalignments = new ArrayList();
private List anchors = new ArrayList();
private String command_line = "";
private String output_file_id = "";
private TrackRelationshipOrderInterface current_relation = null;
private static int align_counter = 1, last_used_id = -1;
private int align_index = getUniqueAlnID();
public static final String ALN_HIGHLIGHT_FEATURE = "alignment highlight";
public AlignOperation() {
}
private synchronized static int getUniqueAlnID() {
int new_id = align_counter++;
last_used_id = new_id;
return new_id;
}
public AlignOperation(List regions) {
super(false, __ALIGN_OPERATION_TYPE);
src_regions = regions;
for (Iterator itr = src_regions.iterator(); itr.hasNext(); ) {
TrackFeature region = (TrackFeature) itr.next();
src_trks.add(new Integer(region.getTrackId()));
}
TrackRelationshipOrderInterface new_rel = findUpGeneRelationship();
if (new_rel != null) {
addRelationship(new_rel);
}
src_trks = DataStoreUser.getInstance().getSockeyeTrackList().
sortTrackIDByVisualOrder(src_trks);
addRelationship(new TrackOrderRelationship(src_trks));
if (relationships.size() == 1) {
try {
addRelationship(new PhyloDistanceRelationship(src_trks));
}
catch (Exception e) {
Log.printStackTrace(e);
}
}
ref_track = ( (Integer) src_trks.get(0)).intValue();
setCurrentRelationship( (TrackRelationshipOrderInterface) relationships.get(
0));
}
public void complete() throws AlignmentException {
completed = true;
int[] downs = getDownTracks();
if (src_trks.size() != downs.length) {
throw new AlignmentException(
"Source and aligned track numbers do not match!");
}
if (ref_track != -1) {
setReferenceTrack(getAlignedTrack(ref_track));
}
ArrayList temp = relationships;
relationships = new ArrayList();
for (Iterator itr = temp.iterator(); itr.hasNext(); ) {
TrackRelationshipOrderInterface up_relation = (
TrackRelationshipOrderInterface) itr.next();
TrackRelationshipOrderInterface dn_relation = null;
try {
if (up_relation instanceof OrthologousRelationship) {
dn_relation = new OrthologousRelationship(uptrk_dntrk,
(OrthologousRelationship) up_relation);
}
else if (up_relation instanceof PhyloDistanceRelationship) {
dn_relation = new PhyloDistanceRelationship(uptrk_dntrk,
(PhyloDistanceRelationship) up_relation);
}
else if (up_relation instanceof CoexpressedRelationship) {
dn_relation = new CoexpressedRelationship(uptrk_dntrk,
(CoexpressedRelationship) up_relation);
}
else if (up_relation instanceof TrackOrderRelationship) {
dn_relation = new TrackOrderRelationship(uptrk_dntrk,
(TrackOrderRelationship) up_relation);
}
else {
Log.println("WARNING: AlignOperation dropped unknown relationship: " +
up_relation.getType());
continue;
}
} catch (TrackRelationshipException e) {
Log.printStackTrace(e);
continue;
}
if (current_relation.getType().equals(up_relation.getType())) {
current_relation = dn_relation;
}
relationships.add(dn_relation);
}
reloadDownTracks();
}
public boolean addTail(int trkID) {
boolean result = super.addTail(trkID);
for (Iterator itr = src_trks.iterator(); itr.hasNext();) {
Integer up_trk = (Integer)itr.next();
if (!uptrk_dntrk.keySet().contains(up_trk)) {
uptrk_dntrk.put(up_trk, new Integer(trkID));
break;
}
}
return result;
}
private TrackRelationshipOrderInterface findUpGeneRelationship() {
TrackRelationshipOrderInterface relation = null;
Operation lastOpParent = null, curOpParent = null;
int trk_id;
for (Iterator i = src_trks.iterator(); i.hasNext(); ) {
trk_id = ((Integer) i.next()).intValue();
curOpParent = TrackManagerImpl.getInstance().getUpOperations(trk_id);
if (lastOpParent != null && curOpParent != lastOpParent) {
if (trk_id == ((Integer) src_trks.get(1)).intValue()) {
Operation up_op = TrackManagerImpl.getInstance().getUpOperations(trk_id);
int[] up_trks = TrackManagerImpl.getInstance().getUpTracks(up_op);
if (up_trks != null) {
for (int k = 0; k < up_trks.length; k++) {
if (up_trks[k] == ((Integer) src_trks.get(0)).intValue()) {
lastOpParent = curOpParent;
break;
}
}
}
if (lastOpParent == curOpParent) continue;
}
Operation[] down_ops = TrackManagerImpl.getInstance().getDownOperations(trk_id);
int k = 0;
for ( k = 0; k < down_ops.length; k++) {
if (lastOpParent == down_ops[k]) {
k = down_ops.length + 999;
curOpParent = lastOpParent;
break;
}
}
if (k == down_ops.length + 999) continue;
curOpParent = null;
break;
}
lastOpParent = curOpParent;
}
if (curOpParent != null) {
relation = curOpParent.getTrackRelationship();
}
return relation;
}
public List getAllRelationships() {
return relationships;
}
public TrackRelationshipOrderInterface getTrackRelationship() {
return current_relation;
}
public List getSourceTracks() {
return this.src_trks;
}
public int getSourceTrack(int align_trk) {
for (Iterator itr = uptrk_dntrk.keySet().iterator(); itr.hasNext(); ) {
Integer src = (Integer)itr.next();
Integer targ = (Integer)uptrk_dntrk.get(src);
if (targ.intValue() == align_trk) return src.intValue();
}
return -1;
}
public int getAlignedTrack(int src_trk) {
return ((Integer)uptrk_dntrk.get(new Integer(src_trk))).intValue();
}
public List getSourceRegions() {
List result = new ArrayList(src_regions.size());
TrackFeature region = null;
for (Iterator itr = src_trks.iterator(); itr.hasNext();) {
int trk_id = ((Integer)itr.next()).intValue();
for (Iterator rtr = src_regions.iterator(); rtr.hasNext();) {
TrackFeature r_index = (TrackFeature)rtr.next();
if (r_index.getTrackId() == trk_id) {
region = r_index;
break;
}
}
result.add(region);
}
return result;
}
public void setCurrentRelationship(TrackRelationshipOrderInterface new_rel) {
current_relation = new_rel;
if (completed) return;
List temp = src_trks;
try {
src_trks = current_relation.getTrackOrder(ref_track);
if (src_trks == null) {
return;
}
src_trks.retainAll(temp);
}
catch (TrackRelationshipException e) {
Log.printStackTrace(e);
}
}
private void reloadDownTracks() {
SockeyeTrackList t_list = DataStoreUser.getInstance().getSockeyeTrackList();
DataSourceManager d_manager = DataStoreUser.getInstance().getDataSourceManager();
List aln_trks = null;
try {
aln_trks = current_relation.getTrackOrder(ref_track);
} catch (TrackRelationshipException e) {
Log.printStackTrace(e);
return;
}
Alignment sub_aln = (Alignment)subalignments.get(alignment_3d);
int start, end, gapped_end, strand, t_offset = 0;
for (int i = 0; i < aln_trks.size(); i++) {
int aln_trk_id = ((Integer)aln_trks.get(i)).intValue();
int src_trk_id = getSourceTrack(aln_trk_id);
start = sub_aln.getStart(aln_trk_id);
end = sub_aln.getEnd(aln_trk_id);
gapped_end = sub_aln.getGappedEnd(aln_trk_id);
strand = sub_aln.onNegativeStrand(aln_trk_id) ? -1 : 1;
t_list.copyTrack(src_trk_id, aln_trk_id, start, end);
t_list.setTrackVisibility(aln_trk_id, false);
t_list.setTrackDataWindow(aln_trk_id, start, gapped_end);
List gaps = sub_aln.getGaps(aln_trk_id);
List gap_features = new ArrayList();
String accession_id;
for (int g = 0; g < gaps.size(); g++) {
DistributionContainer gap = (DistributionContainer)gaps.get(g);
accession_id = "gap" + (g + 1);
gap_features.add(createGapFeature(aln_trk_id, start, accession_id, gap, strand));
}
if (!gap_features.isEmpty()) {
t_list.addFeatures(aln_trk_id, "gap", gap_features);
}
if (aln_trk_id != ref_track) {
t_list.setTrackOffset(aln_trk_id, t_offset);
} else {
t_offset = t_list.getTrackOffset(ref_track);
}
String prefix = "[" + sub_aln.getIdentityTag() + "] ";
String track_name =
(String) DataStoreUser
.getInstance()
.getSockeyeTrackList()
.getTrackAttribute(
aln_trk_id,
"track_name");
t_list.setTrackAttribute(
aln_trk_id,
Track.TRACK_NAME_ATTRIBUTE_KEY,
prefix + track_name);
String marker_accession = getAlignApplication() + " " + getAlignID();
t_list.removeFeature(src_trk_id, ALN_HIGHLIGHT_FEATURE, marker_accession);
TrackFeature aln_marker =
new TrackFeature(
marker_accession,
"Alignment",
ALN_HIGHLIGHT_FEATURE,
start,
end,
GFFTools.NO_SCORE,
strand,
GFFTools.NO_FRAME);
aln_marker.setAccessionID(marker_accession);
aln_marker.setTrackId(src_trk_id);
t_list.addFeature(src_trk_id, ALN_HIGHLIGHT_FEATURE, aln_marker);
t_list.setTrackReverse(aln_trk_id, strand == -1);
t_list.setTrackAttribute(aln_trk_id, "reverse_locked", "non-reversable");
}
List view_features = new ArrayList();
SCProfileDataSource d_src = null;
List dsources =
t_list.getDataSources(ref_track);
for (int i = 0; i < dsources.size(); i++) {
try {
int source_id = ((Integer)dsources.get(i)).intValue();
d_manager.removeDataSource(source_id);
t_list.removeDataSourceId(ref_track, source_id);
} catch (ClassCastException no) {
}
}
if (d_src == null) {
d_src = new SCProfileDataSource(ref_track, this);
d_manager.addDataSource(d_src);
t_list.addDataSourceId(ref_track, d_src.getId());
t_list.addStorageListener(d_src);
view_features.add("sequence conservation profile set");
}
t_list.setFeatureVisibility(view_features, true);
}
private TrackFeature createGapFeature(int trk_id, int offset, String accession_id, DistributionContainer dc, int strand) {
TrackFeature gap =
new TrackFeature(
accession_id,
"Alignment " + getAlignID(),
"gap",
dc.getStart() + offset,
dc.getEnd() + offset,
GFFTools.NO_SCORE,
strand,
GFFTools.NO_FRAME);
gap.setTrackId(trk_id);
gap.setAccessionID(accession_id);
return gap;
}
public void addRelationship(TrackRelationshipOrderInterface rel) {
relationships.add(rel);
}
public HashMap getSourceTargetMapping() {
return uptrk_dntrk;
}
public void setReferenceTrack(int ref_trk) {
ref_track = ref_trk;
if (!completed) {
if (ref_trk == -1) {
ref_track = ( (Integer) src_trks.get(0)).intValue();
}
setCurrentRelationship(current_relation);
}
}
public int getReferenceTrack() {
return ref_track;
}
public boolean isComplete() {
return completed;
}
public void setAlignApplication(String app) {
align_app = app;
}
public void setAlignType(String type) {
align_type = type;
}
public String getAlignType() {
return align_type;
}
public String getAlignApplication() {
return align_app;
}
public int getAlignID() {
return align_index;
}
public void cancel() {
SockeyeTrackList t_list = DataStoreUser.getInstance().getSockeyeTrackList();
String aln_key = this.getAlignApplication() + " " + getAlignID();
List trks = new ArrayList(uptrk_dntrk.values());
for (int i = 0; i < trks.size(); i++) {
int trk = ((Integer)trks.get(i)).intValue();
if (DataStoreUser.getInstance().getSockeyeTrackList().hasTrack(trk)){
TrackManagerImpl.getInstance().removeTrack(trk);
t_list.removeTrack(trk);
int src_trk = getSourceTrack(trk);
if (DataStoreUser.getInstance().getSockeyeTrackList().hasTrack(src_trk)){
t_list.removeFeature(src_trk, ALN_HIGHLIGHT_FEATURE, aln_key);
try {
List all_c_regions = new ArrayList(t_list.getFeatures(src_trk, "Conserved Region"));
for (int j = 0; j < all_c_regions.size(); j++) {
TrackFeature c_region = (TrackFeature)all_c_regions.get(j);
if (c_region.getAccessionID().indexOf(aln_key) > -1) {
t_list.removeFeature(src_trk, "Conserved Region", c_region.getAccessionID());
}
}
} catch (NullPointerException e) {
}
}
}
}
if (getAlignID() == last_used_id) align_counter--;
}
public Alignment getSubAlignment(int index) {
return (Alignment)subalignments.get(index);
}
public List getSubalignments() {
return subalignments;
}
public void addSubalignments(List alignments) {
subalignments.addAll(alignments);
}
public List getAnchors() {
return anchors;
}
public void addAnchors(List anchs) {
anchors.addAll(anchs);
}
public void setCommandline(String command) {
command_line = command;
}
public String getCommandline() {
return command_line;
}
public void setOutputFileID(String id) {
output_file_id = id;
}
public String getOutputFileID() {
return output_file_id;
}
public void set3DSubalignment(int index) {
alignment_3d = index;
reloadDownTracks();
}
public Alignment get3DSubalignment() {
return (Alignment)subalignments.get(alignment_3d);
}
public boolean onDownTrackRemoving(int trkId) {
MultiAlignmentDialog.close(this);
SingleAlignmentDialog.close(this);
SCProfileDialog.close(this);
return super.onDownTrackRemoving(trkId);
}
}
package ca.bcgsc.sockeye.trackmanager;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
public class CoexpressedRelationship implements TrackRelationshipOrderInterface {
HashMap genegene_value = new HashMap();
HashMap track_gene = new HashMap();
private static final String SEPARATOR = "-!-";
private class ValueMap implements Comparable {
int id;
float value;
public ValueMap(int id, float value) {
this.id = id;
this.value = value;
}
public int compareTo(Object b) {
if (b instanceof ValueMap) {
ValueMap v_b = (ValueMap)b;
if (value < v_b.value) return 1;
if (value > v_b.value) return -1;
if (id < v_b.id) return -1;
if (id > v_b.id) return 1;
}
return 0;
}
}
public CoexpressedRelationship() {
}
public CoexpressedRelationship(HashMap track_gene) throws TrackRelationshipException {
this.track_gene = track_gene;
genegene_value = new HashMap();
Service service = Configuration.getService(CoexpressionServiceFactory.
COEXPRESSION_SERVICE);
String mode = null;
String remotehost = null;
if (service != null) {
mode = service.getMode();
remotehost = service.getRemotehost();
}
else {
throw new TrackRelationshipException(
"Coexpression service not set up properly.");
}
CoexpressionService coexpressionService = fac.getService(mode, remotehost);
coexpressionService.getCoexpressionScores(geneId, database); */
}
public CoexpressedRelationship(HashMap trk_ids, CoexpressedRelationship coB)
throws TrackRelationshipException {
genegene_value = new HashMap();
for (Iterator itr = coB.genegene_value.keySet().iterator(); itr.hasNext();) {
String genegene = new String((String) itr.next());
float value =((Float) coB.genegene_value.get(genegene)).floatValue();
genegene_value.put(genegene, new Float(value));
}
track_gene = new HashMap();
for (Iterator itr = coB.track_gene.keySet().iterator(); itr.hasNext();) {
Integer old_trk = (Integer)itr.next();
Object new_trk = trk_ids.get(old_trk);
if (new_trk == null) continue;
String gene = new String((String)coB.track_gene.get(old_trk));
track_gene.put(new_trk, gene);
}
}
public List getTrackOrder(int ref_trackid) throws TrackRelationshipException {
Set track_ids = track_gene.keySet();
ArrayList ordered_values = new ArrayList();
for (Iterator itr = track_ids.iterator(); itr.hasNext();) {
Integer id = (Integer)itr.next();
if (id.intValue() == ref_trackid) continue;
Float value = new Float(getRelationshipValue(ref_trackid, id.intValue()));
ValueMap map = new ValueMap(id.intValue(), value.floatValue());
ordered_values.add(map);
}
Collections.sort(ordered_values);
ArrayList trk_list = new ArrayList();
trk_list.add(new Integer(ref_trackid));
for (Iterator itr = ordered_values.iterator(); itr.hasNext();) {
ValueMap map = (ValueMap)itr.next();
trk_list.add(new Integer(map.id));
}
return trk_list;
}
public float getRelationshipValue(int trk_1, int trk_2) throws TrackRelationshipException {
String trk1_gene = getRelatedName(trk_1);
String trk2_gene = getRelatedName(trk_2);
Float value = (Float)genegene_value.get(trk1_gene + SEPARATOR + trk2_gene);
if (value == null) {
value = (Float)genegene_value.get(trk2_gene + SEPARATOR + trk1_gene);
if (value == null) return Float.MIN_VALUE;
}
return value.floatValue();
}
public String getRelatedName(int trk_id) throws TrackRelationshipException {
String result = (String)track_gene.get(new Integer(trk_id));
if (result == null) throw new TrackRelationshipException("Unkown relationship track: " + trk_id);
return result;
}
public String getGene(int trk_id) throws TrackRelationshipException {
String result = (String)track_gene.get(new Integer(trk_id));
if (result == null) throw new TrackRelationshipException("Unkown relationship track: " + trk_id);
return result;
}
public void addTracks(int trk_1, String gene1, int trk_2, String gene2, float score) {
track_gene.put(new Integer(trk_1), gene1);
track_gene.put(new Integer(trk_2), gene2);
genegene_value.put(gene1 + SEPARATOR + gene2, new Float(score));
}
public String getType() {
return TrackRelationshipOrderInterface.TYPE_COEXPRESSED;
}
public String toString() {
return getType();
}
}
package ca.bcgsc.sockeye.trackmanager;
public class CopyOperation extends Operation {
public CopyOperation() {
super(true, __COPY_OPERATION_TYPE);
}
public TrackRelationshipOrderInterface getTrackRelationship() {
return null;
}
}
package ca.bcgsc.sockeye.trackmanager;
public class ImportGFFOperation extends Operation {
private String fileName;
public ImportGFFOperation() {
super();
}
public ImportGFFOperation(String fileName) {
super(true, __IMPORT_GFF_OPERATION_TYPE);
this.fileName = fileName;
}
public TrackRelationshipOrderInterface getTrackRelationship() {
return null;
}
public String getFileName() {
return fileName;
}
}
package ca.bcgsc.sockeye.trackmanager;
public class LoadCoexpressedOperation extends Operation {
CoexpressedRelationship relationship;
public LoadCoexpressedOperation() {
super(true, __LOAD_COEXPRESS_OPERATION_TYPE);
}
public LoadCoexpressedOperation(CoexpressedRelationship rel) {
super(true, __LOAD_COEXPRESS_OPERATION_TYPE);
relationship = rel;
}
public TrackRelationshipOrderInterface getTrackRelationship() {
return relationship;
}
}
package ca.bcgsc.sockeye.trackmanager;
public class LoadFromDBOperation extends Operation {
public LoadFromDBOperation() {
super(true, __DB_OPERATION_TYPE);
}
public TrackRelationshipOrderInterface getTrackRelationship() {
return null;
}
}
package ca.bcgsc.sockeye.trackmanager;
public class LoadOrthologueOperation extends Operation {
private OrthologousRelationship relationship;
public LoadOrthologueOperation() {
super(true, __LOAD_HOMOLOGUE_OPERATION_TYPE);
}
public LoadOrthologueOperation(OrthologousRelationship rel) {
super(true, __LOAD_HOMOLOGUE_OPERATION_TYPE);
relationship = rel;
}
public TrackRelationshipOrderInterface getTrackRelationship() {
return relationship;
}
}
package ca.bcgsc.sockeye.trackmanager;
import java.util.HashSet;
import java.util.Iterator;
import java.util.StringTokenizer;
public abstract class Operation {
transient public static final int __LOAD_COEXPRESS_OPERATION_TYPE = 0;
transient public static final int __ALIGN_OPERATION_TYPE = 1;
transient public static final int __DB_OPERATION_TYPE = 2;
transient public static final int __COPY_OPERATION_TYPE = 3;
transient public static final int __LOAD_HOMOLOGUE_OPERATION_TYPE = 4;
transient public static final int __IMPORT_GFF_OPERATION_TYPE = 5;
protected boolean isRepeatable;
protected int type;
protected int id;
protected HashSet heads;
protected HashSet tails;
private static int _counter = 0;
public Operation() {
}
public Operation(boolean isRepeatable, int type) {
this.isRepeatable = isRepeatable;
if (type >= 0 && type <= 5) {
this.type = type;
} else {
type = -1;
}
this.id = getCounter();
heads = new HashSet();
tails = new HashSet();
}
static synchronized int getCounter() {
return _counter++;
}
public void onGraphAdded() {
}
public boolean canOperationAppliedOnTrack(Operation operation) {
return true;
}
public int getId() {
return id;
}
public boolean isRepeatable() {
return isRepeatable;
}
public int getType() {
return type;
}
public int tailSize() {
return tails.size();
}
public int headSize() {
return heads.size();
}
public boolean addHead(int trkID) {
return heads.add(new Integer(trkID));
}
public boolean onUpTrackRemoving(int trkId) {
return heads.remove(new Integer(trkId));
}
public boolean addTail(int trkID) {
return tails.add(new Integer(trkID));
}
public boolean onDownTrackRemoving(int trkId) {
return tails.remove(new Integer(trkId));
}
int[] getUpTracks() {
return convertIntegerArray(
(Integer[]) heads.toArray(new Integer[heads.size()]));
}
int[] getDownTracks() {
return convertIntegerArray(
(Integer[]) tails.toArray(new Integer[tails.size()]));
}
private int[] convertIntegerArray(Integer[] integers) {
int[] trackIDs = new int[integers.length];
for (int index = 0; index < integers.length; index++) {
trackIDs[index] = ((Integer) integers[index]).intValue();
}
return trackIDs;
}
public String toString() {
String representation = stringRepresent() + "\n";
Iterator iter = tails.iterator();
while (iter.hasNext()) {
representation += iter.next().toString() + " ";
}
return representation;
}
String stringRepresent() {
return "Op." + this.id + " " + classType();
}
private String classType() {
StringTokenizer packageNameTokenizer =
new StringTokenizer(this.getClass().toString(), ".");
String className = "";
while (packageNameTokenizer.hasMoreTokens()) {
className = packageNameTokenizer.nextToken();
}
return className;
}
public abstract TrackRelationshipOrderInterface getTrackRelationship();
}
package ca.bcgsc.sockeye.trackmanager;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import ca.bcgsc.sockeye.util.StringUtils;
public class OrthologousRelationship
extends PhyloDistanceRelationship
implements TrackRelationshipOrderInterface {
HashMap track_gene;
public OrthologousRelationship() throws TrackRelationshipException {
super();
}
public OrthologousRelationship(HashMap trk_gene)
throws TrackRelationshipException {
super(new ArrayList(trk_gene.keySet()));
track_gene = (HashMap) trk_gene.clone();
verifySpeciesUnique();
}
public OrthologousRelationship(HashMap trk_gene, String phylip_tree)
throws TrackRelationshipException {
super(new ArrayList(trk_gene.keySet()), phylip_tree);
track_gene = (HashMap) trk_gene.clone();
verifySpeciesUnique();
}
public OrthologousRelationship(HashMap trk_gene, HashMap dummy_species)
throws TrackRelationshipException {
super(new ArrayList(trk_gene.keySet()), dummy_species);
track_gene = (HashMap) trk_gene.clone();
verifySpeciesUnique();
}
public OrthologousRelationship(
HashMap trk_id_map,
OrthologousRelationship homoB)
throws TrackRelationshipException {
super(trk_id_map, (PhyloDistanceRelationship) homoB);
track_gene = new HashMap();
for (Iterator itr = homoB.track_gene.keySet().iterator(); itr.hasNext();) {
Integer old_trk = (Integer) itr.next();
Object new_trk = trk_id_map.get(old_trk);
if (new_trk == null)
continue;
String gene = new String((String) homoB.track_gene.get(old_trk));
track_gene.put(new_trk, gene);
}
}
public String getRelatedName(int trk_id) throws TrackRelationshipException {
String result = null;
result = (String) track_gene.get(new Integer(trk_id));
if (result == null)
throw new TrackRelationshipException(
"Unkown relationship track: " + trk_id);
String track_name = "";
try {
track_name = StringUtils.getShortNameForTrackID(trk_id);
} catch (Exception e) {
track_name = trk_id + "";
}
int index = track_name.indexOf("]");
if (index > -1)
track_name = track_name.substring(index + 2);
return result + " (" + track_name + ")";
}
public String getGene(int trk_id) throws TrackRelationshipException {
String result = null;
result = (String) track_gene.get(new Integer(trk_id));
if (result == null)
throw new TrackRelationshipException(
"Unkown relationship track: " + trk_id);
return result;
}
public String getType() {
return PhyloDistanceRelationship.TYPE_HOMOLOGOUS;
}
private void verifySpeciesUnique() throws TrackRelationshipException {
HashSet set = new HashSet();
for (Iterator itr = track_species.keySet().iterator(); itr.hasNext();) {
Integer trk = (Integer) itr.next();
Object species = track_species.get(trk);
if (set.contains(species))
throw new TrackRelationshipException(
"Track " + trk + " contains a duplicate species - not homologous");
set.add(species);
}
}
public void addTrack(int trk, String gene, String species)
throws TrackRelationshipException {
Collection gene_list = track_gene.values();
if (gene_list.contains(gene))
throw new TrackRelationshipException(
"Track "
+ trk
+ " already contains this gene - not homologous so track not added.");
track_species.put(new Integer(trk), species);
track_gene.put(new Integer(trk), gene);
verifyMatrixIndices();
}
}
package ca.bcgsc.sockeye.trackmanager;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import ca.bcgsc.sockeye.analysis.InvalidMatrixException;
import ca.bcgsc.sockeye.analysis.SequenceMatrix;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.util.Log;
import ca.bcgsc.sockeye.util.StringUtils;
public class PhyloDistanceRelationship implements TrackRelationshipOrderInterface {
SequenceMatrix matrix;
HashMap track_species;
private class ValueMap implements Comparable {
int id;
float value;
public ValueMap(int id, float value) {
this.id = id;
this.value = value;
}
public int compareTo(Object b) {
if (b instanceof ValueMap) {
ValueMap v_b = (ValueMap)b;
if (value < v_b.value) return -1;
if (value > v_b.value) return 1;
if (id < v_b.id) return -1;
if (id > v_b.id) return 1;
}
return 0;
}
}
public PhyloDistanceRelationship() throws TrackRelationshipException {
}
public PhyloDistanceRelationship(List track_ids) throws TrackRelationshipException {
matrix = SequenceMatrix.getPhyloDistanceMatrix(SequenceMatrix.BTYPE2);
initSpecies(track_ids);
verifyMatrixIndices();
}
public PhyloDistanceRelationship(List track_ids, String phylip_tree)
throws TrackRelationshipException {
matrix = new SequenceMatrix(phylip_tree, phylip_tree);
initSpecies(track_ids);
verifyMatrixIndices();
}
public PhyloDistanceRelationship(HashMap trk_id_map, PhyloDistanceRelationship phyloB)
throws TrackRelationshipException {
matrix = phyloB.matrix.copy();
track_species = new HashMap();
for (Iterator itr = phyloB.track_species.keySet().iterator(); itr.hasNext();) {
Integer old_trk = (Integer)itr.next();
Object new_trk = trk_id_map.get(old_trk);
if (new_trk == null) continue;
String species = new String((String)phyloB.track_species.get(old_trk));
track_species.put(new_trk, species);
}
}
public PhyloDistanceRelationship(List track_ids, HashMap dummy_species) throws TrackRelationshipException {
matrix = SequenceMatrix.getPhyloDistanceMatrix(SequenceMatrix.BTYPE2);
track_species = dummy_species;
verifyMatrixIndices();
}
public List getTrackOrder(int ref_trackid) throws TrackRelationshipException {
Set track_ids = track_species.keySet();
ArrayList ordered_values = new ArrayList();
for (Iterator itr = track_ids.iterator(); itr.hasNext();) {
Integer id = (Integer)itr.next();
if (id.intValue() == ref_trackid) continue;
Float value = new Float(getRelationshipValue(ref_trackid, id.intValue()));
ValueMap map = new ValueMap(id.intValue(), value.floatValue());
ordered_values.add(map);
}
Collections.sort(ordered_values);
ArrayList trk_list = new ArrayList();
trk_list.add(new Integer(ref_trackid));
for (Iterator itr = ordered_values.iterator(); itr.hasNext();) {
ValueMap map = (ValueMap)itr.next();
trk_list.add(new Integer(map.id));
}
return trk_list;
}
public float getRelationshipValue(int trk_1, int trk_2) throws TrackRelationshipException {
String trk1_species = (String)track_species.get(new Integer(trk_1));
String trk2_species = (String)track_species.get(new Integer(trk_2));
float value = 0;
try {
value = matrix.getElement(trk1_species, trk2_species);
} catch (IndexOutOfBoundsException e) {
Log.printStackTrace(e);
throw new TrackRelationshipException("Error mapping track to matrix ");
}
return value;
}
public String getRelatedName(int trk_id) throws TrackRelationshipException {
String result = (String)track_species.get(new Integer(trk_id));
if (result == null) throw new TrackRelationshipException("Unkown relationship track: " + trk_id);
String track_name = StringUtils.getShortNameForTrackID(trk_id);
int index = track_name.indexOf("]");
if (index > -1) track_name = track_name.substring(index + 2);
return track_name;
}
public String getSpecies(int trk_id) throws TrackRelationshipException {
String result = (String)track_species.get(new Integer(trk_id));
if (result == null) throw new TrackRelationshipException("Unkown relationship track: " + trk_id);
return result;
}
public String getType() {
return PhyloDistanceRelationship.TYPE_PHYLODISTANCE;
}
protected void verifyMatrixIndices() throws TrackRelationshipException {
for (Iterator itr = track_species.keySet().iterator(); itr.hasNext();) {
Integer trk_id = (Integer)itr.next();
String species = (String)track_species.get(trk_id);
try {
matrix.getColIndex(species);
} catch (InvalidMatrixException e) {
Log.printStackTrace(e);
throw new TrackRelationshipException("Unable to identify distance data for species '" +
species + "'");
}
}
}
private String determineSpecies(int trk_id) throws TrackRelationshipException{
List species_list = DataStoreUser.getInstance().getDataSourceManager().getTrackSpecies(trk_id);
if (species_list != null && species_list.size() > 0 ) return (String)species_list.get(0);
throw new TrackRelationshipException("Unable to determine species for track " + trk_id);
}
private void initSpecies(List track_ids) throws TrackRelationshipException {
track_species = new HashMap(track_ids.size());
String species = null, last_species = null;
boolean multiple = false;
for (Iterator i = track_ids.iterator(); i.hasNext();) {
Integer trk_int = (Integer)i.next();
species = determineSpecies(trk_int.intValue());
if (!species.equals(last_species) && last_species != null) multiple = true;
last_species = species;
track_species.put(trk_int, species);
}
if (!multiple) throw new TrackRelationshipException("Invalid Phylogenetic relationship: All tracks share same species: " + track_species);
}
public String toString() {
return getType();
}
}
package ca.bcgsc.sockeye.trackmanager;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Collections;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
public class SequenceConservationRelationship implements TrackRelationshipOrderInterface {
HashMap trktrk_value;
ArrayList tracks;
private static final String SEPARATOR = "-!-";
private class ValueMap implements Comparable {
int id;
float value;
public ValueMap(int id, float value) {
this.id = id;
this.value = value;
}
public int compareTo(Object b) {
if (b instanceof ValueMap) {
ValueMap v_b = (ValueMap)b;
if (value < v_b.value) return 1;
if (value > v_b.value) return -1;
if (id < v_b.id) return -1;
if (id > v_b.id) return 1;
}
return 0;
}
}
public SequenceConservationRelationship() throws TrackRelationshipException {
trktrk_value = new HashMap();
tracks = new ArrayList();
}
public SequenceConservationRelationship(HashMap trk_ids, SequenceConservationRelationship B)
throws TrackRelationshipException {
trktrk_value = new HashMap();
for (Iterator itr = B.trktrk_value.keySet().iterator(); itr.hasNext();) {
String trktrk = (String) itr.next();
String[] trks = trktrk.split(SEPARATOR);
String trk1 = (String)trk_ids.get(trks[0]);
String trk2 = (String)trk_ids.get(trks[1]);
if (trk1 == null || trk2 == null) continue;
Float value = (Float)B.trktrk_value.get(trktrk);
trktrk_value.put(trk1 + SEPARATOR + trk2, new Float(value.floatValue()));
}
tracks = new ArrayList();
for (Iterator itr = B.tracks.iterator(); itr.hasNext();) {
Integer old_trk = (Integer)itr.next();
Integer new_trk = (Integer)trk_ids.get(old_trk);
if (new_trk == null) continue;
tracks.add(new_trk);
}
}
public List getTrackOrder(int ref_trackid) throws TrackRelationshipException {
ArrayList ordered_values = new ArrayList();
for (Iterator itr = tracks.iterator(); itr.hasNext();) {
Integer id = (Integer)itr.next();
if (id.intValue() == ref_trackid) continue;
Float value = new Float(getRelationshipValue(ref_trackid, id.intValue()));
ValueMap map = new ValueMap(id.intValue(), value.floatValue());
ordered_values.add(map);
}
Collections.sort(ordered_values);
ArrayList trk_list = new ArrayList();
trk_list.add(new Integer(ref_trackid));
for (Iterator itr = ordered_values.iterator(); itr.hasNext();) {
ValueMap map = (ValueMap)itr.next();
trk_list.add(new Integer(map.id));
}
return trk_list;
}
public float getRelationshipValue(int trk_1, int trk_2) throws TrackRelationshipException {
Float value = (Float)trktrk_value.get(trk_1 + SEPARATOR + trk_2);
if (value == null) {
value = (Float)trktrk_value.get(trk_2 + SEPARATOR + trk_1);
if (value == null) throw new TrackRelationshipException("Error mapping tracks to values.");
}
return value.floatValue();
}
public String getRelatedName(int trk_id) throws TrackRelationshipException {
if (!tracks.contains(new Integer(trk_id)))
throw new TrackRelationshipException("Unkown relationship track: " + trk_id);
String track_name = (String)DataStoreUser.getInstance().getSockeyeTrackList().getTrackAttribute(trk_id, "track_name");
int index = track_name.indexOf("]");
if (index > -1) track_name = track_name.substring(index + 2);
return track_name;
}
public void addTracks(int trk_1, int trk_2, float score) {
Integer trk1 = new Integer(trk_1);
Integer trk2 = new Integer(trk_2);
if (!tracks.contains(trk1)) tracks.add(trk1);
if (!tracks.contains(trk2)) tracks.add(trk2);
String key = trk_1 + SEPARATOR + trk_2;
trktrk_value.put(key, new Float(score));
}
public String getType() {
return TrackRelationshipOrderInterface.TYPE_PAIRWISECONSERVED;
}
public String toString() {
return getType();
}
}
package ca.bcgsc.sockeye.trackmanager;
import java.util.HashSet;
public class TrackIDWrapper {
private int trackID;
private Operation head;
private HashSet tail;
public TrackIDWrapper() {
tail = new HashSet();
}
public TrackIDWrapper(Operation operation, int trackID) {
this.trackID = trackID;
head = operation;
tail = new HashSet();
}
public Operation getHead() {
return head;
}
public void setHead(Operation operation) {
head = operation;
}
public Operation[] getTail() {
return (Operation[]) tail.toArray(new Operation[tail.size()]);
}
public boolean addTail(Operation operation) {
return tail.add(operation);
}
public boolean removeTail(Operation operation) {
return tail.remove(operation);
}
public int tailSize() {
return tail.size();
}
public String toString() {
return "(Track " + trackID + ")";
}
}
package ca.bcgsc.sockeye.trackmanager;
public interface TrackManager {
public static final int[] EMPTY_INT_ARRAY = new int[0];
public Operation getUpOperations(int trkId);
public Operation[] getDownOperations(int trkId);
public int[] getUpTracks(Operation operation);
public int[] getDownTracks(Operation operation);
public boolean addTrack(Operation operation, int trkId);
public boolean addOperation(Operation operation, int[] trkIds);
public boolean removeTrack(int trkId);
public boolean addTrackToRoot(int trkId);
public Operation findOperationByID(int id);
public void setTrackManager( TrackManager tm);
}
package ca.bcgsc.sockeye.trackmanager;
public class TrackManagerFactory {
static public TrackManager getInstance() {
return TrackManagerImpl.getInstance();
}
}
package ca.bcgsc.sockeye.trackmanager;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.List;
public class TrackManagerImpl implements TrackManager {
private LoadFromDBOperation root;
private List orphanOpList;
private Hashtable tracksTable;
private Hashtable operationsTable;
static private TrackManager __instance = new TrackManagerImpl();
static TrackManager getInstance() {
return __instance;
}
public void setTrackManager( TrackManager tm) {
__instance = tm;
}
public TrackManagerImpl() {
orphanOpList = new ArrayList();
root = new LoadFromDBOperation();
tracksTable = new Hashtable();
operationsTable = new Hashtable();
operationsTable.put(new Integer(root.getId()), root);
}
public synchronized Operation getUpOperations(int trkID) {
TrackIDWrapper track = (TrackIDWrapper) tracksTable.get(new Integer(trkID));
if (track == null) {
return null;
} else {
return track.getHead();
}
}
public synchronized Operation[] getDownOperations(int trkID) {
TrackIDWrapper track = (TrackIDWrapper) tracksTable.get(new Integer(trkID));
if (track == null) {
return null;
} else {
return track.getTail();
}
}
public synchronized int[] getUpTracks(Operation operation) {
if (operation == null || !operationExist(operation))
return null;
else
return operation.getUpTracks();
}
public synchronized int[] getDownTracks(Operation operation) {
if (operation == null || !operationExist(operation))
return EMPTY_INT_ARRAY;
else
return operation.getDownTracks();
}
public synchronized boolean addTrack(Operation operation, int trkID) {
TrackIDWrapper track = new TrackIDWrapper(operation, trkID);
tracksTable.put(new Integer(trkID), track);
return operation.addTail(trkID);
}
public synchronized boolean addTrackToRoot(int trkID) {
TrackIDWrapper track = new TrackIDWrapper(root, trkID);
tracksTable.put(new Integer(trkID), track);
return root.addTail(trkID);
}
public synchronized boolean addOperation(Operation operation, int[] trkIDs) {
if (operation == null) {
return false;
}
if (operation.getType() == Operation.__IMPORT_GFF_OPERATION_TYPE) {
operationsTable.put(new Integer(operation.getId()), operation);
operation.onGraphAdded();
return addOrphan(operation);
} else if (trkIDs == null || !tracksExist(trkIDs)) {
return false;
} else {
boolean success = true;
for (int index = 0; index < trkIDs.length; index++) {
int trkID = trkIDs[index];
TrackIDWrapper track =
(TrackIDWrapper) tracksTable.get(new Integer(trkID));
if (track == null) {
System.out.println("Can't find " + trkID + " in " + tracksTable);
success = false;
} else {
success = success && track.addTail(operation);
success = success && operation.addHead(trkID);
}
}
if (success) {
operationsTable.put(new Integer(operation.getId()), operation);
operation.onGraphAdded();
}
return success;
}
}
public synchronized boolean removeTrack(int trkID) {
boolean result = true;
TrackIDWrapper track = (TrackIDWrapper) tracksTable.get(new Integer(trkID));
if (track != null) {
result = result && track.getHead().onDownTrackRemoving(trkID);
if (track.getHead().getType() == Operation.__IMPORT_GFF_OPERATION_TYPE) {
result = result && removeOrphan(track.getHead());
}
else if (track.getHead().tailSize() == 0) {
if (orphanOpList.contains(track.getHead())) {
result = result && removeOrphan(track.getHead());
}
else if (track.getHead() != root) {
result = result && removeOperation(track.getHead());
}
}
track.setHead(null);
if (track.tailSize() > 0) {
Operation[] operations = track.getTail();
for (int index = 0; index < operations.length; index++) {
Operation current_operation = operations[index];
result = result && current_operation.onUpTrackRemoving(trkID);
result = result && track.removeTail(current_operation);
if (current_operation.headSize() == 0) {
if (current_operation.isRepeatable()) {
int[] tracks = current_operation.getDownTracks();
for (int counter = 0; counter < tracks.length; counter++) {
result = result && root.addTail(tracks[counter]);
(
(TrackIDWrapper) tracksTable.get(
new Integer(tracks[counter]))).setHead(
root);
}
}
else {
result = result && addOrphan(current_operation);
}
operationsTable.remove(new Integer(current_operation.getId()));
}
}
}
tracksTable.remove(new Integer(trkID));
return result;
}
else {
throw new IllegalStateException("Deleting a non-existing track.");
}
}
public synchronized Operation findOperationByID(int operationID) {
Operation operation =
(Operation) operationsTable.get(new Integer(operationID));
return operation;
}
private synchronized boolean removeOperation(Operation operation) {
boolean result = true;
if (operation.tailSize() == 0 && operation != root) {
int[] operationHead = operation.getUpTracks();
for (int index = 0; index < operationHead.length; index++) {
TrackIDWrapper track =
(TrackIDWrapper) tracksTable.get(new Integer(operationHead[index]));
result = result && track.removeTail(operation);
result = result && operation.onUpTrackRemoving(operationHead[index]);
}
operationsTable.remove(new Integer(operation.getId()));
return result;
} else {
return false;
}
}
private synchronized boolean addOrphan(Operation operation) {
return orphanOpList.add(operation);
}
private synchronized boolean removeOrphan(Operation operation) {
operationsTable.remove(new Integer(operation.getId()));
return orphanOpList.remove(operation);
}
private synchronized boolean operationExist(Operation operation) {
return operationsTable.containsValue(operation);
}
private synchronized boolean trackExist(int trkID) {
return tracksTable.containsKey(new Integer(trkID));
}
private synchronized boolean tracksExist(int[] trkIDs) {
if (trkIDs != null) {
boolean result = true;
for (int index = 0; index < trkIDs.length; index++) {
result = result && trackExist(trkIDs[index]);
}
return result;
} else {
return false;
}
}
public String toString() {
String representation = root.stringRepresent() + "\n";
int[] tails = root.getDownTracks();
for (int index = 0; index < tails.length; index++) {
TrackIDWrapper track =
(TrackIDWrapper) tracksTable.get(new Integer(tails[index]));
representation += this.toStringTrackHelper("\t", track);
}
representation += "\n\nOrphan:\n" + orphanOpList;
return representation;
}
private String toStringTrackHelper(String indent, TrackIDWrapper track) {
String representation = indent + track + "\n";
Operation[] tails = track.getTail();
for (int index = 0; index < tails.length; index++) {
Operation oper = tails[index];
representation += toStringOpHelper(indent + "\t", oper);
}
return representation;
}
private String toStringOpHelper(String indent, Operation oper) {
String representation = indent + oper.stringRepresent() + "\n";
int[] tails = oper.getDownTracks();
for (int index = 0; index < tails.length; index++) {
TrackIDWrapper track =
(TrackIDWrapper) tracksTable.get(new Integer(tails[index]));
representation += this.toStringTrackHelper(indent + "\t", track);
}
return representation;
}
}
package ca.bcgsc.sockeye.trackmanager;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import ca.bcgsc.sockeye.util.StringUtils;
public class TrackOrderRelationship implements TrackRelationshipOrderInterface {
private List ordered_tracks;
public TrackOrderRelationship(){
}
public TrackOrderRelationship(List track_ids) {
ordered_tracks = new ArrayList(track_ids.size());
ordered_tracks.addAll(track_ids);
}
public TrackOrderRelationship(HashMap trk_id_map, TrackOrderRelationship ordB)
throws TrackRelationshipException {
ordered_tracks = new ArrayList();
for (Iterator itr = ordB.ordered_tracks.iterator(); itr.hasNext();) {
Integer old_trk = (Integer)itr.next();
Integer new_trk = (Integer)trk_id_map.get(old_trk);
if (new_trk == null) continue;
ordered_tracks.add(new Integer(new_trk.intValue()));
}
}
public List getTrackOrder(int ref_trackid) throws TrackRelationshipException {
return ordered_tracks;
}
public float getRelationshipValue(int trk_1, int trk_2) throws TrackRelationshipException {
float value = ordered_tracks.indexOf(new Integer(trk_1));
if (value == -1) throw new TrackRelationshipException("Track " + trk_1 + " not found.");
return ordered_tracks.size() - value;
}
public String getRelatedName(int trk_id) {
String track_name = StringUtils.getShortNameForTrackID(trk_id);
int index = track_name.indexOf("]");
if (index > -1) track_name = track_name.substring(index + 2);
return track_name;
}
public String getType() {
return PhyloDistanceRelationship.TYPE_TRACKORDER;
}
public String toString() {
return getType();
}
}
package ca.bcgsc.sockeye.trackmanager;
public class TrackRelationshipException
extends Exception {
public TrackRelationshipException(String msg) {
super(msg);
}
}
package ca.bcgsc.sockeye.trackmanager;
import java.util.List;
public interface TrackRelationshipOrderInterface {
public static final String TYPE_PHYLODISTANCE = "Phylogenetic Distance";
public static final String TYPE_HOMOLOGOUS = "Orthologous";
public static final String TYPE_COEXPRESSED = "Co-expressed";
public static final String TYPE_TRACKORDER = "Original Track Order";
public static final String TYPE_PAIRWISECONSERVED = "Pairwise Conservation";
public List getTrackOrder(int ref_trackid) throws TrackRelationshipException;
public float getRelationshipValue(int trk_1, int trk_2) throws TrackRelationshipException;
public String getType();
public String getRelatedName(int trk_id) throws TrackRelationshipException;
}
package ca.bcgsc.sockeye.trackmanager.junit;
import ca.bcgsc.sockeye.trackmanager.CopyOperation;
import ca.bcgsc.sockeye.trackmanager.ImportGFFOperation;
import ca.bcgsc.sockeye.trackmanager.LoadCoexpressedOperation;
import ca.bcgsc.sockeye.trackmanager.LoadFromDBOperation;
import ca.bcgsc.sockeye.trackmanager.LoadOrthologueOperation;
import ca.bcgsc.sockeye.trackmanager.Operation;
import junit.framework.TestSuite;
import junit.framework.TestCase;
public class OperationUnitTest extends TestCase {
public static void main(String[] args) {
junit.textui.TestRunner.run(OperationUnitTest.suite());
}
protected void setUp() {
}
public static TestSuite suite() {
TestSuite testSuite = new TestSuite();
testSuite.addTestSuite(OperationUnitTest.class);
return testSuite;
}
public void testOperationUniqueId() {
assertEquals(0, Operation.__LOAD_COEXPRESS_OPERATION_TYPE);
assertEquals(1, Operation.__ALIGN_OPERATION_TYPE);
assertEquals(2, Operation.__DB_OPERATION_TYPE);
assertEquals(3, Operation.__COPY_OPERATION_TYPE);
assertEquals(4, Operation.__LOAD_HOMOLOGUE_OPERATION_TYPE);
assertEquals(5, Operation.__IMPORT_GFF_OPERATION_TYPE);
}
public void testEachOperationConstructor() {
Operation oper1 = new CopyOperation();
assertTrue(oper1.isRepeatable());
assertEquals(Operation.__COPY_OPERATION_TYPE, oper1.getType());
assertEquals(0, oper1.headSize());
assertEquals(0, oper1.tailSize());
Operation oper2 = new LoadFromDBOperation();
assertTrue(oper2.isRepeatable());
assertEquals(Operation.__DB_OPERATION_TYPE, oper2.getType());
assertEquals(0, oper2.headSize());
assertEquals(0, oper2.tailSize());
Operation oper3 = new LoadOrthologueOperation(null);
assertTrue(oper3.isRepeatable());
assertEquals(Operation.__LOAD_HOMOLOGUE_OPERATION_TYPE, oper3.getType());
assertEquals(0, oper3.headSize());
assertEquals(0, oper3.tailSize());
Operation oper4 = new LoadCoexpressedOperation(null);
assertTrue(oper4.isRepeatable());
assertEquals(Operation.__LOAD_COEXPRESS_OPERATION_TYPE, oper4.getType());
assertEquals(0, oper4.headSize());
assertEquals(0, oper4.tailSize());
Operation oper6 = new ImportGFFOperation(null);
assertTrue(oper6.isRepeatable());
assertEquals(Operation.__IMPORT_GFF_OPERATION_TYPE, oper6.getType());
assertEquals(0, oper6.headSize());
assertEquals(0, oper6.tailSize());
}
public void testHead() {
Operation oper1 = new CopyOperation();
assertEquals(0, oper1.headSize());
assertTrue(oper1.addHead(3));
assertEquals(1, oper1.headSize());
assertFalse(oper1.addHead(3));
assertEquals(1, oper1.headSize());
assertTrue(oper1.addHead(5));
assertEquals(2, oper1.headSize());
assertTrue(oper1.addHead(7));
assertEquals(3, oper1.headSize());
assertFalse(oper1.addHead(5));
assertEquals(3, oper1.headSize());
assertFalse(oper1.onUpTrackRemoving(4));
assertEquals(3, oper1.headSize());
assertTrue(oper1.onUpTrackRemoving(3));
assertEquals(2, oper1.headSize());
assertFalse(oper1.onUpTrackRemoving(2));
assertEquals(2, oper1.headSize());
assertTrue(oper1.onUpTrackRemoving(5));
assertEquals(1, oper1.headSize());
assertTrue(oper1.onUpTrackRemoving(7));
assertEquals(0, oper1.headSize());
assertFalse(oper1.onUpTrackRemoving(7));
assertEquals(0, oper1.headSize());
}
public void testTail() {
Operation oper1 = new LoadFromDBOperation();
assertEquals(0, oper1.tailSize());
assertTrue(oper1.addTail(3));
assertEquals(1, oper1.tailSize());
assertFalse(oper1.addTail(3));
assertEquals(1, oper1.tailSize());
assertTrue(oper1.addTail(5));
assertEquals(2, oper1.tailSize());
assertTrue(oper1.addTail(7));
assertEquals(3, oper1.tailSize());
assertFalse(oper1.addTail(5));
assertEquals(3, oper1.tailSize());
assertFalse(oper1.onDownTrackRemoving(4));
assertEquals(3, oper1.tailSize());
assertTrue(oper1.onDownTrackRemoving(3));
assertEquals(2, oper1.tailSize());
assertFalse(oper1.onDownTrackRemoving(2));
assertEquals(2, oper1.tailSize());
assertTrue(oper1.onDownTrackRemoving(5));
assertEquals(1, oper1.tailSize());
assertTrue(oper1.onDownTrackRemoving(7));
assertEquals(0, oper1.tailSize());
assertFalse(oper1.onDownTrackRemoving(7));
assertEquals(0, oper1.tailSize());
}
}
package ca.bcgsc.sockeye.trackmanager.junit;
import ca.bcgsc.sockeye.trackmanager.ImportGFFOperation;
import ca.bcgsc.sockeye.trackmanager.LoadCoexpressedOperation;
import ca.bcgsc.sockeye.trackmanager.LoadFromDBOperation;
import ca.bcgsc.sockeye.trackmanager.LoadOrthologueOperation;
import ca.bcgsc.sockeye.trackmanager.Operation;
import ca.bcgsc.sockeye.trackmanager.TrackIDWrapper;
import junit.framework.TestSuite;
import junit.framework.TestCase;
public class TrackIDWrapperUnitTest extends TestCase {
public static void main(String[] args) {
junit.textui.TestRunner.run(TrackIDWrapperUnitTest.suite());
}
protected void setUp() {
}
public static TestSuite suite() {
TestSuite testSuite = new TestSuite();
testSuite.addTestSuite(TrackIDWrapperUnitTest.class);
return testSuite;
}
public void testHead() {
Operation op1 = new LoadFromDBOperation();
TrackIDWrapper idWrap1 = new TrackIDWrapper(op1, 1);
assertNotNull(idWrap1.getHead());
assertEquals(0, idWrap1.tailSize());
assertSame(op1, idWrap1.getHead());
Operation op2 = new LoadCoexpressedOperation(null);
idWrap1.setHead(op2);
assertSame(op2, idWrap1.getHead());
assertEquals(0, idWrap1.tailSize());
idWrap1.setHead(null);
assertNull(idWrap1.getHead());
assertEquals(0, idWrap1.tailSize());
}
public void testTails() {
TrackIDWrapper idWrap1 = new TrackIDWrapper(null, 1);
assertEquals(0, idWrap1.tailSize());
Operation op1 = new ImportGFFOperation("");
assertTrue(idWrap1.addTail(op1));
assertEquals(1, idWrap1.tailSize());
Operation[] tails = idWrap1.getTail();
assertEquals(1, tails.length);
assertSame(op1, tails[0]);
assertFalse(idWrap1.addTail(op1));
assertEquals(1, idWrap1.tailSize());
Operation op2 = new LoadOrthologueOperation(null);
assertTrue(idWrap1.addTail(op2));
assertEquals(2, idWrap1.tailSize());
Operation op3 = new LoadOrthologueOperation(null);
assertTrue(idWrap1.addTail(op3));
assertEquals(3, idWrap1.tailSize());
assertFalse(idWrap1.removeTail(null));
assertEquals(3, idWrap1.tailSize());
assertTrue(idWrap1.removeTail(op1));
assertEquals(2, idWrap1.tailSize());
assertFalse(idWrap1.removeTail(op1));
assertEquals(2, idWrap1.tailSize());
assertTrue(idWrap1.removeTail(op2));
assertEquals(1, idWrap1.tailSize());
assertFalse(idWrap1.removeTail(op1));
assertEquals(1, idWrap1.tailSize());
assertTrue(idWrap1.removeTail(op3));
assertEquals(0, idWrap1.tailSize());
assertFalse(idWrap1.removeTail(null));
assertEquals(0, idWrap1.tailSize());
}
}
package ca.bcgsc.sockeye.trackmanager.junit;
import ca.bcgsc.sockeye.trackmanager.CopyOperation;
import ca.bcgsc.sockeye.trackmanager.ImportGFFOperation;
import ca.bcgsc.sockeye.trackmanager.LoadCoexpressedOperation;
import ca.bcgsc.sockeye.trackmanager.LoadOrthologueOperation;
import ca.bcgsc.sockeye.trackmanager.Operation;
import ca.bcgsc.sockeye.trackmanager.TrackManager;
import ca.bcgsc.sockeye.trackmanager.TrackManagerFactory;
import junit.framework.TestSuite;
import junit.framework.TestCase;
public class TrackManagerUnitTest extends TestCase {
private TrackManager tManager;
private static int root_id;
public TrackManagerUnitTest(String name) {
super(name);
}
public static void main(String[] args) {
junit.textui.TestRunner.run(TrackManagerUnitTest.suite());
}
protected void setUp() {
tManager = TrackManagerFactory.getInstance();
}
protected void tearDown() {
}
public static TestSuite suite() {
TestSuite testSuite = new TestSuite();
testSuite.addTest(new TrackManagerUnitTest("testAddSingleTrackToRoot"));
testSuite.addTest(new TrackManagerUnitTest("testAddMultipleTracksToRoot"));
testSuite.addTest(new TrackManagerUnitTest("testAddSingleOperation"));
testSuite.addTest(new TrackManagerUnitTest("testAddMultipleOperations"));
testSuite.addTest(new TrackManagerUnitTest("testRemoveSingleTrack"));
testSuite.addTest(new TrackManagerUnitTest("testRemoveOneTrackOperation"));
testSuite.addTest(new TrackManagerUnitTest("testRemoveOrphanOperation"));
testSuite.addTest(new TrackManagerUnitTest("testRemoveMultipleTracks"));
return testSuite;
}
public void testAddSingleTrackToRoot() {
assertTrue(tManager.addTrackToRoot(1));
Operation root = tManager.getUpOperations(1);
root_id = root.getId();
assertFalse(tManager.addTrackToRoot(1));
Operation oper1 = tManager.findOperationByID(root_id);
assertNotNull(oper1);
assertEquals(1, oper1.tailSize());
int[] tracks = tManager.getDownTracks(oper1);
assertEquals(1, tracks.length);
assertEquals(1, tracks[0]);
}
public void testAddMultipleTracksToRoot() {
Operation oper1 = tManager.findOperationByID(root_id);
assertNotNull(oper1);
assertEquals(1, oper1.tailSize());
assertTrue(tManager.addTrackToRoot(2));
assertEquals(2, oper1.tailSize());
assertTrue(tManager.addTrackToRoot(3));
assertEquals(3, oper1.tailSize());
assertFalse(tManager.addTrackToRoot(2));
assertEquals(3, oper1.tailSize());
}
public void testAddSingleOperation() {
Operation oper1 = tManager.findOperationByID(root_id);
assertEquals(3, oper1.tailSize());
Operation oper2 = new CopyOperation();
int[] copyTrack = { 3 };
assertTrue(tManager.addOperation(oper2, copyTrack));
assertEquals(0, oper2.tailSize());
assertTrue(tManager.addTrack(oper2, 4));
assertEquals(3, oper1.tailSize());
assertEquals(1, oper2.tailSize());
Operation[] operations = tManager.getDownOperations(4);
assertEquals(0, operations.length);
Operation upOperation = tManager.getUpOperations(4);
assertSame(oper2, upOperation);
Operation tempOper1 = tManager.findOperationByID(2+root_id);
assertNull(tempOper1);
Operation tempOper2 = tManager.findOperationByID(1+root_id);
assertNotNull(tempOper2);
assertEquals(TrackManager.EMPTY_INT_ARRAY, tManager.getDownTracks(null));
int[] tracks = tManager.getDownTracks(tempOper2);
assertEquals(1, tracks.length);
assertEquals(4, tracks[0]);
}
public void testAddMultipleOperations() {
Operation homoOper = new LoadOrthologueOperation(null);
int[] parentTracks = { 1 };
assertTrue(tManager.addTrack(homoOper, 5));
tManager.addOperation(homoOper, parentTracks);
Operation gffOper = new ImportGFFOperation("sequences.fasta");
assertTrue(tManager.addOperation(gffOper, null));
assertTrue(tManager.addTrack(gffOper, 6));
Operation coExprOp = new LoadCoexpressedOperation(null);
int[] parentTracks2 = { 16, 1, 2, 3 };
assertFalse(tManager.addOperation(coExprOp, parentTracks2));
int[] parentTracks4 = { 5, 2, 3, 6 };
assertTrue(tManager.addOperation(coExprOp, parentTracks4));
assertTrue(tManager.addTrack(coExprOp, 7));
assertTrue(tManager.addTrack(coExprOp, 8));
}
public void testRemoveSingleTrack() {
Operation coexp = tManager.findOperationByID(4+root_id);
assertNotNull(coexp);
assertEquals(2, coexp.tailSize());
assertTrue(tManager.removeTrack(8));
assertEquals(1, coexp.tailSize());
}
public void testRemoveOneTrackOperation() {
Operation copyOp = tManager.findOperationByID(1+root_id);
assertNotNull(copyOp);
assertEquals(1, copyOp.tailSize());
assertTrue(tManager.removeTrack(4));
Operation copyOp2 = tManager.findOperationByID(1+root_id);
assertNull(copyOp2);
Operation[] track3DownOp = tManager.getDownOperations(3);
assertEquals(1, track3DownOp.length);
assertEquals(tManager.findOperationByID(4+root_id), track3DownOp[0]);
}
public void testRemoveOrphanOperation() {
Operation importGFFOp = tManager.findOperationByID(3+root_id);
assertNotNull(importGFFOp);
assertEquals(1, importGFFOp.tailSize());
assertTrue(tManager.removeTrack(6));
Operation importGFFOp2 = tManager.findOperationByID(3+root_id);
assertNull(importGFFOp2);
}
public void testRemoveMultipleTracks() {
Operation rootOp = tManager.findOperationByID(0+root_id);
assertNotNull(rootOp);
assertEquals(3, rootOp.tailSize());
Operation[] downOp1a = tManager.getDownOperations(1);
assertEquals(1, downOp1a.length);
Operation coExprOp = tManager.findOperationByID(4+root_id);
assertNotNull(coExprOp);
assertEquals(1, coExprOp.tailSize());
assertEquals(3, coExprOp.headSize());
Operation homoOp = tManager.findOperationByID(2+root_id);
assertNotNull(homoOp);
assertEquals(1, homoOp.tailSize());
assertTrue(tManager.removeTrack(5));
Operation[] downOp1b = tManager.getDownOperations(1);
assertEquals(0, downOp1b.length);
assertEquals(0, homoOp.tailSize());
Operation homoOp2 = tManager.findOperationByID(2+root_id);
assertNull(homoOp2);
coExprOp = tManager.findOperationByID(4+root_id);
assertNotNull(coExprOp);
assertEquals(2, coExprOp.headSize());
rootOp = tManager.findOperationByID(root_id);
assertNotNull(rootOp);
assertEquals(3, rootOp.tailSize());
coExprOp = tManager.findOperationByID(4+root_id);
assertNotNull(coExprOp);
assertEquals(1, coExprOp.tailSize());
assertEquals(2, coExprOp.headSize());
assertTrue(tManager.removeTrack(2));
rootOp = tManager.findOperationByID(root_id);
assertNotNull(rootOp);
assertEquals(2, rootOp.tailSize());
coExprOp = tManager.findOperationByID(4+root_id);
assertNotNull(coExprOp);
assertEquals(1, coExprOp.tailSize());
assertEquals(1, coExprOp.headSize());
rootOp = tManager.findOperationByID(root_id);
assertNotNull(rootOp);
assertEquals(2, rootOp.tailSize());
coExprOp = tManager.findOperationByID(4+root_id);
assertNotNull(coExprOp);
assertEquals(1, coExprOp.tailSize());
assertEquals(1, coExprOp.headSize());
assertTrue(tManager.removeTrack(3));
rootOp = tManager.findOperationByID(root_id);
assertNotNull(rootOp);
assertEquals(2, rootOp.tailSize());
assertSame(rootOp, tManager.getUpOperations(7));
coExprOp = tManager.findOperationByID(4+root_id);
assertNull(coExprOp);
}
}
package ca.bcgsc.sockeye.util;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintStream;
import java.util.HashMap;
public class Log {
static private String LOG_NAME = "sockeye.log";
static private HashMap logMap = new HashMap();
private PrintStream os = null;
static public void printStackTrace(Throwable t){
t.printStackTrace(getInstance(LOG_NAME).getPrintStream());
}
static public void println(String s) {
getInstance(LOG_NAME).println2(s);
}
public Log(String filename) {
try {
os = new PrintStream(new FileOutputStream(new File(filename)));
} catch (FileNotFoundException e) {
e.printStackTrace();
os = System.out;
}
}
public void println2(String s) {
os.println(s);
}
public PrintStream getPrintStream() {
return os;
}
static public Log getInstance(String filename) {
Log log = (Log)logMap.get(filename);
if (log == null) {
Log log2 = new Log(filename);
logMap.put(filename, log2);
return log2;
}
return log;
}
}
package ca.bcgsc.sockeye.util;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
public class ResourceLoader {
public static Reader getReader(String relativePath) {
File file = new File(relativePath);
Reader reader = null;
if (file.exists()) {
try {
reader = new FileReader(relativePath);
} catch (FileNotFoundException e) {
e.printStackTrace();
Log.printStackTrace(e);
}
} else {
Log.println("Reading " + relativePath + " from classpath");
InputStream is =
ResourceLoader.class.getClassLoader().getResourceAsStream(
relativePath.replaceAll("\\\\", "/"));
if (is != null) {
reader = new InputStreamReader(is);
}
}
return reader;
}
}
package ca.bcgsc.sockeye.util;
import java.util.List;
import ca.bcgsc.sockeye.datastorage.DataStoreUser;
import ca.bcgsc.sockeye.datastorage.Track;
import ca.bcgsc.sockeye.trackmanager.TrackRelationshipException;
import ca.bcgsc.sockeye.trackmanager.TrackRelationshipOrderInterface;
public class StringUtils {
public static String getShortNameForTrackID(int id){
String oldName = DataStoreUser.getInstance().getSockeyeTrackList().getTrackAttribute(id, Track.TRACK_NAME_ATTRIBUTE_KEY).toString();
if (oldName == null) return null;
return oldName.split(":")[0];
}
public static String getPhylipString(TrackRelationshipOrderInterface relation, int ref_track) {
StringBuffer phylo = new StringBuffer();
int level = 0;
try {
List order = relation.getTrackOrder(ref_track);
for (level = 0; level < order.size(); level++) {
int t_id = ((Integer) order.get(level)).intValue();
List species_list = DataStoreUser.getInstance().getDataSourceManager().getTrackSpecies(t_id);
String species;
if (species_list.size() > 0) species = (String)species_list.get(0);
else species = getShortNameForTrackID(t_id).replace('(', '[').replace(')', ']');
phylo.append("(" + species);
}
while (level-- > 0) phylo.append(")");
} catch (TrackRelationshipException e) {
return null;
}
return phylo.toString();
}
public static String getShortSpeciesName(String long_species_name) {
String shortname = null;
try {
shortname = new String(long_species_name.charAt(0) + ".");
int index = long_species_name.indexOf("_");
shortname = shortname.concat(long_species_name.substring(index + 1, index + 4)).
concat(".");
} catch (Exception e) {
Log.printStackTrace(e);
return null;
}
return shortname;
}
}
